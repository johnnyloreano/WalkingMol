// threejs.org/license
(function(l,ja){"object"===typeof exports&&"undefined"!==typeof module?ja(exports):"function"===typeof define&&define.amd?define(["exports"],ja):ja(l.THREE={})})(this,function(l){function ja(){}function z(a,b){this.x=a||0;this.y=b||0}function O(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];0<arguments.length&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}function ka(a,b,c,d){this._x=a||0;this._y=b||0;this._z=c||0;this._w=void 0!==d?d:1}function n(a,
b,c){this.x=a||0;this.y=b||0;this.z=c||0}function da(){this.elements=[1,0,0,0,1,0,0,0,1];0<arguments.length&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}function X(a,b,c,d,e,f,g,h,k,m){Object.defineProperty(this,"id",{value:Mf++});this.uuid=R.generateUUID();this.name="";this.image=void 0!==a?a:X.DEFAULT_IMAGE;this.mipmaps=[];this.mapping=void 0!==b?b:X.DEFAULT_MAPPING;this.wrapS=void 0!==c?c:1001;this.wrapT=void 0!==d?d:1001;this.magFilter=void 0!==
e?e:1006;this.minFilter=void 0!==f?f:1008;this.anisotropy=void 0!==k?k:1;this.format=void 0!==g?g:1023;this.type=void 0!==h?h:1009;this.offset=new z(0,0);this.repeat=new z(1,1);this.center=new z(0,0);this.rotation=0;this.matrixAutoUpdate=!0;this.matrix=new da;this.generateMipmaps=!0;this.premultiplyAlpha=!1;this.flipY=!0;this.unpackAlignment=4;this.encoding=void 0!==m?m:3E3;this.version=0;this.onUpdate=null}function ca(a,b,c,d){this.x=a||0;this.y=b||0;this.z=c||0;this.w=void 0!==d?d:1}function jb(a,
b,c){this.width=a;this.height=b;this.scissor=new ca(0,0,a,b);this.scissorTest=!1;this.viewport=new ca(0,0,a,b);c=c||{};this.texture=new X(void 0,void 0,c.wrapS,c.wrapT,c.magFilter,c.minFilter,c.format,c.type,c.anisotropy,c.encoding);this.texture.generateMipmaps=void 0!==c.generateMipmaps?c.generateMipmaps:!1;this.texture.minFilter=void 0!==c.minFilter?c.minFilter:1006;this.depthBuffer=void 0!==c.depthBuffer?c.depthBuffer:!0;this.stencilBuffer=void 0!==c.stencilBuffer?c.stencilBuffer:!0;this.depthTexture=
void 0!==c.depthTexture?c.depthTexture:null}function Ib(a,b,c){jb.call(this,a,b,c);this.activeMipMapLevel=this.activeCubeFace=0}function kb(a,b,c,d,e,f,g,h,k,m,q,p){X.call(this,null,f,g,h,k,m,d,e,q,p);this.image={data:a,width:b,height:c};this.magFilter=void 0!==k?k:1003;this.minFilter=void 0!==m?m:1003;this.flipY=this.generateMipmaps=!1;this.unpackAlignment=1}function Wa(a,b){this.min=void 0!==a?a:new n(Infinity,Infinity,Infinity);this.max=void 0!==b?b:new n(-Infinity,-Infinity,-Infinity)}function Ea(a,
b){this.center=void 0!==a?a:new n;this.radius=void 0!==b?b:0}function Pa(a,b){this.normal=void 0!==a?a:new n(1,0,0);this.constant=void 0!==b?b:0}function td(a,b,c,d,e,f){this.planes=[void 0!==a?a:new Pa,void 0!==b?b:new Pa,void 0!==c?c:new Pa,void 0!==d?d:new Pa,void 0!==e?e:new Pa,void 0!==f?f:new Pa]}function Jb(a){var b={},c;for(c in a){b[c]={};for(var d in a[c]){var e=a[c][d];e&&(e.isColor||e.isMatrix3||e.isMatrix4||e.isVector2||e.isVector3||e.isVector4||e.isTexture)?b[c][d]=e.clone():Array.isArray(e)?
b[c][d]=e.slice():b[c][d]=e}}return b}function ua(a){for(var b={},c=0;c<a.length;c++){var d=Jb(a[c]),e;for(e in d)b[e]=d[e]}return b}function J(a,b,c){return void 0===b&&void 0===c?this.set(a):this.setRGB(a,b,c)}function Wd(){function a(e,f){!1!==c&&(d(e,f),b.requestAnimationFrame(a))}var b=null,c=!1,d=null;return{start:function(){!0!==c&&null!==d&&(b.requestAnimationFrame(a),c=!0)},stop:function(){c=!1},setAnimationLoop:function(a){d=a},setContext:function(a){b=a}}}function Nf(a){function b(b,c){var d=
b.array,e=b.dynamic?35048:35044,h=a.createBuffer();a.bindBuffer(c,h);a.bufferData(c,d,e);b.onUploadCallback();c=5126;d instanceof Float32Array?c=5126:d instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):d instanceof Uint16Array?c=5123:d instanceof Int16Array?c=5122:d instanceof Uint32Array?c=5125:d instanceof Int32Array?c=5124:d instanceof Int8Array?c=5120:d instanceof Uint8Array&&(c=5121);return{buffer:h,type:c,bytesPerElement:d.BYTES_PER_ELEMENT,
version:b.version}}var c=new WeakMap;return{get:function(a){a.isInterleavedBufferAttribute&&(a=a.data);return c.get(a)},remove:function(b){b.isInterleavedBufferAttribute&&(b=b.data);var d=c.get(b);d&&(a.deleteBuffer(d.buffer),c.delete(b))},update:function(d,e){d.isInterleavedBufferAttribute&&(d=d.data);var f=c.get(d);if(void 0===f)c.set(d,b(d,e));else if(f.version<d.version){var g=d,h=g.array,k=g.updateRange;a.bindBuffer(e,f.buffer);!1===g.dynamic?a.bufferData(e,h,35044):-1===k.count?a.bufferSubData(e,
0,h):0===k.count?console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually."):(a.bufferSubData(e,k.offset*h.BYTES_PER_ELEMENT,h.subarray(k.offset,k.offset+k.count)),k.count=-1);f.version=d.version}}}}function Kb(a,b,c,d,e,f){this.a=a;this.b=b;this.c=c;this.normal=d&&d.isVector3?d:new n;this.vertexNormals=Array.isArray(d)?d:[];this.color=e&&e.isColor?e:new J;this.vertexColors=
Array.isArray(e)?e:[];this.materialIndex=void 0!==f?f:0}function lb(a,b,c,d){this._x=a||0;this._y=b||0;this._z=c||0;this._order=d||lb.DefaultOrder}function Xd(){this.mask=1}function C(){Object.defineProperty(this,"id",{value:Of++});this.uuid=R.generateUUID();this.name="";this.type="Object3D";this.parent=null;this.children=[];this.up=C.DefaultUp.clone();var a=new n,b=new lb,c=new ka,d=new n(1,1,1);b.onChange(function(){c.setFromEuler(b,!1)});c.onChange(function(){b.setFromQuaternion(c,void 0,!1)});
Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:a},rotation:{configurable:!0,enumerable:!0,value:b},quaternion:{configurable:!0,enumerable:!0,value:c},scale:{configurable:!0,enumerable:!0,value:d},modelViewMatrix:{value:new O},normalMatrix:{value:new da}});this.matrix=new O;this.matrixWorld=new O;this.matrixAutoUpdate=C.DefaultMatrixAutoUpdate;this.matrixWorldNeedsUpdate=!1;this.layers=new Xd;this.visible=!0;this.receiveShadow=this.castShadow=!1;this.frustumCulled=!0;this.renderOrder=
0;this.userData={}}function Q(){Object.defineProperty(this,"id",{value:Pf+=2});this.uuid=R.generateUUID();this.name="";this.type="Geometry";this.vertices=[];this.colors=[];this.faces=[];this.faceVertexUvs=[[]];this.morphTargets=[];this.morphNormals=[];this.skinWeights=[];this.skinIndices=[];this.lineDistances=[];this.boundingSphere=this.boundingBox=null;this.groupsNeedUpdate=this.lineDistancesNeedUpdate=this.colorsNeedUpdate=this.normalsNeedUpdate=this.uvsNeedUpdate=this.verticesNeedUpdate=this.elementsNeedUpdate=
!1}function E(a,b,c){if(Array.isArray(a))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="";this.array=a;this.itemSize=b;this.count=void 0!==a?a.length/b:0;this.normalized=!0===c;this.dynamic=!1;this.updateRange={offset:0,count:-1};this.version=0}function tc(a,b,c){E.call(this,new Int8Array(a),b,c)}function uc(a,b,c){E.call(this,new Uint8Array(a),b,c)}function vc(a,b,c){E.call(this,new Uint8ClampedArray(a),b,c)}function wc(a,b,c){E.call(this,new Int16Array(a),
b,c)}function mb(a,b,c){E.call(this,new Uint16Array(a),b,c)}function xc(a,b,c){E.call(this,new Int32Array(a),b,c)}function nb(a,b,c){E.call(this,new Uint32Array(a),b,c)}function B(a,b,c){E.call(this,new Float32Array(a),b,c)}function yc(a,b,c){E.call(this,new Float64Array(a),b,c)}function Je(){this.vertices=[];this.normals=[];this.colors=[];this.uvs=[];this.uvs2=[];this.groups=[];this.morphTargets={};this.skinWeights=[];this.skinIndices=[];this.boundingSphere=this.boundingBox=null;this.groupsNeedUpdate=
this.uvsNeedUpdate=this.colorsNeedUpdate=this.normalsNeedUpdate=this.verticesNeedUpdate=!1}function Ke(a){if(0===a.length)return-Infinity;for(var b=a[0],c=1,d=a.length;c<d;++c)a[c]>b&&(b=a[c]);return b}function D(){Object.defineProperty(this,"id",{value:Qf+=2});this.uuid=R.generateUUID();this.name="";this.type="BufferGeometry";this.index=null;this.attributes={};this.morphAttributes={};this.groups=[];this.boundingSphere=this.boundingBox=null;this.drawRange={start:0,count:Infinity};this.userData={}}
function Lb(a,b,c,d,e,f){Q.call(this);this.type="BoxGeometry";this.parameters={width:a,height:b,depth:c,widthSegments:d,heightSegments:e,depthSegments:f};this.fromBufferGeometry(new ob(a,b,c,d,e,f));this.mergeVertices()}function ob(a,b,c,d,e,f){function g(a,b,c,d,e,f,g,l,W,A,Mb){var t=f/W,v=g/A,w=f/2,u=g/2,y=l/2;g=W+1;var G=A+1,H=f=0,N,z,B=new n;for(z=0;z<G;z++){var C=z*v-u;for(N=0;N<g;N++)B[a]=(N*t-w)*d,B[b]=C*e,B[c]=y,m.push(B.x,B.y,B.z),B[a]=0,B[b]=0,B[c]=0<l?1:-1,q.push(B.x,B.y,B.z),p.push(N/
W),p.push(1-z/A),f+=1}for(z=0;z<A;z++)for(N=0;N<W;N++)a=r+N+g*(z+1),b=r+(N+1)+g*(z+1),c=r+(N+1)+g*z,k.push(r+N+g*z,a,c),k.push(a,b,c),H+=6;h.addGroup(x,H,Mb);x+=H;r+=f}D.call(this);this.type="BoxBufferGeometry";this.parameters={width:a,height:b,depth:c,widthSegments:d,heightSegments:e,depthSegments:f};var h=this;a=a||1;b=b||1;c=c||1;d=Math.floor(d)||1;e=Math.floor(e)||1;f=Math.floor(f)||1;var k=[],m=[],q=[],p=[],r=0,x=0;g("z","y","x",-1,-1,c,b,a,f,e,0);g("z","y","x",1,-1,c,b,-a,f,e,1);g("x","z","y",
1,1,a,c,b,d,f,2);g("x","z","y",1,-1,a,c,-b,d,f,3);g("x","y","z",1,-1,a,b,c,d,e,4);g("x","y","z",-1,-1,a,b,-c,d,e,5);this.setIndex(k);this.addAttribute("position",new B(m,3));this.addAttribute("normal",new B(q,3));this.addAttribute("uv",new B(p,2))}function zc(a,b,c,d){Q.call(this);this.type="PlaneGeometry";this.parameters={width:a,height:b,widthSegments:c,heightSegments:d};this.fromBufferGeometry(new pb(a,b,c,d));this.mergeVertices()}function pb(a,b,c,d){D.call(this);this.type="PlaneBufferGeometry";
this.parameters={width:a,height:b,widthSegments:c,heightSegments:d};a=a||1;b=b||1;var e=a/2,f=b/2;c=Math.floor(c)||1;d=Math.floor(d)||1;var g=c+1,h=d+1,k=a/c,m=b/d,q=[],p=[],r=[],x=[];for(a=0;a<h;a++){var l=a*m-f;for(b=0;b<g;b++)p.push(b*k-e,-l,0),r.push(0,0,1),x.push(b/c),x.push(1-a/d)}for(a=0;a<d;a++)for(b=0;b<c;b++)e=b+g*(a+1),f=b+1+g*(a+1),h=b+1+g*a,q.push(b+g*a,e,h),q.push(e,f,h);this.setIndex(q);this.addAttribute("position",new B(p,3));this.addAttribute("normal",new B(r,3));this.addAttribute("uv",
new B(x,2))}function L(){Object.defineProperty(this,"id",{value:Rf++});this.uuid=R.generateUUID();this.name="";this.type="Material";this.lights=this.fog=!0;this.blending=1;this.side=0;this.flatShading=!1;this.vertexColors=0;this.opacity=1;this.transparent=!1;this.blendSrc=204;this.blendDst=205;this.blendEquation=100;this.blendEquationAlpha=this.blendDstAlpha=this.blendSrcAlpha=null;this.depthFunc=3;this.depthWrite=this.depthTest=!0;this.clippingPlanes=null;this.clipShadows=this.clipIntersection=!1;
this.shadowSide=null;this.colorWrite=!0;this.precision=null;this.polygonOffset=!1;this.polygonOffsetUnits=this.polygonOffsetFactor=0;this.dithering=!1;this.alphaTest=0;this.premultipliedAlpha=!1;this.visible=!0;this.userData={};this.needsUpdate=!0}function Ba(a){L.call(this);this.type="ShaderMaterial";this.defines={};this.uniforms={};this.vertexShader="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";this.fragmentShader="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
this.linewidth=1;this.wireframe=!1;this.wireframeLinewidth=1;this.morphNormals=this.morphTargets=this.skinning=this.clipping=this.lights=this.fog=!1;this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1};this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]};this.index0AttributeName=void 0;this.uniformsNeedUpdate=!1;void 0!==a&&(void 0!==a.attributes&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(a))}
function qb(a,b){this.origin=void 0!==a?a:new n;this.direction=void 0!==b?b:new n}function ha(a,b,c){this.a=void 0!==a?a:new n;this.b=void 0!==b?b:new n;this.c=void 0!==c?c:new n}function Da(a){L.call(this);this.type="MeshBasicMaterial";this.color=new J(16777215);this.lightMap=this.map=null;this.lightMapIntensity=1;this.aoMap=null;this.aoMapIntensity=1;this.envMap=this.alphaMap=this.specularMap=null;this.combine=0;this.reflectivity=1;this.refractionRatio=.98;this.wireframe=!1;this.wireframeLinewidth=
1;this.wireframeLinejoin=this.wireframeLinecap="round";this.lights=this.morphTargets=this.skinning=!1;this.setValues(a)}function pa(a,b){C.call(this);this.type="Mesh";this.geometry=void 0!==a?a:new D;this.material=void 0!==b?b:new Da({color:16777215*Math.random()});this.drawMode=0;this.updateMorphTargets()}function Sf(a,b,c,d){function e(a,c){b.buffers.color.setClear(a.r,a.g,a.b,c,d)}var f=new J(0),g=0,h,k,m=null,q=0;return{getClearColor:function(){return f},setClearColor:function(a,b){f.set(a);g=
void 0!==b?b:1;e(f,g)},getClearAlpha:function(){return g},setClearAlpha:function(a){g=a;e(f,g)},render:function(b,d,x,l){d=d.background;null===d?(e(f,g),m=null,q=0):d&&d.isColor&&(e(d,1),l=!0,m=null,q=0);(a.autoClear||l)&&a.clear(a.autoClearColor,a.autoClearDepth,a.autoClearStencil);if(d&&(d.isCubeTexture||d.isWebGLRenderTargetCube)){void 0===k&&(k=new pa(new ob(1,1,1),new Ba({type:"BackgroundCubeMaterial",uniforms:Jb(Qa.cube.uniforms),vertexShader:Qa.cube.vertexShader,fragmentShader:Qa.cube.fragmentShader,
side:1,depthTest:!0,depthWrite:!1,fog:!1})),k.geometry.removeAttribute("normal"),k.geometry.removeAttribute("uv"),k.onBeforeRender=function(a,b,c){this.matrixWorld.copyPosition(c.matrixWorld)},Object.defineProperty(k.material,"map",{get:function(){return this.uniforms.tCube.value}}),c.update(k));l=d.isWebGLRenderTargetCube?d.texture:d;k.material.uniforms.tCube.value=l;k.material.uniforms.tFlip.value=d.isWebGLRenderTargetCube?1:-1;if(m!==d||q!==l.version)k.material.needsUpdate=!0,m=d,q=l.version;b.unshift(k,
k.geometry,k.material,0,null)}else if(d&&d.isTexture){void 0===h&&(h=new pa(new pb(2,2),new Ba({type:"BackgroundMaterial",uniforms:Jb(Qa.background.uniforms),vertexShader:Qa.background.vertexShader,fragmentShader:Qa.background.fragmentShader,side:0,depthTest:!1,depthWrite:!1,fog:!1})),h.geometry.removeAttribute("normal"),Object.defineProperty(h.material,"map",{get:function(){return this.uniforms.t2D.value}}),c.update(h));h.material.uniforms.t2D.value=d;!0===d.matrixAutoUpdate&&d.updateMatrix();h.material.uniforms.uvTransform.value.copy(d.matrix);
if(m!==d||q!==d.version)h.material.needsUpdate=!0,m=d,q=d.version;b.unshift(h,h.geometry,h.material,0,null)}}}}function Tf(a,b,c,d){var e;this.setMode=function(a){e=a};this.render=function(b,d){a.drawArrays(e,b,d);c.update(d,e)};this.renderInstances=function(f,g,h){if(d.isWebGL2)var k=a;else if(k=b.get("ANGLE_instanced_arrays"),null===k){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}k[d.isWebGL2?
"drawArraysInstanced":"drawArraysInstancedANGLE"](e,g,h,f.maxInstancedCount);c.update(h,e,f.maxInstancedCount)}}function Uf(a,b,c){function d(b){if("highp"===b){if(0<a.getShaderPrecisionFormat(35633,36338).precision&&0<a.getShaderPrecisionFormat(35632,36338).precision)return"highp";b="mediump"}return"mediump"===b&&0<a.getShaderPrecisionFormat(35633,36337).precision&&0<a.getShaderPrecisionFormat(35632,36337).precision?"mediump":"lowp"}var e,f="undefined"!==typeof WebGL2RenderingContext&&a instanceof
WebGL2RenderingContext,g=void 0!==c.precision?c.precision:"highp",h=d(g);h!==g&&(console.warn("THREE.WebGLRenderer:",g,"not supported, using",h,"instead."),g=h);c=!0===c.logarithmicDepthBuffer;h=a.getParameter(34930);var k=a.getParameter(35660),m=a.getParameter(3379),q=a.getParameter(34076),p=a.getParameter(34921),r=a.getParameter(36347),l=a.getParameter(36348),t=a.getParameter(36349),v=0<k,w=f||!!b.get("OES_texture_float");return{isWebGL2:f,getMaxAnisotropy:function(){if(void 0!==e)return e;var c=
b.get("EXT_texture_filter_anisotropic");return e=null!==c?a.getParameter(c.MAX_TEXTURE_MAX_ANISOTROPY_EXT):0},getMaxPrecision:d,precision:g,logarithmicDepthBuffer:c,maxTextures:h,maxVertexTextures:k,maxTextureSize:m,maxCubemapSize:q,maxAttributes:p,maxVertexUniforms:r,maxVaryings:l,maxFragmentUniforms:t,vertexTextures:v,floatFragmentTextures:w,floatVertexTextures:v&&w}}function Vf(){function a(){m.value!==d&&(m.value=d,m.needsUpdate=0<e);c.numPlanes=e;c.numIntersection=0}function b(a,b,d,e){var f=
null!==a?a.length:0,g=null;if(0!==f){g=m.value;if(!0!==e||null===g){e=d+4*f;b=b.matrixWorldInverse;k.getNormalMatrix(b);if(null===g||g.length<e)g=new Float32Array(e);for(e=0;e!==f;++e,d+=4)h.copy(a[e]).applyMatrix4(b,k),h.normal.toArray(g,d),g[d+3]=h.constant}m.value=g;m.needsUpdate=!0}c.numPlanes=f;return g}var c=this,d=null,e=0,f=!1,g=!1,h=new Pa,k=new da,m={value:null,needsUpdate:!1};this.uniform=m;this.numIntersection=this.numPlanes=0;this.init=function(a,c,g){var h=0!==a.length||c||0!==e||f;
f=c;d=b(a,g,0);e=a.length;return h};this.beginShadows=function(){g=!0;b(null)};this.endShadows=function(){g=!1;a()};this.setState=function(c,h,k,l,t,v){if(!f||null===c||0===c.length||g&&!k)g?b(null):a();else{k=g?0:e;var q=4*k,p=t.clippingState||null;m.value=p;p=b(c,l,q,v);for(c=0;c!==q;++c)p[c]=d[c];t.clippingState=p;this.numIntersection=h?this.numPlanes:0;this.numPlanes+=k}}}function Wf(a){var b={};return{get:function(c){if(void 0!==b[c])return b[c];switch(c){case "WEBGL_depth_texture":var d=a.getExtension("WEBGL_depth_texture")||
a.getExtension("MOZ_WEBGL_depth_texture")||a.getExtension("WEBKIT_WEBGL_depth_texture");break;case "EXT_texture_filter_anisotropic":d=a.getExtension("EXT_texture_filter_anisotropic")||a.getExtension("MOZ_EXT_texture_filter_anisotropic")||a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case "WEBGL_compressed_texture_s3tc":d=a.getExtension("WEBGL_compressed_texture_s3tc")||a.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;
case "WEBGL_compressed_texture_pvrtc":d=a.getExtension("WEBGL_compressed_texture_pvrtc")||a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:d=a.getExtension(c)}null===d&&console.warn("THREE.WebGLRenderer: "+c+" extension not supported.");return b[c]=d}}}function Xf(a,b,c){function d(a){var g=a.target;a=e[g.id];null!==a.index&&b.remove(a.index);for(var k in a.attributes)b.remove(a.attributes[k]);g.removeEventListener("dispose",d);delete e[g.id];if(k=f[a.id])b.remove(k),delete f[a.id];
c.memory.geometries--}var e={},f={};return{get:function(a,b){var f=e[b.id];if(f)return f;b.addEventListener("dispose",d);b.isBufferGeometry?f=b:b.isGeometry&&(void 0===b._bufferGeometry&&(b._bufferGeometry=(new D).setFromObject(a)),f=b._bufferGeometry);e[b.id]=f;c.memory.geometries++;return f},update:function(a){var c=a.index,d=a.attributes;null!==c&&b.update(c,34963);for(var e in d)b.update(d[e],34962);a=a.morphAttributes;for(e in a){c=a[e];d=0;for(var f=c.length;d<f;d++)b.update(c[d],34962)}},getWireframeAttribute:function(a){var c=
f[a.id];if(c)return c;c=[];var d=a.index,e=a.attributes;if(null!==d){d=d.array;e=0;for(var g=d.length;e<g;e+=3){var p=d[e+0],r=d[e+1],l=d[e+2];c.push(p,r,r,l,l,p)}}else for(d=e.position.array,e=0,g=d.length/3-1;e<g;e+=3)p=e+0,r=e+1,l=e+2,c.push(p,r,r,l,l,p);c=new (65535<Ke(c)?nb:mb)(c,1);b.update(c,34963);return f[a.id]=c}}}function Yf(a,b,c,d){var e,f,g;this.setMode=function(a){e=a};this.setIndex=function(a){f=a.type;g=a.bytesPerElement};this.render=function(b,d){a.drawElements(e,d,f,b*g);c.update(d,
e)};this.renderInstances=function(h,k,m){if(d.isWebGL2)var q=a;else if(q=b.get("ANGLE_instanced_arrays"),null===q){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}q[d.isWebGL2?"drawElementsInstanced":"drawElementsInstancedANGLE"](e,m,f,k*g,h.maxInstancedCount);c.update(m,e,h.maxInstancedCount)}}function Zf(a){var b={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,
textures:0},render:b,programs:null,autoReset:!0,reset:function(){b.frame++;b.calls=0;b.triangles=0;b.points=0;b.lines=0},update:function(a,d,e){e=e||1;b.calls++;switch(d){case 4:b.triangles+=a/3*e;break;case 5:case 6:b.triangles+=e*(a-2);break;case 1:b.lines+=a/2*e;break;case 3:b.lines+=e*(a-1);break;case 2:b.lines+=e*a;break;case 0:b.points+=e*a;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",d)}}}}function $f(a,b){return Math.abs(b[1])-Math.abs(a[1])}function ag(a){var b={},c=
new Float32Array(8);return{update:function(d,e,f,g){var h=d.morphTargetInfluences,k=h.length;d=b[e.id];if(void 0===d){d=[];for(var m=0;m<k;m++)d[m]=[m,0];b[e.id]=d}var q=f.morphTargets&&e.morphAttributes.position;f=f.morphNormals&&e.morphAttributes.normal;for(m=0;m<k;m++){var p=d[m];0!==p[1]&&(q&&e.removeAttribute("morphTarget"+m),f&&e.removeAttribute("morphNormal"+m))}for(m=0;m<k;m++)p=d[m],p[0]=m,p[1]=h[m];d.sort($f);for(m=0;8>m;m++){if(p=d[m])if(h=p[0],k=p[1]){q&&e.addAttribute("morphTarget"+m,
q[h]);f&&e.addAttribute("morphNormal"+m,f[h]);c[m]=k;continue}c[m]=0}g.getUniforms().setValue(a,"morphTargetInfluences",c)}}}function bg(a,b){var c={};return{update:function(d){var e=b.render.frame,f=d.geometry,g=a.get(d,f);c[g.id]!==e&&(f.isGeometry&&g.updateFromObject(d),a.update(g),c[g.id]=e);return g},dispose:function(){c={}}}}function Xa(a,b,c,d,e,f,g,h,k,m){a=void 0!==a?a:[];X.call(this,a,void 0!==b?b:301,c,d,e,f,g,h,k,m);this.flipY=!1}function Nb(a,b,c,d){X.call(this,null);this.image={data:a,
width:b,height:c,depth:d};this.minFilter=this.magFilter=1003;this.flipY=this.generateMipmaps=!1}function Ob(a,b,c){var d=a[0];if(0>=d||0<d)return a;var e=b*c,f=Le[e];void 0===f&&(f=new Float32Array(e),Le[e]=f);if(0!==b)for(d.toArray(f,0),d=1,e=0;d!==b;++d)e+=c,a[d].toArray(f,e);return f}function ea(a,b){if(a.length!==b.length)return!1;for(var c=0,d=a.length;c<d;c++)if(a[c]!==b[c])return!1;return!0}function sa(a,b){for(var c=0,d=b.length;c<d;c++)a[c]=b[c]}function Me(a,b){var c=Ne[b];void 0===c&&(c=
new Int32Array(b),Ne[b]=c);for(var d=0;d!==b;++d)c[d]=a.allocTextureUnit();return c}function cg(a,b){var c=this.cache;c[0]!==b&&(a.uniform1f(this.addr,b),c[0]=b)}function dg(a,b){var c=this.cache;c[0]!==b&&(a.uniform1i(this.addr,b),c[0]=b)}function eg(a,b){var c=this.cache;if(void 0!==b.x){if(c[0]!==b.x||c[1]!==b.y)a.uniform2f(this.addr,b.x,b.y),c[0]=b.x,c[1]=b.y}else ea(c,b)||(a.uniform2fv(this.addr,b),sa(c,b))}function fg(a,b){var c=this.cache;if(void 0!==b.x){if(c[0]!==b.x||c[1]!==b.y||c[2]!==
b.z)a.uniform3f(this.addr,b.x,b.y,b.z),c[0]=b.x,c[1]=b.y,c[2]=b.z}else if(void 0!==b.r){if(c[0]!==b.r||c[1]!==b.g||c[2]!==b.b)a.uniform3f(this.addr,b.r,b.g,b.b),c[0]=b.r,c[1]=b.g,c[2]=b.b}else ea(c,b)||(a.uniform3fv(this.addr,b),sa(c,b))}function gg(a,b){var c=this.cache;if(void 0!==b.x){if(c[0]!==b.x||c[1]!==b.y||c[2]!==b.z||c[3]!==b.w)a.uniform4f(this.addr,b.x,b.y,b.z,b.w),c[0]=b.x,c[1]=b.y,c[2]=b.z,c[3]=b.w}else ea(c,b)||(a.uniform4fv(this.addr,b),sa(c,b))}function hg(a,b){var c=this.cache,d=b.elements;
void 0===d?ea(c,b)||(a.uniformMatrix2fv(this.addr,!1,b),sa(c,b)):ea(c,d)||(Oe.set(d),a.uniformMatrix2fv(this.addr,!1,Oe),sa(c,d))}function ig(a,b){var c=this.cache,d=b.elements;void 0===d?ea(c,b)||(a.uniformMatrix3fv(this.addr,!1,b),sa(c,b)):ea(c,d)||(Pe.set(d),a.uniformMatrix3fv(this.addr,!1,Pe),sa(c,d))}function jg(a,b){var c=this.cache,d=b.elements;void 0===d?ea(c,b)||(a.uniformMatrix4fv(this.addr,!1,b),sa(c,b)):ea(c,d)||(Qe.set(d),a.uniformMatrix4fv(this.addr,!1,Qe),sa(c,d))}function kg(a,b,c){var d=
this.cache,e=c.allocTextureUnit();d[0]!==e&&(a.uniform1i(this.addr,e),d[0]=e);c.setTexture2D(b||Re,e)}function lg(a,b,c){var d=this.cache,e=c.allocTextureUnit();d[0]!==e&&(a.uniform1i(this.addr,e),d[0]=e);c.setTexture3D(b||mg,e)}function ng(a,b,c){var d=this.cache,e=c.allocTextureUnit();d[0]!==e&&(a.uniform1i(this.addr,e),d[0]=e);c.setTextureCube(b||Se,e)}function Te(a,b){var c=this.cache;ea(c,b)||(a.uniform2iv(this.addr,b),sa(c,b))}function Ue(a,b){var c=this.cache;ea(c,b)||(a.uniform3iv(this.addr,
b),sa(c,b))}function Ve(a,b){var c=this.cache;ea(c,b)||(a.uniform4iv(this.addr,b),sa(c,b))}function og(a){switch(a){case 5126:return cg;case 35664:return eg;case 35665:return fg;case 35666:return gg;case 35674:return hg;case 35675:return ig;case 35676:return jg;case 35678:case 36198:return kg;case 35679:return lg;case 35680:return ng;case 5124:case 35670:return dg;case 35667:case 35671:return Te;case 35668:case 35672:return Ue;case 35669:case 35673:return Ve}}function pg(a,b){var c=this.cache;ea(c,
b)||(a.uniform1fv(this.addr,b),sa(c,b))}function qg(a,b){var c=this.cache;ea(c,b)||(a.uniform1iv(this.addr,b),sa(c,b))}function rg(a,b){var c=this.cache;b=Ob(b,this.size,2);ea(c,b)||(a.uniform2fv(this.addr,b),this.updateCache(b))}function sg(a,b){var c=this.cache;b=Ob(b,this.size,3);ea(c,b)||(a.uniform3fv(this.addr,b),this.updateCache(b))}function tg(a,b){var c=this.cache;b=Ob(b,this.size,4);ea(c,b)||(a.uniform4fv(this.addr,b),this.updateCache(b))}function ug(a,b){var c=this.cache;b=Ob(b,this.size,
4);ea(c,b)||(a.uniformMatrix2fv(this.addr,!1,b),this.updateCache(b))}function vg(a,b){var c=this.cache;b=Ob(b,this.size,9);ea(c,b)||(a.uniformMatrix3fv(this.addr,!1,b),this.updateCache(b))}function wg(a,b){var c=this.cache;b=Ob(b,this.size,16);ea(c,b)||(a.uniformMatrix4fv(this.addr,!1,b),this.updateCache(b))}function xg(a,b,c){var d=this.cache,e=b.length,f=Me(c,e);!1===ea(d,f)&&(a.uniform1iv(this.addr,f),sa(d,f));for(a=0;a!==e;++a)c.setTexture2D(b[a]||Re,f[a])}function yg(a,b,c){var d=this.cache,
e=b.length,f=Me(c,e);!1===ea(d,f)&&(a.uniform1iv(this.addr,f),sa(d,f));for(a=0;a!==e;++a)c.setTextureCube(b[a]||Se,f[a])}function zg(a){switch(a){case 5126:return pg;case 35664:return rg;case 35665:return sg;case 35666:return tg;case 35674:return ug;case 35675:return vg;case 35676:return wg;case 35678:return xg;case 35680:return yg;case 5124:case 35670:return qg;case 35667:case 35671:return Te;case 35668:case 35672:return Ue;case 35669:case 35673:return Ve}}function Ag(a,b,c){this.id=a;this.addr=
c;this.cache=[];this.setValue=og(b.type)}function We(a,b,c){this.id=a;this.addr=c;this.cache=[];this.size=b.size;this.setValue=zg(b.type)}function Xe(a){this.id=a;this.seq=[];this.map={}}function cb(a,b,c){this.seq=[];this.map={};this.renderer=c;c=a.getProgramParameter(b,35718);for(var d=0;d<c;++d){var e=a.getActiveUniform(b,d),f=a.getUniformLocation(b,e.name),g=this,h=e.name,k=h.length;for(Zd.lastIndex=0;;){var m=Zd.exec(h),q=Zd.lastIndex,p=m[1],r=m[3];"]"===m[2]&&(p|=0);if(void 0===r||"["===r&&
q+2===k){h=g;e=void 0===r?new Ag(p,e,f):new We(p,e,f);h.seq.push(e);h.map[e.id]=e;break}else r=g.map[p],void 0===r&&(r=new Xe(p),p=g,g=r,p.seq.push(g),p.map[g.id]=g),g=r}}}function Bg(a){a=a.split("\n");for(var b=0;b<a.length;b++)a[b]=b+1+": "+a[b];return a.join("\n")}function Ye(a,b,c){var d=a.createShader(b);a.shaderSource(d,c);a.compileShader(d);!1===a.getShaderParameter(d,35713)&&console.error("THREE.WebGLShader: Shader couldn't compile.");""!==a.getShaderInfoLog(d)&&console.warn("THREE.WebGLShader: gl.getShaderInfoLog()",
35633===b?"vertex":"fragment",a.getShaderInfoLog(d),Bg(c));return d}function Ze(a){switch(a){case 3E3:return["Linear","( value )"];case 3001:return["sRGB","( value )"];case 3002:return["RGBE","( value )"];case 3004:return["RGBM","( value, 7.0 )"];case 3005:return["RGBM","( value, 16.0 )"];case 3006:return["RGBD","( value, 256.0 )"];case 3007:return["Gamma","( value, float( GAMMA_FACTOR ) )"];default:throw Error("unsupported encoding: "+a);}}function vd(a,b){b=Ze(b);return"vec4 "+a+"( vec4 value ) { return "+
b[0]+"ToLinear"+b[1]+"; }"}function Cg(a,b){b=Ze(b);return"vec4 "+a+"( vec4 value ) { return LinearTo"+b[0]+b[1]+"; }"}function Dg(a,b){switch(b){case 1:b="Linear";break;case 2:b="Reinhard";break;case 3:b="Uncharted2";break;case 4:b="OptimizedCineon";break;case 5:b="ACESFilmic";break;default:throw Error("unsupported toneMapping: "+b);}return"vec3 "+a+"( vec3 color ) { return "+b+"ToneMapping( color ); }"}function Eg(a,b,c){a=a||{};return[a.derivatives||b.envMapCubeUV||b.bumpMap||b.normalMap&&!b.objectSpaceNormalMap||
b.flatShading?"#extension GL_OES_standard_derivatives : enable":"",(a.fragDepth||b.logarithmicDepthBuffer)&&c.get("EXT_frag_depth")?"#extension GL_EXT_frag_depth : enable":"",a.drawBuffers&&c.get("WEBGL_draw_buffers")?"#extension GL_EXT_draw_buffers : require":"",(a.shaderTextureLOD||b.envMap)&&c.get("EXT_shader_texture_lod")?"#extension GL_EXT_shader_texture_lod : enable":""].filter(Ac).join("\n")}function Fg(a){var b=[],c;for(c in a){var d=a[c];!1!==d&&b.push("#define "+c+" "+d)}return b.join("\n")}
function Ac(a){return""!==a}function $e(a,b){return a.replace(/NUM_DIR_LIGHTS/g,b.numDirLights).replace(/NUM_SPOT_LIGHTS/g,b.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,b.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,b.numPointLights).replace(/NUM_HEMI_LIGHTS/g,b.numHemiLights)}function af(a,b){return a.replace(/NUM_CLIPPING_PLANES/g,b.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,b.numClippingPlanes-b.numClipIntersection)}function $d(a){return a.replace(/^[ \t]*#include +<([\w\d./]+)>/gm,
function(a,c){a=I[c];if(void 0===a)throw Error("Can not resolve #include <"+c+">");return $d(a)})}function bf(a){return a.replace(/#pragma unroll_loop[\s]+?for \( int i = (\d+); i < (\d+); i \+\+ \) \{([\s\S]+?)(?=\})\}/g,function(a,c,d,e){a="";for(c=parseInt(c);c<parseInt(d);c++)a+=e.replace(/\[ i \]/g,"[ "+c+" ]");return a})}function Gg(a,b,c,d,e,f,g){var h=a.context,k=d.defines,m=e.vertexShader,q=e.fragmentShader,p="SHADOWMAP_TYPE_BASIC";1===f.shadowMapType?p="SHADOWMAP_TYPE_PCF":2===f.shadowMapType&&
(p="SHADOWMAP_TYPE_PCF_SOFT");var r="ENVMAP_TYPE_CUBE",l="ENVMAP_MODE_REFLECTION",t="ENVMAP_BLENDING_MULTIPLY";if(f.envMap){switch(d.envMap.mapping){case 301:case 302:r="ENVMAP_TYPE_CUBE";break;case 306:case 307:r="ENVMAP_TYPE_CUBE_UV";break;case 303:case 304:r="ENVMAP_TYPE_EQUIREC";break;case 305:r="ENVMAP_TYPE_SPHERE"}switch(d.envMap.mapping){case 302:case 304:l="ENVMAP_MODE_REFRACTION"}switch(d.combine){case 0:t="ENVMAP_BLENDING_MULTIPLY";break;case 1:t="ENVMAP_BLENDING_MIX";break;case 2:t="ENVMAP_BLENDING_ADD"}}var v=
0<a.gammaFactor?a.gammaFactor:1,w=g.isWebGL2?"":Eg(d.extensions,f,b),n=Fg(k),u=h.createProgram();d.isRawShaderMaterial?(k=[n].filter(Ac).join("\n"),0<k.length&&(k+="\n"),b=[w,n].filter(Ac).join("\n"),0<b.length&&(b+="\n")):(k=["precision "+f.precision+" float;","precision "+f.precision+" int;","#define SHADER_NAME "+e.name,n,f.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+v,"#define MAX_BONES "+f.maxBones,f.useFog&&f.fog?"#define USE_FOG":"",f.useFog&&f.fogExp?"#define FOG_EXP2":
"",f.map?"#define USE_MAP":"",f.envMap?"#define USE_ENVMAP":"",f.envMap?"#define "+l:"",f.lightMap?"#define USE_LIGHTMAP":"",f.aoMap?"#define USE_AOMAP":"",f.emissiveMap?"#define USE_EMISSIVEMAP":"",f.bumpMap?"#define USE_BUMPMAP":"",f.normalMap?"#define USE_NORMALMAP":"",f.normalMap&&f.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",f.displacementMap&&f.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",f.specularMap?"#define USE_SPECULARMAP":"",f.roughnessMap?"#define USE_ROUGHNESSMAP":
"",f.metalnessMap?"#define USE_METALNESSMAP":"",f.alphaMap?"#define USE_ALPHAMAP":"",f.vertexColors?"#define USE_COLOR":"",f.flatShading?"#define FLAT_SHADED":"",f.skinning?"#define USE_SKINNING":"",f.useVertexTexture?"#define BONE_TEXTURE":"",f.morphTargets?"#define USE_MORPHTARGETS":"",f.morphNormals&&!1===f.flatShading?"#define USE_MORPHNORMALS":"",f.doubleSided?"#define DOUBLE_SIDED":"",f.flipSided?"#define FLIP_SIDED":"",f.shadowMapEnabled?"#define USE_SHADOWMAP":"",f.shadowMapEnabled?"#define "+
p:"",f.sizeAttenuation?"#define USE_SIZEATTENUATION":"",f.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",f.logarithmicDepthBuffer&&(g.isWebGL2||b.get("EXT_frag_depth"))?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_COLOR","\tattribute vec3 color;",
"#endif","#ifdef USE_MORPHTARGETS","\tattribute vec3 morphTarget0;","\tattribute vec3 morphTarget1;","\tattribute vec3 morphTarget2;","\tattribute vec3 morphTarget3;","\t#ifdef USE_MORPHNORMALS","\t\tattribute vec3 morphNormal0;","\t\tattribute vec3 morphNormal1;","\t\tattribute vec3 morphNormal2;","\t\tattribute vec3 morphNormal3;","\t#else","\t\tattribute vec3 morphTarget4;","\t\tattribute vec3 morphTarget5;","\t\tattribute vec3 morphTarget6;","\t\tattribute vec3 morphTarget7;","\t#endif","#endif",
"#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(Ac).join("\n"),b=[w,"precision "+f.precision+" float;","precision "+f.precision+" int;","#define SHADER_NAME "+e.name,n,f.alphaTest?"#define ALPHATEST "+f.alphaTest+(f.alphaTest%1?"":".0"):"","#define GAMMA_FACTOR "+v,f.useFog&&f.fog?"#define USE_FOG":"",f.useFog&&f.fogExp?"#define FOG_EXP2":"",f.map?"#define USE_MAP":"",f.matcap?"#define USE_MATCAP":"",f.envMap?"#define USE_ENVMAP":"",f.envMap?
"#define "+r:"",f.envMap?"#define "+l:"",f.envMap?"#define "+t:"",f.lightMap?"#define USE_LIGHTMAP":"",f.aoMap?"#define USE_AOMAP":"",f.emissiveMap?"#define USE_EMISSIVEMAP":"",f.bumpMap?"#define USE_BUMPMAP":"",f.normalMap?"#define USE_NORMALMAP":"",f.normalMap&&f.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",f.specularMap?"#define USE_SPECULARMAP":"",f.roughnessMap?"#define USE_ROUGHNESSMAP":"",f.metalnessMap?"#define USE_METALNESSMAP":"",f.alphaMap?"#define USE_ALPHAMAP":"",f.vertexColors?
"#define USE_COLOR":"",f.gradientMap?"#define USE_GRADIENTMAP":"",f.flatShading?"#define FLAT_SHADED":"",f.doubleSided?"#define DOUBLE_SIDED":"",f.flipSided?"#define FLIP_SIDED":"",f.shadowMapEnabled?"#define USE_SHADOWMAP":"",f.shadowMapEnabled?"#define "+p:"",f.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",f.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",f.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",f.logarithmicDepthBuffer&&(g.isWebGL2||b.get("EXT_frag_depth"))?"#define USE_LOGDEPTHBUF_EXT":
"",f.envMap&&(g.isWebGL2||b.get("EXT_shader_texture_lod"))?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;",0!==f.toneMapping?"#define TONE_MAPPING":"",0!==f.toneMapping?I.tonemapping_pars_fragment:"",0!==f.toneMapping?Dg("toneMapping",f.toneMapping):"",f.dithering?"#define DITHERING":"",f.outputEncoding||f.mapEncoding||f.matcapEncoding||f.envMapEncoding||f.emissiveMapEncoding?I.encodings_pars_fragment:"",f.mapEncoding?vd("mapTexelToLinear",f.mapEncoding):"",
f.matcapEncoding?vd("matcapTexelToLinear",f.matcapEncoding):"",f.envMapEncoding?vd("envMapTexelToLinear",f.envMapEncoding):"",f.emissiveMapEncoding?vd("emissiveMapTexelToLinear",f.emissiveMapEncoding):"",f.outputEncoding?Cg("linearToOutputTexel",f.outputEncoding):"",f.depthPacking?"#define DEPTH_PACKING "+d.depthPacking:"","\n"].filter(Ac).join("\n"));m=$d(m);m=$e(m,f);m=af(m,f);q=$d(q);q=$e(q,f);q=af(q,f);m=bf(m);q=bf(q);g.isWebGL2&&!d.isRawShaderMaterial&&(g=!1,p=/^\s*#version\s+300\s+es\s*\n/,
d.isShaderMaterial&&null!==m.match(p)&&null!==q.match(p)&&(g=!0,m=m.replace(p,""),q=q.replace(p,"")),k="#version 300 es\n\n#define attribute in\n#define varying out\n#define texture2D texture\n"+k,b=["#version 300 es\n\n#define varying in",g?"":"out highp vec4 pc_fragColor;",g?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad"].join("\n")+
"\n"+b);q=b+q;m=Ye(h,35633,k+m);q=Ye(h,35632,q);h.attachShader(u,m);h.attachShader(u,q);void 0!==d.index0AttributeName?h.bindAttribLocation(u,0,d.index0AttributeName):!0===f.morphTargets&&h.bindAttribLocation(u,0,"position");h.linkProgram(u);f=h.getProgramInfoLog(u).trim();g=h.getShaderInfoLog(m).trim();p=h.getShaderInfoLog(q).trim();l=r=!0;if(!1===h.getProgramParameter(u,35714))r=!1,console.error("THREE.WebGLProgram: shader error: ",h.getError(),"35715",h.getProgramParameter(u,35715),"gl.getProgramInfoLog",
f,g,p);else if(""!==f)console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()",f);else if(""===g||""===p)l=!1;l&&(this.diagnostics={runnable:r,material:d,programLog:f,vertexShader:{log:g,prefix:k},fragmentShader:{log:p,prefix:b}});h.deleteShader(m);h.deleteShader(q);var H;this.getUniforms=function(){void 0===H&&(H=new cb(h,u,a));return H};var G;this.getAttributes=function(){if(void 0===G){for(var a={},b=h.getProgramParameter(u,35721),c=0;c<b;c++){var d=h.getActiveAttrib(u,c).name;a[d]=h.getAttribLocation(u,
d)}G=a}return G};this.destroy=function(){h.deleteProgram(u);this.program=void 0};Object.defineProperties(this,{uniforms:{get:function(){console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms().");return this.getUniforms()}},attributes:{get:function(){console.warn("THREE.WebGLProgram: .attributes is now .getAttributes().");return this.getAttributes()}}});this.name=e.name;this.id=Hg++;this.code=c;this.usedTimes=1;this.program=u;this.vertexShader=m;this.fragmentShader=q;return this}function Ig(a,
b,c){function d(a,b){if(a)a.isTexture?c=a.encoding:a.isWebGLRenderTarget&&(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),c=a.texture.encoding);else var c=3E3;3E3===c&&b&&(c=3007);return c}var e=[],f={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"phong",MeshStandardMaterial:"physical",
MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},g="precision supportsVertexTextures map mapEncoding matcap matcapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap objectSpaceNormalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors fog useFog fogExp flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking dithering".split(" ");
this.getParameters=function(b,e,g,q,p,r,l){var h=f[b.type];if(l.isSkinnedMesh){var k=l.skeleton.bones;if(c.floatVertexTextures)k=1024;else{var m=Math.min(Math.floor((c.maxVertexUniforms-20)/4),k.length);m<k.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+k.length+" bones. This GPU supports "+m+"."),k=0):k=m}}else k=0;m=c.precision;null!==b.precision&&(m=c.getMaxPrecision(b.precision),m!==b.precision&&console.warn("THREE.WebGLProgram.getParameters:",b.precision,"not supported, using",m,"instead."));
var x=a.getRenderTarget();return{shaderID:h,precision:m,supportsVertexTextures:c.vertexTextures,outputEncoding:d(x?x.texture:null,a.gammaOutput),map:!!b.map,mapEncoding:d(b.map,a.gammaInput),matcap:!!b.matcap,matcapEncoding:d(b.matcap,a.gammaInput),envMap:!!b.envMap,envMapMode:b.envMap&&b.envMap.mapping,envMapEncoding:d(b.envMap,a.gammaInput),envMapCubeUV:!!b.envMap&&(306===b.envMap.mapping||307===b.envMap.mapping),lightMap:!!b.lightMap,aoMap:!!b.aoMap,emissiveMap:!!b.emissiveMap,emissiveMapEncoding:d(b.emissiveMap,
a.gammaInput),bumpMap:!!b.bumpMap,normalMap:!!b.normalMap,objectSpaceNormalMap:1===b.normalMapType,displacementMap:!!b.displacementMap,roughnessMap:!!b.roughnessMap,metalnessMap:!!b.metalnessMap,specularMap:!!b.specularMap,alphaMap:!!b.alphaMap,gradientMap:!!b.gradientMap,combine:b.combine,vertexColors:b.vertexColors,fog:!!q,useFog:b.fog,fogExp:q&&q.isFogExp2,flatShading:b.flatShading,sizeAttenuation:b.sizeAttenuation,logarithmicDepthBuffer:c.logarithmicDepthBuffer,skinning:b.skinning&&0<k,maxBones:k,
useVertexTexture:c.floatVertexTextures,morphTargets:b.morphTargets,morphNormals:b.morphNormals,maxMorphTargets:a.maxMorphTargets,maxMorphNormals:a.maxMorphNormals,numDirLights:e.directional.length,numPointLights:e.point.length,numSpotLights:e.spot.length,numRectAreaLights:e.rectArea.length,numHemiLights:e.hemi.length,numClippingPlanes:p,numClipIntersection:r,dithering:b.dithering,shadowMapEnabled:a.shadowMap.enabled&&l.receiveShadow&&0<g.length,shadowMapType:a.shadowMap.type,toneMapping:a.toneMapping,
physicallyCorrectLights:a.physicallyCorrectLights,premultipliedAlpha:b.premultipliedAlpha,alphaTest:b.alphaTest,doubleSided:2===b.side,flipSided:1===b.side,depthPacking:void 0!==b.depthPacking?b.depthPacking:!1}};this.getProgramCode=function(b,c){var d=[];c.shaderID?d.push(c.shaderID):(d.push(b.fragmentShader),d.push(b.vertexShader));if(void 0!==b.defines)for(var e in b.defines)d.push(e),d.push(b.defines[e]);for(e=0;e<g.length;e++)d.push(c[g[e]]);d.push(b.onBeforeCompile.toString());d.push(a.gammaOutput);
d.push(a.gammaFactor);return d.join()};this.acquireProgram=function(d,f,g,q){for(var h,k=0,m=e.length;k<m;k++){var l=e[k];if(l.code===q){h=l;++h.usedTimes;break}}void 0===h&&(h=new Gg(a,b,q,d,f,g,c),e.push(h));return h};this.releaseProgram=function(a){if(0===--a.usedTimes){var b=e.indexOf(a);e[b]=e[e.length-1];e.pop();a.destroy()}};this.programs=e}function Jg(){var a=new WeakMap;return{get:function(b){var c=a.get(b);void 0===c&&(c={},a.set(b,c));return c},remove:function(b){a.delete(b)},update:function(b,
c,d){a.get(b)[c]=d},dispose:function(){a=new WeakMap}}}function Kg(a,b){return a.renderOrder!==b.renderOrder?a.renderOrder-b.renderOrder:a.program&&b.program&&a.program!==b.program?a.program.id-b.program.id:a.material.id!==b.material.id?a.material.id-b.material.id:a.z!==b.z?a.z-b.z:a.id-b.id}function Lg(a,b){return a.renderOrder!==b.renderOrder?a.renderOrder-b.renderOrder:a.z!==b.z?b.z-a.z:a.id-b.id}function cf(){function a(a,d,e,k,m){var f=b[c];void 0===f?(f={id:a.id,object:a,geometry:d,material:e,
program:e.program,renderOrder:a.renderOrder,z:k,group:m},b[c]=f):(f.id=a.id,f.object=a,f.geometry=d,f.material=e,f.program=e.program,f.renderOrder=a.renderOrder,f.z=k,f.group=m);c++;return f}var b=[],c=0,d=[],e=[];return{opaque:d,transparent:e,init:function(){c=0;d.length=0;e.length=0},push:function(b,c,h,k,m){b=a(b,c,h,k,m);(!0===h.transparent?e:d).push(b)},unshift:function(b,c,h,k,m){b=a(b,c,h,k,m);(!0===h.transparent?e:d).unshift(b)},sort:function(){1<d.length&&d.sort(Kg);1<e.length&&e.sort(Lg)}}}
function Mg(){var a={};return{get:function(b,c){var d=a[b.id];if(void 0===d){var e=new cf;a[b.id]={};a[b.id][c.id]=e}else e=d[c.id],void 0===e&&(e=new cf,d[c.id]=e);return e},dispose:function(){a={}}}}function Ng(){var a={};return{get:function(b){if(void 0!==a[b.id])return a[b.id];switch(b.type){case "DirectionalLight":var c={direction:new n,color:new J,shadow:!1,shadowBias:0,shadowRadius:1,shadowMapSize:new z};break;case "SpotLight":c={position:new n,direction:new n,color:new J,distance:0,coneCos:0,
penumbraCos:0,decay:0,shadow:!1,shadowBias:0,shadowRadius:1,shadowMapSize:new z};break;case "PointLight":c={position:new n,color:new J,distance:0,decay:0,shadow:!1,shadowBias:0,shadowRadius:1,shadowMapSize:new z,shadowCameraNear:1,shadowCameraFar:1E3};break;case "HemisphereLight":c={direction:new n,skyColor:new J,groundColor:new J};break;case "RectAreaLight":c={color:new J,position:new n,halfWidth:new n,halfHeight:new n}}return a[b.id]=c}}}function Og(){var a=new Ng,b={id:Pg++,hash:{stateID:-1,directionalLength:-1,
pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,shadowsLength:-1},ambient:[0,0,0],directional:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],point:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]},c=new n,d=new O,e=new O;return{setup:function(f,g,h){var k=0,m=0,q=0,p=0,r=0,l=0,t=0,v=0;h=h.matrixWorldInverse;for(var w=0,n=f.length;w<n;w++){var u=f[w],H=u.color,G=u.intensity,N=u.distance,W=u.shadow&&u.shadow.map?u.shadow.map.texture:
null;if(u.isAmbientLight)k+=H.r*G,m+=H.g*G,q+=H.b*G;else if(u.isDirectionalLight){var A=a.get(u);A.color.copy(u.color).multiplyScalar(u.intensity);A.direction.setFromMatrixPosition(u.matrixWorld);c.setFromMatrixPosition(u.target.matrixWorld);A.direction.sub(c);A.direction.transformDirection(h);if(A.shadow=u.castShadow)H=u.shadow,A.shadowBias=H.bias,A.shadowRadius=H.radius,A.shadowMapSize=H.mapSize;b.directionalShadowMap[p]=W;b.directionalShadowMatrix[p]=u.shadow.matrix;b.directional[p]=A;p++}else if(u.isSpotLight){A=
a.get(u);A.position.setFromMatrixPosition(u.matrixWorld);A.position.applyMatrix4(h);A.color.copy(H).multiplyScalar(G);A.distance=N;A.direction.setFromMatrixPosition(u.matrixWorld);c.setFromMatrixPosition(u.target.matrixWorld);A.direction.sub(c);A.direction.transformDirection(h);A.coneCos=Math.cos(u.angle);A.penumbraCos=Math.cos(u.angle*(1-u.penumbra));A.decay=u.decay;if(A.shadow=u.castShadow)H=u.shadow,A.shadowBias=H.bias,A.shadowRadius=H.radius,A.shadowMapSize=H.mapSize;b.spotShadowMap[l]=W;b.spotShadowMatrix[l]=
u.shadow.matrix;b.spot[l]=A;l++}else if(u.isRectAreaLight)A=a.get(u),A.color.copy(H).multiplyScalar(G),A.position.setFromMatrixPosition(u.matrixWorld),A.position.applyMatrix4(h),e.identity(),d.copy(u.matrixWorld),d.premultiply(h),e.extractRotation(d),A.halfWidth.set(.5*u.width,0,0),A.halfHeight.set(0,.5*u.height,0),A.halfWidth.applyMatrix4(e),A.halfHeight.applyMatrix4(e),b.rectArea[t]=A,t++;else if(u.isPointLight){A=a.get(u);A.position.setFromMatrixPosition(u.matrixWorld);A.position.applyMatrix4(h);
A.color.copy(u.color).multiplyScalar(u.intensity);A.distance=u.distance;A.decay=u.decay;if(A.shadow=u.castShadow)H=u.shadow,A.shadowBias=H.bias,A.shadowRadius=H.radius,A.shadowMapSize=H.mapSize,A.shadowCameraNear=H.camera.near,A.shadowCameraFar=H.camera.far;b.pointShadowMap[r]=W;b.pointShadowMatrix[r]=u.shadow.matrix;b.point[r]=A;r++}else u.isHemisphereLight&&(A=a.get(u),A.direction.setFromMatrixPosition(u.matrixWorld),A.direction.transformDirection(h),A.direction.normalize(),A.skyColor.copy(u.color).multiplyScalar(G),
A.groundColor.copy(u.groundColor).multiplyScalar(G),b.hemi[v]=A,v++)}b.ambient[0]=k;b.ambient[1]=m;b.ambient[2]=q;b.directional.length=p;b.spot.length=l;b.rectArea.length=t;b.point.length=r;b.hemi.length=v;b.hash.stateID=b.id;b.hash.directionalLength=p;b.hash.pointLength=r;b.hash.spotLength=l;b.hash.rectAreaLength=t;b.hash.hemiLength=v;b.hash.shadowsLength=g.length},state:b}}function df(){var a=new Og,b=[],c=[];return{init:function(){b.length=0;c.length=0},state:{lightsArray:b,shadowsArray:c,lights:a},
setupLights:function(d){a.setup(b,c,d)},pushLight:function(a){b.push(a)},pushShadow:function(a){c.push(a)}}}function Qg(){var a={};return{get:function(b,c){if(void 0===a[b.id]){var d=new df;a[b.id]={};a[b.id][c.id]=d}else void 0===a[b.id][c.id]?(d=new df,a[b.id][c.id]=d):d=a[b.id][c.id];return d},dispose:function(){a={}}}}function db(a){L.call(this);this.type="MeshDepthMaterial";this.depthPacking=3200;this.morphTargets=this.skinning=!1;this.displacementMap=this.alphaMap=this.map=null;this.displacementScale=
1;this.displacementBias=0;this.wireframe=!1;this.wireframeLinewidth=1;this.lights=this.fog=!1;this.setValues(a)}function eb(a){L.call(this);this.type="MeshDistanceMaterial";this.referencePosition=new n;this.nearDistance=1;this.farDistance=1E3;this.morphTargets=this.skinning=!1;this.displacementMap=this.alphaMap=this.map=null;this.displacementScale=1;this.displacementBias=0;this.lights=this.fog=!1;this.setValues(a)}function ef(a,b,c){function d(b,c,d,e,f,g){var h=b.geometry;var k=p;var m=b.customDepthMaterial;
d&&(k=r,m=b.customDistanceMaterial);m?k=m:(m=!1,c.morphTargets&&(h&&h.isBufferGeometry?m=h.morphAttributes&&h.morphAttributes.position&&0<h.morphAttributes.position.length:h&&h.isGeometry&&(m=h.morphTargets&&0<h.morphTargets.length)),b.isSkinnedMesh&&!1===c.skinning&&console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",b),b=b.isSkinnedMesh&&c.skinning,h=0,m&&(h|=1),b&&(h|=2),k=k[h]);a.localClippingEnabled&&!0===c.clipShadows&&0!==c.clippingPlanes.length&&(h=
k.uuid,m=c.uuid,b=l[h],void 0===b&&(b={},l[h]=b),h=b[m],void 0===h&&(h=k.clone(),b[m]=h),k=h);k.visible=c.visible;k.wireframe=c.wireframe;k.side=null!=c.shadowSide?c.shadowSide:t[c.side];k.clipShadows=c.clipShadows;k.clippingPlanes=c.clippingPlanes;k.clipIntersection=c.clipIntersection;k.wireframeLinewidth=c.wireframeLinewidth;k.linewidth=c.linewidth;d&&k.isMeshDistanceMaterial&&(k.referencePosition.copy(e),k.nearDistance=f,k.farDistance=g);return k}function e(c,g,h,k){if(!1!==c.visible){if(c.layers.test(g.layers)&&
(c.isMesh||c.isLine||c.isPoints)&&c.castShadow&&(!c.frustumCulled||f.intersectsObject(c))){c.modelViewMatrix.multiplyMatrices(h.matrixWorldInverse,c.matrixWorld);var m=b.update(c),p=c.material;if(Array.isArray(p))for(var r=m.groups,l=0,t=r.length;l<t;l++){var x=r[l],W=p[x.materialIndex];W&&W.visible&&(W=d(c,W,k,q,h.near,h.far),a.renderBufferDirect(h,null,m,W,c,x))}else p.visible&&(W=d(c,p,k,q,h.near,h.far),a.renderBufferDirect(h,null,m,W,c,null))}c=c.children;m=0;for(p=c.length;m<p;m++)e(c[m],g,h,
k)}}var f=new td,g=new O,h=new z,k=new z(c,c),m=new n,q=new n,p=Array(4),r=Array(4),l={},t={0:1,1:0,2:2},v=[new n(1,0,0),new n(-1,0,0),new n(0,0,1),new n(0,0,-1),new n(0,1,0),new n(0,-1,0)],w=[new n(0,1,0),new n(0,1,0),new n(0,1,0),new n(0,1,0),new n(0,0,1),new n(0,0,-1)],y=[new ca,new ca,new ca,new ca,new ca,new ca];for(c=0;4!==c;++c){var u=0!==(c&1),H=0!==(c&2),G=new db({depthPacking:3201,morphTargets:u,skinning:H});p[c]=G;u=new eb({morphTargets:u,skinning:H});r[c]=u}var N=this;this.enabled=!1;
this.autoUpdate=!0;this.needsUpdate=!1;this.type=1;this.render=function(b,c,d){if(!1!==N.enabled&&(!1!==N.autoUpdate||!1!==N.needsUpdate)&&0!==b.length){var p=a.state;p.disable(3042);p.buffers.color.setClear(1,1,1,1);p.buffers.depth.setTest(!0);p.setScissorTest(!1);for(var r,l=0,t=b.length;l<t;l++){var x=b[l];r=x.shadow;var W=x&&x.isPointLight;if(void 0===r)console.warn("THREE.WebGLShadowMap:",x,"has no shadow.");else{var A=r.camera;h.copy(r.mapSize);h.min(k);if(W){var n=h.x,u=h.y;y[0].set(2*n,u,
n,u);y[1].set(0,u,n,u);y[2].set(3*n,u,n,u);y[3].set(n,u,n,u);y[4].set(3*n,0,n,u);y[5].set(n,0,n,u);h.x*=4;h.y*=2}null===r.map&&(r.map=new jb(h.x,h.y,{minFilter:1003,magFilter:1003,format:1023}),r.map.texture.name=x.name+".shadowMap",A.updateProjectionMatrix());r.isSpotLightShadow&&r.update(x);n=r.map;u=r.matrix;q.setFromMatrixPosition(x.matrixWorld);A.position.copy(q);W?(r=6,u.makeTranslation(-q.x,-q.y,-q.z)):(r=1,m.setFromMatrixPosition(x.target.matrixWorld),A.lookAt(m),A.updateMatrixWorld(),u.set(.5,
0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),u.multiply(A.projectionMatrix),u.multiply(A.matrixWorldInverse));a.setRenderTarget(n);a.clear();for(x=0;x<r;x++)W&&(m.copy(A.position),m.add(v[x]),A.up.copy(w[x]),A.lookAt(m),A.updateMatrixWorld(),p.viewport(y[x])),g.multiplyMatrices(A.projectionMatrix,A.matrixWorldInverse),f.setFromMatrix(g),e(c,d,A,W)}}N.needsUpdate=!1}}}function Rg(a,b,c,d){function e(b,c,d){var e=new Uint8Array(4),f=a.createTexture();a.bindTexture(b,f);a.texParameteri(b,10241,9728);a.texParameteri(b,
10240,9728);for(b=0;b<d;b++)a.texImage2D(c+b,0,6408,1,1,0,6408,5121,e);return f}function f(c,e){y[c]=1;0===u[c]&&(a.enableVertexAttribArray(c),u[c]=1);H[c]!==e&&((d.isWebGL2?a:b.get("ANGLE_instanced_arrays"))[d.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](c,e),H[c]=e)}function g(b){!0!==G[b]&&(a.enable(b),G[b]=!0)}function h(b){!1!==G[b]&&(a.disable(b),G[b]=!1)}function k(b,d,e,f,k,m,p,q){if(0===b)A&&(h(3042),A=!1);else if(A||(g(3042),A=!0),5!==b){if(b!==Mb||q!==F){if(100!==z||100!==
B)a.blendEquation(32774),B=z=100;if(q)switch(b){case 1:a.blendFuncSeparate(1,771,1,771);break;case 2:a.blendFunc(1,1);break;case 3:a.blendFuncSeparate(0,0,769,771);break;case 4:a.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",b)}else switch(b){case 1:a.blendFuncSeparate(770,771,1,771);break;case 2:a.blendFunc(770,1);break;case 3:a.blendFunc(0,769);break;case 4:a.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",b)}D=
C=Y=Yd=null;Mb=b;F=q}}else{k=k||d;m=m||e;p=p||f;if(d!==z||k!==B)a.blendEquationSeparate(c.convert(d),c.convert(k)),z=d,B=k;if(e!==Yd||f!==Y||m!==C||p!==D)a.blendFuncSeparate(c.convert(e),c.convert(f),c.convert(m),c.convert(p)),Yd=e,Y=f,C=m,D=p;Mb=b;F=null}}function m(b){J!==b&&(b?a.frontFace(2304):a.frontFace(2305),J=b)}function q(b){0!==b?(g(2884),b!==K&&(1===b?a.cullFace(1029):2===b?a.cullFace(1028):a.cullFace(1032))):h(2884);K=b}function p(b,c,d){if(b){if(g(32823),Q!==c||L!==d)a.polygonOffset(c,
d),Q=c,L=d}else h(32823)}function r(b){void 0===b&&(b=33984+R-1);I!==b&&(a.activeTexture(b),I=b)}var l=new function(){var b=!1,c=new ca,d=null,e=new ca(0,0,0,0);return{setMask:function(c){d===c||b||(a.colorMask(c,c,c,c),d=c)},setLocked:function(a){b=a},setClear:function(b,d,f,g,h){!0===h&&(b*=g,d*=g,f*=g);c.set(b,d,f,g);!1===e.equals(c)&&(a.clearColor(b,d,f,g),e.copy(c))},reset:function(){b=!1;d=null;e.set(-1,0,0,0)}}},t=new function(){var b=!1,c=null,d=null,e=null;return{setTest:function(a){a?g(2929):
h(2929)},setMask:function(d){c===d||b||(a.depthMask(d),c=d)},setFunc:function(b){if(d!==b){if(b)switch(b){case 0:a.depthFunc(512);break;case 1:a.depthFunc(519);break;case 2:a.depthFunc(513);break;case 3:a.depthFunc(515);break;case 4:a.depthFunc(514);break;case 5:a.depthFunc(518);break;case 6:a.depthFunc(516);break;case 7:a.depthFunc(517);break;default:a.depthFunc(515)}else a.depthFunc(515);d=b}},setLocked:function(a){b=a},setClear:function(b){e!==b&&(a.clearDepth(b),e=b)},reset:function(){b=!1;e=
d=c=null}}},v=new function(){var b=!1,c=null,d=null,e=null,f=null,k=null,m=null,p=null,q=null;return{setTest:function(a){a?g(2960):h(2960)},setMask:function(d){c===d||b||(a.stencilMask(d),c=d)},setFunc:function(b,c,g){if(d!==b||e!==c||f!==g)a.stencilFunc(b,c,g),d=b,e=c,f=g},setOp:function(b,c,d){if(k!==b||m!==c||p!==d)a.stencilOp(b,c,d),k=b,m=c,p=d},setLocked:function(a){b=a},setClear:function(b){q!==b&&(a.clearStencil(b),q=b)},reset:function(){b=!1;q=p=m=k=f=e=d=c=null}}},n=a.getParameter(34921),
y=new Uint8Array(n),u=new Uint8Array(n),H=new Uint8Array(n),G={},N=null,W=null,A=null,Mb=null,z=null,Yd=null,Y=null,B=null,C=null,D=null,F=!1,J=null,K=null,O=null,Q=null,L=null,R=a.getParameter(35661),E=!1;n=0;n=a.getParameter(7938);-1!==n.indexOf("WebGL")?(n=parseFloat(/^WebGL ([0-9])/.exec(n)[1]),E=1<=n):-1!==n.indexOf("OpenGL ES")&&(n=parseFloat(/^OpenGL ES ([0-9])/.exec(n)[1]),E=2<=n);var I=null,T={},X=new ca,M=new ca,U={};U[3553]=e(3553,3553,1);U[34067]=e(34067,34069,6);l.setClear(0,0,0,1);t.setClear(1);
v.setClear(0);g(2929);t.setFunc(3);m(!1);q(1);g(2884);k(0);return{buffers:{color:l,depth:t,stencil:v},initAttributes:function(){for(var a=0,b=y.length;a<b;a++)y[a]=0},enableAttribute:function(a){f(a,0)},enableAttributeAndDivisor:f,disableUnusedAttributes:function(){for(var b=0,c=u.length;b!==c;++b)u[b]!==y[b]&&(a.disableVertexAttribArray(b),u[b]=0)},enable:g,disable:h,getCompressedTextureFormats:function(){if(null===N&&(N=[],b.get("WEBGL_compressed_texture_pvrtc")||b.get("WEBGL_compressed_texture_s3tc")||
b.get("WEBGL_compressed_texture_etc1")||b.get("WEBGL_compressed_texture_astc")))for(var c=a.getParameter(34467),d=0;d<c.length;d++)N.push(c[d]);return N},useProgram:function(b){return W!==b?(a.useProgram(b),W=b,!0):!1},setBlending:k,setMaterial:function(a,b){2===a.side?h(2884):g(2884);var c=1===a.side;b&&(c=!c);m(c);1===a.blending&&!1===a.transparent?k(0):k(a.blending,a.blendEquation,a.blendSrc,a.blendDst,a.blendEquationAlpha,a.blendSrcAlpha,a.blendDstAlpha,a.premultipliedAlpha);t.setFunc(a.depthFunc);
t.setTest(a.depthTest);t.setMask(a.depthWrite);l.setMask(a.colorWrite);p(a.polygonOffset,a.polygonOffsetFactor,a.polygonOffsetUnits)},setFlipSided:m,setCullFace:q,setLineWidth:function(b){b!==O&&(E&&a.lineWidth(b),O=b)},setPolygonOffset:p,setScissorTest:function(a){a?g(3089):h(3089)},activeTexture:r,bindTexture:function(b,c){null===I&&r();var d=T[I];void 0===d&&(d={type:void 0,texture:void 0},T[I]=d);if(d.type!==b||d.texture!==c)a.bindTexture(b,c||U[b]),d.type=b,d.texture=c},compressedTexImage2D:function(){try{a.compressedTexImage2D.apply(a,
arguments)}catch(fa){console.error("THREE.WebGLState:",fa)}},texImage2D:function(){try{a.texImage2D.apply(a,arguments)}catch(fa){console.error("THREE.WebGLState:",fa)}},texImage3D:function(){try{a.texImage3D.apply(a,arguments)}catch(fa){console.error("THREE.WebGLState:",fa)}},scissor:function(b){!1===X.equals(b)&&(a.scissor(b.x,b.y,b.z,b.w),X.copy(b))},viewport:function(b){!1===M.equals(b)&&(a.viewport(b.x,b.y,b.z,b.w),M.copy(b))},reset:function(){for(var b=0;b<u.length;b++)1===u[b]&&(a.disableVertexAttribArray(b),
u[b]=0);G={};I=N=null;T={};K=J=Mb=W=null;l.reset();t.reset();v.reset()}}}function Sg(a,b,c,d,e,f,g){function h(a,b){if(a.width>b||a.height>b){if("data"in a){console.warn("THREE.WebGLRenderer: image in DataTexture is too big ("+a.width+"x"+a.height+").");return}b/=Math.max(a.width,a.height);var c=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");c.width=Math.floor(a.width*b);c.height=Math.floor(a.height*b);c.getContext("2d").drawImage(a,0,0,a.width,a.height,0,0,c.width,c.height);console.warn("THREE.WebGLRenderer: image is too big ("+
a.width+"x"+a.height+"). Resized to "+c.width+"x"+c.height);return c}return a}function k(a){return R.isPowerOfTwo(a.width)&&R.isPowerOfTwo(a.height)}function m(a,b){return a.generateMipmaps&&b&&1003!==a.minFilter&&1006!==a.minFilter}function q(b,c,e,f){a.generateMipmap(b);d.get(c).__maxMipLevel=Math.log(Math.max(e,f))*Math.LOG2E}function p(a,b){if(!e.isWebGL2)return a;if(6403===a){if(5126===b)return 33326;if(5131===b)return 33325;if(5121===b)return 33321}if(6407===a){if(5126===b)return 34837;if(5131===
b)return 34843;if(5121===b)return 32849}if(6408===a){if(5126===b)return 34836;if(5131===b)return 34842;if(5121===b)return 32856}return a}function r(a){return 1003===a||1004===a||1005===a?9728:9729}function l(b){b=b.target;b.removeEventListener("dispose",l);a:{var c=d.get(b);if(b.image&&c.__image__webglTextureCube)a.deleteTexture(c.__image__webglTextureCube);else{if(void 0===c.__webglInit)break a;a.deleteTexture(c.__webglTexture)}d.remove(b)}b.isVideoTexture&&delete G[b.id];g.memory.textures--}function t(b){b=
b.target;b.removeEventListener("dispose",t);var c=d.get(b),e=d.get(b.texture);if(b){void 0!==e.__webglTexture&&a.deleteTexture(e.__webglTexture);b.depthTexture&&b.depthTexture.dispose();if(b.isWebGLRenderTargetCube)for(e=0;6>e;e++)a.deleteFramebuffer(c.__webglFramebuffer[e]),c.__webglDepthbuffer&&a.deleteRenderbuffer(c.__webglDepthbuffer[e]);else a.deleteFramebuffer(c.__webglFramebuffer),c.__webglDepthbuffer&&a.deleteRenderbuffer(c.__webglDepthbuffer);d.remove(b.texture);d.remove(b)}g.memory.textures--}
function v(a,b){var e=d.get(a);if(a.isVideoTexture){var f=a.id,h=g.render.frame;G[f]!==h&&(G[f]=h,a.update())}if(0<a.version&&e.__version!==a.version)if(f=a.image,void 0===f)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else if(!1===f.complete)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{y(e,a,b);return}c.activeTexture(33984+b);c.bindTexture(3553,e.__webglTexture)}function n(c,g,h){h?(a.texParameteri(c,10242,f.convert(g.wrapS)),
a.texParameteri(c,10243,f.convert(g.wrapT)),a.texParameteri(c,10240,f.convert(g.magFilter)),a.texParameteri(c,10241,f.convert(g.minFilter))):(a.texParameteri(c,10242,33071),a.texParameteri(c,10243,33071),1001===g.wrapS&&1001===g.wrapT||console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),a.texParameteri(c,10240,r(g.magFilter)),a.texParameteri(c,10241,r(g.minFilter)),1003!==g.minFilter&&1006!==g.minFilter&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));
!(h=b.get("EXT_texture_filter_anisotropic"))||1015===g.type&&null===b.get("OES_texture_float_linear")||1016===g.type&&null===(e.isWebGL2||b.get("OES_texture_half_float_linear"))||!(1<g.anisotropy||d.get(g).__currentAnisotropy)||(a.texParameterf(c,h.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(g.anisotropy,e.getMaxAnisotropy())),d.get(g).__currentAnisotropy=g.anisotropy)}function y(b,d,r){var x=d.isDataTexture3D?32879:3553;void 0===b.__webglInit&&(b.__webglInit=!0,d.addEventListener("dispose",l),b.__webglTexture=
a.createTexture(),g.memory.textures++);c.activeTexture(33984+r);c.bindTexture(x,b.__webglTexture);a.pixelStorei(37440,d.flipY);a.pixelStorei(37441,d.premultiplyAlpha);a.pixelStorei(3317,d.unpackAlignment);r=h(d.image,e.maxTextureSize);var t=e.isWebGL2?!1:1001!==d.wrapS||1001!==d.wrapT||1003!==d.minFilter&&1006!==d.minFilter;t&&!1===k(r)&&(r instanceof HTMLImageElement||r instanceof HTMLCanvasElement||r instanceof ImageBitmap)&&(void 0===N&&(N=document.createElementNS("http://www.w3.org/1999/xhtml",
"canvas")),N.width=R.floorPowerOfTwo(r.width),N.height=R.floorPowerOfTwo(r.height),N.getContext("2d").drawImage(r,0,0,N.width,N.height),console.warn("THREE.WebGLRenderer: image is not power of two ("+r.width+"x"+r.height+"). Resized to "+N.width+"x"+N.height),r=N);t=k(r);var v=f.convert(d.format),w=f.convert(d.type),u=p(v,w);n(x,d,t);var W=d.mipmaps;if(d.isDepthTexture){u=6402;if(1015===d.type){if(!e.isWebGL2)throw Error("Float Depth Texture only supported in WebGL2.0");u=36012}else e.isWebGL2&&(u=
33189);1026===d.format&&6402===u&&1012!==d.type&&1014!==d.type&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),d.type=1012,w=f.convert(d.type));1027===d.format&&(u=34041,1020!==d.type&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),d.type=1020,w=f.convert(d.type)));c.texImage2D(3553,0,u,r.width,r.height,0,v,w,null)}else if(d.isDataTexture)if(0<W.length&&t){for(var A=0,G=W.length;A<G;A++)x=
W[A],c.texImage2D(3553,A,u,x.width,x.height,0,v,w,x.data);d.generateMipmaps=!1;b.__maxMipLevel=W.length-1}else c.texImage2D(3553,0,u,r.width,r.height,0,v,w,r.data),b.__maxMipLevel=0;else if(d.isCompressedTexture){A=0;for(G=W.length;A<G;A++)x=W[A],1023!==d.format&&1022!==d.format?-1<c.getCompressedTextureFormats().indexOf(v)?c.compressedTexImage2D(3553,A,u,x.width,x.height,0,x.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):c.texImage2D(3553,
A,u,x.width,x.height,0,v,w,x.data);b.__maxMipLevel=W.length-1}else if(d.isDataTexture3D)c.texImage3D(32879,0,u,r.width,r.height,r.depth,0,v,w,r.data),b.__maxMipLevel=0;else if(0<W.length&&t){A=0;for(G=W.length;A<G;A++)x=W[A],c.texImage2D(3553,A,u,v,w,x);d.generateMipmaps=!1;b.__maxMipLevel=W.length-1}else c.texImage2D(3553,0,u,v,w,r),b.__maxMipLevel=0;m(d,t)&&q(3553,d,r.width,r.height);b.__version=d.version;if(d.onUpdate)d.onUpdate(d)}function u(b,e,g,h){var k=f.convert(e.texture.format),m=f.convert(e.texture.type),
q=p(k,m);c.texImage2D(h,0,q,e.width,e.height,0,k,m,null);a.bindFramebuffer(36160,b);a.framebufferTexture2D(36160,g,h,d.get(e.texture).__webglTexture,0);a.bindFramebuffer(36160,null)}function H(b,c){a.bindRenderbuffer(36161,b);c.depthBuffer&&!c.stencilBuffer?(a.renderbufferStorage(36161,33189,c.width,c.height),a.framebufferRenderbuffer(36160,36096,36161,b)):c.depthBuffer&&c.stencilBuffer?(a.renderbufferStorage(36161,34041,c.width,c.height),a.framebufferRenderbuffer(36160,33306,36161,b)):a.renderbufferStorage(36161,
32854,c.width,c.height);a.bindRenderbuffer(36161,null)}var G={},N;this.setTexture2D=v;this.setTexture3D=function(a,b){var e=d.get(a);0<a.version&&e.__version!==a.version?y(e,a,b):(c.activeTexture(33984+b),c.bindTexture(32879,e.__webglTexture))};this.setTextureCube=function(b,r){var x=d.get(b);if(6===b.image.length)if(0<b.version&&x.__version!==b.version){x.__image__webglTextureCube||(b.addEventListener("dispose",l),x.__image__webglTextureCube=a.createTexture(),g.memory.textures++);c.activeTexture(33984+
r);c.bindTexture(34067,x.__image__webglTextureCube);a.pixelStorei(37440,b.flipY);r=b&&b.isCompressedTexture;for(var t=b.image[0]&&b.image[0].isDataTexture,v=[],u=0;6>u;u++)v[u]=r||t?t?b.image[u].image:b.image[u]:h(b.image[u],e.maxCubemapSize);var w=v[0],W=k(w),A=f.convert(b.format),G=f.convert(b.type),H=p(A,G);n(34067,b,W);for(u=0;6>u;u++)if(r)for(var y,N=v[u].mipmaps,z=0,B=N.length;z<B;z++)y=N[z],1023!==b.format&&1022!==b.format?-1<c.getCompressedTextureFormats().indexOf(A)?c.compressedTexImage2D(34069+
u,z,H,y.width,y.height,0,y.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):c.texImage2D(34069+u,z,H,y.width,y.height,0,A,G,y.data);else t?c.texImage2D(34069+u,0,H,v[u].width,v[u].height,0,A,G,v[u].data):c.texImage2D(34069+u,0,H,A,G,v[u]);x.__maxMipLevel=r?N.length-1:0;m(b,W)&&q(34067,b,w.width,w.height);x.__version=b.version;if(b.onUpdate)b.onUpdate(b)}else c.activeTexture(33984+r),c.bindTexture(34067,x.__image__webglTextureCube)};
this.setTextureCubeDynamic=function(a,b){c.activeTexture(33984+b);c.bindTexture(34067,d.get(a).__webglTexture)};this.setupRenderTarget=function(b){var e=d.get(b),f=d.get(b.texture);b.addEventListener("dispose",t);f.__webglTexture=a.createTexture();g.memory.textures++;var h=!0===b.isWebGLRenderTargetCube,p=k(b);if(h){e.__webglFramebuffer=[];for(var r=0;6>r;r++)e.__webglFramebuffer[r]=a.createFramebuffer()}else e.__webglFramebuffer=a.createFramebuffer();if(h){c.bindTexture(34067,f.__webglTexture);n(34067,
b.texture,p);for(r=0;6>r;r++)u(e.__webglFramebuffer[r],b,36064,34069+r);m(b.texture,p)&&q(34067,b.texture,b.width,b.height);c.bindTexture(34067,null)}else c.bindTexture(3553,f.__webglTexture),n(3553,b.texture,p),u(e.__webglFramebuffer,b,36064,3553),m(b.texture,p)&&q(3553,b.texture,b.width,b.height),c.bindTexture(3553,null);if(b.depthBuffer){e=d.get(b);f=!0===b.isWebGLRenderTargetCube;if(b.depthTexture){if(f)throw Error("target.depthTexture not supported in Cube render targets");if(b&&b.isWebGLRenderTargetCube)throw Error("Depth Texture with cube render targets is not supported");
a.bindFramebuffer(36160,e.__webglFramebuffer);if(!b.depthTexture||!b.depthTexture.isDepthTexture)throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");d.get(b.depthTexture).__webglTexture&&b.depthTexture.image.width===b.width&&b.depthTexture.image.height===b.height||(b.depthTexture.image.width=b.width,b.depthTexture.image.height=b.height,b.depthTexture.needsUpdate=!0);v(b.depthTexture,0);e=d.get(b.depthTexture).__webglTexture;if(1026===b.depthTexture.format)a.framebufferTexture2D(36160,
36096,3553,e,0);else if(1027===b.depthTexture.format)a.framebufferTexture2D(36160,33306,3553,e,0);else throw Error("Unknown depthTexture format");}else if(f)for(e.__webglDepthbuffer=[],f=0;6>f;f++)a.bindFramebuffer(36160,e.__webglFramebuffer[f]),e.__webglDepthbuffer[f]=a.createRenderbuffer(),H(e.__webglDepthbuffer[f],b);else a.bindFramebuffer(36160,e.__webglFramebuffer),e.__webglDepthbuffer=a.createRenderbuffer(),H(e.__webglDepthbuffer,b);a.bindFramebuffer(36160,null)}};this.updateRenderTargetMipmap=
function(a){var b=a.texture,e=k(a);if(m(b,e)){e=a.isWebGLRenderTargetCube?34067:3553;var f=d.get(b).__webglTexture;c.bindTexture(e,f);q(e,b,a.width,a.height);c.bindTexture(e,null)}}}function ff(a,b,c){return{convert:function(a){if(1E3===a)return 10497;if(1001===a)return 33071;if(1002===a)return 33648;if(1003===a)return 9728;if(1004===a)return 9984;if(1005===a)return 9986;if(1006===a)return 9729;if(1007===a)return 9985;if(1008===a)return 9987;if(1009===a)return 5121;if(1017===a)return 32819;if(1018===
a)return 32820;if(1019===a)return 33635;if(1010===a)return 5120;if(1011===a)return 5122;if(1012===a)return 5123;if(1013===a)return 5124;if(1014===a)return 5125;if(1015===a)return 5126;if(1016===a){if(c.isWebGL2)return 5131;var d=b.get("OES_texture_half_float");if(null!==d)return d.HALF_FLOAT_OES}if(1021===a)return 6406;if(1022===a)return 6407;if(1023===a)return 6408;if(1024===a)return 6409;if(1025===a)return 6410;if(1026===a)return 6402;if(1027===a)return 34041;if(1028===a)return 6403;if(100===a)return 32774;
if(101===a)return 32778;if(102===a)return 32779;if(200===a)return 0;if(201===a)return 1;if(202===a)return 768;if(203===a)return 769;if(204===a)return 770;if(205===a)return 771;if(206===a)return 772;if(207===a)return 773;if(208===a)return 774;if(209===a)return 775;if(210===a)return 776;if(33776===a||33777===a||33778===a||33779===a)if(d=b.get("WEBGL_compressed_texture_s3tc"),null!==d){if(33776===a)return d.COMPRESSED_RGB_S3TC_DXT1_EXT;if(33777===a)return d.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(33778===a)return d.COMPRESSED_RGBA_S3TC_DXT3_EXT;
if(33779===a)return d.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(35840===a||35841===a||35842===a||35843===a)if(d=b.get("WEBGL_compressed_texture_pvrtc"),null!==d){if(35840===a)return d.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(35841===a)return d.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(35842===a)return d.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(35843===a)return d.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(36196===a&&(d=b.get("WEBGL_compressed_texture_etc1"),null!==d))return d.COMPRESSED_RGB_ETC1_WEBGL;if(37808===a||37809===a||37810===
a||37811===a||37812===a||37813===a||37814===a||37815===a||37816===a||37817===a||37818===a||37819===a||37820===a||37821===a)if(d=b.get("WEBGL_compressed_texture_astc"),null!==d)return a;if(103===a||104===a){if(c.isWebGL2){if(103===a)return 32775;if(104===a)return 32776}d=b.get("EXT_blend_minmax");if(null!==d){if(103===a)return d.MIN_EXT;if(104===a)return d.MAX_EXT}}if(1020===a){if(c.isWebGL2)return 34042;d=b.get("WEBGL_depth_texture");if(null!==d)return d.UNSIGNED_INT_24_8_WEBGL}return 0}}}function Pb(){C.call(this);
this.type="Group"}function Ra(){C.call(this);this.type="Camera";this.matrixWorldInverse=new O;this.projectionMatrix=new O;this.projectionMatrixInverse=new O}function V(a,b,c,d){Ra.call(this);this.type="PerspectiveCamera";this.fov=void 0!==a?a:50;this.zoom=1;this.near=void 0!==c?c:.1;this.far=void 0!==d?d:2E3;this.focus=10;this.aspect=void 0!==b?b:1;this.view=null;this.filmGauge=35;this.filmOffset=0;this.updateProjectionMatrix()}function Dc(a){V.call(this);this.cameras=a||[]}function gf(a,b,c){hf.setFromMatrixPosition(b.matrixWorld);
jf.setFromMatrixPosition(c.matrixWorld);var d=hf.distanceTo(jf),e=b.projectionMatrix.elements,f=c.projectionMatrix.elements,g=e[14]/(e[10]-1);c=e[14]/(e[10]+1);var h=(e[9]+1)/e[5],k=(e[9]-1)/e[5],m=(e[8]-1)/e[0],q=(f[8]+1)/f[0];e=g*m;f=g*q;q=d/(-m+q);m=q*-m;b.matrixWorld.decompose(a.position,a.quaternion,a.scale);a.translateX(m);a.translateZ(q);a.matrixWorld.compose(a.position,a.quaternion,a.scale);a.matrixWorldInverse.getInverse(a.matrixWorld);b=g+q;g=c+q;a.projectionMatrix.makePerspective(e-m,f+
(d-m),h*c/g*b,k*c/g*b,b,g)}function kf(a){function b(){return null!==e&&!0===e.isPresenting}function c(){if(b()){var c=e.getEyeParameters("left"),f=c.renderWidth*q;c=c.renderHeight*q;H=a.getPixelRatio();u=a.getSize();a.setDrawingBufferSize(2*f,c,1);N.start()}else d.enabled&&a.setDrawingBufferSize(u.width,u.height,H),N.stop()}var d=this,e=null,f=null,g=null,h=[],k=new O,m=new O,q=1,p="stage";"undefined"!==typeof window&&"VRFrameData"in window&&(f=new window.VRFrameData,window.addEventListener("vrdisplaypresentchange",
c,!1));var r=new O,l=new ka,t=new n,v=new V;v.bounds=new ca(0,0,.5,1);v.layers.enable(1);var w=new V;w.bounds=new ca(.5,0,.5,1);w.layers.enable(2);var y=new Dc([v,w]);y.layers.enable(1);y.layers.enable(2);var u,H,G=[];this.enabled=!1;this.getController=function(a){var b=h[a];void 0===b&&(b=new Pb,b.matrixAutoUpdate=!1,b.visible=!1,h[a]=b);return b};this.getDevice=function(){return e};this.setDevice=function(a){void 0!==a&&(e=a);N.setContext(a)};this.setFramebufferScaleFactor=function(a){q=a};this.setFrameOfReferenceType=
function(a){p=a};this.setPoseTarget=function(a){void 0!==a&&(g=a)};this.getCamera=function(a){var b="stage"===p?1.6:0;if(null===e)return a.position.set(0,b,0),a;e.depthNear=a.near;e.depthFar=a.far;e.getFrameData(f);if("stage"===p){var c=e.stageParameters;c?k.fromArray(c.sittingToStandingTransform):k.makeTranslation(0,b,0)}b=f.pose;c=null!==g?g:a;c.matrix.copy(k);c.matrix.decompose(c.position,c.quaternion,c.scale);null!==b.orientation&&(l.fromArray(b.orientation),c.quaternion.multiply(l));null!==b.position&&
(l.setFromRotationMatrix(k),t.fromArray(b.position),t.applyQuaternion(l),c.position.add(t));c.updateMatrixWorld();if(!1===e.isPresenting)return a;v.near=a.near;w.near=a.near;v.far=a.far;w.far=a.far;v.matrixWorldInverse.fromArray(f.leftViewMatrix);w.matrixWorldInverse.fromArray(f.rightViewMatrix);m.getInverse(k);"stage"===p&&(v.matrixWorldInverse.multiply(m),w.matrixWorldInverse.multiply(m));a=c.parent;null!==a&&(r.getInverse(a.matrixWorld),v.matrixWorldInverse.multiply(r),w.matrixWorldInverse.multiply(r));
v.matrixWorld.getInverse(v.matrixWorldInverse);w.matrixWorld.getInverse(w.matrixWorldInverse);v.projectionMatrix.fromArray(f.leftProjectionMatrix);w.projectionMatrix.fromArray(f.rightProjectionMatrix);gf(y,v,w);a=e.getLayers();a.length&&(a=a[0],null!==a.leftBounds&&4===a.leftBounds.length&&v.bounds.fromArray(a.leftBounds),null!==a.rightBounds&&4===a.rightBounds.length&&w.bounds.fromArray(a.rightBounds));a:for(a=0;a<h.length;a++){b=h[a];b:{c=a;for(var d=navigator.getGamepads&&navigator.getGamepads(),
q=0,x=0,n=d.length;q<n;q++){var u=d[q];if(u&&("Daydream Controller"===u.id||"Gear VR Controller"===u.id||"Oculus Go Controller"===u.id||"OpenVR Gamepad"===u.id||u.id.startsWith("Oculus Touch")||u.id.startsWith("Spatial Controller"))){if(x===c){c=u;break b}x++}}c=void 0}if(void 0!==c&&void 0!==c.pose){if(null===c.pose)break a;d=c.pose;!1===d.hasPosition&&b.position.set(.2,-.6,-.05);null!==d.position&&b.position.fromArray(d.position);null!==d.orientation&&b.quaternion.fromArray(d.orientation);b.matrix.compose(b.position,
b.quaternion,b.scale);b.matrix.premultiply(k);b.matrix.decompose(b.position,b.quaternion,b.scale);b.matrixWorldNeedsUpdate=!0;b.visible=!0;d="Daydream Controller"===c.id?0:1;G[a]!==c.buttons[d].pressed&&(G[a]=c.buttons[d].pressed,!0===G[a]?b.dispatchEvent({type:"selectstart"}):(b.dispatchEvent({type:"selectend"}),b.dispatchEvent({type:"select"})))}else b.visible=!1}return y};this.getStandingMatrix=function(){return k};this.isPresenting=b;var N=new Wd;this.setAnimationLoop=function(a){N.setAnimationLoop(a)};
this.submitFrame=function(){b()&&e.submitFrame()};this.dispose=function(){"undefined"!==typeof window&&window.removeEventListener("vrdisplaypresentchange",c)}}function Tg(a){function b(){return null!==h&&null!==m}function c(a){var b=r[l.indexOf(a.inputSource)];b&&b.dispatchEvent({type:a.type})}function d(){a.setFramebuffer(null);u.stop()}function e(a,b){null===b?a.matrixWorld.copy(a.matrix):a.matrixWorld.multiplyMatrices(b.matrixWorld,a.matrix);a.matrixWorldInverse.getInverse(a.matrixWorld)}var f=
a.context,g=null,h=null,k=1,m=null,q="stage",p=null,r=[],l=[],t=new V;t.layers.enable(1);t.viewport=new ca;var v=new V;v.layers.enable(2);v.viewport=new ca;var n=new Dc([t,v]);n.layers.enable(1);n.layers.enable(2);this.enabled=!1;this.getController=function(a){var b=r[a];void 0===b&&(b=new Pb,b.matrixAutoUpdate=!1,b.visible=!1,r[a]=b);return b};this.getDevice=function(){return g};this.setDevice=function(a){void 0!==a&&(g=a);a instanceof XRDevice&&f.setCompatibleXRDevice(a)};this.setFramebufferScaleFactor=
function(a){k=a};this.setFrameOfReferenceType=function(a){q=a};this.setSession=function(b){h=b;null!==h&&(h.addEventListener("select",c),h.addEventListener("selectstart",c),h.addEventListener("selectend",c),h.addEventListener("end",d),h.baseLayer=new XRWebGLLayer(h,f,{framebufferScaleFactor:k}),h.requestFrameOfReference(q).then(function(b){m=b;a.setFramebuffer(h.baseLayer.framebuffer);u.setContext(h);u.start()}),l=h.getInputSources(),h.addEventListener("inputsourceschange",function(){l=h.getInputSources();
console.log(l);for(var a=0;a<r.length;a++)r[a].userData.inputSource=l[a]}))};this.getCamera=function(a){if(b()){var c=a.parent,d=n.cameras;e(n,c);for(var f=0;f<d.length;f++)e(d[f],c);a.matrixWorld.copy(n.matrixWorld);a=a.children;f=0;for(c=a.length;f<c;f++)a[f].updateMatrixWorld(!0);gf(n,t,v);return n}return a};this.isPresenting=b;var y=null,u=new Wd;u.setAnimationLoop(function(a,b){p=b.getDevicePose(m);if(null!==p)for(var c=h.baseLayer,d=b.views,e=0;e<d.length;e++){var f=d[e],g=c.getViewport(f),
k=p.getViewMatrix(f),q=n.cameras[e];q.matrix.fromArray(k).getInverse(q.matrix);q.projectionMatrix.fromArray(f.projectionMatrix);q.viewport.set(g.x,g.y,g.width,g.height);0===e&&n.matrix.copy(q.matrix)}for(e=0;e<r.length;e++){c=r[e];if(d=l[e])if(d=b.getInputPose(d,m),null!==d){"targetRay"in d?c.matrix.elements=d.targetRay.transformMatrix:"pointerMatrix"in d&&(c.matrix.elements=d.pointerMatrix);c.matrix.decompose(c.position,c.rotation,c.scale);c.visible=!0;continue}c.visible=!1}y&&y(a)});this.setAnimationLoop=
function(a){y=a};this.dispose=function(){};this.getStandingMatrix=function(){console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed.");return new THREE.Matrix4};this.submitFrame=function(){}}function be(a){var b;function c(){la=new Wf(P);wa=new Uf(P,la,a);wa.isWebGL2||(la.get("WEBGL_depth_texture"),la.get("OES_texture_float"),la.get("OES_texture_half_float"),la.get("OES_texture_half_float_linear"),la.get("OES_standard_derivatives"),la.get("OES_element_index_uint"),la.get("ANGLE_instanced_arrays"));
la.get("OES_texture_float_linear");ia=new ff(P,la,wa);aa=new Rg(P,la,ia,wa);aa.scissor(Cc.copy(ka).multiplyScalar(U));aa.viewport(S.copy(fa).multiplyScalar(U));da=new Zf(P);Ca=new Jg;ha=new Sg(P,la,aa,Ca,wa,ia,da);ra=new Nf(P);ta=new Xf(P,ra,da);oa=new bg(ta,da);xa=new ag(P);na=new Ig(Y,la,wa);ua=new Mg;pa=new Qg;ma=new Sf(Y,aa,oa,z);za=new Tf(P,la,da,wa);Aa=new Yf(P,la,da,wa);da.programs=na.programs;Y.context=P;Y.capabilities=wa;Y.extensions=la;Y.properties=Ca;Y.renderLists=ua;Y.state=aa;Y.info=
da}function d(a){a.preventDefault();console.log("THREE.WebGLRenderer: Context Lost.");J=!0}function e(){console.log("THREE.WebGLRenderer: Context Restored.");J=!1;c()}function f(a){a=a.target;a.removeEventListener("dispose",f);g(a);Ca.remove(a)}function g(a){var b=Ca.get(a).program;a.program=void 0;void 0!==b&&na.releaseProgram(b)}function h(a,b){a.render(function(a){Y.renderBufferImmediate(a,b)})}function k(a,b,c){if(!1!==a.visible){if(a.layers.test(b.layers))if(a.isLight)D.pushLight(a),a.castShadow&&
D.pushShadow(a);else if(a.isSprite){if(!a.frustumCulled||qa.intersectsSprite(a)){c&&fb.setFromMatrixPosition(a.matrixWorld).applyMatrix4(Bc);var d=oa.update(a),e=a.material;C.push(a,d,e,fb.z,null)}}else if(a.isImmediateRenderObject)c&&fb.setFromMatrixPosition(a.matrixWorld).applyMatrix4(Bc),C.push(a,null,a.material,fb.z,null);else if(a.isMesh||a.isLine||a.isPoints)if(a.isSkinnedMesh&&a.skeleton.update(),!a.frustumCulled||qa.intersectsObject(a))if(c&&fb.setFromMatrixPosition(a.matrixWorld).applyMatrix4(Bc),
d=oa.update(a),e=a.material,Array.isArray(e))for(var f=d.groups,g=0,h=f.length;g<h;g++){var m=f[g],p=e[m.materialIndex];p&&p.visible&&C.push(a,d,p,fb.z,m)}else e.visible&&C.push(a,d,e,fb.z,null);a=a.children;g=0;for(h=a.length;g<h;g++)k(a[g],b,c)}}function m(a,b,c,d){for(var e=0,f=a.length;e<f;e++){var g=a[e],h=g.object,k=g.geometry,m=void 0===d?g.material:d;g=g.group;if(c.isArrayCamera){X=c;for(var p=c.cameras,r=0,l=p.length;r<l;r++){var t=p[r];if(h.layers.test(t.layers)){if("viewport"in t)aa.viewport(S.copy(t.viewport));
else{var x=t.bounds;aa.viewport(S.set(x.x*V,x.y*M,x.z*V,x.w*M).multiplyScalar(U))}D.setupLights(t);q(h,b,t,k,m,g)}}}else X=null,q(h,b,c,k,m,g)}}function q(a,c,d,e,f,g){a.onBeforeRender(Y,c,d,e,f,g);D=pa.get(c,X||d);a.modelViewMatrix.multiplyMatrices(d.matrixWorldInverse,a.matrixWorld);a.normalMatrix.getNormalMatrix(a.modelViewMatrix);if(a.isImmediateRenderObject){aa.setMaterial(f);var k=r(d,c.fog,f,a);I=b=null;ud=!1;h(a,k)}else Y.renderBufferDirect(d,c.fog,e,f,a,g);a.onAfterRender(Y,c,d,e,f,g);D=
pa.get(c,X||d)}function p(a,b,c){var d=Ca.get(a),e=D.state.lights,h=d.lightsHash,k=e.state.hash;c=na.getParameters(a,e.state,D.state.shadowsArray,b,Z.numPlanes,Z.numIntersection,c);var m=na.getProgramCode(a,c),p=d.program,q=!0;if(void 0===p)a.addEventListener("dispose",f);else if(p.code!==m)g(a);else{if(h.stateID!==k.stateID||h.directionalLength!==k.directionalLength||h.pointLength!==k.pointLength||h.spotLength!==k.spotLength||h.rectAreaLength!==k.rectAreaLength||h.hemiLength!==k.hemiLength||h.shadowsLength!==
k.shadowsLength)h.stateID=k.stateID,h.directionalLength=k.directionalLength,h.pointLength=k.pointLength,h.spotLength=k.spotLength,h.rectAreaLength=k.rectAreaLength,h.hemiLength=k.hemiLength,h.shadowsLength=k.shadowsLength;else if(void 0!==c.shaderID)return;q=!1}q&&(c.shaderID?(m=Qa[c.shaderID],d.shader={name:a.type,uniforms:Jb(m.uniforms),vertexShader:m.vertexShader,fragmentShader:m.fragmentShader}):d.shader={name:a.type,uniforms:a.uniforms,vertexShader:a.vertexShader,fragmentShader:a.fragmentShader},
a.onBeforeCompile(d.shader,Y),m=na.getProgramCode(a,c),p=na.acquireProgram(a,d.shader,c,m),d.program=p,a.program=p);c=p.getAttributes();if(a.morphTargets)for(m=a.numSupportedMorphTargets=0;m<Y.maxMorphTargets;m++)0<=c["morphTarget"+m]&&a.numSupportedMorphTargets++;if(a.morphNormals)for(m=a.numSupportedMorphNormals=0;m<Y.maxMorphNormals;m++)0<=c["morphNormal"+m]&&a.numSupportedMorphNormals++;c=d.shader.uniforms;if(!a.isShaderMaterial&&!a.isRawShaderMaterial||!0===a.clipping)d.numClippingPlanes=Z.numPlanes,
d.numIntersection=Z.numIntersection,c.clippingPlanes=Z.uniform;d.fog=b;void 0===h&&(d.lightsHash=h={});h.stateID=k.stateID;h.directionalLength=k.directionalLength;h.pointLength=k.pointLength;h.spotLength=k.spotLength;h.rectAreaLength=k.rectAreaLength;h.hemiLength=k.hemiLength;h.shadowsLength=k.shadowsLength;a.lights&&(c.ambientLightColor.value=e.state.ambient,c.directionalLights.value=e.state.directional,c.spotLights.value=e.state.spot,c.rectAreaLights.value=e.state.rectArea,c.pointLights.value=e.state.point,
c.hemisphereLights.value=e.state.hemi,c.directionalShadowMap.value=e.state.directionalShadowMap,c.directionalShadowMatrix.value=e.state.directionalShadowMatrix,c.spotShadowMap.value=e.state.spotShadowMap,c.spotShadowMatrix.value=e.state.spotShadowMatrix,c.pointShadowMap.value=e.state.pointShadowMap,c.pointShadowMatrix.value=e.state.pointShadowMatrix);a=d.program.getUniforms();a=cb.seqWithValue(a.seq,c);d.uniformsList=a}function r(a,b,c,d){ba=0;var e=Ca.get(c),f=e.lightsHash,g=D.state.lights.state.hash;
wd&&(ae||a!==T)&&Z.setState(c.clippingPlanes,c.clipIntersection,c.clipShadows,a,e,a===T&&c.id===E);!1===c.needsUpdate&&(void 0===e.program?c.needsUpdate=!0:c.fog&&e.fog!==b?c.needsUpdate=!0:!c.lights||f.stateID===g.stateID&&f.directionalLength===g.directionalLength&&f.pointLength===g.pointLength&&f.spotLength===g.spotLength&&f.rectAreaLength===g.rectAreaLength&&f.hemiLength===g.hemiLength&&f.shadowsLength===g.shadowsLength?void 0===e.numClippingPlanes||e.numClippingPlanes===Z.numPlanes&&e.numIntersection===
Z.numIntersection||(c.needsUpdate=!0):c.needsUpdate=!0);c.needsUpdate&&(p(c,b,d),c.needsUpdate=!1);var h=!1,k=!1,m=!1;f=e.program;g=f.getUniforms();var q=e.shader.uniforms;aa.useProgram(f.program)&&(m=k=h=!0);c.id!==E&&(E=c.id,k=!0);if(h||T!==a){g.setValue(P,"projectionMatrix",a.projectionMatrix);wa.logarithmicDepthBuffer&&g.setValue(P,"logDepthBufFC",2/(Math.log(a.far+1)/Math.LN2));T!==a&&(T=a,m=k=!0);if(c.isShaderMaterial||c.isMeshPhongMaterial||c.isMeshStandardMaterial||c.envMap)h=g.map.cameraPosition,
void 0!==h&&h.setValue(P,fb.setFromMatrixPosition(a.matrixWorld));(c.isMeshPhongMaterial||c.isMeshLambertMaterial||c.isMeshBasicMaterial||c.isMeshStandardMaterial||c.isShaderMaterial||c.skinning)&&g.setValue(P,"viewMatrix",a.matrixWorldInverse)}if(c.skinning&&(g.setOptional(P,d,"bindMatrix"),g.setOptional(P,d,"bindMatrixInverse"),a=d.skeleton))if(h=a.bones,wa.floatVertexTextures){if(void 0===a.boneTexture){h=Math.sqrt(4*h.length);h=R.ceilPowerOfTwo(h);h=Math.max(h,4);var r=new Float32Array(h*h*4);
r.set(a.boneMatrices);var x=new kb(r,h,h,1023,1015);x.needsUpdate=!0;a.boneMatrices=r;a.boneTexture=x;a.boneTextureSize=h}g.setValue(P,"boneTexture",a.boneTexture);g.setValue(P,"boneTextureSize",a.boneTextureSize)}else g.setOptional(P,a,"boneMatrices");k&&(g.setValue(P,"toneMappingExposure",Y.toneMappingExposure),g.setValue(P,"toneMappingWhitePoint",Y.toneMappingWhitePoint),c.lights&&(k=m,q.ambientLightColor.needsUpdate=k,q.directionalLights.needsUpdate=k,q.pointLights.needsUpdate=k,q.spotLights.needsUpdate=
k,q.rectAreaLights.needsUpdate=k,q.hemisphereLights.needsUpdate=k),b&&c.fog&&(q.fogColor.value=b.color,b.isFog?(q.fogNear.value=b.near,q.fogFar.value=b.far):b.isFogExp2&&(q.fogDensity.value=b.density)),c.isMeshBasicMaterial?l(q,c):c.isMeshLambertMaterial?(l(q,c),c.emissiveMap&&(q.emissiveMap.value=c.emissiveMap)):c.isMeshPhongMaterial?(l(q,c),c.isMeshToonMaterial?(t(q,c),c.gradientMap&&(q.gradientMap.value=c.gradientMap)):t(q,c)):c.isMeshStandardMaterial?(l(q,c),c.isMeshPhysicalMaterial?(v(q,c),q.reflectivity.value=
c.reflectivity,q.clearCoat.value=c.clearCoat,q.clearCoatRoughness.value=c.clearCoatRoughness):v(q,c)):c.isMeshMatcapMaterial?(l(q,c),c.matcap&&(q.matcap.value=c.matcap),c.bumpMap&&(q.bumpMap.value=c.bumpMap,q.bumpScale.value=c.bumpScale,1===c.side&&(q.bumpScale.value*=-1)),c.normalMap&&(q.normalMap.value=c.normalMap,q.normalScale.value.copy(c.normalScale),1===c.side&&q.normalScale.value.negate()),c.displacementMap&&(q.displacementMap.value=c.displacementMap,q.displacementScale.value=c.displacementScale,
q.displacementBias.value=c.displacementBias)):c.isMeshDepthMaterial?(l(q,c),c.displacementMap&&(q.displacementMap.value=c.displacementMap,q.displacementScale.value=c.displacementScale,q.displacementBias.value=c.displacementBias)):c.isMeshDistanceMaterial?(l(q,c),c.displacementMap&&(q.displacementMap.value=c.displacementMap,q.displacementScale.value=c.displacementScale,q.displacementBias.value=c.displacementBias),q.referencePosition.value.copy(c.referencePosition),q.nearDistance.value=c.nearDistance,
q.farDistance.value=c.farDistance):c.isMeshNormalMaterial?(l(q,c),c.bumpMap&&(q.bumpMap.value=c.bumpMap,q.bumpScale.value=c.bumpScale,1===c.side&&(q.bumpScale.value*=-1)),c.normalMap&&(q.normalMap.value=c.normalMap,q.normalScale.value.copy(c.normalScale),1===c.side&&q.normalScale.value.negate()),c.displacementMap&&(q.displacementMap.value=c.displacementMap,q.displacementScale.value=c.displacementScale,q.displacementBias.value=c.displacementBias)):c.isLineBasicMaterial?(q.diffuse.value=c.color,q.opacity.value=
c.opacity,c.isLineDashedMaterial&&(q.dashSize.value=c.dashSize,q.totalSize.value=c.dashSize+c.gapSize,q.scale.value=c.scale)):c.isPointsMaterial?(q.diffuse.value=c.color,q.opacity.value=c.opacity,q.size.value=c.size*U,q.scale.value=.5*M,q.map.value=c.map,null!==c.map&&(!0===c.map.matrixAutoUpdate&&c.map.updateMatrix(),q.uvTransform.value.copy(c.map.matrix))):c.isSpriteMaterial?(q.diffuse.value=c.color,q.opacity.value=c.opacity,q.rotation.value=c.rotation,q.map.value=c.map,null!==c.map&&(!0===c.map.matrixAutoUpdate&&
c.map.updateMatrix(),q.uvTransform.value.copy(c.map.matrix))):c.isShadowMaterial&&(q.color.value=c.color,q.opacity.value=c.opacity),void 0!==q.ltc_1&&(q.ltc_1.value=F.LTC_1),void 0!==q.ltc_2&&(q.ltc_2.value=F.LTC_2),cb.upload(P,e.uniformsList,q,Y));c.isShaderMaterial&&!0===c.uniformsNeedUpdate&&(cb.upload(P,e.uniformsList,q,Y),c.uniformsNeedUpdate=!1);c.isSpriteMaterial&&g.setValue(P,"center",d.center);g.setValue(P,"modelViewMatrix",d.modelViewMatrix);g.setValue(P,"normalMatrix",d.normalMatrix);g.setValue(P,
"modelMatrix",d.matrixWorld);return f}function l(a,b){a.opacity.value=b.opacity;b.color&&(a.diffuse.value=b.color);b.emissive&&a.emissive.value.copy(b.emissive).multiplyScalar(b.emissiveIntensity);b.map&&(a.map.value=b.map);b.alphaMap&&(a.alphaMap.value=b.alphaMap);b.specularMap&&(a.specularMap.value=b.specularMap);b.envMap&&(a.envMap.value=b.envMap,a.flipEnvMap.value=b.envMap.isCubeTexture?-1:1,a.reflectivity.value=b.reflectivity,a.refractionRatio.value=b.refractionRatio,a.maxMipLevel.value=Ca.get(b.envMap).__maxMipLevel);
b.lightMap&&(a.lightMap.value=b.lightMap,a.lightMapIntensity.value=b.lightMapIntensity);b.aoMap&&(a.aoMap.value=b.aoMap,a.aoMapIntensity.value=b.aoMapIntensity);if(b.map)var c=b.map;else b.specularMap?c=b.specularMap:b.displacementMap?c=b.displacementMap:b.normalMap?c=b.normalMap:b.bumpMap?c=b.bumpMap:b.roughnessMap?c=b.roughnessMap:b.metalnessMap?c=b.metalnessMap:b.alphaMap?c=b.alphaMap:b.emissiveMap&&(c=b.emissiveMap);void 0!==c&&(c.isWebGLRenderTarget&&(c=c.texture),!0===c.matrixAutoUpdate&&c.updateMatrix(),
a.uvTransform.value.copy(c.matrix))}function t(a,b){a.specular.value=b.specular;a.shininess.value=Math.max(b.shininess,1E-4);b.emissiveMap&&(a.emissiveMap.value=b.emissiveMap);b.bumpMap&&(a.bumpMap.value=b.bumpMap,a.bumpScale.value=b.bumpScale,1===b.side&&(a.bumpScale.value*=-1));b.normalMap&&(a.normalMap.value=b.normalMap,a.normalScale.value.copy(b.normalScale),1===b.side&&a.normalScale.value.negate());b.displacementMap&&(a.displacementMap.value=b.displacementMap,a.displacementScale.value=b.displacementScale,
a.displacementBias.value=b.displacementBias)}function v(a,b){a.roughness.value=b.roughness;a.metalness.value=b.metalness;b.roughnessMap&&(a.roughnessMap.value=b.roughnessMap);b.metalnessMap&&(a.metalnessMap.value=b.metalnessMap);b.emissiveMap&&(a.emissiveMap.value=b.emissiveMap);b.bumpMap&&(a.bumpMap.value=b.bumpMap,a.bumpScale.value=b.bumpScale,1===b.side&&(a.bumpScale.value*=-1));b.normalMap&&(a.normalMap.value=b.normalMap,a.normalScale.value.copy(b.normalScale),1===b.side&&a.normalScale.value.negate());
b.displacementMap&&(a.displacementMap.value=b.displacementMap,a.displacementScale.value=b.displacementScale,a.displacementBias.value=b.displacementBias);b.envMap&&(a.envMapIntensity.value=b.envMapIntensity)}console.log("THREE.WebGLRenderer","99");a=a||{};var w=void 0!==a.canvas?a.canvas:document.createElementNS("http://www.w3.org/1999/xhtml","canvas"),y=void 0!==a.context?a.context:null,u=void 0!==a.alpha?a.alpha:!1,H=void 0!==a.depth?a.depth:!0,G=void 0!==a.stencil?a.stencil:!0,N=void 0!==a.antialias?
a.antialias:!1,z=void 0!==a.premultipliedAlpha?a.premultipliedAlpha:!0,A=void 0!==a.preserveDrawingBuffer?a.preserveDrawingBuffer:!1,B=void 0!==a.powerPreference?a.powerPreference:"default",C=null,D=null;this.domElement=w;this.context=null;this.sortObjects=this.autoClearStencil=this.autoClearDepth=this.autoClearColor=this.autoClear=!0;this.clippingPlanes=[];this.localClippingEnabled=!1;this.gammaFactor=2;this.physicallyCorrectLights=this.gammaOutput=this.gammaInput=!1;this.toneMappingWhitePoint=this.toneMappingExposure=
this.toneMapping=1;this.maxMorphTargets=8;this.maxMorphNormals=4;var Y=this,J=!1,K=null,Q=null,L=null,E=-1;var I=b=null;var ud=!1;var T=null,X=null,S=new ca,Cc=new ca,ea=null,ba=0,V=w.width,M=w.height,U=1,fa=new ca(0,0,V,M),ka=new ca(0,0,V,M),sa=!1,qa=new td,Z=new Vf,wd=!1,ae=!1,Bc=new O,fb=new n;try{u={alpha:u,depth:H,stencil:G,antialias:N,premultipliedAlpha:z,preserveDrawingBuffer:A,powerPreference:B};w.addEventListener("webglcontextlost",d,!1);w.addEventListener("webglcontextrestored",e,!1);var P=
y||w.getContext("webgl",u)||w.getContext("experimental-webgl",u);if(null===P){if(null!==w.getContext("webgl"))throw Error("Error creating WebGL context with your selected attributes.");throw Error("Error creating WebGL context.");}void 0===P.getShaderPrecisionFormat&&(P.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(Ug){console.error("THREE.WebGLRenderer: "+Ug.message)}var la,wa,aa,da,Ca,ha,ra,ta,oa,na,ua,pa,ma,xa,za,Aa,ia;c();var ja=null;"undefined"!==typeof navigator&&
(ja="xr"in navigator?new Tg(Y):new kf(Y));this.vr=ja;var Ba=new ef(Y,oa,wa.maxTextureSize);this.shadowMap=Ba;this.getContext=function(){return P};this.getContextAttributes=function(){return P.getContextAttributes()};this.forceContextLoss=function(){var a=la.get("WEBGL_lose_context");a&&a.loseContext()};this.forceContextRestore=function(){var a=la.get("WEBGL_lose_context");a&&a.restoreContext()};this.getPixelRatio=function(){return U};this.setPixelRatio=function(a){void 0!==a&&(U=a,this.setSize(V,
M,!1))};this.getSize=function(){return{width:V,height:M}};this.setSize=function(a,b,c){ja.isPresenting()?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(V=a,M=b,w.width=a*U,w.height=b*U,!1!==c&&(w.style.width=a+"px",w.style.height=b+"px"),this.setViewport(0,0,a,b))};this.getDrawingBufferSize=function(){return{width:V*U,height:M*U}};this.setDrawingBufferSize=function(a,b,c){V=a;M=b;U=c;w.width=a*c;w.height=b*c;this.setViewport(0,0,a,b)};this.getCurrentViewport=
function(){return S};this.setViewport=function(a,b,c,d){fa.set(a,M-b-d,c,d);aa.viewport(S.copy(fa).multiplyScalar(U))};this.setScissor=function(a,b,c,d){ka.set(a,M-b-d,c,d);aa.scissor(Cc.copy(ka).multiplyScalar(U))};this.setScissorTest=function(a){aa.setScissorTest(sa=a)};this.getClearColor=function(){return ma.getClearColor()};this.setClearColor=function(){ma.setClearColor.apply(ma,arguments)};this.getClearAlpha=function(){return ma.getClearAlpha()};this.setClearAlpha=function(){ma.setClearAlpha.apply(ma,
arguments)};this.clear=function(a,b,c){var d=0;if(void 0===a||a)d|=16384;if(void 0===b||b)d|=256;if(void 0===c||c)d|=1024;P.clear(d)};this.clearColor=function(){this.clear(!0,!1,!1)};this.clearDepth=function(){this.clear(!1,!0,!1)};this.clearStencil=function(){this.clear(!1,!1,!0)};this.dispose=function(){w.removeEventListener("webglcontextlost",d,!1);w.removeEventListener("webglcontextrestored",e,!1);ua.dispose();pa.dispose();Ca.dispose();oa.dispose();ja.dispose();va.stop()};this.renderBufferImmediate=
function(a,b){aa.initAttributes();var c=Ca.get(a);a.hasPositions&&!c.position&&(c.position=P.createBuffer());a.hasNormals&&!c.normal&&(c.normal=P.createBuffer());a.hasUvs&&!c.uv&&(c.uv=P.createBuffer());a.hasColors&&!c.color&&(c.color=P.createBuffer());b=b.getAttributes();a.hasPositions&&(P.bindBuffer(34962,c.position),P.bufferData(34962,a.positionArray,35048),aa.enableAttribute(b.position),P.vertexAttribPointer(b.position,3,5126,!1,0,0));a.hasNormals&&(P.bindBuffer(34962,c.normal),P.bufferData(34962,
a.normalArray,35048),aa.enableAttribute(b.normal),P.vertexAttribPointer(b.normal,3,5126,!1,0,0));a.hasUvs&&(P.bindBuffer(34962,c.uv),P.bufferData(34962,a.uvArray,35048),aa.enableAttribute(b.uv),P.vertexAttribPointer(b.uv,2,5126,!1,0,0));a.hasColors&&(P.bindBuffer(34962,c.color),P.bufferData(34962,a.colorArray,35048),aa.enableAttribute(b.color),P.vertexAttribPointer(b.color,3,5126,!1,0,0));aa.disableUnusedAttributes();P.drawArrays(4,0,a.count);a.count=0};this.renderBufferDirect=function(a,c,d,e,f,
g){var h=f.isMesh&&0>f.normalMatrix.determinant();aa.setMaterial(e,h);var k=r(a,c,e,f),m=!1;if(b!==d.id||I!==k.id||ud!==(!0===e.wireframe))b=d.id,I=k.id,ud=!0===e.wireframe,m=!0;f.morphTargetInfluences&&(xa.update(f,d,e,k),m=!0);h=d.index;var q=d.attributes.position;c=1;!0===e.wireframe&&(h=ta.getWireframeAttribute(d),c=2);a=za;if(null!==h){var p=ra.get(h);a=Aa;a.setIndex(p)}if(m){if(d&&d.isInstancedBufferGeometry&!wa.isWebGL2&&null===la.get("ANGLE_instanced_arrays"))console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
else{aa.initAttributes();m=d.attributes;k=k.getAttributes();var l=e.defaultAttributeValues;for(A in k){var t=k[A];if(0<=t){var x=m[A];if(void 0!==x){var v=x.normalized,n=x.itemSize,u=ra.get(x);if(void 0!==u){var w=u.buffer,y=u.type;u=u.bytesPerElement;if(x.isInterleavedBufferAttribute){var G=x.data,H=G.stride;x=x.offset;G&&G.isInstancedInterleavedBuffer?(aa.enableAttributeAndDivisor(t,G.meshPerAttribute),void 0===d.maxInstancedCount&&(d.maxInstancedCount=G.meshPerAttribute*G.count)):aa.enableAttribute(t);
P.bindBuffer(34962,w);P.vertexAttribPointer(t,n,y,v,H*u,x*u)}else x.isInstancedBufferAttribute?(aa.enableAttributeAndDivisor(t,x.meshPerAttribute),void 0===d.maxInstancedCount&&(d.maxInstancedCount=x.meshPerAttribute*x.count)):aa.enableAttribute(t),P.bindBuffer(34962,w),P.vertexAttribPointer(t,n,y,v,0,0)}}else if(void 0!==l&&(v=l[A],void 0!==v))switch(v.length){case 2:P.vertexAttrib2fv(t,v);break;case 3:P.vertexAttrib3fv(t,v);break;case 4:P.vertexAttrib4fv(t,v);break;default:P.vertexAttrib1fv(t,v)}}}aa.disableUnusedAttributes()}null!==
h&&P.bindBuffer(34963,p.buffer)}p=Infinity;null!==h?p=h.count:void 0!==q&&(p=q.count);h=d.drawRange.start*c;q=null!==g?g.start*c:0;var A=Math.max(h,q);g=Math.max(0,Math.min(p,h+d.drawRange.count*c,q+(null!==g?g.count*c:Infinity))-1-A+1);if(0!==g){if(f.isMesh)if(!0===e.wireframe)aa.setLineWidth(e.wireframeLinewidth*(null===Q?U:1)),a.setMode(1);else switch(f.drawMode){case 0:a.setMode(4);break;case 1:a.setMode(5);break;case 2:a.setMode(6)}else f.isLine?(e=e.linewidth,void 0===e&&(e=1),aa.setLineWidth(e*
(null===Q?U:1)),f.isLineSegments?a.setMode(1):f.isLineLoop?a.setMode(2):a.setMode(3)):f.isPoints?a.setMode(0):f.isSprite&&a.setMode(4);d&&d.isInstancedBufferGeometry?0<d.maxInstancedCount&&a.renderInstances(d,A,g):a.render(A,g)}};this.compile=function(a,b){D=pa.get(a,b);D.init();a.traverse(function(a){a.isLight&&(D.pushLight(a),a.castShadow&&D.pushShadow(a))});D.setupLights(b);a.traverse(function(b){if(b.material)if(Array.isArray(b.material))for(var c=0;c<b.material.length;c++)p(b.material[c],a.fog,
b);else p(b.material,a.fog,b)})};var ya=null,va=new Wd;va.setAnimationLoop(function(a){ja.isPresenting()||ya&&ya(a)});"undefined"!==typeof window&&va.setContext(window);this.setAnimationLoop=function(a){ya=a;ja.setAnimationLoop(a);va.start()};this.render=function(a,c,d,e){if(!c||!c.isCamera)console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");else if(!J){I=b=null;ud=!1;E=-1;T=null;!0===a.autoUpdate&&a.updateMatrixWorld();null===c.parent&&c.updateMatrixWorld();ja.enabled&&
(c=ja.getCamera(c));D=pa.get(a,c);D.init();a.onBeforeRender(Y,a,c,d);Bc.multiplyMatrices(c.projectionMatrix,c.matrixWorldInverse);qa.setFromMatrix(Bc);ae=this.localClippingEnabled;wd=Z.init(this.clippingPlanes,ae,c);C=ua.get(a,c);C.init();k(a,c,Y.sortObjects);!0===Y.sortObjects&&C.sort();wd&&Z.beginShadows();Ba.render(D.state.shadowsArray,a,c);D.setupLights(c);wd&&Z.endShadows();this.info.autoReset&&this.info.reset();void 0===d&&(d=null);this.setRenderTarget(d);ma.render(C,a,c,e);e=C.opaque;var f=
C.transparent;if(a.overrideMaterial){var g=a.overrideMaterial;e.length&&m(e,a,c,g);f.length&&m(f,a,c,g)}else e.length&&m(e,a,c),f.length&&m(f,a,c);d&&ha.updateRenderTargetMipmap(d);aa.buffers.depth.setTest(!0);aa.buffers.depth.setMask(!0);aa.buffers.color.setMask(!0);aa.setPolygonOffset(!1);a.onAfterRender(Y,a,c);ja.enabled&&ja.submitFrame();D=C=null}};this.allocTextureUnit=function(){var a=ba;a>=wa.maxTextures&&console.warn("THREE.WebGLRenderer: Trying to use "+a+" texture units while this GPU supports only "+
wa.maxTextures);ba+=1;return a};this.setTexture2D=function(){var a=!1;return function(b,c){b&&b.isWebGLRenderTarget&&(a||(console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."),a=!0),b=b.texture);ha.setTexture2D(b,c)}}();this.setTexture3D=function(){return function(a,b){ha.setTexture3D(a,b)}}();this.setTexture=function(){var a=!1;return function(b,c){a||(console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."),
a=!0);ha.setTexture2D(b,c)}}();this.setTextureCube=function(){var a=!1;return function(b,c){b&&b.isWebGLRenderTargetCube&&(a||(console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."),a=!0),b=b.texture);b&&b.isCubeTexture||Array.isArray(b.image)&&6===b.image.length?ha.setTextureCube(b,c):ha.setTextureCubeDynamic(b,c)}}();this.setFramebuffer=function(a){K=a};this.getRenderTarget=function(){return Q};this.setRenderTarget=function(a){(Q=
a)&&void 0===Ca.get(a).__webglFramebuffer&&ha.setupRenderTarget(a);var b=K,c=!1;a?(b=Ca.get(a).__webglFramebuffer,a.isWebGLRenderTargetCube&&(b=b[a.activeCubeFace],c=!0),S.copy(a.viewport),Cc.copy(a.scissor),ea=a.scissorTest):(S.copy(fa).multiplyScalar(U),Cc.copy(ka).multiplyScalar(U),ea=sa);L!==b&&(P.bindFramebuffer(36160,b),L=b);aa.viewport(S);aa.scissor(Cc);aa.setScissorTest(ea);c&&(c=Ca.get(a.texture),P.framebufferTexture2D(36160,36064,34069+a.activeCubeFace,c.__webglTexture,a.activeMipMapLevel))};
this.readRenderTargetPixels=function(a,b,c,d,e,f){if(a&&a.isWebGLRenderTarget){var g=Ca.get(a).__webglFramebuffer;if(g){var h=!1;g!==L&&(P.bindFramebuffer(36160,g),h=!0);try{var k=a.texture,m=k.format,q=k.type;1023!==m&&ia.convert(m)!==P.getParameter(35739)?console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."):1009===q||ia.convert(q)===P.getParameter(35738)||1015===q&&(wa.isWebGL2||la.get("OES_texture_float")||la.get("WEBGL_color_buffer_float"))||
1016===q&&(wa.isWebGL2?la.get("EXT_color_buffer_float"):la.get("EXT_color_buffer_half_float"))?36053===P.checkFramebufferStatus(36160)?0<=b&&b<=a.width-d&&0<=c&&c<=a.height-e&&P.readPixels(b,c,d,e,ia.convert(m),ia.convert(q),f):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."):console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.")}finally{h&&P.bindFramebuffer(36160,
L)}}}else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")};this.copyFramebufferToTexture=function(a,b,c){var d=b.image.width,e=b.image.height,f=ia.convert(b.format);this.setTexture2D(b,0);P.copyTexImage2D(3553,c||0,f,a.x,a.y,d,e,0)};this.copyTextureToTexture=function(a,b,c,d){var e=b.image.width,f=b.image.height,g=ia.convert(c.format),h=ia.convert(c.type);this.setTexture2D(c,0);b.isDataTexture?P.texSubImage2D(3553,d||0,a.x,a.y,e,f,g,h,b.image.data):
P.texSubImage2D(3553,d||0,a.x,a.y,g,h,b.image)}}function Qb(a,b){this.name="";this.color=new J(a);this.density=void 0!==b?b:2.5E-4}function Rb(a,b,c){this.name="";this.color=new J(a);this.near=void 0!==b?b:1;this.far=void 0!==c?c:1E3}function xd(){C.call(this);this.type="Scene";this.overrideMaterial=this.fog=this.background=null;this.autoUpdate=!0}function rb(a,b){this.array=a;this.stride=b;this.count=void 0!==a?a.length/b:0;this.dynamic=!1;this.updateRange={offset:0,count:-1};this.version=0}function Ec(a,
b,c,d){this.data=a;this.itemSize=b;this.offset=c;this.normalized=!0===d}function gb(a){L.call(this);this.type="SpriteMaterial";this.color=new J(16777215);this.map=null;this.rotation=0;this.sizeAttenuation=!0;this.lights=!1;this.transparent=!0;this.setValues(a)}function Fc(a){C.call(this);this.type="Sprite";if(void 0===Sb){Sb=new D;var b=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]);b=new rb(b,5);Sb.setIndex([0,1,2,0,2,3]);Sb.addAttribute("position",new Ec(b,3,0,!1));Sb.addAttribute("uv",
new Ec(b,2,3,!1))}this.geometry=Sb;this.material=void 0!==a?a:new gb;this.center=new z(.5,.5)}function Gc(){C.call(this);this.type="LOD";Object.defineProperties(this,{levels:{enumerable:!0,value:[]}})}function Hc(a,b){a&&a.isGeometry&&console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");pa.call(this,a,b);this.type="SkinnedMesh";this.bindMode="attached";this.bindMatrix=new O;this.bindMatrixInverse=new O}function yd(a,b){a=a||[];this.bones=a.slice(0);
this.boneMatrices=new Float32Array(16*this.bones.length);if(void 0===b)this.calculateInverses();else if(this.bones.length===b.length)this.boneInverses=b.slice(0);else for(console.warn("THREE.Skeleton boneInverses is the wrong length."),this.boneInverses=[],a=0,b=this.bones.length;a<b;a++)this.boneInverses.push(new O)}function ce(){C.call(this);this.type="Bone"}function T(a){L.call(this);this.type="LineBasicMaterial";this.color=new J(16777215);this.linewidth=1;this.linejoin=this.linecap="round";this.lights=
!1;this.setValues(a)}function ma(a,b,c){1===c&&console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.");C.call(this);this.type="Line";this.geometry=void 0!==a?a:new D;this.material=void 0!==b?b:new T({color:16777215*Math.random()})}function S(a,b){ma.call(this,a,b);this.type="LineSegments"}function zd(a,b){ma.call(this,a,b);this.type="LineLoop"}function Fa(a){L.call(this);this.type="PointsMaterial";this.color=new J(16777215);this.map=null;this.size=
1;this.sizeAttenuation=!0;this.lights=this.morphTargets=!1;this.setValues(a)}function Tb(a,b){C.call(this);this.type="Points";this.geometry=void 0!==a?a:new D;this.material=void 0!==b?b:new Fa({color:16777215*Math.random()})}function de(a,b,c,d,e,f,g,h,k){X.call(this,a,b,c,d,e,f,g,h,k);this.format=void 0!==g?g:1022;this.minFilter=void 0!==f?f:1006;this.magFilter=void 0!==e?e:1006;this.generateMipmaps=!1}function Ub(a,b,c,d,e,f,g,h,k,m,q,p){X.call(this,null,f,g,h,k,m,d,e,q,p);this.image={width:b,height:c};
this.mipmaps=a;this.generateMipmaps=this.flipY=!1}function Ic(a,b,c,d,e,f,g,h,k){X.call(this,a,b,c,d,e,f,g,h,k);this.needsUpdate=!0}function Jc(a,b,c,d,e,f,g,h,k,m){m=void 0!==m?m:1026;if(1026!==m&&1027!==m)throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");void 0===c&&1026===m&&(c=1012);void 0===c&&1027===m&&(c=1020);X.call(this,null,d,e,f,g,h,m,c,k);this.image={width:a,height:b};this.magFilter=void 0!==g?g:1003;this.minFilter=void 0!==h?h:1003;this.generateMipmaps=
this.flipY=!1}function Vb(a){D.call(this);this.type="WireframeGeometry";var b=[],c,d,e,f=[0,0],g={},h=["a","b","c"];if(a&&a.isGeometry){var k=a.faces;var m=0;for(d=k.length;m<d;m++){var q=k[m];for(c=0;3>c;c++){var p=q[h[c]];var r=q[h[(c+1)%3]];f[0]=Math.min(p,r);f[1]=Math.max(p,r);p=f[0]+","+f[1];void 0===g[p]&&(g[p]={index1:f[0],index2:f[1]})}}for(p in g)m=g[p],h=a.vertices[m.index1],b.push(h.x,h.y,h.z),h=a.vertices[m.index2],b.push(h.x,h.y,h.z)}else if(a&&a.isBufferGeometry)if(h=new n,null!==a.index){k=
a.attributes.position;q=a.index;var l=a.groups;0===l.length&&(l=[{start:0,count:q.count,materialIndex:0}]);a=0;for(e=l.length;a<e;++a)for(m=l[a],c=m.start,d=m.count,m=c,d=c+d;m<d;m+=3)for(c=0;3>c;c++)p=q.getX(m+c),r=q.getX(m+(c+1)%3),f[0]=Math.min(p,r),f[1]=Math.max(p,r),p=f[0]+","+f[1],void 0===g[p]&&(g[p]={index1:f[0],index2:f[1]});for(p in g)m=g[p],h.fromBufferAttribute(k,m.index1),b.push(h.x,h.y,h.z),h.fromBufferAttribute(k,m.index2),b.push(h.x,h.y,h.z)}else for(k=a.attributes.position,m=0,d=
k.count/3;m<d;m++)for(c=0;3>c;c++)g=3*m+c,h.fromBufferAttribute(k,g),b.push(h.x,h.y,h.z),g=3*m+(c+1)%3,h.fromBufferAttribute(k,g),b.push(h.x,h.y,h.z);this.addAttribute("position",new B(b,3))}function Kc(a,b,c){Q.call(this);this.type="ParametricGeometry";this.parameters={func:a,slices:b,stacks:c};this.fromBufferGeometry(new Wb(a,b,c));this.mergeVertices()}function Wb(a,b,c){D.call(this);this.type="ParametricBufferGeometry";this.parameters={func:a,slices:b,stacks:c};var d=[],e=[],f=[],g=[],h=new n,
k=new n,m=new n,q=new n,p=new n,r,l;3>a.length&&console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");var t=b+1;for(r=0;r<=c;r++){var v=r/c;for(l=0;l<=b;l++){var w=l/b;a(w,v,k);e.push(k.x,k.y,k.z);0<=w-1E-5?(a(w-1E-5,v,m),q.subVectors(k,m)):(a(w+1E-5,v,m),q.subVectors(m,k));0<=v-1E-5?(a(w,v-1E-5,m),p.subVectors(k,m)):(a(w,v+1E-5,m),p.subVectors(m,k));h.crossVectors(q,p).normalize();f.push(h.x,h.y,h.z);g.push(w,v)}}for(r=0;r<c;r++)for(l=0;l<b;l++)a=r*t+l+
1,h=(r+1)*t+l+1,k=(r+1)*t+l,d.push(r*t+l,a,k),d.push(a,h,k);this.setIndex(d);this.addAttribute("position",new B(e,3));this.addAttribute("normal",new B(f,3));this.addAttribute("uv",new B(g,2))}function Lc(a,b,c,d){Q.call(this);this.type="PolyhedronGeometry";this.parameters={vertices:a,indices:b,radius:c,detail:d};this.fromBufferGeometry(new xa(a,b,c,d));this.mergeVertices()}function xa(a,b,c,d){function e(a){h.push(a.x,a.y,a.z)}function f(b,c){b*=3;c.x=a[b+0];c.y=a[b+1];c.z=a[b+2]}function g(a,b,c,
d){0>d&&1===a.x&&(k[b]=a.x-1);0===c.x&&0===c.z&&(k[b]=d/2/Math.PI+.5)}D.call(this);this.type="PolyhedronBufferGeometry";this.parameters={vertices:a,indices:b,radius:c,detail:d};c=c||1;d=d||0;var h=[],k=[];(function(a){for(var c=new n,d=new n,g=new n,h=0;h<b.length;h+=3){f(b[h+0],c);f(b[h+1],d);f(b[h+2],g);var k,m,l=c,y=d,u=g,H=Math.pow(2,a),G=[];for(m=0;m<=H;m++){G[m]=[];var N=l.clone().lerp(u,m/H),z=y.clone().lerp(u,m/H),A=H-m;for(k=0;k<=A;k++)G[m][k]=0===k&&m===H?N:N.clone().lerp(z,k/A)}for(m=0;m<
H;m++)for(k=0;k<2*(H-m)-1;k++)l=Math.floor(k/2),0===k%2?(e(G[m][l+1]),e(G[m+1][l]),e(G[m][l])):(e(G[m][l+1]),e(G[m+1][l+1]),e(G[m+1][l]))}})(d);(function(a){for(var b=new n,c=0;c<h.length;c+=3)b.x=h[c+0],b.y=h[c+1],b.z=h[c+2],b.normalize().multiplyScalar(a),h[c+0]=b.x,h[c+1]=b.y,h[c+2]=b.z})(c);(function(){for(var a=new n,b=0;b<h.length;b+=3)a.x=h[b+0],a.y=h[b+1],a.z=h[b+2],k.push(Math.atan2(a.z,-a.x)/2/Math.PI+.5,1-(Math.atan2(-a.y,Math.sqrt(a.x*a.x+a.z*a.z))/Math.PI+.5));a=new n;b=new n;for(var c=
new n,d=new n,e=new z,f=new z,l=new z,w=0,y=0;w<h.length;w+=9,y+=6){a.set(h[w+0],h[w+1],h[w+2]);b.set(h[w+3],h[w+4],h[w+5]);c.set(h[w+6],h[w+7],h[w+8]);e.set(k[y+0],k[y+1]);f.set(k[y+2],k[y+3]);l.set(k[y+4],k[y+5]);d.copy(a).add(b).add(c).divideScalar(3);var u=Math.atan2(d.z,-d.x);g(e,y+0,a,u);g(f,y+2,b,u);g(l,y+4,c,u)}for(a=0;a<k.length;a+=6)b=k[a+0],c=k[a+2],d=k[a+4],e=Math.min(b,c,d),.9<Math.max(b,c,d)&&.1>e&&(.2>b&&(k[a+0]+=1),.2>c&&(k[a+2]+=1),.2>d&&(k[a+4]+=1))})();this.addAttribute("position",
new B(h,3));this.addAttribute("normal",new B(h.slice(),3));this.addAttribute("uv",new B(k,2));0===d?this.computeVertexNormals():this.normalizeNormals()}function Mc(a,b){Q.call(this);this.type="TetrahedronGeometry";this.parameters={radius:a,detail:b};this.fromBufferGeometry(new Xb(a,b));this.mergeVertices()}function Xb(a,b){xa.call(this,[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],[2,1,0,0,3,2,1,3,0,2,3,1],a,b);this.type="TetrahedronBufferGeometry";this.parameters={radius:a,detail:b}}function Nc(a,b){Q.call(this);
this.type="OctahedronGeometry";this.parameters={radius:a,detail:b};this.fromBufferGeometry(new sb(a,b));this.mergeVertices()}function sb(a,b){xa.call(this,[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2],a,b);this.type="OctahedronBufferGeometry";this.parameters={radius:a,detail:b}}function Oc(a,b){Q.call(this);this.type="IcosahedronGeometry";this.parameters={radius:a,detail:b};this.fromBufferGeometry(new Yb(a,b));this.mergeVertices()}function Yb(a,b){var c=
(1+Math.sqrt(5))/2;xa.call(this,[-1,c,0,1,c,0,-1,-c,0,1,-c,0,0,-1,c,0,1,c,0,-1,-c,0,1,-c,c,0,-1,c,0,1,-c,0,-1,-c,0,1],[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],a,b);this.type="IcosahedronBufferGeometry";this.parameters={radius:a,detail:b}}function Pc(a,b){Q.call(this);this.type="DodecahedronGeometry";this.parameters={radius:a,detail:b};this.fromBufferGeometry(new Zb(a,b));this.mergeVertices()}function Zb(a,b){var c=
(1+Math.sqrt(5))/2,d=1/c;xa.call(this,[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-d,-c,0,-d,c,0,d,-c,0,d,c,-d,-c,0,-d,c,0,d,-c,0,d,c,0,-c,0,-d,c,0,-d,-c,0,d,c,0,d],[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9],a,b);this.type="DodecahedronBufferGeometry";this.parameters=
{radius:a,detail:b}}function Qc(a,b,c,d,e,f){Q.call(this);this.type="TubeGeometry";this.parameters={path:a,tubularSegments:b,radius:c,radialSegments:d,closed:e};void 0!==f&&console.warn("THREE.TubeGeometry: taper has been removed.");a=new $b(a,b,c,d,e);this.tangents=a.tangents;this.normals=a.normals;this.binormals=a.binormals;this.fromBufferGeometry(a);this.mergeVertices()}function $b(a,b,c,d,e){function f(e){q=a.getPointAt(e/b,q);var f=g.normals[e];e=g.binormals[e];for(r=0;r<=d;r++){var m=r/d*Math.PI*
2,p=Math.sin(m);m=-Math.cos(m);k.x=m*f.x+p*e.x;k.y=m*f.y+p*e.y;k.z=m*f.z+p*e.z;k.normalize();t.push(k.x,k.y,k.z);h.x=q.x+c*k.x;h.y=q.y+c*k.y;h.z=q.z+c*k.z;l.push(h.x,h.y,h.z)}}D.call(this);this.type="TubeBufferGeometry";this.parameters={path:a,tubularSegments:b,radius:c,radialSegments:d,closed:e};b=b||64;c=c||1;d=d||8;e=e||!1;var g=a.computeFrenetFrames(b,e);this.tangents=g.tangents;this.normals=g.normals;this.binormals=g.binormals;var h=new n,k=new n,m=new z,q=new n,p,r,l=[],t=[],v=[],w=[];for(p=
0;p<b;p++)f(p);f(!1===e?b:0);for(p=0;p<=b;p++)for(r=0;r<=d;r++)m.x=p/b,m.y=r/d,v.push(m.x,m.y);(function(){for(r=1;r<=b;r++)for(p=1;p<=d;p++){var a=(d+1)*r+(p-1),c=(d+1)*r+p,e=(d+1)*(r-1)+p;w.push((d+1)*(r-1)+(p-1),a,e);w.push(a,c,e)}})();this.setIndex(w);this.addAttribute("position",new B(l,3));this.addAttribute("normal",new B(t,3));this.addAttribute("uv",new B(v,2))}function Rc(a,b,c,d,e,f,g){Q.call(this);this.type="TorusKnotGeometry";this.parameters={radius:a,tube:b,tubularSegments:c,radialSegments:d,
p:e,q:f};void 0!==g&&console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.");this.fromBufferGeometry(new ac(a,b,c,d,e,f));this.mergeVertices()}function ac(a,b,c,d,e,f){function g(a,b,c,d,e){var f=Math.sin(a);b=c/b*a;c=Math.cos(b);e.x=d*(2+c)*.5*Math.cos(a);e.y=d*(2+c)*f*.5;e.z=d*Math.sin(b)*.5}D.call(this);this.type="TorusKnotBufferGeometry";this.parameters={radius:a,tube:b,tubularSegments:c,radialSegments:d,p:e,q:f};a=a||1;b=b||.4;c=Math.floor(c)||
64;d=Math.floor(d)||8;e=e||2;f=f||3;var h=[],k=[],m=[],q=[],p,r=new n,l=new n,t=new n,v=new n,w=new n,y=new n,u=new n;for(p=0;p<=c;++p){var H=p/c*e*Math.PI*2;g(H,e,f,a,t);g(H+.01,e,f,a,v);y.subVectors(v,t);u.addVectors(v,t);w.crossVectors(y,u);u.crossVectors(w,y);w.normalize();u.normalize();for(H=0;H<=d;++H){var G=H/d*Math.PI*2,N=-b*Math.cos(G);G=b*Math.sin(G);r.x=t.x+(N*u.x+G*w.x);r.y=t.y+(N*u.y+G*w.y);r.z=t.z+(N*u.z+G*w.z);k.push(r.x,r.y,r.z);l.subVectors(r,t).normalize();m.push(l.x,l.y,l.z);q.push(p/
c);q.push(H/d)}}for(H=1;H<=c;H++)for(p=1;p<=d;p++)a=(d+1)*H+(p-1),b=(d+1)*H+p,e=(d+1)*(H-1)+p,h.push((d+1)*(H-1)+(p-1),a,e),h.push(a,b,e);this.setIndex(h);this.addAttribute("position",new B(k,3));this.addAttribute("normal",new B(m,3));this.addAttribute("uv",new B(q,2))}function Sc(a,b,c,d,e){Q.call(this);this.type="TorusGeometry";this.parameters={radius:a,tube:b,radialSegments:c,tubularSegments:d,arc:e};this.fromBufferGeometry(new bc(a,b,c,d,e));this.mergeVertices()}function bc(a,b,c,d,e){D.call(this);
this.type="TorusBufferGeometry";this.parameters={radius:a,tube:b,radialSegments:c,tubularSegments:d,arc:e};a=a||1;b=b||.4;c=Math.floor(c)||8;d=Math.floor(d)||6;e=e||2*Math.PI;var f=[],g=[],h=[],k=[],m=new n,q=new n,p=new n,r,l;for(r=0;r<=c;r++)for(l=0;l<=d;l++){var t=l/d*e,v=r/c*Math.PI*2;q.x=(a+b*Math.cos(v))*Math.cos(t);q.y=(a+b*Math.cos(v))*Math.sin(t);q.z=b*Math.sin(v);g.push(q.x,q.y,q.z);m.x=a*Math.cos(t);m.y=a*Math.sin(t);p.subVectors(q,m).normalize();h.push(p.x,p.y,p.z);k.push(l/d);k.push(r/
c)}for(r=1;r<=c;r++)for(l=1;l<=d;l++)a=(d+1)*(r-1)+l-1,b=(d+1)*(r-1)+l,e=(d+1)*r+l,f.push((d+1)*r+l-1,a,e),f.push(a,b,e);this.setIndex(f);this.addAttribute("position",new B(g,3));this.addAttribute("normal",new B(h,3));this.addAttribute("uv",new B(k,2))}function lf(a,b,c,d,e){for(var f,g=0,h=b,k=c-d;h<c;h+=d)g+=(a[k]-a[h])*(a[h+1]+a[k+1]),k=h;if(e===0<g)for(e=b;e<c;e+=d)f=mf(e,a[e],a[e+1],f);else for(e=c-d;e>=b;e-=d)f=mf(e,a[e],a[e+1],f);f&&tb(f,f.next)&&(Tc(f),f=f.next);return f}function Uc(a,b){if(!a)return a;
b||(b=a);do{var c=!1;if(a.steiner||!tb(a,a.next)&&0!==na(a.prev,a,a.next))a=a.next;else{Tc(a);a=b=a.prev;if(a===a.next)break;c=!0}}while(c||a!==b);return b}function Vc(a,b,c,d,e,f,g){if(a){if(!g&&f){var h=a,k=h;do null===k.z&&(k.z=ee(k.x,k.y,d,e,f)),k.prevZ=k.prev,k=k.nextZ=k.next;while(k!==h);k.prevZ.nextZ=null;k.prevZ=null;h=k;var m,q,p,r,l=1;do{k=h;var t=h=null;for(q=0;k;){q++;var n=k;for(m=p=0;m<l&&(p++,n=n.nextZ,n);m++);for(r=l;0<p||0<r&&n;)0!==p&&(0===r||!n||k.z<=n.z)?(m=k,k=k.nextZ,p--):(m=
n,n=n.nextZ,r--),t?t.nextZ=m:h=m,m.prevZ=t,t=m;k=n}t.nextZ=null;l*=2}while(1<q)}for(h=a;a.prev!==a.next;){k=a.prev;n=a.next;if(f)a:{t=a;r=d;var w=e,y=f;q=t.prev;p=t;l=t.next;if(0<=na(q,p,l))t=!1;else{var u=q.x>p.x?q.x>l.x?q.x:l.x:p.x>l.x?p.x:l.x,H=q.y>p.y?q.y>l.y?q.y:l.y:p.y>l.y?p.y:l.y;m=ee(q.x<p.x?q.x<l.x?q.x:l.x:p.x<l.x?p.x:l.x,q.y<p.y?q.y<l.y?q.y:l.y:p.y<l.y?p.y:l.y,r,w,y);r=ee(u,H,r,w,y);for(w=t.nextZ;w&&w.z<=r;){if(w!==t.prev&&w!==t.next&&Ad(q.x,q.y,p.x,p.y,l.x,l.y,w.x,w.y)&&0<=na(w.prev,w,
w.next)){t=!1;break a}w=w.nextZ}for(w=t.prevZ;w&&w.z>=m;){if(w!==t.prev&&w!==t.next&&Ad(q.x,q.y,p.x,p.y,l.x,l.y,w.x,w.y)&&0<=na(w.prev,w,w.next)){t=!1;break a}w=w.prevZ}t=!0}}else a:if(t=a,q=t.prev,p=t,l=t.next,0<=na(q,p,l))t=!1;else{for(m=t.next.next;m!==t.prev;){if(Ad(q.x,q.y,p.x,p.y,l.x,l.y,m.x,m.y)&&0<=na(m.prev,m,m.next)){t=!1;break a}m=m.next}t=!0}if(t)b.push(k.i/c),b.push(a.i/c),b.push(n.i/c),Tc(a),h=a=n.next;else if(a=n,a===h){if(!g)Vc(Uc(a),b,c,d,e,f,1);else if(1===g){g=b;h=c;k=a;do n=k.prev,
t=k.next.next,!tb(n,t)&&nf(n,k,k.next,t)&&Wc(n,t)&&Wc(t,n)&&(g.push(n.i/h),g.push(k.i/h),g.push(t.i/h),Tc(k),Tc(k.next),k=a=t),k=k.next;while(k!==a);a=k;Vc(a,b,c,d,e,f,2)}else if(2===g)a:{g=a;do{for(h=g.next.next;h!==g.prev;){if(k=g.i!==h.i){k=g;n=h;if(t=k.next.i!==n.i&&k.prev.i!==n.i){b:{t=k;do{if(t.i!==k.i&&t.next.i!==k.i&&t.i!==n.i&&t.next.i!==n.i&&nf(t,t.next,k,n)){t=!0;break b}t=t.next}while(t!==k);t=!1}t=!t}if(t=t&&Wc(k,n)&&Wc(n,k)){t=k;q=!1;p=(k.x+n.x)/2;n=(k.y+n.y)/2;do t.y>n!==t.next.y>n&&
t.next.y!==t.y&&p<(t.next.x-t.x)*(n-t.y)/(t.next.y-t.y)+t.x&&(q=!q),t=t.next;while(t!==k);t=q}k=t}if(k){a=of(g,h);g=Uc(g,g.next);a=Uc(a,a.next);Vc(g,b,c,d,e,f);Vc(a,b,c,d,e,f);break a}h=h.next}g=g.next}while(g!==a)}break}}}}function Vg(a,b){return a.x-b.x}function Wg(a,b){var c=b,d=a.x,e=a.y,f=-Infinity;do{if(e<=c.y&&e>=c.next.y&&c.next.y!==c.y){var g=c.x+(e-c.y)*(c.next.x-c.x)/(c.next.y-c.y);if(g<=d&&g>f){f=g;if(g===d){if(e===c.y)return c;if(e===c.next.y)return c.next}var h=c.x<c.next.x?c:c.next}}c=
c.next}while(c!==b);if(!h)return null;if(d===f)return h.prev;b=h;g=h.x;var k=h.y,m=Infinity;for(c=h.next;c!==b;){if(d>=c.x&&c.x>=g&&d!==c.x&&Ad(e<k?d:f,e,g,k,e<k?f:d,e,c.x,c.y)){var q=Math.abs(e-c.y)/(d-c.x);(q<m||q===m&&c.x>h.x)&&Wc(c,a)&&(h=c,m=q)}c=c.next}return h}function ee(a,b,c,d,e){a=32767*(a-c)*e;b=32767*(b-d)*e;a=(a|a<<8)&16711935;a=(a|a<<4)&252645135;a=(a|a<<2)&858993459;b=(b|b<<8)&16711935;b=(b|b<<4)&252645135;b=(b|b<<2)&858993459;return(a|a<<1)&1431655765|((b|b<<1)&1431655765)<<1}function Xg(a){var b=
a,c=a;do b.x<c.x&&(c=b),b=b.next;while(b!==a);return c}function Ad(a,b,c,d,e,f,g,h){return 0<=(e-g)*(b-h)-(a-g)*(f-h)&&0<=(a-g)*(d-h)-(c-g)*(b-h)&&0<=(c-g)*(f-h)-(e-g)*(d-h)}function na(a,b,c){return(b.y-a.y)*(c.x-b.x)-(b.x-a.x)*(c.y-b.y)}function tb(a,b){return a.x===b.x&&a.y===b.y}function nf(a,b,c,d){return tb(a,b)&&tb(c,d)||tb(a,d)&&tb(c,b)?!0:0<na(a,b,c)!==0<na(a,b,d)&&0<na(c,d,a)!==0<na(c,d,b)}function Wc(a,b){return 0>na(a.prev,a,a.next)?0<=na(a,b,a.next)&&0<=na(a,a.prev,b):0>na(a,b,a.prev)||
0>na(a,a.next,b)}function of(a,b){var c=new fe(a.i,a.x,a.y),d=new fe(b.i,b.x,b.y),e=a.next,f=b.prev;a.next=b;b.prev=a;c.next=e;e.prev=c;d.next=c;c.prev=d;f.next=d;d.prev=f;return d}function mf(a,b,c,d){a=new fe(a,b,c);d?(a.next=d.next,a.prev=d,d.next.prev=a,d.next=a):(a.prev=a,a.next=a);return a}function Tc(a){a.next.prev=a.prev;a.prev.next=a.next;a.prevZ&&(a.prevZ.nextZ=a.nextZ);a.nextZ&&(a.nextZ.prevZ=a.prevZ)}function fe(a,b,c){this.i=a;this.x=b;this.y=c;this.nextZ=this.prevZ=this.z=this.next=
this.prev=null;this.steiner=!1}function pf(a){var b=a.length;2<b&&a[b-1].equals(a[0])&&a.pop()}function qf(a,b){for(var c=0;c<b.length;c++)a.push(b[c].x),a.push(b[c].y)}function ub(a,b){Q.call(this);this.type="ExtrudeGeometry";this.parameters={shapes:a,options:b};this.fromBufferGeometry(new Sa(a,b));this.mergeVertices()}function Sa(a,b){function c(a){function c(a,b,c){b||console.error("THREE.ExtrudeGeometry: vec does not exist");return b.clone().multiplyScalar(c).add(a)}function g(a,b,c){var d=a.x-
b.x;var e=a.y-b.y;var f=c.x-a.x;var g=c.y-a.y,h=d*d+e*e;if(Math.abs(d*g-e*f)>Number.EPSILON){var k=Math.sqrt(h),m=Math.sqrt(f*f+g*g);h=b.x-e/k;b=b.y+d/k;g=((c.x-g/m-h)*g-(c.y+f/m-b)*f)/(d*g-e*f);f=h+d*g-a.x;d=b+e*g-a.y;e=f*f+d*d;if(2>=e)return new z(f,d);e=Math.sqrt(e/2)}else a=!1,d>Number.EPSILON?f>Number.EPSILON&&(a=!0):d<-Number.EPSILON?f<-Number.EPSILON&&(a=!0):Math.sign(e)===Math.sign(g)&&(a=!0),a?(f=-e,e=Math.sqrt(h)):(f=d,d=e,e=Math.sqrt(h/2));return new z(f/e,d/e)}function h(a,b){for(M=a.length;0<=
--M;){var c=M;var f=M-1;0>f&&(f=a.length-1);var g,h=u+2*A;for(g=0;g<h;g++){var k=X*g,m=X*(g+1),q=b+f+k,p=b+f+m;m=b+c+m;t(b+c+k);t(q);t(m);t(q);t(p);t(m);k=e.length/3;k=C.generateSideWallUV(d,e,k-6,k-3,k-2,k-1);v(k[0]);v(k[1]);v(k[3]);v(k[1]);v(k[2]);v(k[3])}}}function k(a,b,c){w.push(a);w.push(b);w.push(c)}function l(a,b,c){t(a);t(b);t(c);a=e.length/3;a=C.generateTopUV(d,e,a-3,a-2,a-1);v(a[0]);v(a[1]);v(a[2])}function t(a){e.push(w[3*a]);e.push(w[3*a+1]);e.push(w[3*a+2])}function v(a){f.push(a.x);
f.push(a.y)}var w=[],y=void 0!==b.curveSegments?b.curveSegments:12,u=void 0!==b.steps?b.steps:1,H=void 0!==b.depth?b.depth:100,G=void 0!==b.bevelEnabled?b.bevelEnabled:!0,N=void 0!==b.bevelThickness?b.bevelThickness:6,W=void 0!==b.bevelSize?b.bevelSize:N-2,A=void 0!==b.bevelSegments?b.bevelSegments:3,B=b.extrudePath,C=void 0!==b.UVGenerator?b.UVGenerator:Yg;void 0!==b.amount&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),H=b.amount);var D=!1;if(B){var Y=B.getSpacedPoints(u);
D=!0;G=!1;var F=B.computeFrenetFrames(u,!1);var J=new n;var K=new n;var Q=new n}G||(W=N=A=0);var O;y=a.extractPoints(y);a=y.shape;var L=y.holes;if(!Ya.isClockWise(a)){a=a.reverse();var E=0;for(O=L.length;E<O;E++){var I=L[E];Ya.isClockWise(I)&&(L[E]=I.reverse())}}var R=Ya.triangulateShape(a,L),T=a;E=0;for(O=L.length;E<O;E++)I=L[E],a=a.concat(I);var S,X=a.length,V,ca=R.length;y=[];var M=0;var U=T.length;var fa=U-1;for(S=M+1;M<U;M++,fa++,S++)fa===U&&(fa=0),S===U&&(S=0),y[M]=g(T[M],T[fa],T[S]);B=[];var ea=
y.concat();E=0;for(O=L.length;E<O;E++){I=L[E];var ba=[];M=0;U=I.length;fa=U-1;for(S=M+1;M<U;M++,fa++,S++)fa===U&&(fa=0),S===U&&(S=0),ba[M]=g(I[M],I[fa],I[S]);B.push(ba);ea=ea.concat(ba)}for(fa=0;fa<A;fa++){U=fa/A;var da=N*Math.cos(U*Math.PI/2);S=W*Math.sin(U*Math.PI/2);M=0;for(U=T.length;M<U;M++){var Z=c(T[M],y[M],S);k(Z.x,Z.y,-da)}E=0;for(O=L.length;E<O;E++)for(I=L[E],ba=B[E],M=0,U=I.length;M<U;M++)Z=c(I[M],ba[M],S),k(Z.x,Z.y,-da)}S=W;for(M=0;M<X;M++)Z=G?c(a[M],ea[M],S):a[M],D?(K.copy(F.normals[0]).multiplyScalar(Z.x),
J.copy(F.binormals[0]).multiplyScalar(Z.y),Q.copy(Y[0]).add(K).add(J),k(Q.x,Q.y,Q.z)):k(Z.x,Z.y,0);for(U=1;U<=u;U++)for(M=0;M<X;M++)Z=G?c(a[M],ea[M],S):a[M],D?(K.copy(F.normals[U]).multiplyScalar(Z.x),J.copy(F.binormals[U]).multiplyScalar(Z.y),Q.copy(Y[U]).add(K).add(J),k(Q.x,Q.y,Q.z)):k(Z.x,Z.y,H/u*U);for(fa=A-1;0<=fa;fa--){U=fa/A;da=N*Math.cos(U*Math.PI/2);S=W*Math.sin(U*Math.PI/2);M=0;for(U=T.length;M<U;M++)Z=c(T[M],y[M],S),k(Z.x,Z.y,H+da);E=0;for(O=L.length;E<O;E++)for(I=L[E],ba=B[E],M=0,U=I.length;M<
U;M++)Z=c(I[M],ba[M],S),D?k(Z.x,Z.y+Y[u-1].y,Y[u-1].x+da):k(Z.x,Z.y,H+da)}(function(){var a=e.length/3;if(G){var b=0*X;for(M=0;M<ca;M++)V=R[M],l(V[2]+b,V[1]+b,V[0]+b);b=X*(u+2*A);for(M=0;M<ca;M++)V=R[M],l(V[0]+b,V[1]+b,V[2]+b)}else{for(M=0;M<ca;M++)V=R[M],l(V[2],V[1],V[0]);for(M=0;M<ca;M++)V=R[M],l(V[0]+X*u,V[1]+X*u,V[2]+X*u)}d.addGroup(a,e.length/3-a,0)})();(function(){var a=e.length/3,b=0;h(T,b);b+=T.length;E=0;for(O=L.length;E<O;E++)I=L[E],h(I,b),b+=I.length;d.addGroup(a,e.length/3-a,1)})()}D.call(this);
this.type="ExtrudeBufferGeometry";this.parameters={shapes:a,options:b};a=Array.isArray(a)?a:[a];for(var d=this,e=[],f=[],g=0,h=a.length;g<h;g++)c(a[g]);this.addAttribute("position",new B(e,3));this.addAttribute("uv",new B(f,2));this.computeVertexNormals()}function rf(a,b,c){c.shapes=[];if(Array.isArray(a))for(var d=0,e=a.length;d<e;d++)c.shapes.push(a[d].uuid);else c.shapes.push(a.uuid);void 0!==b.extrudePath&&(c.options.extrudePath=b.extrudePath.toJSON());return c}function Xc(a,b){Q.call(this);this.type=
"TextGeometry";this.parameters={text:a,parameters:b};this.fromBufferGeometry(new cc(a,b));this.mergeVertices()}function cc(a,b){b=b||{};var c=b.font;if(!c||!c.isFont)return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."),new Q;a=c.generateShapes(a,b.size);b.depth=void 0!==b.height?b.height:50;void 0===b.bevelThickness&&(b.bevelThickness=10);void 0===b.bevelSize&&(b.bevelSize=8);void 0===b.bevelEnabled&&(b.bevelEnabled=!1);Sa.call(this,a,b);this.type="TextBufferGeometry"}
function Yc(a,b,c,d,e,f,g){Q.call(this);this.type="SphereGeometry";this.parameters={radius:a,widthSegments:b,heightSegments:c,phiStart:d,phiLength:e,thetaStart:f,thetaLength:g};this.fromBufferGeometry(new vb(a,b,c,d,e,f,g));this.mergeVertices()}function vb(a,b,c,d,e,f,g){D.call(this);this.type="SphereBufferGeometry";this.parameters={radius:a,widthSegments:b,heightSegments:c,phiStart:d,phiLength:e,thetaStart:f,thetaLength:g};a=a||1;b=Math.max(3,Math.floor(b)||8);c=Math.max(2,Math.floor(c)||6);d=void 0!==
d?d:0;e=void 0!==e?e:2*Math.PI;f=void 0!==f?f:0;g=void 0!==g?g:Math.PI;var h=f+g,k,m,q=0,p=[],l=new n,x=new n,t=[],v=[],w=[],y=[];for(m=0;m<=c;m++){var u=[],H=m/c;for(k=0;k<=b;k++){var G=k/b;l.x=-a*Math.cos(d+G*e)*Math.sin(f+H*g);l.y=a*Math.cos(f+H*g);l.z=a*Math.sin(d+G*e)*Math.sin(f+H*g);v.push(l.x,l.y,l.z);x.set(l.x,l.y,l.z).normalize();w.push(x.x,x.y,x.z);y.push(G,1-H);u.push(q++)}p.push(u)}for(m=0;m<c;m++)for(k=0;k<b;k++)a=p[m][k+1],d=p[m][k],e=p[m+1][k],g=p[m+1][k+1],(0!==m||0<f)&&t.push(a,d,
g),(m!==c-1||h<Math.PI)&&t.push(d,e,g);this.setIndex(t);this.addAttribute("position",new B(v,3));this.addAttribute("normal",new B(w,3));this.addAttribute("uv",new B(y,2))}function Zc(a,b,c,d,e,f){Q.call(this);this.type="RingGeometry";this.parameters={innerRadius:a,outerRadius:b,thetaSegments:c,phiSegments:d,thetaStart:e,thetaLength:f};this.fromBufferGeometry(new dc(a,b,c,d,e,f));this.mergeVertices()}function dc(a,b,c,d,e,f){D.call(this);this.type="RingBufferGeometry";this.parameters={innerRadius:a,
outerRadius:b,thetaSegments:c,phiSegments:d,thetaStart:e,thetaLength:f};a=a||.5;b=b||1;e=void 0!==e?e:0;f=void 0!==f?f:2*Math.PI;c=void 0!==c?Math.max(3,c):8;d=void 0!==d?Math.max(1,d):1;var g=[],h=[],k=[],m=[],q=a,p=(b-a)/d,l=new n,x=new z,t,v;for(t=0;t<=d;t++){for(v=0;v<=c;v++)a=e+v/c*f,l.x=q*Math.cos(a),l.y=q*Math.sin(a),h.push(l.x,l.y,l.z),k.push(0,0,1),x.x=(l.x/b+1)/2,x.y=(l.y/b+1)/2,m.push(x.x,x.y);q+=p}for(t=0;t<d;t++)for(b=t*(c+1),v=0;v<c;v++)a=v+b,e=a+c+1,f=a+c+2,q=a+1,g.push(a,e,q),g.push(e,
f,q);this.setIndex(g);this.addAttribute("position",new B(h,3));this.addAttribute("normal",new B(k,3));this.addAttribute("uv",new B(m,2))}function $c(a,b,c,d){Q.call(this);this.type="LatheGeometry";this.parameters={points:a,segments:b,phiStart:c,phiLength:d};this.fromBufferGeometry(new ec(a,b,c,d));this.mergeVertices()}function ec(a,b,c,d){D.call(this);this.type="LatheBufferGeometry";this.parameters={points:a,segments:b,phiStart:c,phiLength:d};b=Math.floor(b)||12;c=c||0;d=d||2*Math.PI;d=R.clamp(d,
0,2*Math.PI);var e=[],f=[],g=[],h=1/b,k=new n,m=new z,q;for(q=0;q<=b;q++){var p=c+q*h*d;var l=Math.sin(p),x=Math.cos(p);for(p=0;p<=a.length-1;p++)k.x=a[p].x*l,k.y=a[p].y,k.z=a[p].x*x,f.push(k.x,k.y,k.z),m.x=q/b,m.y=p/(a.length-1),g.push(m.x,m.y)}for(q=0;q<b;q++)for(p=0;p<a.length-1;p++)c=p+q*a.length,h=c+a.length,k=c+a.length+1,m=c+1,e.push(c,h,m),e.push(h,k,m);this.setIndex(e);this.addAttribute("position",new B(f,3));this.addAttribute("uv",new B(g,2));this.computeVertexNormals();if(d===2*Math.PI)for(d=
this.attributes.normal.array,e=new n,f=new n,g=new n,c=b*a.length*3,p=q=0;q<a.length;q++,p+=3)e.x=d[p+0],e.y=d[p+1],e.z=d[p+2],f.x=d[c+p+0],f.y=d[c+p+1],f.z=d[c+p+2],g.addVectors(e,f).normalize(),d[p+0]=d[c+p+0]=g.x,d[p+1]=d[c+p+1]=g.y,d[p+2]=d[c+p+2]=g.z}function wb(a,b){Q.call(this);this.type="ShapeGeometry";"object"===typeof b&&(console.warn("THREE.ShapeGeometry: Options parameter has been removed."),b=b.curveSegments);this.parameters={shapes:a,curveSegments:b};this.fromBufferGeometry(new xb(a,
b));this.mergeVertices()}function xb(a,b){function c(a){var c,h=e.length/3;a=a.extractPoints(b);var m=a.shape,q=a.holes;if(!1===Ya.isClockWise(m))for(m=m.reverse(),a=0,c=q.length;a<c;a++){var l=q[a];!0===Ya.isClockWise(l)&&(q[a]=l.reverse())}var n=Ya.triangulateShape(m,q);a=0;for(c=q.length;a<c;a++)l=q[a],m=m.concat(l);a=0;for(c=m.length;a<c;a++)l=m[a],e.push(l.x,l.y,0),f.push(0,0,1),g.push(l.x,l.y);a=0;for(c=n.length;a<c;a++)m=n[a],d.push(m[0]+h,m[1]+h,m[2]+h),k+=3}D.call(this);this.type="ShapeBufferGeometry";
this.parameters={shapes:a,curveSegments:b};b=b||12;var d=[],e=[],f=[],g=[],h=0,k=0;if(!1===Array.isArray(a))c(a);else for(var m=0;m<a.length;m++)c(a[m]),this.addGroup(h,k,m),h+=k,k=0;this.setIndex(d);this.addAttribute("position",new B(e,3));this.addAttribute("normal",new B(f,3));this.addAttribute("uv",new B(g,2))}function sf(a,b){b.shapes=[];if(Array.isArray(a))for(var c=0,d=a.length;c<d;c++)b.shapes.push(a[c].uuid);else b.shapes.push(a.uuid);return b}function fc(a,b){D.call(this);this.type="EdgesGeometry";
this.parameters={thresholdAngle:b};var c=[];b=Math.cos(R.DEG2RAD*(void 0!==b?b:1));var d=[0,0],e={},f=["a","b","c"];if(a.isBufferGeometry){var g=new Q;g.fromBufferGeometry(a)}else g=a.clone();g.mergeVertices();g.computeFaceNormals();a=g.vertices;g=g.faces;for(var h=0,k=g.length;h<k;h++)for(var m=g[h],q=0;3>q;q++){var l=m[f[q]];var r=m[f[(q+1)%3]];d[0]=Math.min(l,r);d[1]=Math.max(l,r);l=d[0]+","+d[1];void 0===e[l]?e[l]={index1:d[0],index2:d[1],face1:h,face2:void 0}:e[l].face2=h}for(l in e)if(d=e[l],
void 0===d.face2||g[d.face1].normal.dot(g[d.face2].normal)<=b)f=a[d.index1],c.push(f.x,f.y,f.z),f=a[d.index2],c.push(f.x,f.y,f.z);this.addAttribute("position",new B(c,3))}function yb(a,b,c,d,e,f,g,h){Q.call(this);this.type="CylinderGeometry";this.parameters={radiusTop:a,radiusBottom:b,height:c,radialSegments:d,heightSegments:e,openEnded:f,thetaStart:g,thetaLength:h};this.fromBufferGeometry(new Za(a,b,c,d,e,f,g,h));this.mergeVertices()}function Za(a,b,c,d,e,f,g,h){function k(c){var e,f=new z,k=new n,
p=0,u=!0===c?a:b,v=!0===c?1:-1;var B=t;for(e=1;e<=d;e++)l.push(0,w*v,0),r.push(0,v,0),x.push(.5,.5),t++;var C=t;for(e=0;e<=d;e++){var D=e/d*h+g,E=Math.cos(D);D=Math.sin(D);k.x=u*D;k.y=w*v;k.z=u*E;l.push(k.x,k.y,k.z);r.push(0,v,0);f.x=.5*E+.5;f.y=.5*D*v+.5;x.push(f.x,f.y);t++}for(e=0;e<d;e++)f=B+e,k=C+e,!0===c?q.push(k,k+1,f):q.push(k+1,k,f),p+=3;m.addGroup(y,p,!0===c?1:2);y+=p}D.call(this);this.type="CylinderBufferGeometry";this.parameters={radiusTop:a,radiusBottom:b,height:c,radialSegments:d,heightSegments:e,
openEnded:f,thetaStart:g,thetaLength:h};var m=this;a=void 0!==a?a:1;b=void 0!==b?b:1;c=c||1;d=Math.floor(d)||8;e=Math.floor(e)||1;f=void 0!==f?f:!1;g=void 0!==g?g:0;h=void 0!==h?h:2*Math.PI;var q=[],l=[],r=[],x=[],t=0,v=[],w=c/2,y=0;(function(){var f,k,p=new n,N=new n,z=0,A=(b-a)/c;for(k=0;k<=e;k++){var B=[],D=k/e,C=D*(b-a)+a;for(f=0;f<=d;f++){var E=f/d,F=E*h+g,J=Math.sin(F);F=Math.cos(F);N.x=C*J;N.y=-D*c+w;N.z=C*F;l.push(N.x,N.y,N.z);p.set(J,A,F).normalize();r.push(p.x,p.y,p.z);x.push(E,1-D);B.push(t++)}v.push(B)}for(f=
0;f<d;f++)for(k=0;k<e;k++)p=v[k+1][f],N=v[k+1][f+1],A=v[k][f+1],q.push(v[k][f],p,A),q.push(p,N,A),z+=6;m.addGroup(y,z,0);y+=z})();!1===f&&(0<a&&k(!0),0<b&&k(!1));this.setIndex(q);this.addAttribute("position",new B(l,3));this.addAttribute("normal",new B(r,3));this.addAttribute("uv",new B(x,2))}function ad(a,b,c,d,e,f,g){yb.call(this,0,a,b,c,d,e,f,g);this.type="ConeGeometry";this.parameters={radius:a,height:b,radialSegments:c,heightSegments:d,openEnded:e,thetaStart:f,thetaLength:g}}function bd(a,b,
c,d,e,f,g){Za.call(this,0,a,b,c,d,e,f,g);this.type="ConeBufferGeometry";this.parameters={radius:a,height:b,radialSegments:c,heightSegments:d,openEnded:e,thetaStart:f,thetaLength:g}}function cd(a,b,c,d){Q.call(this);this.type="CircleGeometry";this.parameters={radius:a,segments:b,thetaStart:c,thetaLength:d};this.fromBufferGeometry(new gc(a,b,c,d));this.mergeVertices()}function gc(a,b,c,d){D.call(this);this.type="CircleBufferGeometry";this.parameters={radius:a,segments:b,thetaStart:c,thetaLength:d};
a=a||1;b=void 0!==b?Math.max(3,b):8;c=void 0!==c?c:0;d=void 0!==d?d:2*Math.PI;var e=[],f=[],g=[],h=[],k,m=new n,q=new z;f.push(0,0,0);g.push(0,0,1);h.push(.5,.5);var l=0;for(k=3;l<=b;l++,k+=3){var r=c+l/b*d;m.x=a*Math.cos(r);m.y=a*Math.sin(r);f.push(m.x,m.y,m.z);g.push(0,0,1);q.x=(f[k]/a+1)/2;q.y=(f[k+1]/a+1)/2;h.push(q.x,q.y)}for(k=1;k<=b;k++)e.push(k,k+1,0);this.setIndex(e);this.addAttribute("position",new B(f,3));this.addAttribute("normal",new B(g,3));this.addAttribute("uv",new B(h,2))}function zb(a){L.call(this);
this.type="ShadowMaterial";this.color=new J(0);this.transparent=!0;this.setValues(a)}function hc(a){Ba.call(this,a);this.type="RawShaderMaterial"}function Ta(a){L.call(this);this.defines={STANDARD:""};this.type="MeshStandardMaterial";this.color=new J(16777215);this.metalness=this.roughness=.5;this.lightMap=this.map=null;this.lightMapIntensity=1;this.aoMap=null;this.aoMapIntensity=1;this.emissive=new J(0);this.emissiveIntensity=1;this.bumpMap=this.emissiveMap=null;this.bumpScale=1;this.normalMap=null;
this.normalMapType=0;this.normalScale=new z(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.envMap=this.alphaMap=this.metalnessMap=this.roughnessMap=null;this.envMapIntensity=1;this.refractionRatio=.98;this.wireframe=!1;this.wireframeLinewidth=1;this.wireframeLinejoin=this.wireframeLinecap="round";this.morphNormals=this.morphTargets=this.skinning=!1;this.setValues(a)}function Ab(a){Ta.call(this);this.defines={PHYSICAL:""};this.type="MeshPhysicalMaterial";this.reflectivity=
.5;this.clearCoatRoughness=this.clearCoat=0;this.setValues(a)}function Ga(a){L.call(this);this.type="MeshPhongMaterial";this.color=new J(16777215);this.specular=new J(1118481);this.shininess=30;this.lightMap=this.map=null;this.lightMapIntensity=1;this.aoMap=null;this.aoMapIntensity=1;this.emissive=new J(0);this.emissiveIntensity=1;this.bumpMap=this.emissiveMap=null;this.bumpScale=1;this.normalMap=null;this.normalMapType=0;this.normalScale=new z(1,1);this.displacementMap=null;this.displacementScale=
1;this.displacementBias=0;this.envMap=this.alphaMap=this.specularMap=null;this.combine=0;this.reflectivity=1;this.refractionRatio=.98;this.wireframe=!1;this.wireframeLinewidth=1;this.wireframeLinejoin=this.wireframeLinecap="round";this.morphNormals=this.morphTargets=this.skinning=!1;this.setValues(a)}function Bb(a){Ga.call(this);this.defines={TOON:""};this.type="MeshToonMaterial";this.gradientMap=null;this.setValues(a)}function Cb(a){L.call(this);this.type="MeshNormalMaterial";this.bumpMap=null;this.bumpScale=
1;this.normalMap=null;this.normalMapType=0;this.normalScale=new z(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.wireframe=!1;this.wireframeLinewidth=1;this.morphNormals=this.morphTargets=this.skinning=this.lights=this.fog=!1;this.setValues(a)}function Db(a){L.call(this);this.type="MeshLambertMaterial";this.color=new J(16777215);this.lightMap=this.map=null;this.lightMapIntensity=1;this.aoMap=null;this.aoMapIntensity=1;this.emissive=new J(0);this.emissiveIntensity=
1;this.envMap=this.alphaMap=this.specularMap=this.emissiveMap=null;this.combine=0;this.reflectivity=1;this.refractionRatio=.98;this.wireframe=!1;this.wireframeLinewidth=1;this.wireframeLinejoin=this.wireframeLinecap="round";this.morphNormals=this.morphTargets=this.skinning=!1;this.setValues(a)}function Eb(a){L.call(this);this.defines={MATCAP:""};this.type="MeshMatcapMaterial";this.color=new J(16777215);this.bumpMap=this.map=this.matcap=null;this.bumpScale=1;this.normalMap=null;this.normalMapType=
0;this.normalScale=new z(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.alphaMap=null;this.lights=this.morphNormals=this.morphTargets=this.skinning=!1;this.setValues(a)}function Fb(a){T.call(this);this.type="LineDashedMaterial";this.scale=1;this.dashSize=3;this.gapSize=1;this.setValues(a)}function ya(a,b,c,d){this.parameterPositions=a;this._cachedIndex=0;this.resultBuffer=void 0!==d?d:new b.constructor(c);this.sampleValues=b;this.valueSize=c}function Bd(a,b,c,
d){ya.call(this,a,b,c,d);this._offsetNext=this._weightNext=this._offsetPrev=this._weightPrev=-0}function dd(a,b,c,d){ya.call(this,a,b,c,d)}function Cd(a,b,c,d){ya.call(this,a,b,c,d)}function qa(a,b,c,d){if(void 0===a)throw Error("THREE.KeyframeTrack: track name is undefined");if(void 0===b||0===b.length)throw Error("THREE.KeyframeTrack: no keyframes in track named "+a);this.name=a;this.times=ra.convertArray(b,this.TimeBufferType);this.values=ra.convertArray(c,this.ValueBufferType);this.setInterpolation(d||
this.DefaultInterpolation)}function Dd(a,b,c){qa.call(this,a,b,c)}function Ed(a,b,c,d){qa.call(this,a,b,c,d)}function ic(a,b,c,d){qa.call(this,a,b,c,d)}function Fd(a,b,c,d){ya.call(this,a,b,c,d)}function ed(a,b,c,d){qa.call(this,a,b,c,d)}function Gd(a,b,c,d){qa.call(this,a,b,c,d)}function jc(a,b,c,d){qa.call(this,a,b,c,d)}function Ha(a,b,c){this.name=a;this.tracks=c;this.duration=void 0!==b?b:-1;this.uuid=R.generateUUID();0>this.duration&&this.resetDuration()}function Zg(a){switch(a.toLowerCase()){case "scalar":case "double":case "float":case "number":case "integer":return ic;
case "vector":case "vector2":case "vector3":case "vector4":return jc;case "color":return Ed;case "quaternion":return ed;case "bool":case "boolean":return Dd;case "string":return Gd}throw Error("THREE.KeyframeTrack: Unsupported typeName: "+a);}function $g(a){if(void 0===a.type)throw Error("THREE.KeyframeTrack: track type undefined, can not parse");var b=Zg(a.type);if(void 0===a.times){var c=[],d=[];ra.flattenJSON(a.keys,c,d,"value");a.times=c;a.values=d}return void 0!==b.parse?b.parse(a):new b(a.name,
a.times,a.values,a.interpolation)}function ge(a,b,c){var d=this,e=!1,f=0,g=0,h=void 0;this.onStart=void 0;this.onLoad=a;this.onProgress=b;this.onError=c;this.itemStart=function(a){g++;if(!1===e&&void 0!==d.onStart)d.onStart(a,f,g);e=!0};this.itemEnd=function(a){f++;if(void 0!==d.onProgress)d.onProgress(a,f,g);if(f===g&&(e=!1,void 0!==d.onLoad))d.onLoad()};this.itemError=function(a){if(void 0!==d.onError)d.onError(a)};this.resolveURL=function(a){return h?h(a):a};this.setURLModifier=function(a){h=a;
return this}}function Ia(a){this.manager=void 0!==a?a:za}function tf(a){this.manager=void 0!==a?a:za}function uf(a){this.manager=void 0!==a?a:za;this._parser=null}function he(a){this.manager=void 0!==a?a:za;this._parser=null}function fd(a){this.manager=void 0!==a?a:za}function ie(a){this.manager=void 0!==a?a:za}function Hd(a){this.manager=void 0!==a?a:za}function K(){this.type="Curve";this.arcLengthDivisions=200}function va(a,b,c,d,e,f,g,h){K.call(this);this.type="EllipseCurve";this.aX=a||0;this.aY=
b||0;this.xRadius=c||1;this.yRadius=d||1;this.aStartAngle=e||0;this.aEndAngle=f||2*Math.PI;this.aClockwise=g||!1;this.aRotation=h||0}function kc(a,b,c,d,e,f){va.call(this,a,b,c,c,d,e,f);this.type="ArcCurve"}function je(){var a=0,b=0,c=0,d=0;return{initCatmullRom:function(e,f,g,h,k){e=k*(g-e);h=k*(h-f);a=f;b=e;c=-3*f+3*g-2*e-h;d=2*f-2*g+e+h},initNonuniformCatmullRom:function(e,f,g,h,k,m,q){e=((f-e)/k-(g-e)/(k+m)+(g-f)/m)*m;h=((g-f)/m-(h-f)/(m+q)+(h-g)/q)*m;a=f;b=e;c=-3*f+3*g-2*e-h;d=2*f-2*g+e+h},calc:function(e){var f=
e*e;return a+b*e+c*f+d*f*e}}}function ta(a,b,c,d){K.call(this);this.type="CatmullRomCurve3";this.points=a||[];this.closed=b||!1;this.curveType=c||"centripetal";this.tension=d||.5}function vf(a,b,c,d,e){b=.5*(d-b);e=.5*(e-c);var f=a*a;return(2*c-2*d+b+e)*a*f+(-3*c+3*d-2*b-e)*f+b*a+c}function gd(a,b,c,d){var e=1-a;return e*e*b+2*(1-a)*a*c+a*a*d}function hd(a,b,c,d,e){var f=1-a,g=1-a;return f*f*f*b+3*g*g*a*c+3*(1-a)*a*a*d+a*a*a*e}function Ja(a,b,c,d){K.call(this);this.type="CubicBezierCurve";this.v0=
a||new z;this.v1=b||new z;this.v2=c||new z;this.v3=d||new z}function Ua(a,b,c,d){K.call(this);this.type="CubicBezierCurve3";this.v0=a||new n;this.v1=b||new n;this.v2=c||new n;this.v3=d||new n}function Aa(a,b){K.call(this);this.type="LineCurve";this.v1=a||new z;this.v2=b||new z}function Ka(a,b){K.call(this);this.type="LineCurve3";this.v1=a||new n;this.v2=b||new n}function La(a,b,c){K.call(this);this.type="QuadraticBezierCurve";this.v0=a||new z;this.v1=b||new z;this.v2=c||new z}function Va(a,b,c){K.call(this);
this.type="QuadraticBezierCurve3";this.v0=a||new n;this.v1=b||new n;this.v2=c||new n}function Ma(a){K.call(this);this.type="SplineCurve";this.points=a||[]}function $a(){K.call(this);this.type="CurvePath";this.curves=[];this.autoClose=!1}function Na(a){$a.call(this);this.type="Path";this.currentPoint=new z;a&&this.setFromPoints(a)}function hb(a){Na.call(this,a);this.uuid=R.generateUUID();this.type="Shape";this.holes=[]}function ba(a,b){C.call(this);this.type="Light";this.color=new J(a);this.intensity=
void 0!==b?b:1;this.receiveShadow=void 0}function Id(a,b,c){ba.call(this,a,c);this.type="HemisphereLight";this.castShadow=void 0;this.position.copy(C.DefaultUp);this.updateMatrix();this.groundColor=new J(b)}function Gb(a){this.camera=a;this.bias=0;this.radius=1;this.mapSize=new z(512,512);this.map=null;this.matrix=new O}function Jd(){Gb.call(this,new V(50,1,.5,500))}function Kd(a,b,c,d,e,f){ba.call(this,a,b);this.type="SpotLight";this.position.copy(C.DefaultUp);this.updateMatrix();this.target=new C;
Object.defineProperty(this,"power",{get:function(){return this.intensity*Math.PI},set:function(a){this.intensity=a/Math.PI}});this.distance=void 0!==c?c:0;this.angle=void 0!==d?d:Math.PI/3;this.penumbra=void 0!==e?e:0;this.decay=void 0!==f?f:1;this.shadow=new Jd}function Ld(a,b,c,d){ba.call(this,a,b);this.type="PointLight";Object.defineProperty(this,"power",{get:function(){return 4*this.intensity*Math.PI},set:function(a){this.intensity=a/(4*Math.PI)}});this.distance=void 0!==c?c:0;this.decay=void 0!==
d?d:1;this.shadow=new Gb(new V(90,1,.5,500))}function id(a,b,c,d,e,f){Ra.call(this);this.type="OrthographicCamera";this.zoom=1;this.view=null;this.left=void 0!==a?a:-1;this.right=void 0!==b?b:1;this.top=void 0!==c?c:1;this.bottom=void 0!==d?d:-1;this.near=void 0!==e?e:.1;this.far=void 0!==f?f:2E3;this.updateProjectionMatrix()}function Md(){Gb.call(this,new id(-5,5,5,-5,.5,500))}function Nd(a,b){ba.call(this,a,b);this.type="DirectionalLight";this.position.copy(C.DefaultUp);this.updateMatrix();this.target=
new C;this.shadow=new Md}function Od(a,b){ba.call(this,a,b);this.type="AmbientLight";this.castShadow=void 0}function Pd(a,b,c,d){ba.call(this,a,b);this.type="RectAreaLight";this.width=void 0!==c?c:10;this.height=void 0!==d?d:10}function Qd(a){this.manager=void 0!==a?a:za;this.textures={}}function ke(a){this.manager=void 0!==a?a:za}function le(a){this.manager=void 0!==a?a:za;this.resourcePath=""}function me(a){"undefined"===typeof createImageBitmap&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
"undefined"===typeof fetch&&console.warn("THREE.ImageBitmapLoader: fetch() not supported.");this.manager=void 0!==a?a:za;this.options=void 0}function ne(){this.type="ShapePath";this.color=new J;this.subPaths=[];this.currentPath=null}function oe(a){this.type="Font";this.data=a}function wf(a){this.manager=void 0!==a?a:za}function jd(){}function pe(a){this.manager=void 0!==a?a:za}function xf(){this.type="StereoCamera";this.aspect=1;this.eyeSep=.064;this.cameraL=new V;this.cameraL.layers.enable(1);this.cameraL.matrixAutoUpdate=
!1;this.cameraR=new V;this.cameraR.layers.enable(2);this.cameraR.matrixAutoUpdate=!1}function kd(a,b,c,d){C.call(this);this.type="CubeCamera";var e=new V(90,1,a,b);e.up.set(0,-1,0);e.lookAt(new n(1,0,0));this.add(e);var f=new V(90,1,a,b);f.up.set(0,-1,0);f.lookAt(new n(-1,0,0));this.add(f);var g=new V(90,1,a,b);g.up.set(0,0,1);g.lookAt(new n(0,1,0));this.add(g);var h=new V(90,1,a,b);h.up.set(0,0,-1);h.lookAt(new n(0,-1,0));this.add(h);var k=new V(90,1,a,b);k.up.set(0,-1,0);k.lookAt(new n(0,0,1));
this.add(k);var m=new V(90,1,a,b);m.up.set(0,-1,0);m.lookAt(new n(0,0,-1));this.add(m);d=d||{format:1022,magFilter:1006,minFilter:1006};this.renderTarget=new Ib(c,c,d);this.renderTarget.texture.name="CubeCamera";this.update=function(a,b){null===this.parent&&this.updateMatrixWorld();var c=this.renderTarget,d=c.texture.generateMipmaps;c.texture.generateMipmaps=!1;c.activeCubeFace=0;a.render(b,e,c);c.activeCubeFace=1;a.render(b,f,c);c.activeCubeFace=2;a.render(b,g,c);c.activeCubeFace=3;a.render(b,h,
c);c.activeCubeFace=4;a.render(b,k,c);c.texture.generateMipmaps=d;c.activeCubeFace=5;a.render(b,m,c);a.setRenderTarget(null)};this.clear=function(a,b,c,d){for(var e=this.renderTarget,f=0;6>f;f++)e.activeCubeFace=f,a.setRenderTarget(e),a.clear(b,c,d);a.setRenderTarget(null)}}function qe(a){this.autoStart=void 0!==a?a:!0;this.elapsedTime=this.oldTime=this.startTime=0;this.running=!1}function re(){C.call(this);this.type="AudioListener";this.context=se.getContext();this.gain=this.context.createGain();
this.gain.connect(this.context.destination);this.filter=null;this.timeDelta=0}function lc(a){C.call(this);this.type="Audio";this.listener=a;this.context=a.context;this.gain=this.context.createGain();this.gain.connect(a.getInput());this.autoplay=!1;this.buffer=null;this.detune=0;this.loop=!1;this.offset=this.startTime=0;this.playbackRate=1;this.isPlaying=!1;this.hasPlaybackControl=!0;this.sourceType="empty";this.filters=[]}function te(a){lc.call(this,a);this.panner=this.context.createPanner();this.panner.connect(this.gain)}
function ue(a,b){this.analyser=a.context.createAnalyser();this.analyser.fftSize=void 0!==b?b:2048;this.data=new Uint8Array(this.analyser.frequencyBinCount);a.getOutput().connect(this.analyser)}function ve(a,b,c){this.binding=a;this.valueSize=c;a=Float64Array;switch(b){case "quaternion":b=this._slerp;break;case "string":case "bool":a=Array;b=this._select;break;default:b=this._lerp}this.buffer=new a(4*c);this._mixBufferRegion=b;this.referenceCount=this.useCount=this.cumulativeWeight=0}function yf(a,
b,c){c=c||oa.parseTrackName(b);this._targetGroup=a;this._bindings=a.subscribe_(b,c)}function oa(a,b,c){this.path=b;this.parsedPath=c||oa.parseTrackName(b);this.node=oa.findNode(a,this.parsedPath.nodeName)||a;this.rootNode=a}function zf(){this.uuid=R.generateUUID();this._objects=Array.prototype.slice.call(arguments);this.nCachedObjects_=0;var a={};this._indicesByUUID=a;for(var b=0,c=arguments.length;b!==c;++b)a[arguments[b].uuid]=b;this._paths=[];this._parsedPaths=[];this._bindings=[];this._bindingsIndicesByPath=
{};var d=this;this.stats={objects:{get total(){return d._objects.length},get inUse(){return this.total-d.nCachedObjects_}},get bindingsPerObject(){return d._bindings.length}}}function Af(a,b,c){this._mixer=a;this._clip=b;this._localRoot=c||null;a=b.tracks;b=a.length;c=Array(b);for(var d={endingStart:2400,endingEnd:2400},e=0;e!==b;++e){var f=a[e].createInterpolant(null);c[e]=f;f.settings=d}this._interpolantSettings=d;this._interpolants=c;this._propertyBindings=Array(b);this._weightInterpolant=this._timeScaleInterpolant=
this._byClipCacheIndex=this._cacheIndex=null;this.loop=2201;this._loopCount=-1;this._startTime=null;this.time=0;this._effectiveWeight=this.weight=this._effectiveTimeScale=this.timeScale=1;this.repetitions=Infinity;this.paused=!1;this.enabled=!0;this.clampWhenFinished=!1;this.zeroSlopeAtEnd=this.zeroSlopeAtStart=!0}function we(a){this._root=a;this._initMemoryManager();this.time=this._accuIndex=0;this.timeScale=1}function Rd(a,b){"string"===typeof a&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),
a=b);this.value=a}function xe(){D.call(this);this.type="InstancedBufferGeometry";this.maxInstancedCount=void 0}function ye(a,b,c){rb.call(this,a,b);this.meshPerAttribute=c||1}function ze(a,b,c,d){"number"===typeof c&&(d=c,c=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."));E.call(this,a,b,c);this.meshPerAttribute=d||1}function Bf(a,b,c,d){this.ray=new qb(a,b);this.near=c||0;this.far=d||Infinity;this.params={Mesh:{},Line:{},LOD:{},Points:{threshold:1},
Sprite:{}};Object.defineProperties(this.params,{PointCloud:{get:function(){console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points.");return this.Points}}})}function Cf(a,b){return a.distance-b.distance}function Ae(a,b,c,d){if(!1!==a.visible&&(a.raycast(b,c),!0===d)){a=a.children;d=0;for(var e=a.length;d<e;d++)Ae(a[d],b,c,!0)}}function Df(a,b,c){this.radius=void 0!==a?a:1;this.phi=void 0!==b?b:0;this.theta=void 0!==c?c:0;return this}function Ef(a,b,c){this.radius=void 0!==
a?a:1;this.theta=void 0!==b?b:0;this.y=void 0!==c?c:0;return this}function Be(a,b){this.min=void 0!==a?a:new z(Infinity,Infinity);this.max=void 0!==b?b:new z(-Infinity,-Infinity)}function Ce(a,b){this.start=void 0!==a?a:new n;this.end=void 0!==b?b:new n}function ld(a){C.call(this);this.material=a;this.render=function(){}}function md(a,b,c,d){this.object=a;this.size=void 0!==b?b:1;a=void 0!==c?c:16711680;d=void 0!==d?d:1;b=0;(c=this.object.geometry)&&c.isGeometry?b=3*c.faces.length:c&&c.isBufferGeometry&&
(b=c.attributes.normal.count);c=new D;b=new B(6*b,3);c.addAttribute("position",b);S.call(this,c,new T({color:a,linewidth:d}));this.matrixAutoUpdate=!1;this.update()}function mc(a,b){C.call(this);this.light=a;this.light.updateMatrixWorld();this.matrix=a.matrixWorld;this.matrixAutoUpdate=!1;this.color=b;a=new D;b=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(var c=0,d=1;32>c;c++,d++){var e=c/32*Math.PI*2,f=d/32*Math.PI*2;b.push(Math.cos(e),Math.sin(e),1,Math.cos(f),Math.sin(f),
1)}a.addAttribute("position",new B(b,3));b=new T({fog:!1});this.cone=new S(a,b);this.add(this.cone);this.update()}function Ff(a){var b=[];a&&a.isBone&&b.push(a);for(var c=0;c<a.children.length;c++)b.push.apply(b,Ff(a.children[c]));return b}function nc(a){for(var b=Ff(a),c=new D,d=[],e=[],f=new J(0,0,1),g=new J(0,1,0),h=0;h<b.length;h++){var k=b[h];k.parent&&k.parent.isBone&&(d.push(0,0,0),d.push(0,0,0),e.push(f.r,f.g,f.b),e.push(g.r,g.g,g.b))}c.addAttribute("position",new B(d,3));c.addAttribute("color",
new B(e,3));d=new T({vertexColors:2,depthTest:!1,depthWrite:!1,transparent:!0});S.call(this,c,d);this.root=a;this.bones=b;this.matrix=a.matrixWorld;this.matrixAutoUpdate=!1}function oc(a,b,c){this.light=a;this.light.updateMatrixWorld();this.color=c;a=new vb(b,4,2);b=new Da({wireframe:!0,fog:!1});pa.call(this,a,b);this.matrix=this.light.matrixWorld;this.matrixAutoUpdate=!1;this.update()}function pc(a,b){C.call(this);this.light=a;this.light.updateMatrixWorld();this.matrix=a.matrixWorld;this.matrixAutoUpdate=
!1;this.color=b;a=new T({fog:!1});b=new D;b.addAttribute("position",new E(new Float32Array(15),3));this.line=new ma(b,a);this.add(this.line);this.update()}function qc(a,b,c){C.call(this);this.light=a;this.light.updateMatrixWorld();this.matrix=a.matrixWorld;this.matrixAutoUpdate=!1;this.color=c;a=new sb(b);a.rotateY(.5*Math.PI);this.material=new Da({wireframe:!0,fog:!1});void 0===this.color&&(this.material.vertexColors=2);b=a.getAttribute("position");b=new Float32Array(3*b.count);a.addAttribute("color",
new E(b,3));this.add(new pa(a,this.material));this.update()}function nd(a,b,c,d){a=a||10;b=b||10;c=new J(void 0!==c?c:4473924);d=new J(void 0!==d?d:8947848);var e=b/2,f=a/b,g=a/2;a=[];for(var h=[],k=0,m=0,q=-g;k<=b;k++,q+=f){a.push(-g,0,q,g,0,q);a.push(q,0,-g,q,0,g);var l=k===e?c:d;l.toArray(h,m);m+=3;l.toArray(h,m);m+=3;l.toArray(h,m);m+=3;l.toArray(h,m);m+=3}b=new D;b.addAttribute("position",new B(a,3));b.addAttribute("color",new B(h,3));c=new T({vertexColors:2});S.call(this,b,c)}function Sd(a,
b,c,d,e,f){a=a||10;b=b||16;c=c||8;d=d||64;e=new J(void 0!==e?e:4473924);f=new J(void 0!==f?f:8947848);var g=[],h=[],k;for(k=0;k<=b;k++){var m=k/b*2*Math.PI;var q=Math.sin(m)*a;m=Math.cos(m)*a;g.push(0,0,0);g.push(q,0,m);var l=k&1?e:f;h.push(l.r,l.g,l.b);h.push(l.r,l.g,l.b)}for(k=0;k<=c;k++){l=k&1?e:f;var r=a-a/c*k;for(b=0;b<d;b++)m=b/d*2*Math.PI,q=Math.sin(m)*r,m=Math.cos(m)*r,g.push(q,0,m),h.push(l.r,l.g,l.b),m=(b+1)/d*2*Math.PI,q=Math.sin(m)*r,m=Math.cos(m)*r,g.push(q,0,m),h.push(l.r,l.g,l.b)}a=
new D;a.addAttribute("position",new B(g,3));a.addAttribute("color",new B(h,3));g=new T({vertexColors:2});S.call(this,a,g)}function od(a,b,c,d){this.object=a;this.size=void 0!==b?b:1;a=void 0!==c?c:16776960;d=void 0!==d?d:1;b=0;(c=this.object.geometry)&&c.isGeometry?b=c.faces.length:console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");c=new D;b=new B(6*b,3);c.addAttribute("position",b);S.call(this,c,new T({color:a,linewidth:d}));this.matrixAutoUpdate=
!1;this.update()}function rc(a,b,c){C.call(this);this.light=a;this.light.updateMatrixWorld();this.matrix=a.matrixWorld;this.matrixAutoUpdate=!1;this.color=c;void 0===b&&(b=1);a=new D;a.addAttribute("position",new B([-b,b,0,b,b,0,b,-b,0,-b,-b,0,-b,b,0],3));b=new T({fog:!1});this.lightPlane=new ma(a,b);this.add(this.lightPlane);a=new D;a.addAttribute("position",new B([0,0,0,0,0,1],3));this.targetLine=new ma(a,b);this.add(this.targetLine);this.update()}function pd(a){function b(a,b,d){c(a,d);c(b,d)}
function c(a,b){f.push(0,0,0);g.push(b.r,b.g,b.b);void 0===h[a]&&(h[a]=[]);h[a].push(f.length/3-1)}var d=new D,e=new T({color:16777215,vertexColors:1}),f=[],g=[],h={},k=new J(16755200),m=new J(16711680),q=new J(43775),l=new J(16777215),r=new J(3355443);b("n1","n2",k);b("n2","n4",k);b("n4","n3",k);b("n3","n1",k);b("f1","f2",k);b("f2","f4",k);b("f4","f3",k);b("f3","f1",k);b("n1","f1",k);b("n2","f2",k);b("n3","f3",k);b("n4","f4",k);b("p","n1",m);b("p","n2",m);b("p","n3",m);b("p","n4",m);b("u1","u2",
q);b("u2","u3",q);b("u3","u1",q);b("c","t",l);b("p","c",r);b("cn1","cn2",r);b("cn3","cn4",r);b("cf1","cf2",r);b("cf3","cf4",r);d.addAttribute("position",new B(f,3));d.addAttribute("color",new B(g,3));S.call(this,d,e);this.camera=a;this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix();this.matrix=a.matrixWorld;this.matrixAutoUpdate=!1;this.pointMap=h;this.update()}function ab(a,b){this.object=a;void 0===b&&(b=16776960);a=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,
6,3,7]);var c=new Float32Array(24),d=new D;d.setIndex(new E(a,1));d.addAttribute("position",new E(c,3));S.call(this,d,new T({color:b}));this.matrixAutoUpdate=!1;this.update()}function qd(a,b){this.type="Box3Helper";this.box=a;a=void 0!==b?b:16776960;b=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]);var c=new D;c.setIndex(new E(b,1));c.addAttribute("position",new B([1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],3));S.call(this,c,new T({color:a}));this.geometry.computeBoundingSphere()}
function rd(a,b,c){this.type="PlaneHelper";this.plane=a;this.size=void 0===b?1:b;a=void 0!==c?c:16776960;b=new D;b.addAttribute("position",new B([1,-1,1,-1,1,1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,0,0,1,0,0,0],3));b.computeBoundingSphere();ma.call(this,b,new T({color:a}));b=new D;b.addAttribute("position",new B([1,1,1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,1],3));b.computeBoundingSphere();this.add(new pa(b,new Da({color:a,opacity:.2,transparent:!0,depthWrite:!1})))}function bb(a,b,c,d,e,f){C.call(this);
void 0===a&&(a=new THREE.Vector3(0,0,1));void 0===b&&(b=new THREE.Vector3(0,0,0));void 0===c&&(c=1);void 0===d&&(d=16776960);void 0===e&&(e=.2*c);void 0===f&&(f=.2*e);void 0===Td&&(Td=new D,Td.addAttribute("position",new B([0,0,0,0,1,0],3)),De=new Za(0,.5,1,5,1),De.translate(0,-.5,0));this.position.copy(b);this.line=new ma(Td,new T({color:d}));this.line.matrixAutoUpdate=!1;this.add(this.line);this.cone=new pa(De,new Da({color:d}));this.cone.matrixAutoUpdate=!1;this.add(this.cone);this.setDirection(a);
this.setLength(c,e,f)}function sd(a){a=a||1;var b=[0,0,0,a,0,0,0,0,0,0,a,0,0,0,0,0,0,a];a=new D;a.addAttribute("position",new B(b,3));a.addAttribute("color",new B([1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],3));b=new T({vertexColors:2});S.call(this,a,b)}function Gf(a){console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.");ta.call(this,a);this.type="catmullrom";this.closed=!0}function Hf(a){console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.");
ta.call(this,a);this.type="catmullrom"}function Ee(a){console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.");ta.call(this,a);this.type="catmullrom"}void 0===Number.EPSILON&&(Number.EPSILON=Math.pow(2,-52));void 0===Number.isInteger&&(Number.isInteger=function(a){return"number"===typeof a&&isFinite(a)&&Math.floor(a)===a});void 0===Math.sign&&(Math.sign=function(a){return 0>a?-1:0<a?1:+a});!1==="name"in Function.prototype&&Object.defineProperty(Function.prototype,"name",
{get:function(){return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]}});void 0===Object.assign&&function(){Object.assign=function(a){if(void 0===a||null===a)throw new TypeError("Cannot convert undefined or null to object");for(var b=Object(a),c=1;c<arguments.length;c++){var d=arguments[c];if(void 0!==d&&null!==d)for(var e in d)Object.prototype.hasOwnProperty.call(d,e)&&(b[e]=d[e])}return b}}();Object.assign(ja.prototype,{addEventListener:function(a,b){void 0===this._listeners&&(this._listeners=
{});var c=this._listeners;void 0===c[a]&&(c[a]=[]);-1===c[a].indexOf(b)&&c[a].push(b)},hasEventListener:function(a,b){if(void 0===this._listeners)return!1;var c=this._listeners;return void 0!==c[a]&&-1!==c[a].indexOf(b)},removeEventListener:function(a,b){void 0!==this._listeners&&(a=this._listeners[a],void 0!==a&&(b=a.indexOf(b),-1!==b&&a.splice(b,1)))},dispatchEvent:function(a){if(void 0!==this._listeners){var b=this._listeners[a.type];if(void 0!==b){a.target=this;b=b.slice(0);for(var c=0,d=b.length;c<
d;c++)b[c].call(this,a)}}}});var R={DEG2RAD:Math.PI/180,RAD2DEG:180/Math.PI,generateUUID:function(){for(var a=[],b=0;256>b;b++)a[b]=(16>b?"0":"")+b.toString(16);return function(){var b=4294967295*Math.random()|0,d=4294967295*Math.random()|0,e=4294967295*Math.random()|0,f=4294967295*Math.random()|0;return(a[b&255]+a[b>>8&255]+a[b>>16&255]+a[b>>24&255]+"-"+a[d&255]+a[d>>8&255]+"-"+a[d>>16&15|64]+a[d>>24&255]+"-"+a[e&63|128]+a[e>>8&255]+"-"+a[e>>16&255]+a[e>>24&255]+a[f&255]+a[f>>8&255]+a[f>>16&255]+
a[f>>24&255]).toUpperCase()}}(),clamp:function(a,b,c){return Math.max(b,Math.min(c,a))},euclideanModulo:function(a,b){return(a%b+b)%b},mapLinear:function(a,b,c,d,e){return d+(a-b)*(e-d)/(c-b)},lerp:function(a,b,c){return(1-c)*a+c*b},smoothstep:function(a,b,c){if(a<=b)return 0;if(a>=c)return 1;a=(a-b)/(c-b);return a*a*(3-2*a)},smootherstep:function(a,b,c){if(a<=b)return 0;if(a>=c)return 1;a=(a-b)/(c-b);return a*a*a*(a*(6*a-15)+10)},randInt:function(a,b){return a+Math.floor(Math.random()*(b-a+1))},
randFloat:function(a,b){return a+Math.random()*(b-a)},randFloatSpread:function(a){return a*(.5-Math.random())},degToRad:function(a){return a*R.DEG2RAD},radToDeg:function(a){return a*R.RAD2DEG},isPowerOfTwo:function(a){return 0===(a&a-1)&&0!==a},ceilPowerOfTwo:function(a){return Math.pow(2,Math.ceil(Math.log(a)/Math.LN2))},floorPowerOfTwo:function(a){return Math.pow(2,Math.floor(Math.log(a)/Math.LN2))}};Object.defineProperties(z.prototype,{width:{get:function(){return this.x},set:function(a){this.x=
a}},height:{get:function(){return this.y},set:function(a){this.y=a}}});Object.assign(z.prototype,{isVector2:!0,set:function(a,b){this.x=a;this.y=b;return this},setScalar:function(a){this.y=this.x=a;return this},setX:function(a){this.x=a;return this},setY:function(a){this.y=a;return this},setComponent:function(a,b){switch(a){case 0:this.x=b;break;case 1:this.y=b;break;default:throw Error("index is out of range: "+a);}return this},getComponent:function(a){switch(a){case 0:return this.x;case 1:return this.y;
default:throw Error("index is out of range: "+a);}},clone:function(){return new this.constructor(this.x,this.y)},copy:function(a){this.x=a.x;this.y=a.y;return this},add:function(a,b){if(void 0!==b)return console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(a,b);this.x+=a.x;this.y+=a.y;return this},addScalar:function(a){this.x+=a;this.y+=a;return this},addVectors:function(a,b){this.x=a.x+b.x;this.y=a.y+b.y;return this},addScaledVector:function(a,
b){this.x+=a.x*b;this.y+=a.y*b;return this},sub:function(a,b){if(void 0!==b)return console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(a,b);this.x-=a.x;this.y-=a.y;return this},subScalar:function(a){this.x-=a;this.y-=a;return this},subVectors:function(a,b){this.x=a.x-b.x;this.y=a.y-b.y;return this},multiply:function(a){this.x*=a.x;this.y*=a.y;return this},multiplyScalar:function(a){this.x*=a;this.y*=a;return this},divide:function(a){this.x/=
a.x;this.y/=a.y;return this},divideScalar:function(a){return this.multiplyScalar(1/a)},applyMatrix3:function(a){var b=this.x,c=this.y;a=a.elements;this.x=a[0]*b+a[3]*c+a[6];this.y=a[1]*b+a[4]*c+a[7];return this},min:function(a){this.x=Math.min(this.x,a.x);this.y=Math.min(this.y,a.y);return this},max:function(a){this.x=Math.max(this.x,a.x);this.y=Math.max(this.y,a.y);return this},clamp:function(a,b){this.x=Math.max(a.x,Math.min(b.x,this.x));this.y=Math.max(a.y,Math.min(b.y,this.y));return this},clampScalar:function(){var a=
new z,b=new z;return function(c,d){a.set(c,c);b.set(d,d);return this.clamp(a,b)}}(),clampLength:function(a,b){var c=this.length();return this.divideScalar(c||1).multiplyScalar(Math.max(a,Math.min(b,c)))},floor:function(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);return this},ceil:function(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);return this},round:function(){this.x=Math.round(this.x);this.y=Math.round(this.y);return this},roundToZero:function(){this.x=0>this.x?Math.ceil(this.x):
Math.floor(this.x);this.y=0>this.y?Math.ceil(this.y):Math.floor(this.y);return this},negate:function(){this.x=-this.x;this.y=-this.y;return this},dot:function(a){return this.x*a.x+this.y*a.y},cross:function(a){return this.x*a.y-this.y*a.x},lengthSq:function(){return this.x*this.x+this.y*this.y},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y)},manhattanLength:function(){return Math.abs(this.x)+Math.abs(this.y)},normalize:function(){return this.divideScalar(this.length()||1)},angle:function(){var a=
Math.atan2(this.y,this.x);0>a&&(a+=2*Math.PI);return a},distanceTo:function(a){return Math.sqrt(this.distanceToSquared(a))},distanceToSquared:function(a){var b=this.x-a.x;a=this.y-a.y;return b*b+a*a},manhattanDistanceTo:function(a){return Math.abs(this.x-a.x)+Math.abs(this.y-a.y)},setLength:function(a){return this.normalize().multiplyScalar(a)},lerp:function(a,b){this.x+=(a.x-this.x)*b;this.y+=(a.y-this.y)*b;return this},lerpVectors:function(a,b,c){return this.subVectors(b,a).multiplyScalar(c).add(a)},
equals:function(a){return a.x===this.x&&a.y===this.y},fromArray:function(a,b){void 0===b&&(b=0);this.x=a[b];this.y=a[b+1];return this},toArray:function(a,b){void 0===a&&(a=[]);void 0===b&&(b=0);a[b]=this.x;a[b+1]=this.y;return a},fromBufferAttribute:function(a,b,c){void 0!==c&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");this.x=a.getX(b);this.y=a.getY(b);return this},rotateAround:function(a,b){var c=Math.cos(b);b=Math.sin(b);var d=this.x-a.x,e=this.y-a.y;this.x=
d*c-e*b+a.x;this.y=d*b+e*c+a.y;return this}});Object.assign(O.prototype,{isMatrix4:!0,set:function(a,b,c,d,e,f,g,h,k,m,l,p,r,n,t,v){var q=this.elements;q[0]=a;q[4]=b;q[8]=c;q[12]=d;q[1]=e;q[5]=f;q[9]=g;q[13]=h;q[2]=k;q[6]=m;q[10]=l;q[14]=p;q[3]=r;q[7]=n;q[11]=t;q[15]=v;return this},identity:function(){this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return this},clone:function(){return(new O).fromArray(this.elements)},copy:function(a){var b=this.elements;a=a.elements;b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];
b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];b[9]=a[9];b[10]=a[10];b[11]=a[11];b[12]=a[12];b[13]=a[13];b[14]=a[14];b[15]=a[15];return this},copyPosition:function(a){var b=this.elements;a=a.elements;b[12]=a[12];b[13]=a[13];b[14]=a[14];return this},extractBasis:function(a,b,c){a.setFromMatrixColumn(this,0);b.setFromMatrixColumn(this,1);c.setFromMatrixColumn(this,2);return this},makeBasis:function(a,b,c){this.set(a.x,b.x,c.x,0,a.y,b.y,c.y,0,a.z,b.z,c.z,0,0,0,0,1);return this},extractRotation:function(){var a=
new n;return function(b){var c=this.elements,d=b.elements,e=1/a.setFromMatrixColumn(b,0).length(),f=1/a.setFromMatrixColumn(b,1).length();b=1/a.setFromMatrixColumn(b,2).length();c[0]=d[0]*e;c[1]=d[1]*e;c[2]=d[2]*e;c[3]=0;c[4]=d[4]*f;c[5]=d[5]*f;c[6]=d[6]*f;c[7]=0;c[8]=d[8]*b;c[9]=d[9]*b;c[10]=d[10]*b;c[11]=0;c[12]=0;c[13]=0;c[14]=0;c[15]=1;return this}}(),makeRotationFromEuler:function(a){a&&a.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
var b=this.elements,c=a.x,d=a.y,e=a.z,f=Math.cos(c);c=Math.sin(c);var g=Math.cos(d);d=Math.sin(d);var h=Math.cos(e);e=Math.sin(e);if("XYZ"===a.order){a=f*h;var k=f*e,m=c*h,q=c*e;b[0]=g*h;b[4]=-g*e;b[8]=d;b[1]=k+m*d;b[5]=a-q*d;b[9]=-c*g;b[2]=q-a*d;b[6]=m+k*d;b[10]=f*g}else"YXZ"===a.order?(a=g*h,k=g*e,m=d*h,q=d*e,b[0]=a+q*c,b[4]=m*c-k,b[8]=f*d,b[1]=f*e,b[5]=f*h,b[9]=-c,b[2]=k*c-m,b[6]=q+a*c,b[10]=f*g):"ZXY"===a.order?(a=g*h,k=g*e,m=d*h,q=d*e,b[0]=a-q*c,b[4]=-f*e,b[8]=m+k*c,b[1]=k+m*c,b[5]=f*h,b[9]=
q-a*c,b[2]=-f*d,b[6]=c,b[10]=f*g):"ZYX"===a.order?(a=f*h,k=f*e,m=c*h,q=c*e,b[0]=g*h,b[4]=m*d-k,b[8]=a*d+q,b[1]=g*e,b[5]=q*d+a,b[9]=k*d-m,b[2]=-d,b[6]=c*g,b[10]=f*g):"YZX"===a.order?(a=f*g,k=f*d,m=c*g,q=c*d,b[0]=g*h,b[4]=q-a*e,b[8]=m*e+k,b[1]=e,b[5]=f*h,b[9]=-c*h,b[2]=-d*h,b[6]=k*e+m,b[10]=a-q*e):"XZY"===a.order&&(a=f*g,k=f*d,m=c*g,q=c*d,b[0]=g*h,b[4]=-e,b[8]=d*h,b[1]=a*e+q,b[5]=f*h,b[9]=k*e-m,b[2]=m*e-k,b[6]=c*h,b[10]=q*e+a);b[3]=0;b[7]=0;b[11]=0;b[12]=0;b[13]=0;b[14]=0;b[15]=1;return this},makeRotationFromQuaternion:function(){var a=
new n(0,0,0),b=new n(1,1,1);return function(c){return this.compose(a,c,b)}}(),lookAt:function(){var a=new n,b=new n,c=new n;return function(d,e,f){var g=this.elements;c.subVectors(d,e);0===c.lengthSq()&&(c.z=1);c.normalize();a.crossVectors(f,c);0===a.lengthSq()&&(1===Math.abs(f.z)?c.x+=1E-4:c.z+=1E-4,c.normalize(),a.crossVectors(f,c));a.normalize();b.crossVectors(c,a);g[0]=a.x;g[4]=b.x;g[8]=c.x;g[1]=a.y;g[5]=b.y;g[9]=c.y;g[2]=a.z;g[6]=b.z;g[10]=c.z;return this}}(),multiply:function(a,b){return void 0!==
b?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(a,b)):this.multiplyMatrices(this,a)},premultiply:function(a){return this.multiplyMatrices(a,this)},multiplyMatrices:function(a,b){var c=a.elements,d=b.elements;b=this.elements;a=c[0];var e=c[4],f=c[8],g=c[12],h=c[1],k=c[5],m=c[9],q=c[13],l=c[2],r=c[6],n=c[10],t=c[14],v=c[3],w=c[7],y=c[11];c=c[15];var u=d[0],z=d[4],G=d[8],N=d[12],B=d[1],A=d[5],D=d[9],C=d[13],E=d[2],
F=d[6],J=d[10],L=d[14],I=d[3],K=d[7],O=d[11];d=d[15];b[0]=a*u+e*B+f*E+g*I;b[4]=a*z+e*A+f*F+g*K;b[8]=a*G+e*D+f*J+g*O;b[12]=a*N+e*C+f*L+g*d;b[1]=h*u+k*B+m*E+q*I;b[5]=h*z+k*A+m*F+q*K;b[9]=h*G+k*D+m*J+q*O;b[13]=h*N+k*C+m*L+q*d;b[2]=l*u+r*B+n*E+t*I;b[6]=l*z+r*A+n*F+t*K;b[10]=l*G+r*D+n*J+t*O;b[14]=l*N+r*C+n*L+t*d;b[3]=v*u+w*B+y*E+c*I;b[7]=v*z+w*A+y*F+c*K;b[11]=v*G+w*D+y*J+c*O;b[15]=v*N+w*C+y*L+c*d;return this},multiplyScalar:function(a){var b=this.elements;b[0]*=a;b[4]*=a;b[8]*=a;b[12]*=a;b[1]*=a;b[5]*=
a;b[9]*=a;b[13]*=a;b[2]*=a;b[6]*=a;b[10]*=a;b[14]*=a;b[3]*=a;b[7]*=a;b[11]*=a;b[15]*=a;return this},applyToBufferAttribute:function(){var a=new n;return function(b){for(var c=0,d=b.count;c<d;c++)a.x=b.getX(c),a.y=b.getY(c),a.z=b.getZ(c),a.applyMatrix4(this),b.setXYZ(c,a.x,a.y,a.z);return b}}(),determinant:function(){var a=this.elements,b=a[0],c=a[4],d=a[8],e=a[12],f=a[1],g=a[5],h=a[9],k=a[13],m=a[2],q=a[6],l=a[10],r=a[14];return a[3]*(+e*h*q-d*k*q-e*g*l+c*k*l+d*g*r-c*h*r)+a[7]*(+b*h*r-b*k*l+e*f*l-
d*f*r+d*k*m-e*h*m)+a[11]*(+b*k*q-b*g*r-e*f*q+c*f*r+e*g*m-c*k*m)+a[15]*(-d*g*m-b*h*q+b*g*l+d*f*q-c*f*l+c*h*m)},transpose:function(){var a=this.elements;var b=a[1];a[1]=a[4];a[4]=b;b=a[2];a[2]=a[8];a[8]=b;b=a[6];a[6]=a[9];a[9]=b;b=a[3];a[3]=a[12];a[12]=b;b=a[7];a[7]=a[13];a[13]=b;b=a[11];a[11]=a[14];a[14]=b;return this},setPosition:function(a){var b=this.elements;b[12]=a.x;b[13]=a.y;b[14]=a.z;return this},getInverse:function(a,b){var c=this.elements,d=a.elements;a=d[0];var e=d[1],f=d[2],g=d[3],h=d[4],
k=d[5],m=d[6],q=d[7],l=d[8],r=d[9],n=d[10],t=d[11],v=d[12],w=d[13],y=d[14];d=d[15];var u=r*y*q-w*n*q+w*m*t-k*y*t-r*m*d+k*n*d,z=v*n*q-l*y*q-v*m*t+h*y*t+l*m*d-h*n*d,G=l*w*q-v*r*q+v*k*t-h*w*t-l*k*d+h*r*d,N=v*r*m-l*w*m-v*k*n+h*w*n+l*k*y-h*r*y,B=a*u+e*z+f*G+g*N;if(0===B){if(!0===b)throw Error("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0");console.warn("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0");return this.identity()}b=1/B;c[0]=u*b;c[1]=(w*n*g-r*y*g-w*f*
t+e*y*t+r*f*d-e*n*d)*b;c[2]=(k*y*g-w*m*g+w*f*q-e*y*q-k*f*d+e*m*d)*b;c[3]=(r*m*g-k*n*g-r*f*q+e*n*q+k*f*t-e*m*t)*b;c[4]=z*b;c[5]=(l*y*g-v*n*g+v*f*t-a*y*t-l*f*d+a*n*d)*b;c[6]=(v*m*g-h*y*g-v*f*q+a*y*q+h*f*d-a*m*d)*b;c[7]=(h*n*g-l*m*g+l*f*q-a*n*q-h*f*t+a*m*t)*b;c[8]=G*b;c[9]=(v*r*g-l*w*g-v*e*t+a*w*t+l*e*d-a*r*d)*b;c[10]=(h*w*g-v*k*g+v*e*q-a*w*q-h*e*d+a*k*d)*b;c[11]=(l*k*g-h*r*g-l*e*q+a*r*q+h*e*t-a*k*t)*b;c[12]=N*b;c[13]=(l*w*f-v*r*f+v*e*n-a*w*n-l*e*y+a*r*y)*b;c[14]=(v*k*f-h*w*f-v*e*m+a*w*m+h*e*y-a*k*y)*
b;c[15]=(h*r*f-l*k*f+l*e*m-a*r*m-h*e*n+a*k*n)*b;return this},scale:function(a){var b=this.elements,c=a.x,d=a.y;a=a.z;b[0]*=c;b[4]*=d;b[8]*=a;b[1]*=c;b[5]*=d;b[9]*=a;b[2]*=c;b[6]*=d;b[10]*=a;b[3]*=c;b[7]*=d;b[11]*=a;return this},getMaxScaleOnAxis:function(){var a=this.elements;return Math.sqrt(Math.max(a[0]*a[0]+a[1]*a[1]+a[2]*a[2],a[4]*a[4]+a[5]*a[5]+a[6]*a[6],a[8]*a[8]+a[9]*a[9]+a[10]*a[10]))},makeTranslation:function(a,b,c){this.set(1,0,0,a,0,1,0,b,0,0,1,c,0,0,0,1);return this},makeRotationX:function(a){var b=
Math.cos(a);a=Math.sin(a);this.set(1,0,0,0,0,b,-a,0,0,a,b,0,0,0,0,1);return this},makeRotationY:function(a){var b=Math.cos(a);a=Math.sin(a);this.set(b,0,a,0,0,1,0,0,-a,0,b,0,0,0,0,1);return this},makeRotationZ:function(a){var b=Math.cos(a);a=Math.sin(a);this.set(b,-a,0,0,a,b,0,0,0,0,1,0,0,0,0,1);return this},makeRotationAxis:function(a,b){var c=Math.cos(b);b=Math.sin(b);var d=1-c,e=a.x,f=a.y;a=a.z;var g=d*e,h=d*f;this.set(g*e+c,g*f-b*a,g*a+b*f,0,g*f+b*a,h*f+c,h*a-b*e,0,g*a-b*f,h*a+b*e,d*a*a+c,0,0,
0,0,1);return this},makeScale:function(a,b,c){this.set(a,0,0,0,0,b,0,0,0,0,c,0,0,0,0,1);return this},makeShear:function(a,b,c){this.set(1,b,c,0,a,1,c,0,a,b,1,0,0,0,0,1);return this},compose:function(a,b,c){var d=this.elements,e=b._x,f=b._y,g=b._z,h=b._w,k=e+e,m=f+f,l=g+g;b=e*k;var p=e*m;e*=l;var r=f*m;f*=l;g*=l;k*=h;m*=h;h*=l;l=c.x;var n=c.y;c=c.z;d[0]=(1-(r+g))*l;d[1]=(p+h)*l;d[2]=(e-m)*l;d[3]=0;d[4]=(p-h)*n;d[5]=(1-(b+g))*n;d[6]=(f+k)*n;d[7]=0;d[8]=(e+m)*c;d[9]=(f-k)*c;d[10]=(1-(b+r))*c;d[11]=0;
d[12]=a.x;d[13]=a.y;d[14]=a.z;d[15]=1;return this},decompose:function(){var a=new n,b=new O;return function(c,d,e){var f=this.elements,g=a.set(f[0],f[1],f[2]).length(),h=a.set(f[4],f[5],f[6]).length(),k=a.set(f[8],f[9],f[10]).length();0>this.determinant()&&(g=-g);c.x=f[12];c.y=f[13];c.z=f[14];b.copy(this);c=1/g;f=1/h;var m=1/k;b.elements[0]*=c;b.elements[1]*=c;b.elements[2]*=c;b.elements[4]*=f;b.elements[5]*=f;b.elements[6]*=f;b.elements[8]*=m;b.elements[9]*=m;b.elements[10]*=m;d.setFromRotationMatrix(b);
e.x=g;e.y=h;e.z=k;return this}}(),makePerspective:function(a,b,c,d,e,f){void 0===f&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");var g=this.elements;g[0]=2*e/(b-a);g[4]=0;g[8]=(b+a)/(b-a);g[12]=0;g[1]=0;g[5]=2*e/(c-d);g[9]=(c+d)/(c-d);g[13]=0;g[2]=0;g[6]=0;g[10]=-(f+e)/(f-e);g[14]=-2*f*e/(f-e);g[3]=0;g[7]=0;g[11]=-1;g[15]=0;return this},makeOrthographic:function(a,b,c,d,e,f){var g=this.elements,h=1/(b-a),k=1/(c-d),m=1/(f-e);g[0]=
2*h;g[4]=0;g[8]=0;g[12]=-((b+a)*h);g[1]=0;g[5]=2*k;g[9]=0;g[13]=-((c+d)*k);g[2]=0;g[6]=0;g[10]=-2*m;g[14]=-((f+e)*m);g[3]=0;g[7]=0;g[11]=0;g[15]=1;return this},equals:function(a){var b=this.elements;a=a.elements;for(var c=0;16>c;c++)if(b[c]!==a[c])return!1;return!0},fromArray:function(a,b){void 0===b&&(b=0);for(var c=0;16>c;c++)this.elements[c]=a[c+b];return this},toArray:function(a,b){void 0===a&&(a=[]);void 0===b&&(b=0);var c=this.elements;a[b]=c[0];a[b+1]=c[1];a[b+2]=c[2];a[b+3]=c[3];a[b+4]=c[4];
a[b+5]=c[5];a[b+6]=c[6];a[b+7]=c[7];a[b+8]=c[8];a[b+9]=c[9];a[b+10]=c[10];a[b+11]=c[11];a[b+12]=c[12];a[b+13]=c[13];a[b+14]=c[14];a[b+15]=c[15];return a}});Object.assign(ka,{slerp:function(a,b,c,d){return c.copy(a).slerp(b,d)},slerpFlat:function(a,b,c,d,e,f,g){var h=c[d+0],k=c[d+1],m=c[d+2];c=c[d+3];d=e[f+0];var l=e[f+1],p=e[f+2];e=e[f+3];if(c!==e||h!==d||k!==l||m!==p){f=1-g;var r=h*d+k*l+m*p+c*e,n=0<=r?1:-1,t=1-r*r;t>Number.EPSILON&&(t=Math.sqrt(t),r=Math.atan2(t,r*n),f=Math.sin(f*r)/t,g=Math.sin(g*
r)/t);n*=g;h=h*f+d*n;k=k*f+l*n;m=m*f+p*n;c=c*f+e*n;f===1-g&&(g=1/Math.sqrt(h*h+k*k+m*m+c*c),h*=g,k*=g,m*=g,c*=g)}a[b]=h;a[b+1]=k;a[b+2]=m;a[b+3]=c}});Object.defineProperties(ka.prototype,{x:{get:function(){return this._x},set:function(a){this._x=a;this.onChangeCallback()}},y:{get:function(){return this._y},set:function(a){this._y=a;this.onChangeCallback()}},z:{get:function(){return this._z},set:function(a){this._z=a;this.onChangeCallback()}},w:{get:function(){return this._w},set:function(a){this._w=
a;this.onChangeCallback()}}});Object.assign(ka.prototype,{isQuaternion:!0,set:function(a,b,c,d){this._x=a;this._y=b;this._z=c;this._w=d;this.onChangeCallback();return this},clone:function(){return new this.constructor(this._x,this._y,this._z,this._w)},copy:function(a){this._x=a.x;this._y=a.y;this._z=a.z;this._w=a.w;this.onChangeCallback();return this},setFromEuler:function(a,b){if(!a||!a.isEuler)throw Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
var c=a._x,d=a._y,e=a._z;a=a.order;var f=Math.cos,g=Math.sin,h=f(c/2),k=f(d/2);f=f(e/2);c=g(c/2);d=g(d/2);e=g(e/2);"XYZ"===a?(this._x=c*k*f+h*d*e,this._y=h*d*f-c*k*e,this._z=h*k*e+c*d*f,this._w=h*k*f-c*d*e):"YXZ"===a?(this._x=c*k*f+h*d*e,this._y=h*d*f-c*k*e,this._z=h*k*e-c*d*f,this._w=h*k*f+c*d*e):"ZXY"===a?(this._x=c*k*f-h*d*e,this._y=h*d*f+c*k*e,this._z=h*k*e+c*d*f,this._w=h*k*f-c*d*e):"ZYX"===a?(this._x=c*k*f-h*d*e,this._y=h*d*f+c*k*e,this._z=h*k*e-c*d*f,this._w=h*k*f+c*d*e):"YZX"===a?(this._x=
c*k*f+h*d*e,this._y=h*d*f+c*k*e,this._z=h*k*e-c*d*f,this._w=h*k*f-c*d*e):"XZY"===a&&(this._x=c*k*f-h*d*e,this._y=h*d*f-c*k*e,this._z=h*k*e+c*d*f,this._w=h*k*f+c*d*e);if(!1!==b)this.onChangeCallback();return this},setFromAxisAngle:function(a,b){b/=2;var c=Math.sin(b);this._x=a.x*c;this._y=a.y*c;this._z=a.z*c;this._w=Math.cos(b);this.onChangeCallback();return this},setFromRotationMatrix:function(a){var b=a.elements,c=b[0];a=b[4];var d=b[8],e=b[1],f=b[5],g=b[9],h=b[2],k=b[6];b=b[10];var m=c+f+b;0<m?
(c=.5/Math.sqrt(m+1),this._w=.25/c,this._x=(k-g)*c,this._y=(d-h)*c,this._z=(e-a)*c):c>f&&c>b?(c=2*Math.sqrt(1+c-f-b),this._w=(k-g)/c,this._x=.25*c,this._y=(a+e)/c,this._z=(d+h)/c):f>b?(c=2*Math.sqrt(1+f-c-b),this._w=(d-h)/c,this._x=(a+e)/c,this._y=.25*c,this._z=(g+k)/c):(c=2*Math.sqrt(1+b-c-f),this._w=(e-a)/c,this._x=(d+h)/c,this._y=(g+k)/c,this._z=.25*c);this.onChangeCallback();return this},setFromUnitVectors:function(){var a=new n,b;return function(c,d){void 0===a&&(a=new n);b=c.dot(d)+1;1E-6>b?
(b=0,Math.abs(c.x)>Math.abs(c.z)?a.set(-c.y,c.x,0):a.set(0,-c.z,c.y)):a.crossVectors(c,d);this._x=a.x;this._y=a.y;this._z=a.z;this._w=b;return this.normalize()}}(),angleTo:function(a){return 2*Math.acos(Math.abs(R.clamp(this.dot(a),-1,1)))},rotateTowards:function(a,b){var c=this.angleTo(a);if(0===c)return this;this.slerp(a,Math.min(1,b/c));return this},inverse:function(){return this.conjugate()},conjugate:function(){this._x*=-1;this._y*=-1;this._z*=-1;this.onChangeCallback();return this},dot:function(a){return this._x*
a._x+this._y*a._y+this._z*a._z+this._w*a._w},lengthSq:function(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w},length:function(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)},normalize:function(){var a=this.length();0===a?(this._z=this._y=this._x=0,this._w=1):(a=1/a,this._x*=a,this._y*=a,this._z*=a,this._w*=a);this.onChangeCallback();return this},multiply:function(a,b){return void 0!==b?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),
this.multiplyQuaternions(a,b)):this.multiplyQuaternions(this,a)},premultiply:function(a){return this.multiplyQuaternions(a,this)},multiplyQuaternions:function(a,b){var c=a._x,d=a._y,e=a._z;a=a._w;var f=b._x,g=b._y,h=b._z;b=b._w;this._x=c*b+a*f+d*h-e*g;this._y=d*b+a*g+e*f-c*h;this._z=e*b+a*h+c*g-d*f;this._w=a*b-c*f-d*g-e*h;this.onChangeCallback();return this},slerp:function(a,b){if(0===b)return this;if(1===b)return this.copy(a);var c=this._x,d=this._y,e=this._z,f=this._w,g=f*a._w+c*a._x+d*a._y+e*a._z;
0>g?(this._w=-a._w,this._x=-a._x,this._y=-a._y,this._z=-a._z,g=-g):this.copy(a);if(1<=g)return this._w=f,this._x=c,this._y=d,this._z=e,this;a=1-g*g;if(a<=Number.EPSILON)return g=1-b,this._w=g*f+b*this._w,this._x=g*c+b*this._x,this._y=g*d+b*this._y,this._z=g*e+b*this._z,this.normalize();a=Math.sqrt(a);var h=Math.atan2(a,g);g=Math.sin((1-b)*h)/a;b=Math.sin(b*h)/a;this._w=f*g+this._w*b;this._x=c*g+this._x*b;this._y=d*g+this._y*b;this._z=e*g+this._z*b;this.onChangeCallback();return this},equals:function(a){return a._x===
this._x&&a._y===this._y&&a._z===this._z&&a._w===this._w},fromArray:function(a,b){void 0===b&&(b=0);this._x=a[b];this._y=a[b+1];this._z=a[b+2];this._w=a[b+3];this.onChangeCallback();return this},toArray:function(a,b){void 0===a&&(a=[]);void 0===b&&(b=0);a[b]=this._x;a[b+1]=this._y;a[b+2]=this._z;a[b+3]=this._w;return a},onChange:function(a){this.onChangeCallback=a;return this},onChangeCallback:function(){}});Object.assign(n.prototype,{isVector3:!0,set:function(a,b,c){this.x=a;this.y=b;this.z=c;return this},
setScalar:function(a){this.z=this.y=this.x=a;return this},setX:function(a){this.x=a;return this},setY:function(a){this.y=a;return this},setZ:function(a){this.z=a;return this},setComponent:function(a,b){switch(a){case 0:this.x=b;break;case 1:this.y=b;break;case 2:this.z=b;break;default:throw Error("index is out of range: "+a);}return this},getComponent:function(a){switch(a){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw Error("index is out of range: "+a);}},clone:function(){return new this.constructor(this.x,
this.y,this.z)},copy:function(a){this.x=a.x;this.y=a.y;this.z=a.z;return this},add:function(a,b){if(void 0!==b)return console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(a,b);this.x+=a.x;this.y+=a.y;this.z+=a.z;return this},addScalar:function(a){this.x+=a;this.y+=a;this.z+=a;return this},addVectors:function(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;return this},addScaledVector:function(a,b){this.x+=a.x*b;this.y+=a.y*b;this.z+=
a.z*b;return this},sub:function(a,b){if(void 0!==b)return console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(a,b);this.x-=a.x;this.y-=a.y;this.z-=a.z;return this},subScalar:function(a){this.x-=a;this.y-=a;this.z-=a;return this},subVectors:function(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;return this},multiply:function(a,b){if(void 0!==b)return console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),
this.multiplyVectors(a,b);this.x*=a.x;this.y*=a.y;this.z*=a.z;return this},multiplyScalar:function(a){this.x*=a;this.y*=a;this.z*=a;return this},multiplyVectors:function(a,b){this.x=a.x*b.x;this.y=a.y*b.y;this.z=a.z*b.z;return this},applyEuler:function(){var a=new ka;return function(b){b&&b.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");return this.applyQuaternion(a.setFromEuler(b))}}(),applyAxisAngle:function(){var a=new ka;return function(b,
c){return this.applyQuaternion(a.setFromAxisAngle(b,c))}}(),applyMatrix3:function(a){var b=this.x,c=this.y,d=this.z;a=a.elements;this.x=a[0]*b+a[3]*c+a[6]*d;this.y=a[1]*b+a[4]*c+a[7]*d;this.z=a[2]*b+a[5]*c+a[8]*d;return this},applyMatrix4:function(a){var b=this.x,c=this.y,d=this.z;a=a.elements;var e=1/(a[3]*b+a[7]*c+a[11]*d+a[15]);this.x=(a[0]*b+a[4]*c+a[8]*d+a[12])*e;this.y=(a[1]*b+a[5]*c+a[9]*d+a[13])*e;this.z=(a[2]*b+a[6]*c+a[10]*d+a[14])*e;return this},applyQuaternion:function(a){var b=this.x,
c=this.y,d=this.z,e=a.x,f=a.y,g=a.z;a=a.w;var h=a*b+f*d-g*c,k=a*c+g*b-e*d,m=a*d+e*c-f*b;b=-e*b-f*c-g*d;this.x=h*a+b*-e+k*-g-m*-f;this.y=k*a+b*-f+m*-e-h*-g;this.z=m*a+b*-g+h*-f-k*-e;return this},project:function(a){return this.applyMatrix4(a.matrixWorldInverse).applyMatrix4(a.projectionMatrix)},unproject:function(){var a=new O;return function(b){return this.applyMatrix4(a.getInverse(b.projectionMatrix)).applyMatrix4(b.matrixWorld)}}(),transformDirection:function(a){var b=this.x,c=this.y,d=this.z;a=
a.elements;this.x=a[0]*b+a[4]*c+a[8]*d;this.y=a[1]*b+a[5]*c+a[9]*d;this.z=a[2]*b+a[6]*c+a[10]*d;return this.normalize()},divide:function(a){this.x/=a.x;this.y/=a.y;this.z/=a.z;return this},divideScalar:function(a){return this.multiplyScalar(1/a)},min:function(a){this.x=Math.min(this.x,a.x);this.y=Math.min(this.y,a.y);this.z=Math.min(this.z,a.z);return this},max:function(a){this.x=Math.max(this.x,a.x);this.y=Math.max(this.y,a.y);this.z=Math.max(this.z,a.z);return this},clamp:function(a,b){this.x=Math.max(a.x,
Math.min(b.x,this.x));this.y=Math.max(a.y,Math.min(b.y,this.y));this.z=Math.max(a.z,Math.min(b.z,this.z));return this},clampScalar:function(){var a=new n,b=new n;return function(c,d){a.set(c,c,c);b.set(d,d,d);return this.clamp(a,b)}}(),clampLength:function(a,b){var c=this.length();return this.divideScalar(c||1).multiplyScalar(Math.max(a,Math.min(b,c)))},floor:function(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);this.z=Math.floor(this.z);return this},ceil:function(){this.x=Math.ceil(this.x);
this.y=Math.ceil(this.y);this.z=Math.ceil(this.z);return this},round:function(){this.x=Math.round(this.x);this.y=Math.round(this.y);this.z=Math.round(this.z);return this},roundToZero:function(){this.x=0>this.x?Math.ceil(this.x):Math.floor(this.x);this.y=0>this.y?Math.ceil(this.y):Math.floor(this.y);this.z=0>this.z?Math.ceil(this.z):Math.floor(this.z);return this},negate:function(){this.x=-this.x;this.y=-this.y;this.z=-this.z;return this},dot:function(a){return this.x*a.x+this.y*a.y+this.z*a.z},lengthSq:function(){return this.x*
this.x+this.y*this.y+this.z*this.z},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)},manhattanLength:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)},normalize:function(){return this.divideScalar(this.length()||1)},setLength:function(a){return this.normalize().multiplyScalar(a)},lerp:function(a,b){this.x+=(a.x-this.x)*b;this.y+=(a.y-this.y)*b;this.z+=(a.z-this.z)*b;return this},lerpVectors:function(a,b,c){return this.subVectors(b,a).multiplyScalar(c).add(a)},
cross:function(a,b){return void 0!==b?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(a,b)):this.crossVectors(this,a)},crossVectors:function(a,b){var c=a.x,d=a.y;a=a.z;var e=b.x,f=b.y;b=b.z;this.x=d*b-a*f;this.y=a*e-c*b;this.z=c*f-d*e;return this},projectOnVector:function(a){var b=a.dot(this)/a.lengthSq();return this.copy(a).multiplyScalar(b)},projectOnPlane:function(){var a=new n;return function(b){a.copy(this).projectOnVector(b);
return this.sub(a)}}(),reflect:function(){var a=new n;return function(b){return this.sub(a.copy(b).multiplyScalar(2*this.dot(b)))}}(),angleTo:function(a){a=this.dot(a)/Math.sqrt(this.lengthSq()*a.lengthSq());return Math.acos(R.clamp(a,-1,1))},distanceTo:function(a){return Math.sqrt(this.distanceToSquared(a))},distanceToSquared:function(a){var b=this.x-a.x,c=this.y-a.y;a=this.z-a.z;return b*b+c*c+a*a},manhattanDistanceTo:function(a){return Math.abs(this.x-a.x)+Math.abs(this.y-a.y)+Math.abs(this.z-
a.z)},setFromSpherical:function(a){return this.setFromSphericalCoords(a.radius,a.phi,a.theta)},setFromSphericalCoords:function(a,b,c){var d=Math.sin(b)*a;this.x=d*Math.sin(c);this.y=Math.cos(b)*a;this.z=d*Math.cos(c);return this},setFromCylindrical:function(a){return this.setFromCylindricalCoords(a.radius,a.theta,a.y)},setFromCylindricalCoords:function(a,b,c){this.x=a*Math.sin(b);this.y=c;this.z=a*Math.cos(b);return this},setFromMatrixPosition:function(a){a=a.elements;this.x=a[12];this.y=a[13];this.z=
a[14];return this},setFromMatrixScale:function(a){var b=this.setFromMatrixColumn(a,0).length(),c=this.setFromMatrixColumn(a,1).length();a=this.setFromMatrixColumn(a,2).length();this.x=b;this.y=c;this.z=a;return this},setFromMatrixColumn:function(a,b){return this.fromArray(a.elements,4*b)},equals:function(a){return a.x===this.x&&a.y===this.y&&a.z===this.z},fromArray:function(a,b){void 0===b&&(b=0);this.x=a[b];this.y=a[b+1];this.z=a[b+2];return this},toArray:function(a,b){void 0===a&&(a=[]);void 0===
b&&(b=0);a[b]=this.x;a[b+1]=this.y;a[b+2]=this.z;return a},fromBufferAttribute:function(a,b,c){void 0!==c&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");this.x=a.getX(b);this.y=a.getY(b);this.z=a.getZ(b);return this}});Object.assign(da.prototype,{isMatrix3:!0,set:function(a,b,c,d,e,f,g,h,k){var m=this.elements;m[0]=a;m[1]=d;m[2]=g;m[3]=b;m[4]=e;m[5]=h;m[6]=c;m[7]=f;m[8]=k;return this},identity:function(){this.set(1,0,0,0,1,0,0,0,1);return this},clone:function(){return(new this.constructor).fromArray(this.elements)},
copy:function(a){var b=this.elements;a=a.elements;b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];return this},setFromMatrix4:function(a){a=a.elements;this.set(a[0],a[4],a[8],a[1],a[5],a[9],a[2],a[6],a[10]);return this},applyToBufferAttribute:function(){var a=new n;return function(b){for(var c=0,d=b.count;c<d;c++)a.x=b.getX(c),a.y=b.getY(c),a.z=b.getZ(c),a.applyMatrix3(this),b.setXYZ(c,a.x,a.y,a.z);return b}}(),multiply:function(a){return this.multiplyMatrices(this,
a)},premultiply:function(a){return this.multiplyMatrices(a,this)},multiplyMatrices:function(a,b){var c=a.elements,d=b.elements;b=this.elements;a=c[0];var e=c[3],f=c[6],g=c[1],h=c[4],k=c[7],m=c[2],l=c[5];c=c[8];var p=d[0],r=d[3],n=d[6],t=d[1],v=d[4],w=d[7],y=d[2],u=d[5];d=d[8];b[0]=a*p+e*t+f*y;b[3]=a*r+e*v+f*u;b[6]=a*n+e*w+f*d;b[1]=g*p+h*t+k*y;b[4]=g*r+h*v+k*u;b[7]=g*n+h*w+k*d;b[2]=m*p+l*t+c*y;b[5]=m*r+l*v+c*u;b[8]=m*n+l*w+c*d;return this},multiplyScalar:function(a){var b=this.elements;b[0]*=a;b[3]*=
a;b[6]*=a;b[1]*=a;b[4]*=a;b[7]*=a;b[2]*=a;b[5]*=a;b[8]*=a;return this},determinant:function(){var a=this.elements,b=a[0],c=a[1],d=a[2],e=a[3],f=a[4],g=a[5],h=a[6],k=a[7];a=a[8];return b*f*a-b*g*k-c*e*a+c*g*h+d*e*k-d*f*h},getInverse:function(a,b){a&&a.isMatrix4&&console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");var c=a.elements;a=this.elements;var d=c[0],e=c[1],f=c[2],g=c[3],h=c[4],k=c[5],m=c[6],l=c[7];c=c[8];var p=c*h-k*l,r=k*m-c*g,n=l*g-h*m,t=d*p+e*r+f*n;if(0===t){if(!0===
b)throw Error("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0");console.warn("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0");return this.identity()}b=1/t;a[0]=p*b;a[1]=(f*l-c*e)*b;a[2]=(k*e-f*h)*b;a[3]=r*b;a[4]=(c*d-f*m)*b;a[5]=(f*g-k*d)*b;a[6]=n*b;a[7]=(e*m-l*d)*b;a[8]=(h*d-e*g)*b;return this},transpose:function(){var a=this.elements;var b=a[1];a[1]=a[3];a[3]=b;b=a[2];a[2]=a[6];a[6]=b;b=a[5];a[5]=a[7];a[7]=b;return this},getNormalMatrix:function(a){return this.setFromMatrix4(a).getInverse(this).transpose()},
transposeIntoArray:function(a){var b=this.elements;a[0]=b[0];a[1]=b[3];a[2]=b[6];a[3]=b[1];a[4]=b[4];a[5]=b[7];a[6]=b[2];a[7]=b[5];a[8]=b[8];return this},setUvTransform:function(a,b,c,d,e,f,g){var h=Math.cos(e);e=Math.sin(e);this.set(c*h,c*e,-c*(h*f+e*g)+f+a,-d*e,d*h,-d*(-e*f+h*g)+g+b,0,0,1)},scale:function(a,b){var c=this.elements;c[0]*=a;c[3]*=a;c[6]*=a;c[1]*=b;c[4]*=b;c[7]*=b;return this},rotate:function(a){var b=Math.cos(a);a=Math.sin(a);var c=this.elements,d=c[0],e=c[3],f=c[6],g=c[1],h=c[4],
k=c[7];c[0]=b*d+a*g;c[3]=b*e+a*h;c[6]=b*f+a*k;c[1]=-a*d+b*g;c[4]=-a*e+b*h;c[7]=-a*f+b*k;return this},translate:function(a,b){var c=this.elements;c[0]+=a*c[2];c[3]+=a*c[5];c[6]+=a*c[8];c[1]+=b*c[2];c[4]+=b*c[5];c[7]+=b*c[8];return this},equals:function(a){var b=this.elements;a=a.elements;for(var c=0;9>c;c++)if(b[c]!==a[c])return!1;return!0},fromArray:function(a,b){void 0===b&&(b=0);for(var c=0;9>c;c++)this.elements[c]=a[c+b];return this},toArray:function(a,b){void 0===a&&(a=[]);void 0===b&&(b=0);var c=
this.elements;a[b]=c[0];a[b+1]=c[1];a[b+2]=c[2];a[b+3]=c[3];a[b+4]=c[4];a[b+5]=c[5];a[b+6]=c[6];a[b+7]=c[7];a[b+8]=c[8];return a}});var sc,ib={getDataURL:function(a){if("undefined"==typeof HTMLCanvasElement)return a.src;if(!(a instanceof HTMLCanvasElement)){void 0===sc&&(sc=document.createElementNS("http://www.w3.org/1999/xhtml","canvas"));sc.width=a.width;sc.height=a.height;var b=sc.getContext("2d");a instanceof ImageData?b.putImageData(a,0,0):b.drawImage(a,0,0,a.width,a.height);a=sc}return 2048<
a.width||2048<a.height?a.toDataURL("image/jpeg",.6):a.toDataURL("image/png")}},Mf=0;X.DEFAULT_IMAGE=void 0;X.DEFAULT_MAPPING=300;X.prototype=Object.assign(Object.create(ja.prototype),{constructor:X,isTexture:!0,updateMatrix:function(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)},clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.name=a.name;this.image=a.image;this.mipmaps=a.mipmaps.slice(0);
this.mapping=a.mapping;this.wrapS=a.wrapS;this.wrapT=a.wrapT;this.magFilter=a.magFilter;this.minFilter=a.minFilter;this.anisotropy=a.anisotropy;this.format=a.format;this.type=a.type;this.offset.copy(a.offset);this.repeat.copy(a.repeat);this.center.copy(a.center);this.rotation=a.rotation;this.matrixAutoUpdate=a.matrixAutoUpdate;this.matrix.copy(a.matrix);this.generateMipmaps=a.generateMipmaps;this.premultiplyAlpha=a.premultiplyAlpha;this.flipY=a.flipY;this.unpackAlignment=a.unpackAlignment;this.encoding=
a.encoding;return this},toJSON:function(a){var b=void 0===a||"string"===typeof a;if(!b&&void 0!==a.textures[this.uuid])return a.textures[this.uuid];var c={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,minFilter:this.minFilter,magFilter:this.magFilter,
anisotropy:this.anisotropy,flipY:this.flipY};if(void 0!==this.image){var d=this.image;void 0===d.uuid&&(d.uuid=R.generateUUID());if(!b&&void 0===a.images[d.uuid]){if(Array.isArray(d)){var e=[];for(var f=0,g=d.length;f<g;f++)e.push(ib.getDataURL(d[f]))}else e=ib.getDataURL(d);a.images[d.uuid]={uuid:d.uuid,url:e}}c.image=d.uuid}b||(a.textures[this.uuid]=c);return c},dispose:function(){this.dispatchEvent({type:"dispose"})},transformUv:function(a){if(300!==this.mapping)return a;a.applyMatrix3(this.matrix);
if(0>a.x||1<a.x)switch(this.wrapS){case 1E3:a.x-=Math.floor(a.x);break;case 1001:a.x=0>a.x?0:1;break;case 1002:a.x=1===Math.abs(Math.floor(a.x)%2)?Math.ceil(a.x)-a.x:a.x-Math.floor(a.x)}if(0>a.y||1<a.y)switch(this.wrapT){case 1E3:a.y-=Math.floor(a.y);break;case 1001:a.y=0>a.y?0:1;break;case 1002:a.y=1===Math.abs(Math.floor(a.y)%2)?Math.ceil(a.y)-a.y:a.y-Math.floor(a.y)}this.flipY&&(a.y=1-a.y);return a}});Object.defineProperty(X.prototype,"needsUpdate",{set:function(a){!0===a&&this.version++}});Object.assign(ca.prototype,
{isVector4:!0,set:function(a,b,c,d){this.x=a;this.y=b;this.z=c;this.w=d;return this},setScalar:function(a){this.w=this.z=this.y=this.x=a;return this},setX:function(a){this.x=a;return this},setY:function(a){this.y=a;return this},setZ:function(a){this.z=a;return this},setW:function(a){this.w=a;return this},setComponent:function(a,b){switch(a){case 0:this.x=b;break;case 1:this.y=b;break;case 2:this.z=b;break;case 3:this.w=b;break;default:throw Error("index is out of range: "+a);}return this},getComponent:function(a){switch(a){case 0:return this.x;
case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw Error("index is out of range: "+a);}},clone:function(){return new this.constructor(this.x,this.y,this.z,this.w)},copy:function(a){this.x=a.x;this.y=a.y;this.z=a.z;this.w=void 0!==a.w?a.w:1;return this},add:function(a,b){if(void 0!==b)return console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(a,b);this.x+=a.x;this.y+=a.y;this.z+=a.z;this.w+=a.w;return this},
addScalar:function(a){this.x+=a;this.y+=a;this.z+=a;this.w+=a;return this},addVectors:function(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;this.w=a.w+b.w;return this},addScaledVector:function(a,b){this.x+=a.x*b;this.y+=a.y*b;this.z+=a.z*b;this.w+=a.w*b;return this},sub:function(a,b){if(void 0!==b)return console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(a,b);this.x-=a.x;this.y-=a.y;this.z-=a.z;this.w-=a.w;return this},subScalar:function(a){this.x-=
a;this.y-=a;this.z-=a;this.w-=a;return this},subVectors:function(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;this.w=a.w-b.w;return this},multiplyScalar:function(a){this.x*=a;this.y*=a;this.z*=a;this.w*=a;return this},applyMatrix4:function(a){var b=this.x,c=this.y,d=this.z,e=this.w;a=a.elements;this.x=a[0]*b+a[4]*c+a[8]*d+a[12]*e;this.y=a[1]*b+a[5]*c+a[9]*d+a[13]*e;this.z=a[2]*b+a[6]*c+a[10]*d+a[14]*e;this.w=a[3]*b+a[7]*c+a[11]*d+a[15]*e;return this},divideScalar:function(a){return this.multiplyScalar(1/
a)},setAxisAngleFromQuaternion:function(a){this.w=2*Math.acos(a.w);var b=Math.sqrt(1-a.w*a.w);1E-4>b?(this.x=1,this.z=this.y=0):(this.x=a.x/b,this.y=a.y/b,this.z=a.z/b);return this},setAxisAngleFromRotationMatrix:function(a){a=a.elements;var b=a[0];var c=a[4];var d=a[8],e=a[1],f=a[5],g=a[9];var h=a[2];var k=a[6];var m=a[10];if(.01>Math.abs(c-e)&&.01>Math.abs(d-h)&&.01>Math.abs(g-k)){if(.1>Math.abs(c+e)&&.1>Math.abs(d+h)&&.1>Math.abs(g+k)&&.1>Math.abs(b+f+m-3))return this.set(1,0,0,0),this;a=Math.PI;
b=(b+1)/2;f=(f+1)/2;m=(m+1)/2;c=(c+e)/4;d=(d+h)/4;g=(g+k)/4;b>f&&b>m?.01>b?(k=0,c=h=.707106781):(k=Math.sqrt(b),h=c/k,c=d/k):f>m?.01>f?(k=.707106781,h=0,c=.707106781):(h=Math.sqrt(f),k=c/h,c=g/h):.01>m?(h=k=.707106781,c=0):(c=Math.sqrt(m),k=d/c,h=g/c);this.set(k,h,c,a);return this}a=Math.sqrt((k-g)*(k-g)+(d-h)*(d-h)+(e-c)*(e-c));.001>Math.abs(a)&&(a=1);this.x=(k-g)/a;this.y=(d-h)/a;this.z=(e-c)/a;this.w=Math.acos((b+f+m-1)/2);return this},min:function(a){this.x=Math.min(this.x,a.x);this.y=Math.min(this.y,
a.y);this.z=Math.min(this.z,a.z);this.w=Math.min(this.w,a.w);return this},max:function(a){this.x=Math.max(this.x,a.x);this.y=Math.max(this.y,a.y);this.z=Math.max(this.z,a.z);this.w=Math.max(this.w,a.w);return this},clamp:function(a,b){this.x=Math.max(a.x,Math.min(b.x,this.x));this.y=Math.max(a.y,Math.min(b.y,this.y));this.z=Math.max(a.z,Math.min(b.z,this.z));this.w=Math.max(a.w,Math.min(b.w,this.w));return this},clampScalar:function(){var a,b;return function(c,d){void 0===a&&(a=new ca,b=new ca);a.set(c,
c,c,c);b.set(d,d,d,d);return this.clamp(a,b)}}(),clampLength:function(a,b){var c=this.length();return this.divideScalar(c||1).multiplyScalar(Math.max(a,Math.min(b,c)))},floor:function(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);this.z=Math.floor(this.z);this.w=Math.floor(this.w);return this},ceil:function(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);this.z=Math.ceil(this.z);this.w=Math.ceil(this.w);return this},round:function(){this.x=Math.round(this.x);this.y=Math.round(this.y);
this.z=Math.round(this.z);this.w=Math.round(this.w);return this},roundToZero:function(){this.x=0>this.x?Math.ceil(this.x):Math.floor(this.x);this.y=0>this.y?Math.ceil(this.y):Math.floor(this.y);this.z=0>this.z?Math.ceil(this.z):Math.floor(this.z);this.w=0>this.w?Math.ceil(this.w):Math.floor(this.w);return this},negate:function(){this.x=-this.x;this.y=-this.y;this.z=-this.z;this.w=-this.w;return this},dot:function(a){return this.x*a.x+this.y*a.y+this.z*a.z+this.w*a.w},lengthSq:function(){return this.x*
this.x+this.y*this.y+this.z*this.z+this.w*this.w},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)},manhattanLength:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)},normalize:function(){return this.divideScalar(this.length()||1)},setLength:function(a){return this.normalize().multiplyScalar(a)},lerp:function(a,b){this.x+=(a.x-this.x)*b;this.y+=(a.y-this.y)*b;this.z+=(a.z-this.z)*b;this.w+=(a.w-this.w)*b;return this},lerpVectors:function(a,
b,c){return this.subVectors(b,a).multiplyScalar(c).add(a)},equals:function(a){return a.x===this.x&&a.y===this.y&&a.z===this.z&&a.w===this.w},fromArray:function(a,b){void 0===b&&(b=0);this.x=a[b];this.y=a[b+1];this.z=a[b+2];this.w=a[b+3];return this},toArray:function(a,b){void 0===a&&(a=[]);void 0===b&&(b=0);a[b]=this.x;a[b+1]=this.y;a[b+2]=this.z;a[b+3]=this.w;return a},fromBufferAttribute:function(a,b,c){void 0!==c&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
this.x=a.getX(b);this.y=a.getY(b);this.z=a.getZ(b);this.w=a.getW(b);return this}});jb.prototype=Object.assign(Object.create(ja.prototype),{constructor:jb,isWebGLRenderTarget:!0,setSize:function(a,b){if(this.width!==a||this.height!==b)this.width=a,this.height=b,this.dispose();this.viewport.set(0,0,a,b);this.scissor.set(0,0,a,b)},clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.width=a.width;this.height=a.height;this.viewport.copy(a.viewport);this.texture=a.texture.clone();
this.depthBuffer=a.depthBuffer;this.stencilBuffer=a.stencilBuffer;this.depthTexture=a.depthTexture;return this},dispose:function(){this.dispatchEvent({type:"dispose"})}});Ib.prototype=Object.create(jb.prototype);Ib.prototype.constructor=Ib;Ib.prototype.isWebGLRenderTargetCube=!0;kb.prototype=Object.create(X.prototype);kb.prototype.constructor=kb;kb.prototype.isDataTexture=!0;Object.assign(Wa.prototype,{isBox3:!0,set:function(a,b){this.min.copy(a);this.max.copy(b);return this},setFromArray:function(a){for(var b=
Infinity,c=Infinity,d=Infinity,e=-Infinity,f=-Infinity,g=-Infinity,h=0,k=a.length;h<k;h+=3){var m=a[h],l=a[h+1],p=a[h+2];m<b&&(b=m);l<c&&(c=l);p<d&&(d=p);m>e&&(e=m);l>f&&(f=l);p>g&&(g=p)}this.min.set(b,c,d);this.max.set(e,f,g);return this},setFromBufferAttribute:function(a){for(var b=Infinity,c=Infinity,d=Infinity,e=-Infinity,f=-Infinity,g=-Infinity,h=0,k=a.count;h<k;h++){var m=a.getX(h),l=a.getY(h),p=a.getZ(h);m<b&&(b=m);l<c&&(c=l);p<d&&(d=p);m>e&&(e=m);l>f&&(f=l);p>g&&(g=p)}this.min.set(b,c,d);
this.max.set(e,f,g);return this},setFromPoints:function(a){this.makeEmpty();for(var b=0,c=a.length;b<c;b++)this.expandByPoint(a[b]);return this},setFromCenterAndSize:function(){var a=new n;return function(b,c){c=a.copy(c).multiplyScalar(.5);this.min.copy(b).sub(c);this.max.copy(b).add(c);return this}}(),setFromObject:function(a){this.makeEmpty();return this.expandByObject(a)},clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.min.copy(a.min);this.max.copy(a.max);return this},
makeEmpty:function(){this.min.x=this.min.y=this.min.z=Infinity;this.max.x=this.max.y=this.max.z=-Infinity;return this},isEmpty:function(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z},getCenter:function(a){void 0===a&&(console.warn("THREE.Box3: .getCenter() target is now required"),a=new n);return this.isEmpty()?a.set(0,0,0):a.addVectors(this.min,this.max).multiplyScalar(.5)},getSize:function(a){void 0===a&&(console.warn("THREE.Box3: .getSize() target is now required"),
a=new n);return this.isEmpty()?a.set(0,0,0):a.subVectors(this.max,this.min)},expandByPoint:function(a){this.min.min(a);this.max.max(a);return this},expandByVector:function(a){this.min.sub(a);this.max.add(a);return this},expandByScalar:function(a){this.min.addScalar(-a);this.max.addScalar(a);return this},expandByObject:function(){function a(a){var f=a.geometry;if(void 0!==f)if(f.isGeometry)for(f=f.vertices,c=0,d=f.length;c<d;c++)e.copy(f[c]),e.applyMatrix4(a.matrixWorld),b.expandByPoint(e);else if(f.isBufferGeometry&&
(f=f.attributes.position,void 0!==f))for(c=0,d=f.count;c<d;c++)e.fromBufferAttribute(f,c).applyMatrix4(a.matrixWorld),b.expandByPoint(e)}var b,c,d,e=new n;return function(c){b=this;c.updateMatrixWorld(!0);c.traverse(a);return this}}(),containsPoint:function(a){return a.x<this.min.x||a.x>this.max.x||a.y<this.min.y||a.y>this.max.y||a.z<this.min.z||a.z>this.max.z?!1:!0},containsBox:function(a){return this.min.x<=a.min.x&&a.max.x<=this.max.x&&this.min.y<=a.min.y&&a.max.y<=this.max.y&&this.min.z<=a.min.z&&
a.max.z<=this.max.z},getParameter:function(a,b){void 0===b&&(console.warn("THREE.Box3: .getParameter() target is now required"),b=new n);return b.set((a.x-this.min.x)/(this.max.x-this.min.x),(a.y-this.min.y)/(this.max.y-this.min.y),(a.z-this.min.z)/(this.max.z-this.min.z))},intersectsBox:function(a){return a.max.x<this.min.x||a.min.x>this.max.x||a.max.y<this.min.y||a.min.y>this.max.y||a.max.z<this.min.z||a.min.z>this.max.z?!1:!0},intersectsSphere:function(){var a=new n;return function(b){this.clampPoint(b.center,
a);return a.distanceToSquared(b.center)<=b.radius*b.radius}}(),intersectsPlane:function(a){if(0<a.normal.x){var b=a.normal.x*this.min.x;var c=a.normal.x*this.max.x}else b=a.normal.x*this.max.x,c=a.normal.x*this.min.x;0<a.normal.y?(b+=a.normal.y*this.min.y,c+=a.normal.y*this.max.y):(b+=a.normal.y*this.max.y,c+=a.normal.y*this.min.y);0<a.normal.z?(b+=a.normal.z*this.min.z,c+=a.normal.z*this.max.z):(b+=a.normal.z*this.max.z,c+=a.normal.z*this.min.z);return b<=-a.constant&&c>=-a.constant},intersectsTriangle:function(){function a(a){var e;
var f=0;for(e=a.length-3;f<=e;f+=3){h.fromArray(a,f);var g=m.x*Math.abs(h.x)+m.y*Math.abs(h.y)+m.z*Math.abs(h.z),k=b.dot(h),l=c.dot(h),q=d.dot(h);if(Math.max(-Math.max(k,l,q),Math.min(k,l,q))>g)return!1}return!0}var b=new n,c=new n,d=new n,e=new n,f=new n,g=new n,h=new n,k=new n,m=new n,l=new n;return function(h){if(this.isEmpty())return!1;this.getCenter(k);m.subVectors(this.max,k);b.subVectors(h.a,k);c.subVectors(h.b,k);d.subVectors(h.c,k);e.subVectors(c,b);f.subVectors(d,c);g.subVectors(b,d);h=
[0,-e.z,e.y,0,-f.z,f.y,0,-g.z,g.y,e.z,0,-e.x,f.z,0,-f.x,g.z,0,-g.x,-e.y,e.x,0,-f.y,f.x,0,-g.y,g.x,0];if(!a(h))return!1;h=[1,0,0,0,1,0,0,0,1];if(!a(h))return!1;l.crossVectors(e,f);h=[l.x,l.y,l.z];return a(h)}}(),clampPoint:function(a,b){void 0===b&&(console.warn("THREE.Box3: .clampPoint() target is now required"),b=new n);return b.copy(a).clamp(this.min,this.max)},distanceToPoint:function(){var a=new n;return function(b){return a.copy(b).clamp(this.min,this.max).sub(b).length()}}(),getBoundingSphere:function(){var a=
new n;return function(b){void 0===b&&(console.warn("THREE.Box3: .getBoundingSphere() target is now required"),b=new Ea);this.getCenter(b.center);b.radius=.5*this.getSize(a).length();return b}}(),intersect:function(a){this.min.max(a.min);this.max.min(a.max);this.isEmpty()&&this.makeEmpty();return this},union:function(a){this.min.min(a.min);this.max.max(a.max);return this},applyMatrix4:function(){var a=[new n,new n,new n,new n,new n,new n,new n,new n];return function(b){if(this.isEmpty())return this;
a[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(b);a[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(b);a[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(b);a[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(b);a[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(b);a[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(b);a[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(b);a[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(b);this.setFromPoints(a);return this}}(),
translate:function(a){this.min.add(a);this.max.add(a);return this},equals:function(a){return a.min.equals(this.min)&&a.max.equals(this.max)}});Object.assign(Ea.prototype,{set:function(a,b){this.center.copy(a);this.radius=b;return this},setFromPoints:function(){var a=new Wa;return function(b,c){var d=this.center;void 0!==c?d.copy(c):a.setFromPoints(b).getCenter(d);for(var e=c=0,f=b.length;e<f;e++)c=Math.max(c,d.distanceToSquared(b[e]));this.radius=Math.sqrt(c);return this}}(),clone:function(){return(new this.constructor).copy(this)},
copy:function(a){this.center.copy(a.center);this.radius=a.radius;return this},empty:function(){return 0>=this.radius},containsPoint:function(a){return a.distanceToSquared(this.center)<=this.radius*this.radius},distanceToPoint:function(a){return a.distanceTo(this.center)-this.radius},intersectsSphere:function(a){var b=this.radius+a.radius;return a.center.distanceToSquared(this.center)<=b*b},intersectsBox:function(a){return a.intersectsSphere(this)},intersectsPlane:function(a){return Math.abs(a.distanceToPoint(this.center))<=
this.radius},clampPoint:function(a,b){var c=this.center.distanceToSquared(a);void 0===b&&(console.warn("THREE.Sphere: .clampPoint() target is now required"),b=new n);b.copy(a);c>this.radius*this.radius&&(b.sub(this.center).normalize(),b.multiplyScalar(this.radius).add(this.center));return b},getBoundingBox:function(a){void 0===a&&(console.warn("THREE.Sphere: .getBoundingBox() target is now required"),a=new Wa);a.set(this.center,this.center);a.expandByScalar(this.radius);return a},applyMatrix4:function(a){this.center.applyMatrix4(a);
this.radius*=a.getMaxScaleOnAxis();return this},translate:function(a){this.center.add(a);return this},equals:function(a){return a.center.equals(this.center)&&a.radius===this.radius}});Object.assign(Pa.prototype,{set:function(a,b){this.normal.copy(a);this.constant=b;return this},setComponents:function(a,b,c,d){this.normal.set(a,b,c);this.constant=d;return this},setFromNormalAndCoplanarPoint:function(a,b){this.normal.copy(a);this.constant=-b.dot(this.normal);return this},setFromCoplanarPoints:function(){var a=
new n,b=new n;return function(c,d,e){d=a.subVectors(e,d).cross(b.subVectors(c,d)).normalize();this.setFromNormalAndCoplanarPoint(d,c);return this}}(),clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.normal.copy(a.normal);this.constant=a.constant;return this},normalize:function(){var a=1/this.normal.length();this.normal.multiplyScalar(a);this.constant*=a;return this},negate:function(){this.constant*=-1;this.normal.negate();return this},distanceToPoint:function(a){return this.normal.dot(a)+
this.constant},distanceToSphere:function(a){return this.distanceToPoint(a.center)-a.radius},projectPoint:function(a,b){void 0===b&&(console.warn("THREE.Plane: .projectPoint() target is now required"),b=new n);return b.copy(this.normal).multiplyScalar(-this.distanceToPoint(a)).add(a)},intersectLine:function(){var a=new n;return function(b,c){void 0===c&&(console.warn("THREE.Plane: .intersectLine() target is now required"),c=new n);var d=b.delta(a),e=this.normal.dot(d);if(0===e){if(0===this.distanceToPoint(b.start))return c.copy(b.start)}else if(e=
-(b.start.dot(this.normal)+this.constant)/e,!(0>e||1<e))return c.copy(d).multiplyScalar(e).add(b.start)}}(),intersectsLine:function(a){var b=this.distanceToPoint(a.start);a=this.distanceToPoint(a.end);return 0>b&&0<a||0>a&&0<b},intersectsBox:function(a){return a.intersectsPlane(this)},intersectsSphere:function(a){return a.intersectsPlane(this)},coplanarPoint:function(a){void 0===a&&(console.warn("THREE.Plane: .coplanarPoint() target is now required"),a=new n);return a.copy(this.normal).multiplyScalar(-this.constant)},
applyMatrix4:function(){var a=new n,b=new da;return function(c,d){d=d||b.getNormalMatrix(c);c=this.coplanarPoint(a).applyMatrix4(c);d=this.normal.applyMatrix3(d).normalize();this.constant=-c.dot(d);return this}}(),translate:function(a){this.constant-=a.dot(this.normal);return this},equals:function(a){return a.normal.equals(this.normal)&&a.constant===this.constant}});Object.assign(td.prototype,{set:function(a,b,c,d,e,f){var g=this.planes;g[0].copy(a);g[1].copy(b);g[2].copy(c);g[3].copy(d);g[4].copy(e);
g[5].copy(f);return this},clone:function(){return(new this.constructor).copy(this)},copy:function(a){for(var b=this.planes,c=0;6>c;c++)b[c].copy(a.planes[c]);return this},setFromMatrix:function(a){var b=this.planes,c=a.elements;a=c[0];var d=c[1],e=c[2],f=c[3],g=c[4],h=c[5],k=c[6],m=c[7],l=c[8],p=c[9],r=c[10],n=c[11],t=c[12],v=c[13],w=c[14];c=c[15];b[0].setComponents(f-a,m-g,n-l,c-t).normalize();b[1].setComponents(f+a,m+g,n+l,c+t).normalize();b[2].setComponents(f+d,m+h,n+p,c+v).normalize();b[3].setComponents(f-
d,m-h,n-p,c-v).normalize();b[4].setComponents(f-e,m-k,n-r,c-w).normalize();b[5].setComponents(f+e,m+k,n+r,c+w).normalize();return this},intersectsObject:function(){var a=new Ea;return function(b){var c=b.geometry;null===c.boundingSphere&&c.computeBoundingSphere();a.copy(c.boundingSphere).applyMatrix4(b.matrixWorld);return this.intersectsSphere(a)}}(),intersectsSprite:function(){var a=new Ea;return function(b){a.center.set(0,0,0);a.radius=.7071067811865476;a.applyMatrix4(b.matrixWorld);return this.intersectsSphere(a)}}(),
intersectsSphere:function(a){var b=this.planes,c=a.center;a=-a.radius;for(var d=0;6>d;d++)if(b[d].distanceToPoint(c)<a)return!1;return!0},intersectsBox:function(){var a=new n;return function(b){for(var c=this.planes,d=0;6>d;d++){var e=c[d];a.x=0<e.normal.x?b.max.x:b.min.x;a.y=0<e.normal.y?b.max.y:b.min.y;a.z=0<e.normal.z?b.max.z:b.min.z;if(0>e.distanceToPoint(a))return!1}return!0}}(),containsPoint:function(a){for(var b=this.planes,c=0;6>c;c++)if(0>b[c].distanceToPoint(a))return!1;return!0}});var I=
{alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",begin_vertex:"vec3 transformed = vec3( position );",beginnormal_vertex:"vec3 objectNormal = vec3( normal );",bsdfs:"float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}",
bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif",
color_fragment:"#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",color_pars_vertex:"#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",color_vertex:"#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",common:"#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}",
cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif",
defaultnormal_vertex:"vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif",
emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",encodings_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",encodings_pars_fragment:"\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
envmap_fragment:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
envmap_pars_fragment:"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",envmap_physical_pars_fragment:"#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
envmap_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
fog_vertex:"#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
gradientmap_pars_fragment:"#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif",lightmap_fragment:"#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif",
lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",lights_lambert_vertex:"vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif",
lights_pars_begin:"uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",lights_phong_pars_fragment:"varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif",
lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
lights_fragment_begin:"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif",
lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif",
lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif",logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif",
logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif",map_fragment:"#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",map_particle_fragment:"#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif",map_particle_pars_fragment:"#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif",metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
normal_fragment_begin:"#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif",normal_fragment_maps:"#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif",
packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;",dithering_fragment:"#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",dithering_pars_fragment:"#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
shadowmap_pars_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif",
shadowmap_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif",
shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}",
skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif",
specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
uv_pars_fragment:"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",uv_pars_vertex:"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif",
uv_vertex:"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",uv2_pars_fragment:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",uv2_pars_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
uv2_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif",background_frag:"uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
cube_frag:"uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}",
depth_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}",
distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
meshbasic_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
meshlambert_frag:"uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
meshlambert_vert:"#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
meshphysical_frag:"#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
meshphysical_vert:"#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
normal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
normal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}",shadow_vert:"#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"},
ah={clone:Jb,merge:ua},bh={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,
darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,
grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,
lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,
palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,
teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};Object.assign(J.prototype,{isColor:!0,r:1,g:1,b:1,set:function(a){a&&a.isColor?this.copy(a):"number"===typeof a?this.setHex(a):"string"===typeof a&&this.setStyle(a);return this},setScalar:function(a){this.b=this.g=this.r=a;return this},setHex:function(a){a=Math.floor(a);this.r=(a>>16&255)/255;this.g=(a>>8&255)/255;this.b=(a&255)/255;
return this},setRGB:function(a,b,c){this.r=a;this.g=b;this.b=c;return this},setHSL:function(){function a(a,c,d){0>d&&(d+=1);1<d&&--d;return d<1/6?a+6*(c-a)*d:.5>d?c:d<2/3?a+6*(c-a)*(2/3-d):a}return function(b,c,d){b=R.euclideanModulo(b,1);c=R.clamp(c,0,1);d=R.clamp(d,0,1);0===c?this.r=this.g=this.b=d:(c=.5>=d?d*(1+c):d+c-d*c,d=2*d-c,this.r=a(d,c,b+1/3),this.g=a(d,c,b),this.b=a(d,c,b-1/3));return this}}(),setStyle:function(a){function b(b){void 0!==b&&1>parseFloat(b)&&console.warn("THREE.Color: Alpha component of "+
a+" will be ignored.")}var c;if(c=/^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(a)){var d=c[2];switch(c[1]){case "rgb":case "rgba":if(c=/^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d))return this.r=Math.min(255,parseInt(c[1],10))/255,this.g=Math.min(255,parseInt(c[2],10))/255,this.b=Math.min(255,parseInt(c[3],10))/255,b(c[5]),this;if(c=/^(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d))return this.r=Math.min(100,parseInt(c[1],10))/100,this.g=Math.min(100,parseInt(c[2],
10))/100,this.b=Math.min(100,parseInt(c[3],10))/100,b(c[5]),this;break;case "hsl":case "hsla":if(c=/^([0-9]*\.?[0-9]+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)){d=parseFloat(c[1])/360;var e=parseInt(c[2],10)/100,f=parseInt(c[3],10)/100;b(c[5]);return this.setHSL(d,e,f)}}}else if(c=/^#([A-Fa-f0-9]+)$/.exec(a)){c=c[1];d=c.length;if(3===d)return this.r=parseInt(c.charAt(0)+c.charAt(0),16)/255,this.g=parseInt(c.charAt(1)+c.charAt(1),16)/255,this.b=parseInt(c.charAt(2)+c.charAt(2),
16)/255,this;if(6===d)return this.r=parseInt(c.charAt(0)+c.charAt(1),16)/255,this.g=parseInt(c.charAt(2)+c.charAt(3),16)/255,this.b=parseInt(c.charAt(4)+c.charAt(5),16)/255,this}a&&0<a.length&&(c=bh[a],void 0!==c?this.setHex(c):console.warn("THREE.Color: Unknown color "+a));return this},clone:function(){return new this.constructor(this.r,this.g,this.b)},copy:function(a){this.r=a.r;this.g=a.g;this.b=a.b;return this},copyGammaToLinear:function(a,b){void 0===b&&(b=2);this.r=Math.pow(a.r,b);this.g=Math.pow(a.g,
b);this.b=Math.pow(a.b,b);return this},copyLinearToGamma:function(a,b){void 0===b&&(b=2);b=0<b?1/b:1;this.r=Math.pow(a.r,b);this.g=Math.pow(a.g,b);this.b=Math.pow(a.b,b);return this},convertGammaToLinear:function(a){this.copyGammaToLinear(this,a);return this},convertLinearToGamma:function(a){this.copyLinearToGamma(this,a);return this},copySRGBToLinear:function(){function a(a){return.04045>a?.0773993808*a:Math.pow(.9478672986*a+.0521327014,2.4)}return function(b){this.r=a(b.r);this.g=a(b.g);this.b=
a(b.b);return this}}(),copyLinearToSRGB:function(){function a(a){return.0031308>a?12.92*a:1.055*Math.pow(a,.41666)-.055}return function(b){this.r=a(b.r);this.g=a(b.g);this.b=a(b.b);return this}}(),convertSRGBToLinear:function(){this.copySRGBToLinear(this);return this},convertLinearToSRGB:function(){this.copyLinearToSRGB(this);return this},getHex:function(){return 255*this.r<<16^255*this.g<<8^255*this.b<<0},getHexString:function(){return("000000"+this.getHex().toString(16)).slice(-6)},getHSL:function(a){void 0===
a&&(console.warn("THREE.Color: .getHSL() target is now required"),a={h:0,s:0,l:0});var b=this.r,c=this.g,d=this.b,e=Math.max(b,c,d),f=Math.min(b,c,d),g,h=(f+e)/2;if(f===e)f=g=0;else{var k=e-f;f=.5>=h?k/(e+f):k/(2-e-f);switch(e){case b:g=(c-d)/k+(c<d?6:0);break;case c:g=(d-b)/k+2;break;case d:g=(b-c)/k+4}g/=6}a.h=g;a.s=f;a.l=h;return a},getStyle:function(){return"rgb("+(255*this.r|0)+","+(255*this.g|0)+","+(255*this.b|0)+")"},offsetHSL:function(){var a={};return function(b,c,d){this.getHSL(a);a.h+=
b;a.s+=c;a.l+=d;this.setHSL(a.h,a.s,a.l);return this}}(),add:function(a){this.r+=a.r;this.g+=a.g;this.b+=a.b;return this},addColors:function(a,b){this.r=a.r+b.r;this.g=a.g+b.g;this.b=a.b+b.b;return this},addScalar:function(a){this.r+=a;this.g+=a;this.b+=a;return this},sub:function(a){this.r=Math.max(0,this.r-a.r);this.g=Math.max(0,this.g-a.g);this.b=Math.max(0,this.b-a.b);return this},multiply:function(a){this.r*=a.r;this.g*=a.g;this.b*=a.b;return this},multiplyScalar:function(a){this.r*=a;this.g*=
a;this.b*=a;return this},lerp:function(a,b){this.r+=(a.r-this.r)*b;this.g+=(a.g-this.g)*b;this.b+=(a.b-this.b)*b;return this},lerpHSL:function(){var a={h:0,s:0,l:0},b={h:0,s:0,l:0};return function(c,d){this.getHSL(a);c.getHSL(b);c=R.lerp(a.h,b.h,d);var e=R.lerp(a.s,b.s,d);d=R.lerp(a.l,b.l,d);this.setHSL(c,e,d);return this}}(),equals:function(a){return a.r===this.r&&a.g===this.g&&a.b===this.b},fromArray:function(a,b){void 0===b&&(b=0);this.r=a[b];this.g=a[b+1];this.b=a[b+2];return this},toArray:function(a,
b){void 0===a&&(a=[]);void 0===b&&(b=0);a[b]=this.r;a[b+1]=this.g;a[b+2]=this.b;return a},toJSON:function(){return this.getHex()}});var F={common:{diffuse:{value:new J(15658734)},opacity:{value:1},map:{value:null},uvTransform:{value:new da},alphaMap:{value:null}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},
lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new z(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:2.5E-4},fogNear:{value:1},fogFar:{value:2E3},fogColor:{value:new J(16777215)}},
lights:{ambientLightColor:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{},shadow:{},shadowBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{},shadow:{},shadowBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},
decay:{},distance:{},shadow:{},shadowBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}}},points:{diffuse:{value:new J(15658734)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},uvTransform:{value:new da}},sprite:{diffuse:{value:new J(15658734)},
opacity:{value:1},center:{value:new z(.5,.5)},rotation:{value:0},map:{value:null},uvTransform:{value:new da}}},Qa={basic:{uniforms:ua([F.common,F.specularmap,F.envmap,F.aomap,F.lightmap,F.fog]),vertexShader:I.meshbasic_vert,fragmentShader:I.meshbasic_frag},lambert:{uniforms:ua([F.common,F.specularmap,F.envmap,F.aomap,F.lightmap,F.emissivemap,F.fog,F.lights,{emissive:{value:new J(0)}}]),vertexShader:I.meshlambert_vert,fragmentShader:I.meshlambert_frag},phong:{uniforms:ua([F.common,F.specularmap,F.envmap,
F.aomap,F.lightmap,F.emissivemap,F.bumpmap,F.normalmap,F.displacementmap,F.gradientmap,F.fog,F.lights,{emissive:{value:new J(0)},specular:{value:new J(1118481)},shininess:{value:30}}]),vertexShader:I.meshphong_vert,fragmentShader:I.meshphong_frag},standard:{uniforms:ua([F.common,F.envmap,F.aomap,F.lightmap,F.emissivemap,F.bumpmap,F.normalmap,F.displacementmap,F.roughnessmap,F.metalnessmap,F.fog,F.lights,{emissive:{value:new J(0)},roughness:{value:.5},metalness:{value:.5},envMapIntensity:{value:1}}]),
vertexShader:I.meshphysical_vert,fragmentShader:I.meshphysical_frag},matcap:{uniforms:ua([F.common,F.bumpmap,F.normalmap,F.displacementmap,F.fog,{matcap:{value:null}}]),vertexShader:I.meshmatcap_vert,fragmentShader:I.meshmatcap_frag},points:{uniforms:ua([F.points,F.fog]),vertexShader:I.points_vert,fragmentShader:I.points_frag},dashed:{uniforms:ua([F.common,F.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:I.linedashed_vert,fragmentShader:I.linedashed_frag},depth:{uniforms:ua([F.common,
F.displacementmap]),vertexShader:I.depth_vert,fragmentShader:I.depth_frag},normal:{uniforms:ua([F.common,F.bumpmap,F.normalmap,F.displacementmap,{opacity:{value:1}}]),vertexShader:I.normal_vert,fragmentShader:I.normal_frag},sprite:{uniforms:ua([F.sprite,F.fog]),vertexShader:I.sprite_vert,fragmentShader:I.sprite_frag},background:{uniforms:{uvTransform:{value:new da},t2D:{value:null}},vertexShader:I.background_vert,fragmentShader:I.background_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},
opacity:{value:1}},vertexShader:I.cube_vert,fragmentShader:I.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:I.equirect_vert,fragmentShader:I.equirect_frag},distanceRGBA:{uniforms:ua([F.common,F.displacementmap,{referencePosition:{value:new n},nearDistance:{value:1},farDistance:{value:1E3}}]),vertexShader:I.distanceRGBA_vert,fragmentShader:I.distanceRGBA_frag},shadow:{uniforms:ua([F.lights,F.fog,{color:{value:new J(0)},opacity:{value:1}}]),vertexShader:I.shadow_vert,fragmentShader:I.shadow_frag}};
Qa.physical={uniforms:ua([Qa.standard.uniforms,{clearCoat:{value:0},clearCoatRoughness:{value:0}}]),vertexShader:I.meshphysical_vert,fragmentShader:I.meshphysical_frag};Object.assign(Kb.prototype,{clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.a=a.a;this.b=a.b;this.c=a.c;this.normal.copy(a.normal);this.color.copy(a.color);this.materialIndex=a.materialIndex;for(var b=0,c=a.vertexNormals.length;b<c;b++)this.vertexNormals[b]=a.vertexNormals[b].clone();b=0;for(c=a.vertexColors.length;b<
c;b++)this.vertexColors[b]=a.vertexColors[b].clone();return this}});lb.RotationOrders="XYZ YZX ZXY XZY YXZ ZYX".split(" ");lb.DefaultOrder="XYZ";Object.defineProperties(lb.prototype,{x:{get:function(){return this._x},set:function(a){this._x=a;this.onChangeCallback()}},y:{get:function(){return this._y},set:function(a){this._y=a;this.onChangeCallback()}},z:{get:function(){return this._z},set:function(a){this._z=a;this.onChangeCallback()}},order:{get:function(){return this._order},set:function(a){this._order=
a;this.onChangeCallback()}}});Object.assign(lb.prototype,{isEuler:!0,set:function(a,b,c,d){this._x=a;this._y=b;this._z=c;this._order=d||this._order;this.onChangeCallback();return this},clone:function(){return new this.constructor(this._x,this._y,this._z,this._order)},copy:function(a){this._x=a._x;this._y=a._y;this._z=a._z;this._order=a._order;this.onChangeCallback();return this},setFromRotationMatrix:function(a,b,c){var d=R.clamp,e=a.elements;a=e[0];var f=e[4],g=e[8],h=e[1],k=e[5],m=e[9],l=e[2],p=
e[6];e=e[10];b=b||this._order;"XYZ"===b?(this._y=Math.asin(d(g,-1,1)),.99999>Math.abs(g)?(this._x=Math.atan2(-m,e),this._z=Math.atan2(-f,a)):(this._x=Math.atan2(p,k),this._z=0)):"YXZ"===b?(this._x=Math.asin(-d(m,-1,1)),.99999>Math.abs(m)?(this._y=Math.atan2(g,e),this._z=Math.atan2(h,k)):(this._y=Math.atan2(-l,a),this._z=0)):"ZXY"===b?(this._x=Math.asin(d(p,-1,1)),.99999>Math.abs(p)?(this._y=Math.atan2(-l,e),this._z=Math.atan2(-f,k)):(this._y=0,this._z=Math.atan2(h,a))):"ZYX"===b?(this._y=Math.asin(-d(l,
-1,1)),.99999>Math.abs(l)?(this._x=Math.atan2(p,e),this._z=Math.atan2(h,a)):(this._x=0,this._z=Math.atan2(-f,k))):"YZX"===b?(this._z=Math.asin(d(h,-1,1)),.99999>Math.abs(h)?(this._x=Math.atan2(-m,k),this._y=Math.atan2(-l,a)):(this._x=0,this._y=Math.atan2(g,e))):"XZY"===b?(this._z=Math.asin(-d(f,-1,1)),.99999>Math.abs(f)?(this._x=Math.atan2(p,k),this._y=Math.atan2(g,a)):(this._x=Math.atan2(-m,e),this._y=0)):console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: "+b);this._order=
b;if(!1!==c)this.onChangeCallback();return this},setFromQuaternion:function(){var a=new O;return function(b,c,d){a.makeRotationFromQuaternion(b);return this.setFromRotationMatrix(a,c,d)}}(),setFromVector3:function(a,b){return this.set(a.x,a.y,a.z,b||this._order)},reorder:function(){var a=new ka;return function(b){a.setFromEuler(this);return this.setFromQuaternion(a,b)}}(),equals:function(a){return a._x===this._x&&a._y===this._y&&a._z===this._z&&a._order===this._order},fromArray:function(a){this._x=
a[0];this._y=a[1];this._z=a[2];void 0!==a[3]&&(this._order=a[3]);this.onChangeCallback();return this},toArray:function(a,b){void 0===a&&(a=[]);void 0===b&&(b=0);a[b]=this._x;a[b+1]=this._y;a[b+2]=this._z;a[b+3]=this._order;return a},toVector3:function(a){return a?a.set(this._x,this._y,this._z):new n(this._x,this._y,this._z)},onChange:function(a){this.onChangeCallback=a;return this},onChangeCallback:function(){}});Object.assign(Xd.prototype,{set:function(a){this.mask=1<<a|0},enable:function(a){this.mask=
this.mask|1<<a|0},toggle:function(a){this.mask^=1<<a|0},disable:function(a){this.mask&=~(1<<a|0)},test:function(a){return 0!==(this.mask&a.mask)}});var Of=0;C.DefaultUp=new n(0,1,0);C.DefaultMatrixAutoUpdate=!0;C.prototype=Object.assign(Object.create(ja.prototype),{constructor:C,isObject3D:!0,onBeforeRender:function(){},onAfterRender:function(){},applyMatrix:function(a){this.matrix.multiplyMatrices(a,this.matrix);this.matrix.decompose(this.position,this.quaternion,this.scale)},applyQuaternion:function(a){this.quaternion.premultiply(a);
return this},setRotationFromAxisAngle:function(a,b){this.quaternion.setFromAxisAngle(a,b)},setRotationFromEuler:function(a){this.quaternion.setFromEuler(a,!0)},setRotationFromMatrix:function(a){this.quaternion.setFromRotationMatrix(a)},setRotationFromQuaternion:function(a){this.quaternion.copy(a)},rotateOnAxis:function(){var a=new ka;return function(b,c){a.setFromAxisAngle(b,c);this.quaternion.multiply(a);return this}}(),rotateOnWorldAxis:function(){var a=new ka;return function(b,c){a.setFromAxisAngle(b,
c);this.quaternion.premultiply(a);return this}}(),rotateX:function(){var a=new n(1,0,0);return function(b){return this.rotateOnAxis(a,b)}}(),rotateY:function(){var a=new n(0,1,0);return function(b){return this.rotateOnAxis(a,b)}}(),rotateZ:function(){var a=new n(0,0,1);return function(b){return this.rotateOnAxis(a,b)}}(),translateOnAxis:function(){var a=new n;return function(b,c){a.copy(b).applyQuaternion(this.quaternion);this.position.add(a.multiplyScalar(c));return this}}(),translateX:function(){var a=
new n(1,0,0);return function(b){return this.translateOnAxis(a,b)}}(),translateY:function(){var a=new n(0,1,0);return function(b){return this.translateOnAxis(a,b)}}(),translateZ:function(){var a=new n(0,0,1);return function(b){return this.translateOnAxis(a,b)}}(),localToWorld:function(a){return a.applyMatrix4(this.matrixWorld)},worldToLocal:function(){var a=new O;return function(b){return b.applyMatrix4(a.getInverse(this.matrixWorld))}}(),lookAt:function(){var a=new ka,b=new O,c=new n,d=new n;return function(e,
f,g){e.isVector3?c.copy(e):c.set(e,f,g);e=this.parent;this.updateWorldMatrix(!0,!1);d.setFromMatrixPosition(this.matrixWorld);this.isCamera?b.lookAt(d,c,this.up):b.lookAt(c,d,this.up);this.quaternion.setFromRotationMatrix(b);e&&(b.extractRotation(e.matrixWorld),a.setFromRotationMatrix(b),this.quaternion.premultiply(a.inverse()))}}(),add:function(a){if(1<arguments.length){for(var b=0;b<arguments.length;b++)this.add(arguments[b]);return this}if(a===this)return console.error("THREE.Object3D.add: object can't be added as a child of itself.",
a),this;a&&a.isObject3D?(null!==a.parent&&a.parent.remove(a),a.parent=this,a.dispatchEvent({type:"added"}),this.children.push(a)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",a);return this},remove:function(a){if(1<arguments.length){for(var b=0;b<arguments.length;b++)this.remove(arguments[b]);return this}b=this.children.indexOf(a);-1!==b&&(a.parent=null,a.dispatchEvent({type:"removed"}),this.children.splice(b,1));return this},getObjectById:function(a){return this.getObjectByProperty("id",
a)},getObjectByName:function(a){return this.getObjectByProperty("name",a)},getObjectByProperty:function(a,b){if(this[a]===b)return this;for(var c=0,d=this.children.length;c<d;c++){var e=this.children[c].getObjectByProperty(a,b);if(void 0!==e)return e}},getWorldPosition:function(a){void 0===a&&(console.warn("THREE.Object3D: .getWorldPosition() target is now required"),a=new n);this.updateMatrixWorld(!0);return a.setFromMatrixPosition(this.matrixWorld)},getWorldQuaternion:function(){var a=new n,b=new n;
return function(c){void 0===c&&(console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),c=new ka);this.updateMatrixWorld(!0);this.matrixWorld.decompose(a,c,b);return c}}(),getWorldScale:function(){var a=new n,b=new ka;return function(c){void 0===c&&(console.warn("THREE.Object3D: .getWorldScale() target is now required"),c=new n);this.updateMatrixWorld(!0);this.matrixWorld.decompose(a,b,c);return c}}(),getWorldDirection:function(a){void 0===a&&(console.warn("THREE.Object3D: .getWorldDirection() target is now required"),
a=new n);this.updateMatrixWorld(!0);var b=this.matrixWorld.elements;return a.set(b[8],b[9],b[10]).normalize()},raycast:function(){},traverse:function(a){a(this);for(var b=this.children,c=0,d=b.length;c<d;c++)b[c].traverse(a)},traverseVisible:function(a){if(!1!==this.visible){a(this);for(var b=this.children,c=0,d=b.length;c<d;c++)b[c].traverseVisible(a)}},traverseAncestors:function(a){var b=this.parent;null!==b&&(a(b),b.traverseAncestors(a))},updateMatrix:function(){this.matrix.compose(this.position,
this.quaternion,this.scale);this.matrixWorldNeedsUpdate=!0},updateMatrixWorld:function(a){this.matrixAutoUpdate&&this.updateMatrix();if(this.matrixWorldNeedsUpdate||a)null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,a=!0;for(var b=this.children,c=0,d=b.length;c<d;c++)b[c].updateMatrixWorld(a)},updateWorldMatrix:function(a,b){var c=this.parent;!0===a&&null!==c&&c.updateWorldMatrix(!0,!1);this.matrixAutoUpdate&&
this.updateMatrix();null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix);if(!0===b)for(a=this.children,b=0,c=a.length;b<c;b++)a[b].updateWorldMatrix(!1,!0)},toJSON:function(a){function b(b,c){void 0===b[c.uuid]&&(b[c.uuid]=c.toJSON(a));return c.uuid}function c(a){var b=[],c;for(c in a){var d=a[c];delete d.metadata;b.push(d)}return b}var d=void 0===a||"string"===typeof a,e={};d&&(a={geometries:{},materials:{},textures:{},images:{},
shapes:{}},e.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});var f={};f.uuid=this.uuid;f.type=this.type;""!==this.name&&(f.name=this.name);!0===this.castShadow&&(f.castShadow=!0);!0===this.receiveShadow&&(f.receiveShadow=!0);!1===this.visible&&(f.visible=!1);!1===this.frustumCulled&&(f.frustumCulled=!1);0!==this.renderOrder&&(f.renderOrder=this.renderOrder);"{}"!==JSON.stringify(this.userData)&&(f.userData=this.userData);f.layers=this.layers.mask;f.matrix=this.matrix.toArray();!1===
this.matrixAutoUpdate&&(f.matrixAutoUpdate=!1);if(this.isMesh||this.isLine||this.isPoints){f.geometry=b(a.geometries,this.geometry);var g=this.geometry.parameters;if(void 0!==g&&void 0!==g.shapes)if(g=g.shapes,Array.isArray(g))for(var h=0,k=g.length;h<k;h++)b(a.shapes,g[h]);else b(a.shapes,g)}if(void 0!==this.material)if(Array.isArray(this.material)){g=[];h=0;for(k=this.material.length;h<k;h++)g.push(b(a.materials,this.material[h]));f.material=g}else f.material=b(a.materials,this.material);if(0<this.children.length)for(f.children=
[],h=0;h<this.children.length;h++)f.children.push(this.children[h].toJSON(a).object);if(d){d=c(a.geometries);h=c(a.materials);k=c(a.textures);var m=c(a.images);g=c(a.shapes);0<d.length&&(e.geometries=d);0<h.length&&(e.materials=h);0<k.length&&(e.textures=k);0<m.length&&(e.images=m);0<g.length&&(e.shapes=g)}e.object=f;return e},clone:function(a){return(new this.constructor).copy(this,a)},copy:function(a,b){void 0===b&&(b=!0);this.name=a.name;this.up.copy(a.up);this.position.copy(a.position);this.quaternion.copy(a.quaternion);
this.scale.copy(a.scale);this.matrix.copy(a.matrix);this.matrixWorld.copy(a.matrixWorld);this.matrixAutoUpdate=a.matrixAutoUpdate;this.matrixWorldNeedsUpdate=a.matrixWorldNeedsUpdate;this.layers.mask=a.layers.mask;this.visible=a.visible;this.castShadow=a.castShadow;this.receiveShadow=a.receiveShadow;this.frustumCulled=a.frustumCulled;this.renderOrder=a.renderOrder;this.userData=JSON.parse(JSON.stringify(a.userData));if(!0===b)for(b=0;b<a.children.length;b++)this.add(a.children[b].clone());return this}});
var Pf=0;Q.prototype=Object.assign(Object.create(ja.prototype),{constructor:Q,isGeometry:!0,applyMatrix:function(a){for(var b=(new da).getNormalMatrix(a),c=0,d=this.vertices.length;c<d;c++)this.vertices[c].applyMatrix4(a);c=0;for(d=this.faces.length;c<d;c++){a=this.faces[c];a.normal.applyMatrix3(b).normalize();for(var e=0,f=a.vertexNormals.length;e<f;e++)a.vertexNormals[e].applyMatrix3(b).normalize()}null!==this.boundingBox&&this.computeBoundingBox();null!==this.boundingSphere&&this.computeBoundingSphere();
this.normalsNeedUpdate=this.verticesNeedUpdate=!0;return this},rotateX:function(){var a=new O;return function(b){a.makeRotationX(b);this.applyMatrix(a);return this}}(),rotateY:function(){var a=new O;return function(b){a.makeRotationY(b);this.applyMatrix(a);return this}}(),rotateZ:function(){var a=new O;return function(b){a.makeRotationZ(b);this.applyMatrix(a);return this}}(),translate:function(){var a=new O;return function(b,c,d){a.makeTranslation(b,c,d);this.applyMatrix(a);return this}}(),scale:function(){var a=
new O;return function(b,c,d){a.makeScale(b,c,d);this.applyMatrix(a);return this}}(),lookAt:function(){var a=new C;return function(b){a.lookAt(b);a.updateMatrix();this.applyMatrix(a.matrix)}}(),fromBufferGeometry:function(a){function b(a,b,d,e){var f=void 0===h?[]:[c.colors[a].clone(),c.colors[b].clone(),c.colors[d].clone()],l=void 0===g?[]:[(new n).fromArray(g,3*a),(new n).fromArray(g,3*b),(new n).fromArray(g,3*d)];e=new Kb(a,b,d,l,f,e);c.faces.push(e);void 0!==k&&c.faceVertexUvs[0].push([(new z).fromArray(k,
2*a),(new z).fromArray(k,2*b),(new z).fromArray(k,2*d)]);void 0!==m&&c.faceVertexUvs[1].push([(new z).fromArray(m,2*a),(new z).fromArray(m,2*b),(new z).fromArray(m,2*d)])}var c=this,d=null!==a.index?a.index.array:void 0,e=a.attributes,f=e.position.array,g=void 0!==e.normal?e.normal.array:void 0,h=void 0!==e.color?e.color.array:void 0,k=void 0!==e.uv?e.uv.array:void 0,m=void 0!==e.uv2?e.uv2.array:void 0;void 0!==m&&(this.faceVertexUvs[1]=[]);for(var l=e=0;e<f.length;e+=3,l+=2)c.vertices.push((new n).fromArray(f,
e)),void 0!==h&&c.colors.push((new J).fromArray(h,e));var p=a.groups;if(0<p.length)for(e=0;e<p.length;e++){f=p[e];var r=f.start,x=f.count;l=r;for(r+=x;l<r;l+=3)void 0!==d?b(d[l],d[l+1],d[l+2],f.materialIndex):b(l,l+1,l+2,f.materialIndex)}else if(void 0!==d)for(e=0;e<d.length;e+=3)b(d[e],d[e+1],d[e+2]);else for(e=0;e<f.length/3;e+=3)b(e,e+1,e+2);this.computeFaceNormals();null!==a.boundingBox&&(this.boundingBox=a.boundingBox.clone());null!==a.boundingSphere&&(this.boundingSphere=a.boundingSphere.clone());
return this},center:function(){var a=new n;return function(){this.computeBoundingBox();this.boundingBox.getCenter(a).negate();this.translate(a.x,a.y,a.z);return this}}(),normalize:function(){this.computeBoundingSphere();var a=this.boundingSphere.center,b=this.boundingSphere.radius;b=0===b?1:1/b;var c=new O;c.set(b,0,0,-b*a.x,0,b,0,-b*a.y,0,0,b,-b*a.z,0,0,0,1);this.applyMatrix(c);return this},computeFaceNormals:function(){for(var a=new n,b=new n,c=0,d=this.faces.length;c<d;c++){var e=this.faces[c],
f=this.vertices[e.a],g=this.vertices[e.b];a.subVectors(this.vertices[e.c],g);b.subVectors(f,g);a.cross(b);a.normalize();e.normal.copy(a)}},computeVertexNormals:function(a){void 0===a&&(a=!0);var b;var c=Array(this.vertices.length);var d=0;for(b=this.vertices.length;d<b;d++)c[d]=new n;if(a){var e=new n,f=new n;a=0;for(d=this.faces.length;a<d;a++){b=this.faces[a];var g=this.vertices[b.a];var h=this.vertices[b.b];var k=this.vertices[b.c];e.subVectors(k,h);f.subVectors(g,h);e.cross(f);c[b.a].add(e);c[b.b].add(e);
c[b.c].add(e)}}else for(this.computeFaceNormals(),a=0,d=this.faces.length;a<d;a++)b=this.faces[a],c[b.a].add(b.normal),c[b.b].add(b.normal),c[b.c].add(b.normal);d=0;for(b=this.vertices.length;d<b;d++)c[d].normalize();a=0;for(d=this.faces.length;a<d;a++)b=this.faces[a],g=b.vertexNormals,3===g.length?(g[0].copy(c[b.a]),g[1].copy(c[b.b]),g[2].copy(c[b.c])):(g[0]=c[b.a].clone(),g[1]=c[b.b].clone(),g[2]=c[b.c].clone());0<this.faces.length&&(this.normalsNeedUpdate=!0)},computeFlatVertexNormals:function(){var a;
this.computeFaceNormals();var b=0;for(a=this.faces.length;b<a;b++){var c=this.faces[b];var d=c.vertexNormals;3===d.length?(d[0].copy(c.normal),d[1].copy(c.normal),d[2].copy(c.normal)):(d[0]=c.normal.clone(),d[1]=c.normal.clone(),d[2]=c.normal.clone())}0<this.faces.length&&(this.normalsNeedUpdate=!0)},computeMorphNormals:function(){var a,b;var c=0;for(b=this.faces.length;c<b;c++){var d=this.faces[c];d.__originalFaceNormal?d.__originalFaceNormal.copy(d.normal):d.__originalFaceNormal=d.normal.clone();
d.__originalVertexNormals||(d.__originalVertexNormals=[]);var e=0;for(a=d.vertexNormals.length;e<a;e++)d.__originalVertexNormals[e]?d.__originalVertexNormals[e].copy(d.vertexNormals[e]):d.__originalVertexNormals[e]=d.vertexNormals[e].clone()}var f=new Q;f.faces=this.faces;e=0;for(a=this.morphTargets.length;e<a;e++){if(!this.morphNormals[e]){this.morphNormals[e]={};this.morphNormals[e].faceNormals=[];this.morphNormals[e].vertexNormals=[];d=this.morphNormals[e].faceNormals;var g=this.morphNormals[e].vertexNormals;
c=0;for(b=this.faces.length;c<b;c++){var h=new n;var k={a:new n,b:new n,c:new n};d.push(h);g.push(k)}}g=this.morphNormals[e];f.vertices=this.morphTargets[e].vertices;f.computeFaceNormals();f.computeVertexNormals();c=0;for(b=this.faces.length;c<b;c++)d=this.faces[c],h=g.faceNormals[c],k=g.vertexNormals[c],h.copy(d.normal),k.a.copy(d.vertexNormals[0]),k.b.copy(d.vertexNormals[1]),k.c.copy(d.vertexNormals[2])}c=0;for(b=this.faces.length;c<b;c++)d=this.faces[c],d.normal=d.__originalFaceNormal,d.vertexNormals=
d.__originalVertexNormals},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new Wa);this.boundingBox.setFromPoints(this.vertices)},computeBoundingSphere:function(){null===this.boundingSphere&&(this.boundingSphere=new Ea);this.boundingSphere.setFromPoints(this.vertices)},merge:function(a,b,c){if(a&&a.isGeometry){var d,e=this.vertices.length,f=this.vertices,g=a.vertices,h=this.faces,k=a.faces,m=this.faceVertexUvs[0],l=a.faceVertexUvs[0],p=this.colors,r=a.colors;void 0===c&&(c=
0);void 0!==b&&(d=(new da).getNormalMatrix(b));a=0;for(var n=g.length;a<n;a++){var t=g[a].clone();void 0!==b&&t.applyMatrix4(b);f.push(t)}a=0;for(n=r.length;a<n;a++)p.push(r[a].clone());a=0;for(n=k.length;a<n;a++){g=k[a];var v=g.vertexNormals;r=g.vertexColors;p=new Kb(g.a+e,g.b+e,g.c+e);p.normal.copy(g.normal);void 0!==d&&p.normal.applyMatrix3(d).normalize();b=0;for(f=v.length;b<f;b++)t=v[b].clone(),void 0!==d&&t.applyMatrix3(d).normalize(),p.vertexNormals.push(t);p.color.copy(g.color);b=0;for(f=
r.length;b<f;b++)t=r[b],p.vertexColors.push(t.clone());p.materialIndex=g.materialIndex+c;h.push(p)}a=0;for(n=l.length;a<n;a++)if(c=l[a],d=[],void 0!==c){b=0;for(f=c.length;b<f;b++)d.push(c[b].clone());m.push(d)}}else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",a)},mergeMesh:function(a){a&&a.isMesh?(a.matrixAutoUpdate&&a.updateMatrix(),this.merge(a.geometry,a.matrix)):console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",a)},mergeVertices:function(){var a=
{},b=[],c=[],d=Math.pow(10,4),e;var f=0;for(e=this.vertices.length;f<e;f++){var g=this.vertices[f];g=Math.round(g.x*d)+"_"+Math.round(g.y*d)+"_"+Math.round(g.z*d);void 0===a[g]?(a[g]=f,b.push(this.vertices[f]),c[f]=b.length-1):c[f]=c[a[g]]}a=[];f=0;for(e=this.faces.length;f<e;f++)for(d=this.faces[f],d.a=c[d.a],d.b=c[d.b],d.c=c[d.c],d=[d.a,d.b,d.c],g=0;3>g;g++)if(d[g]===d[(g+1)%3]){a.push(f);break}for(f=a.length-1;0<=f;f--)for(d=a[f],this.faces.splice(d,1),c=0,e=this.faceVertexUvs.length;c<e;c++)this.faceVertexUvs[c].splice(d,
1);f=this.vertices.length-b.length;this.vertices=b;return f},setFromPoints:function(a){this.vertices=[];for(var b=0,c=a.length;b<c;b++){var d=a[b];this.vertices.push(new n(d.x,d.y,d.z||0))}return this},sortFacesByMaterialIndex:function(){for(var a=this.faces,b=a.length,c=0;c<b;c++)a[c]._id=c;a.sort(function(a,b){return a.materialIndex-b.materialIndex});var d=this.faceVertexUvs[0],e=this.faceVertexUvs[1],f,g;d&&d.length===b&&(f=[]);e&&e.length===b&&(g=[]);for(c=0;c<b;c++){var h=a[c]._id;f&&f.push(d[h]);
g&&g.push(e[h])}f&&(this.faceVertexUvs[0]=f);g&&(this.faceVertexUvs[1]=g)},toJSON:function(){function a(a,b,c){return c?a|1<<b:a&~(1<<b)}function b(a){var b=a.x.toString()+a.y.toString()+a.z.toString();if(void 0!==m[b])return m[b];m[b]=k.length/3;k.push(a.x,a.y,a.z);return m[b]}function c(a){var b=a.r.toString()+a.g.toString()+a.b.toString();if(void 0!==p[b])return p[b];p[b]=l.length;l.push(a.getHex());return p[b]}function d(a){var b=a.x.toString()+a.y.toString();if(void 0!==n[b])return n[b];n[b]=
r.length/2;r.push(a.x,a.y);return n[b]}var e={metadata:{version:4.5,type:"Geometry",generator:"Geometry.toJSON"}};e.uuid=this.uuid;e.type=this.type;""!==this.name&&(e.name=this.name);if(void 0!==this.parameters){var f=this.parameters,g;for(g in f)void 0!==f[g]&&(e[g]=f[g]);return e}f=[];for(g=0;g<this.vertices.length;g++){var h=this.vertices[g];f.push(h.x,h.y,h.z)}h=[];var k=[],m={},l=[],p={},r=[],n={};for(g=0;g<this.faces.length;g++){var t=this.faces[g],v=void 0!==this.faceVertexUvs[0][g],w=0<t.normal.length(),
y=0<t.vertexNormals.length,u=1!==t.color.r||1!==t.color.g||1!==t.color.b,z=0<t.vertexColors.length,G=0;G=a(G,0,0);G=a(G,1,!0);G=a(G,2,!1);G=a(G,3,v);G=a(G,4,w);G=a(G,5,y);G=a(G,6,u);G=a(G,7,z);h.push(G);h.push(t.a,t.b,t.c);h.push(t.materialIndex);v&&(v=this.faceVertexUvs[0][g],h.push(d(v[0]),d(v[1]),d(v[2])));w&&h.push(b(t.normal));y&&(w=t.vertexNormals,h.push(b(w[0]),b(w[1]),b(w[2])));u&&h.push(c(t.color));z&&(t=t.vertexColors,h.push(c(t[0]),c(t[1]),c(t[2])))}e.data={};e.data.vertices=f;e.data.normals=
k;0<l.length&&(e.data.colors=l);0<r.length&&(e.data.uvs=[r]);e.data.faces=h;return e},clone:function(){return(new Q).copy(this)},copy:function(a){var b,c,d;this.vertices=[];this.colors=[];this.faces=[];this.faceVertexUvs=[[]];this.morphTargets=[];this.morphNormals=[];this.skinWeights=[];this.skinIndices=[];this.lineDistances=[];this.boundingSphere=this.boundingBox=null;this.name=a.name;var e=a.vertices;var f=0;for(b=e.length;f<b;f++)this.vertices.push(e[f].clone());e=a.colors;f=0;for(b=e.length;f<
b;f++)this.colors.push(e[f].clone());e=a.faces;f=0;for(b=e.length;f<b;f++)this.faces.push(e[f].clone());f=0;for(b=a.faceVertexUvs.length;f<b;f++){var g=a.faceVertexUvs[f];void 0===this.faceVertexUvs[f]&&(this.faceVertexUvs[f]=[]);e=0;for(c=g.length;e<c;e++){var h=g[e],k=[];var m=0;for(d=h.length;m<d;m++)k.push(h[m].clone());this.faceVertexUvs[f].push(k)}}m=a.morphTargets;f=0;for(b=m.length;f<b;f++){d={};d.name=m[f].name;if(void 0!==m[f].vertices)for(d.vertices=[],e=0,c=m[f].vertices.length;e<c;e++)d.vertices.push(m[f].vertices[e].clone());
if(void 0!==m[f].normals)for(d.normals=[],e=0,c=m[f].normals.length;e<c;e++)d.normals.push(m[f].normals[e].clone());this.morphTargets.push(d)}m=a.morphNormals;f=0;for(b=m.length;f<b;f++){d={};if(void 0!==m[f].vertexNormals)for(d.vertexNormals=[],e=0,c=m[f].vertexNormals.length;e<c;e++)g=m[f].vertexNormals[e],h={},h.a=g.a.clone(),h.b=g.b.clone(),h.c=g.c.clone(),d.vertexNormals.push(h);if(void 0!==m[f].faceNormals)for(d.faceNormals=[],e=0,c=m[f].faceNormals.length;e<c;e++)d.faceNormals.push(m[f].faceNormals[e].clone());
this.morphNormals.push(d)}e=a.skinWeights;f=0;for(b=e.length;f<b;f++)this.skinWeights.push(e[f].clone());e=a.skinIndices;f=0;for(b=e.length;f<b;f++)this.skinIndices.push(e[f].clone());e=a.lineDistances;f=0;for(b=e.length;f<b;f++)this.lineDistances.push(e[f]);f=a.boundingBox;null!==f&&(this.boundingBox=f.clone());f=a.boundingSphere;null!==f&&(this.boundingSphere=f.clone());this.elementsNeedUpdate=a.elementsNeedUpdate;this.verticesNeedUpdate=a.verticesNeedUpdate;this.uvsNeedUpdate=a.uvsNeedUpdate;this.normalsNeedUpdate=
a.normalsNeedUpdate;this.colorsNeedUpdate=a.colorsNeedUpdate;this.lineDistancesNeedUpdate=a.lineDistancesNeedUpdate;this.groupsNeedUpdate=a.groupsNeedUpdate;return this},dispose:function(){this.dispatchEvent({type:"dispose"})}});Object.defineProperty(E.prototype,"needsUpdate",{set:function(a){!0===a&&this.version++}});Object.assign(E.prototype,{isBufferAttribute:!0,onUploadCallback:function(){},setArray:function(a){if(Array.isArray(a))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
this.count=void 0!==a?a.length/this.itemSize:0;this.array=a;return this},setDynamic:function(a){this.dynamic=a;return this},copy:function(a){this.name=a.name;this.array=new a.array.constructor(a.array);this.itemSize=a.itemSize;this.count=a.count;this.normalized=a.normalized;this.dynamic=a.dynamic;return this},copyAt:function(a,b,c){a*=this.itemSize;c*=b.itemSize;for(var d=0,e=this.itemSize;d<e;d++)this.array[a+d]=b.array[c+d];return this},copyArray:function(a){this.array.set(a);return this},copyColorsArray:function(a){for(var b=
this.array,c=0,d=0,e=a.length;d<e;d++){var f=a[d];void 0===f&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",d),f=new J);b[c++]=f.r;b[c++]=f.g;b[c++]=f.b}return this},copyVector2sArray:function(a){for(var b=this.array,c=0,d=0,e=a.length;d<e;d++){var f=a[d];void 0===f&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",d),f=new z);b[c++]=f.x;b[c++]=f.y}return this},copyVector3sArray:function(a){for(var b=this.array,c=0,d=0,e=a.length;d<e;d++){var f=
a[d];void 0===f&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",d),f=new n);b[c++]=f.x;b[c++]=f.y;b[c++]=f.z}return this},copyVector4sArray:function(a){for(var b=this.array,c=0,d=0,e=a.length;d<e;d++){var f=a[d];void 0===f&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",d),f=new ca);b[c++]=f.x;b[c++]=f.y;b[c++]=f.z;b[c++]=f.w}return this},set:function(a,b){void 0===b&&(b=0);this.array.set(a,b);return this},getX:function(a){return this.array[a*
this.itemSize]},setX:function(a,b){this.array[a*this.itemSize]=b;return this},getY:function(a){return this.array[a*this.itemSize+1]},setY:function(a,b){this.array[a*this.itemSize+1]=b;return this},getZ:function(a){return this.array[a*this.itemSize+2]},setZ:function(a,b){this.array[a*this.itemSize+2]=b;return this},getW:function(a){return this.array[a*this.itemSize+3]},setW:function(a,b){this.array[a*this.itemSize+3]=b;return this},setXY:function(a,b,c){a*=this.itemSize;this.array[a+0]=b;this.array[a+
1]=c;return this},setXYZ:function(a,b,c,d){a*=this.itemSize;this.array[a+0]=b;this.array[a+1]=c;this.array[a+2]=d;return this},setXYZW:function(a,b,c,d,e){a*=this.itemSize;this.array[a+0]=b;this.array[a+1]=c;this.array[a+2]=d;this.array[a+3]=e;return this},onUpload:function(a){this.onUploadCallback=a;return this},clone:function(){return(new this.constructor(this.array,this.itemSize)).copy(this)}});tc.prototype=Object.create(E.prototype);tc.prototype.constructor=tc;uc.prototype=Object.create(E.prototype);
uc.prototype.constructor=uc;vc.prototype=Object.create(E.prototype);vc.prototype.constructor=vc;wc.prototype=Object.create(E.prototype);wc.prototype.constructor=wc;mb.prototype=Object.create(E.prototype);mb.prototype.constructor=mb;xc.prototype=Object.create(E.prototype);xc.prototype.constructor=xc;nb.prototype=Object.create(E.prototype);nb.prototype.constructor=nb;B.prototype=Object.create(E.prototype);B.prototype.constructor=B;yc.prototype=Object.create(E.prototype);yc.prototype.constructor=yc;
Object.assign(Je.prototype,{computeGroups:function(a){var b=[],c=void 0;a=a.faces;for(var d=0;d<a.length;d++){var e=a[d];if(e.materialIndex!==c){c=e.materialIndex;void 0!==f&&(f.count=3*d-f.start,b.push(f));var f={start:3*d,materialIndex:c}}}void 0!==f&&(f.count=3*d-f.start,b.push(f));this.groups=b},fromGeometry:function(a){var b=a.faces,c=a.vertices,d=a.faceVertexUvs,e=d[0]&&0<d[0].length,f=d[1]&&0<d[1].length,g=a.morphTargets,h=g.length;if(0<h){var k=[];for(var m=0;m<h;m++)k[m]={name:g[m].name,
data:[]};this.morphTargets.position=k}var l=a.morphNormals,p=l.length;if(0<p){var r=[];for(m=0;m<p;m++)r[m]={name:l[m].name,data:[]};this.morphTargets.normal=r}var n=a.skinIndices,t=a.skinWeights,v=n.length===c.length,w=t.length===c.length;0<c.length&&0===b.length&&console.error("THREE.DirectGeometry: Faceless geometries are not supported.");for(m=0;m<b.length;m++){var y=b[m];this.vertices.push(c[y.a],c[y.b],c[y.c]);var u=y.vertexNormals;3===u.length?this.normals.push(u[0],u[1],u[2]):(u=y.normal,
this.normals.push(u,u,u));u=y.vertexColors;3===u.length?this.colors.push(u[0],u[1],u[2]):(u=y.color,this.colors.push(u,u,u));!0===e&&(u=d[0][m],void 0!==u?this.uvs.push(u[0],u[1],u[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",m),this.uvs.push(new z,new z,new z)));!0===f&&(u=d[1][m],void 0!==u?this.uvs2.push(u[0],u[1],u[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",m),this.uvs2.push(new z,new z,new z)));for(u=0;u<h;u++){var H=g[u].vertices;
k[u].data.push(H[y.a],H[y.b],H[y.c])}for(u=0;u<p;u++)H=l[u].vertexNormals[m],r[u].data.push(H.a,H.b,H.c);v&&this.skinIndices.push(n[y.a],n[y.b],n[y.c]);w&&this.skinWeights.push(t[y.a],t[y.b],t[y.c])}this.computeGroups(a);this.verticesNeedUpdate=a.verticesNeedUpdate;this.normalsNeedUpdate=a.normalsNeedUpdate;this.colorsNeedUpdate=a.colorsNeedUpdate;this.uvsNeedUpdate=a.uvsNeedUpdate;this.groupsNeedUpdate=a.groupsNeedUpdate;return this}});var Qf=1;D.prototype=Object.assign(Object.create(ja.prototype),
{constructor:D,isBufferGeometry:!0,getIndex:function(){return this.index},setIndex:function(a){Array.isArray(a)?this.index=new (65535<Ke(a)?nb:mb)(a,1):this.index=a},addAttribute:function(a,b,c){if(!(b&&b.isBufferAttribute||b&&b.isInterleavedBufferAttribute))return console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.addAttribute(a,new E(b,c));if("index"===a)return console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(b),
this;this.attributes[a]=b;return this},getAttribute:function(a){return this.attributes[a]},removeAttribute:function(a){delete this.attributes[a];return this},addGroup:function(a,b,c){this.groups.push({start:a,count:b,materialIndex:void 0!==c?c:0})},clearGroups:function(){this.groups=[]},setDrawRange:function(a,b){this.drawRange.start=a;this.drawRange.count=b},applyMatrix:function(a){var b=this.attributes.position;void 0!==b&&(a.applyToBufferAttribute(b),b.needsUpdate=!0);b=this.attributes.normal;
void 0!==b&&((new da).getNormalMatrix(a).applyToBufferAttribute(b),b.needsUpdate=!0);null!==this.boundingBox&&this.computeBoundingBox();null!==this.boundingSphere&&this.computeBoundingSphere();return this},rotateX:function(){var a=new O;return function(b){a.makeRotationX(b);this.applyMatrix(a);return this}}(),rotateY:function(){var a=new O;return function(b){a.makeRotationY(b);this.applyMatrix(a);return this}}(),rotateZ:function(){var a=new O;return function(b){a.makeRotationZ(b);this.applyMatrix(a);
return this}}(),translate:function(){var a=new O;return function(b,c,d){a.makeTranslation(b,c,d);this.applyMatrix(a);return this}}(),scale:function(){var a=new O;return function(b,c,d){a.makeScale(b,c,d);this.applyMatrix(a);return this}}(),lookAt:function(){var a=new C;return function(b){a.lookAt(b);a.updateMatrix();this.applyMatrix(a.matrix)}}(),center:function(){var a=new n;return function(){this.computeBoundingBox();this.boundingBox.getCenter(a).negate();this.translate(a.x,a.y,a.z);return this}}(),
setFromObject:function(a){var b=a.geometry;if(a.isPoints||a.isLine){a=new B(3*b.vertices.length,3);var c=new B(3*b.colors.length,3);this.addAttribute("position",a.copyVector3sArray(b.vertices));this.addAttribute("color",c.copyColorsArray(b.colors));b.lineDistances&&b.lineDistances.length===b.vertices.length&&(a=new B(b.lineDistances.length,1),this.addAttribute("lineDistance",a.copyArray(b.lineDistances)));null!==b.boundingSphere&&(this.boundingSphere=b.boundingSphere.clone());null!==b.boundingBox&&
(this.boundingBox=b.boundingBox.clone())}else a.isMesh&&b&&b.isGeometry&&this.fromGeometry(b);return this},setFromPoints:function(a){for(var b=[],c=0,d=a.length;c<d;c++){var e=a[c];b.push(e.x,e.y,e.z||0)}this.addAttribute("position",new B(b,3));return this},updateFromObject:function(a){var b=a.geometry;if(a.isMesh){var c=b.__directGeometry;!0===b.elementsNeedUpdate&&(c=void 0,b.elementsNeedUpdate=!1);if(void 0===c)return this.fromGeometry(b);c.verticesNeedUpdate=b.verticesNeedUpdate;c.normalsNeedUpdate=
b.normalsNeedUpdate;c.colorsNeedUpdate=b.colorsNeedUpdate;c.uvsNeedUpdate=b.uvsNeedUpdate;c.groupsNeedUpdate=b.groupsNeedUpdate;b.verticesNeedUpdate=!1;b.normalsNeedUpdate=!1;b.colorsNeedUpdate=!1;b.uvsNeedUpdate=!1;b.groupsNeedUpdate=!1;b=c}!0===b.verticesNeedUpdate&&(c=this.attributes.position,void 0!==c&&(c.copyVector3sArray(b.vertices),c.needsUpdate=!0),b.verticesNeedUpdate=!1);!0===b.normalsNeedUpdate&&(c=this.attributes.normal,void 0!==c&&(c.copyVector3sArray(b.normals),c.needsUpdate=!0),b.normalsNeedUpdate=
!1);!0===b.colorsNeedUpdate&&(c=this.attributes.color,void 0!==c&&(c.copyColorsArray(b.colors),c.needsUpdate=!0),b.colorsNeedUpdate=!1);b.uvsNeedUpdate&&(c=this.attributes.uv,void 0!==c&&(c.copyVector2sArray(b.uvs),c.needsUpdate=!0),b.uvsNeedUpdate=!1);b.lineDistancesNeedUpdate&&(c=this.attributes.lineDistance,void 0!==c&&(c.copyArray(b.lineDistances),c.needsUpdate=!0),b.lineDistancesNeedUpdate=!1);b.groupsNeedUpdate&&(b.computeGroups(a.geometry),this.groups=b.groups,b.groupsNeedUpdate=!1);return this},
fromGeometry:function(a){a.__directGeometry=(new Je).fromGeometry(a);return this.fromDirectGeometry(a.__directGeometry)},fromDirectGeometry:function(a){var b=new Float32Array(3*a.vertices.length);this.addAttribute("position",(new E(b,3)).copyVector3sArray(a.vertices));0<a.normals.length&&(b=new Float32Array(3*a.normals.length),this.addAttribute("normal",(new E(b,3)).copyVector3sArray(a.normals)));0<a.colors.length&&(b=new Float32Array(3*a.colors.length),this.addAttribute("color",(new E(b,3)).copyColorsArray(a.colors)));
0<a.uvs.length&&(b=new Float32Array(2*a.uvs.length),this.addAttribute("uv",(new E(b,2)).copyVector2sArray(a.uvs)));0<a.uvs2.length&&(b=new Float32Array(2*a.uvs2.length),this.addAttribute("uv2",(new E(b,2)).copyVector2sArray(a.uvs2)));this.groups=a.groups;for(var c in a.morphTargets){b=[];for(var d=a.morphTargets[c],e=0,f=d.length;e<f;e++){var g=d[e],h=new B(3*g.data.length,3);h.name=g.name;b.push(h.copyVector3sArray(g.data))}this.morphAttributes[c]=b}0<a.skinIndices.length&&(c=new B(4*a.skinIndices.length,
4),this.addAttribute("skinIndex",c.copyVector4sArray(a.skinIndices)));0<a.skinWeights.length&&(c=new B(4*a.skinWeights.length,4),this.addAttribute("skinWeight",c.copyVector4sArray(a.skinWeights)));null!==a.boundingSphere&&(this.boundingSphere=a.boundingSphere.clone());null!==a.boundingBox&&(this.boundingBox=a.boundingBox.clone());return this},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new Wa);var a=this.attributes.position;void 0!==a?this.boundingBox.setFromBufferAttribute(a):
this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)},computeBoundingSphere:function(){var a=new Wa,b=new n;return function(){null===this.boundingSphere&&(this.boundingSphere=new Ea);var c=this.attributes.position;if(c){var d=this.boundingSphere.center;a.setFromBufferAttribute(c);
a.getCenter(d);for(var e=0,f=0,g=c.count;f<g;f++)b.x=c.getX(f),b.y=c.getY(f),b.z=c.getZ(f),e=Math.max(e,d.distanceToSquared(b));this.boundingSphere.radius=Math.sqrt(e);isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}}(),computeFaceNormals:function(){},computeVertexNormals:function(){var a=this.index,b=this.attributes;if(b.position){var c=b.position.array;if(void 0===
b.normal)this.addAttribute("normal",new E(new Float32Array(c.length),3));else for(var d=b.normal.array,e=0,f=d.length;e<f;e++)d[e]=0;d=b.normal.array;var g=new n,h=new n,k=new n,m=new n,l=new n;if(a){var p=a.array;e=0;for(f=a.count;e<f;e+=3){a=3*p[e+0];var r=3*p[e+1];var x=3*p[e+2];g.fromArray(c,a);h.fromArray(c,r);k.fromArray(c,x);m.subVectors(k,h);l.subVectors(g,h);m.cross(l);d[a]+=m.x;d[a+1]+=m.y;d[a+2]+=m.z;d[r]+=m.x;d[r+1]+=m.y;d[r+2]+=m.z;d[x]+=m.x;d[x+1]+=m.y;d[x+2]+=m.z}}else for(e=0,f=c.length;e<
f;e+=9)g.fromArray(c,e),h.fromArray(c,e+3),k.fromArray(c,e+6),m.subVectors(k,h),l.subVectors(g,h),m.cross(l),d[e]=m.x,d[e+1]=m.y,d[e+2]=m.z,d[e+3]=m.x,d[e+4]=m.y,d[e+5]=m.z,d[e+6]=m.x,d[e+7]=m.y,d[e+8]=m.z;this.normalizeNormals();b.normal.needsUpdate=!0}},merge:function(a,b){if(a&&a.isBufferGeometry){void 0===b&&(b=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));var c=this.attributes,
d;for(d in c)if(void 0!==a.attributes[d]){var e=c[d].array,f=a.attributes[d],g=f.array,h=0;for(f=f.itemSize*b;h<g.length;h++,f++)e[f]=g[h]}return this}console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",a)},normalizeNormals:function(){var a=new n;return function(){for(var b=this.attributes.normal,c=0,d=b.count;c<d;c++)a.x=b.getX(c),a.y=b.getY(c),a.z=b.getZ(c),a.normalize(),b.setXYZ(c,a.x,a.y,a.z)}}(),toNonIndexed:function(){if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."),
this;var a=new D,b=this.index.array,c=this.attributes,d;for(d in c){var e=c[d],f=e.array,g=e.itemSize,h=new f.constructor(b.length*g),k=0;e=0;for(var m=b.length;e<m;e++){var l=b[e]*g;for(var p=0;p<g;p++)h[k++]=f[l++]}a.addAttribute(d,new E(h,g))}b=this.groups;e=0;for(m=b.length;e<m;e++)c=b[e],a.addGroup(c.start,c.count,c.materialIndex);return a},toJSON:function(){var a={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};a.uuid=this.uuid;a.type=this.type;""!==this.name&&
(a.name=this.name);0<Object.keys(this.userData).length&&(a.userData=this.userData);if(void 0!==this.parameters){var b=this.parameters;for(e in b)void 0!==b[e]&&(a[e]=b[e]);return a}a.data={attributes:{}};var c=this.index;null!==c&&(b=Array.prototype.slice.call(c.array),a.data.index={type:c.array.constructor.name,array:b});c=this.attributes;for(e in c){var d=c[e];b=Array.prototype.slice.call(d.array);a.data.attributes[e]={itemSize:d.itemSize,type:d.array.constructor.name,array:b,normalized:d.normalized}}var e=
this.groups;0<e.length&&(a.data.groups=JSON.parse(JSON.stringify(e)));e=this.boundingSphere;null!==e&&(a.data.boundingSphere={center:e.center.toArray(),radius:e.radius});return a},clone:function(){return(new D).copy(this)},copy:function(a){var b;this.index=null;this.attributes={};this.morphAttributes={};this.groups=[];this.boundingSphere=this.boundingBox=null;this.name=a.name;var c=a.index;null!==c&&this.setIndex(c.clone());c=a.attributes;for(g in c)this.addAttribute(g,c[g].clone());var d=a.morphAttributes;
for(g in d){var e=[],f=d[g];c=0;for(b=f.length;c<b;c++)e.push(f[c].clone());this.morphAttributes[g]=e}var g=a.groups;c=0;for(b=g.length;c<b;c++)d=g[c],this.addGroup(d.start,d.count,d.materialIndex);g=a.boundingBox;null!==g&&(this.boundingBox=g.clone());g=a.boundingSphere;null!==g&&(this.boundingSphere=g.clone());this.drawRange.start=a.drawRange.start;this.drawRange.count=a.drawRange.count;this.userData=a.userData;return this},dispose:function(){this.dispatchEvent({type:"dispose"})}});Lb.prototype=
Object.create(Q.prototype);Lb.prototype.constructor=Lb;ob.prototype=Object.create(D.prototype);ob.prototype.constructor=ob;zc.prototype=Object.create(Q.prototype);zc.prototype.constructor=zc;pb.prototype=Object.create(D.prototype);pb.prototype.constructor=pb;var Rf=0;L.prototype=Object.assign(Object.create(ja.prototype),{constructor:L,isMaterial:!0,onBeforeCompile:function(){},setValues:function(a){if(void 0!==a)for(var b in a){var c=a[b];if(void 0===c)console.warn("THREE.Material: '"+b+"' parameter is undefined.");
else if("shading"===b)console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=1===c?!0:!1;else{var d=this[b];void 0===d?console.warn("THREE."+this.type+": '"+b+"' is not a property of this material."):d&&d.isColor?d.set(c):d&&d.isVector3&&c&&c.isVector3?d.copy(c):this[b]=c}}},toJSON:function(a){function b(a){var b=[],c;for(c in a){var d=a[c];delete d.metadata;b.push(d)}return b}var c=void 0===a||"string"===typeof a;c&&(a={textures:{},
images:{}});var d={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};d.uuid=this.uuid;d.type=this.type;""!==this.name&&(d.name=this.name);this.color&&this.color.isColor&&(d.color=this.color.getHex());void 0!==this.roughness&&(d.roughness=this.roughness);void 0!==this.metalness&&(d.metalness=this.metalness);this.emissive&&this.emissive.isColor&&(d.emissive=this.emissive.getHex());1!==this.emissiveIntensity&&(d.emissiveIntensity=this.emissiveIntensity);this.specular&&this.specular.isColor&&
(d.specular=this.specular.getHex());void 0!==this.shininess&&(d.shininess=this.shininess);void 0!==this.clearCoat&&(d.clearCoat=this.clearCoat);void 0!==this.clearCoatRoughness&&(d.clearCoatRoughness=this.clearCoatRoughness);this.map&&this.map.isTexture&&(d.map=this.map.toJSON(a).uuid);this.alphaMap&&this.alphaMap.isTexture&&(d.alphaMap=this.alphaMap.toJSON(a).uuid);this.lightMap&&this.lightMap.isTexture&&(d.lightMap=this.lightMap.toJSON(a).uuid);this.aoMap&&this.aoMap.isTexture&&(d.aoMap=this.aoMap.toJSON(a).uuid,
d.aoMapIntensity=this.aoMapIntensity);this.bumpMap&&this.bumpMap.isTexture&&(d.bumpMap=this.bumpMap.toJSON(a).uuid,d.bumpScale=this.bumpScale);this.normalMap&&this.normalMap.isTexture&&(d.normalMap=this.normalMap.toJSON(a).uuid,d.normalMapType=this.normalMapType,d.normalScale=this.normalScale.toArray());this.displacementMap&&this.displacementMap.isTexture&&(d.displacementMap=this.displacementMap.toJSON(a).uuid,d.displacementScale=this.displacementScale,d.displacementBias=this.displacementBias);this.roughnessMap&&
this.roughnessMap.isTexture&&(d.roughnessMap=this.roughnessMap.toJSON(a).uuid);this.metalnessMap&&this.metalnessMap.isTexture&&(d.metalnessMap=this.metalnessMap.toJSON(a).uuid);this.emissiveMap&&this.emissiveMap.isTexture&&(d.emissiveMap=this.emissiveMap.toJSON(a).uuid);this.specularMap&&this.specularMap.isTexture&&(d.specularMap=this.specularMap.toJSON(a).uuid);this.envMap&&this.envMap.isTexture&&(d.envMap=this.envMap.toJSON(a).uuid,d.reflectivity=this.reflectivity,void 0!==this.combine&&(d.combine=
this.combine),void 0!==this.envMapIntensity&&(d.envMapIntensity=this.envMapIntensity));this.gradientMap&&this.gradientMap.isTexture&&(d.gradientMap=this.gradientMap.toJSON(a).uuid);void 0!==this.size&&(d.size=this.size);void 0!==this.sizeAttenuation&&(d.sizeAttenuation=this.sizeAttenuation);1!==this.blending&&(d.blending=this.blending);!0===this.flatShading&&(d.flatShading=this.flatShading);0!==this.side&&(d.side=this.side);0!==this.vertexColors&&(d.vertexColors=this.vertexColors);1>this.opacity&&
(d.opacity=this.opacity);!0===this.transparent&&(d.transparent=this.transparent);d.depthFunc=this.depthFunc;d.depthTest=this.depthTest;d.depthWrite=this.depthWrite;0!==this.rotation&&(d.rotation=this.rotation);!0===this.polygonOffset&&(d.polygonOffset=!0);0!==this.polygonOffsetFactor&&(d.polygonOffsetFactor=this.polygonOffsetFactor);0!==this.polygonOffsetUnits&&(d.polygonOffsetUnits=this.polygonOffsetUnits);1!==this.linewidth&&(d.linewidth=this.linewidth);void 0!==this.dashSize&&(d.dashSize=this.dashSize);
void 0!==this.gapSize&&(d.gapSize=this.gapSize);void 0!==this.scale&&(d.scale=this.scale);!0===this.dithering&&(d.dithering=!0);0<this.alphaTest&&(d.alphaTest=this.alphaTest);!0===this.premultipliedAlpha&&(d.premultipliedAlpha=this.premultipliedAlpha);!0===this.wireframe&&(d.wireframe=this.wireframe);1<this.wireframeLinewidth&&(d.wireframeLinewidth=this.wireframeLinewidth);"round"!==this.wireframeLinecap&&(d.wireframeLinecap=this.wireframeLinecap);"round"!==this.wireframeLinejoin&&(d.wireframeLinejoin=
this.wireframeLinejoin);!0===this.morphTargets&&(d.morphTargets=!0);!0===this.skinning&&(d.skinning=!0);!1===this.visible&&(d.visible=!1);"{}"!==JSON.stringify(this.userData)&&(d.userData=this.userData);c&&(c=b(a.textures),a=b(a.images),0<c.length&&(d.textures=c),0<a.length&&(d.images=a));return d},clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.name=a.name;this.fog=a.fog;this.lights=a.lights;this.blending=a.blending;this.side=a.side;this.flatShading=a.flatShading;
this.vertexColors=a.vertexColors;this.opacity=a.opacity;this.transparent=a.transparent;this.blendSrc=a.blendSrc;this.blendDst=a.blendDst;this.blendEquation=a.blendEquation;this.blendSrcAlpha=a.blendSrcAlpha;this.blendDstAlpha=a.blendDstAlpha;this.blendEquationAlpha=a.blendEquationAlpha;this.depthFunc=a.depthFunc;this.depthTest=a.depthTest;this.depthWrite=a.depthWrite;this.colorWrite=a.colorWrite;this.precision=a.precision;this.polygonOffset=a.polygonOffset;this.polygonOffsetFactor=a.polygonOffsetFactor;
this.polygonOffsetUnits=a.polygonOffsetUnits;this.dithering=a.dithering;this.alphaTest=a.alphaTest;this.premultipliedAlpha=a.premultipliedAlpha;this.visible=a.visible;this.userData=JSON.parse(JSON.stringify(a.userData));this.clipShadows=a.clipShadows;this.clipIntersection=a.clipIntersection;var b=a.clippingPlanes,c=null;if(null!==b){var d=b.length;c=Array(d);for(var e=0;e!==d;++e)c[e]=b[e].clone()}this.clippingPlanes=c;this.shadowSide=a.shadowSide;return this},dispose:function(){this.dispatchEvent({type:"dispose"})}});
Ba.prototype=Object.create(L.prototype);Ba.prototype.constructor=Ba;Ba.prototype.isShaderMaterial=!0;Ba.prototype.copy=function(a){L.prototype.copy.call(this,a);this.fragmentShader=a.fragmentShader;this.vertexShader=a.vertexShader;this.uniforms=Jb(a.uniforms);this.defines=Object.assign({},a.defines);this.wireframe=a.wireframe;this.wireframeLinewidth=a.wireframeLinewidth;this.lights=a.lights;this.clipping=a.clipping;this.skinning=a.skinning;this.morphTargets=a.morphTargets;this.morphNormals=a.morphNormals;
this.extensions=a.extensions;return this};Ba.prototype.toJSON=function(a){var b=L.prototype.toJSON.call(this,a);b.uniforms={};for(var c in this.uniforms){var d=this.uniforms[c].value;b.uniforms[c]=d.isTexture?{type:"t",value:d.toJSON(a).uuid}:d.isColor?{type:"c",value:d.getHex()}:d.isVector2?{type:"v2",value:d.toArray()}:d.isVector3?{type:"v3",value:d.toArray()}:d.isVector4?{type:"v4",value:d.toArray()}:d.isMatrix4?{type:"m4",value:d.toArray()}:{value:d}}0<Object.keys(this.defines).length&&(b.defines=
this.defines);b.vertexShader=this.vertexShader;b.fragmentShader=this.fragmentShader;return b};Object.assign(qb.prototype,{set:function(a,b){this.origin.copy(a);this.direction.copy(b);return this},clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.origin.copy(a.origin);this.direction.copy(a.direction);return this},at:function(a,b){void 0===b&&(console.warn("THREE.Ray: .at() target is now required"),b=new n);return b.copy(this.direction).multiplyScalar(a).add(this.origin)},
lookAt:function(a){this.direction.copy(a).sub(this.origin).normalize();return this},recast:function(){var a=new n;return function(b){this.origin.copy(this.at(b,a));return this}}(),closestPointToPoint:function(a,b){void 0===b&&(console.warn("THREE.Ray: .closestPointToPoint() target is now required"),b=new n);b.subVectors(a,this.origin);a=b.dot(this.direction);return 0>a?b.copy(this.origin):b.copy(this.direction).multiplyScalar(a).add(this.origin)},distanceToPoint:function(a){return Math.sqrt(this.distanceSqToPoint(a))},
distanceSqToPoint:function(){var a=new n;return function(b){var c=a.subVectors(b,this.origin).dot(this.direction);if(0>c)return this.origin.distanceToSquared(b);a.copy(this.direction).multiplyScalar(c).add(this.origin);return a.distanceToSquared(b)}}(),distanceSqToSegment:function(){var a=new n,b=new n,c=new n;return function(d,e,f,g){a.copy(d).add(e).multiplyScalar(.5);b.copy(e).sub(d).normalize();c.copy(this.origin).sub(a);var h=.5*d.distanceTo(e),k=-this.direction.dot(b),m=c.dot(this.direction),
l=-c.dot(b),p=c.lengthSq(),r=Math.abs(1-k*k);if(0<r){d=k*l-m;e=k*m-l;var n=h*r;0<=d?e>=-n?e<=n?(h=1/r,d*=h,e*=h,k=d*(d+k*e+2*m)+e*(k*d+e+2*l)+p):(e=h,d=Math.max(0,-(k*e+m)),k=-d*d+e*(e+2*l)+p):(e=-h,d=Math.max(0,-(k*e+m)),k=-d*d+e*(e+2*l)+p):e<=-n?(d=Math.max(0,-(-k*h+m)),e=0<d?-h:Math.min(Math.max(-h,-l),h),k=-d*d+e*(e+2*l)+p):e<=n?(d=0,e=Math.min(Math.max(-h,-l),h),k=e*(e+2*l)+p):(d=Math.max(0,-(k*h+m)),e=0<d?h:Math.min(Math.max(-h,-l),h),k=-d*d+e*(e+2*l)+p)}else e=0<k?-h:h,d=Math.max(0,-(k*e+m)),
k=-d*d+e*(e+2*l)+p;f&&f.copy(this.direction).multiplyScalar(d).add(this.origin);g&&g.copy(b).multiplyScalar(e).add(a);return k}}(),intersectSphere:function(){var a=new n;return function(b,c){a.subVectors(b.center,this.origin);var d=a.dot(this.direction),e=a.dot(a)-d*d;b=b.radius*b.radius;if(e>b)return null;b=Math.sqrt(b-e);e=d-b;d+=b;return 0>e&&0>d?null:0>e?this.at(d,c):this.at(e,c)}}(),intersectsSphere:function(a){return this.distanceSqToPoint(a.center)<=a.radius*a.radius},distanceToPlane:function(a){var b=
a.normal.dot(this.direction);if(0===b)return 0===a.distanceToPoint(this.origin)?0:null;a=-(this.origin.dot(a.normal)+a.constant)/b;return 0<=a?a:null},intersectPlane:function(a,b){a=this.distanceToPlane(a);return null===a?null:this.at(a,b)},intersectsPlane:function(a){var b=a.distanceToPoint(this.origin);return 0===b||0>a.normal.dot(this.direction)*b?!0:!1},intersectBox:function(a,b){var c=1/this.direction.x;var d=1/this.direction.y;var e=1/this.direction.z,f=this.origin;if(0<=c){var g=(a.min.x-f.x)*
c;c*=a.max.x-f.x}else g=(a.max.x-f.x)*c,c*=a.min.x-f.x;if(0<=d){var h=(a.min.y-f.y)*d;d*=a.max.y-f.y}else h=(a.max.y-f.y)*d,d*=a.min.y-f.y;if(g>d||h>c)return null;if(h>g||g!==g)g=h;if(d<c||c!==c)c=d;0<=e?(h=(a.min.z-f.z)*e,a=(a.max.z-f.z)*e):(h=(a.max.z-f.z)*e,a=(a.min.z-f.z)*e);if(g>a||h>c)return null;if(h>g||g!==g)g=h;if(a<c||c!==c)c=a;return 0>c?null:this.at(0<=g?g:c,b)},intersectsBox:function(){var a=new n;return function(b){return null!==this.intersectBox(b,a)}}(),intersectTriangle:function(){var a=
new n,b=new n,c=new n,d=new n;return function(e,f,g,h,k){b.subVectors(f,e);c.subVectors(g,e);d.crossVectors(b,c);f=this.direction.dot(d);if(0<f){if(h)return null;h=1}else if(0>f)h=-1,f=-f;else return null;a.subVectors(this.origin,e);e=h*this.direction.dot(c.crossVectors(a,c));if(0>e)return null;g=h*this.direction.dot(b.cross(a));if(0>g||e+g>f)return null;e=-h*a.dot(d);return 0>e?null:this.at(e/f,k)}}(),applyMatrix4:function(a){this.origin.applyMatrix4(a);this.direction.transformDirection(a);return this},
equals:function(a){return a.origin.equals(this.origin)&&a.direction.equals(this.direction)}});Object.assign(ha,{getNormal:function(){var a=new n;return function(b,c,d,e){void 0===e&&(console.warn("THREE.Triangle: .getNormal() target is now required"),e=new n);e.subVectors(d,c);a.subVectors(b,c);e.cross(a);b=e.lengthSq();return 0<b?e.multiplyScalar(1/Math.sqrt(b)):e.set(0,0,0)}}(),getBarycoord:function(){var a=new n,b=new n,c=new n;return function(d,e,f,g,h){a.subVectors(g,e);b.subVectors(f,e);c.subVectors(d,
e);d=a.dot(a);e=a.dot(b);f=a.dot(c);var k=b.dot(b);g=b.dot(c);var m=d*k-e*e;void 0===h&&(console.warn("THREE.Triangle: .getBarycoord() target is now required"),h=new n);if(0===m)return h.set(-2,-1,-1);m=1/m;k=(k*f-e*g)*m;d=(d*g-e*f)*m;return h.set(1-k-d,d,k)}}(),containsPoint:function(){var a=new n;return function(b,c,d,e){ha.getBarycoord(b,c,d,e,a);return 0<=a.x&&0<=a.y&&1>=a.x+a.y}}(),getUV:function(){var a=new n;return function(b,c,d,e,f,g,h,k){this.getBarycoord(b,c,d,e,a);k.set(0,0);k.addScaledVector(f,
a.x);k.addScaledVector(g,a.y);k.addScaledVector(h,a.z);return k}}()});Object.assign(ha.prototype,{set:function(a,b,c){this.a.copy(a);this.b.copy(b);this.c.copy(c);return this},setFromPointsAndIndices:function(a,b,c,d){this.a.copy(a[b]);this.b.copy(a[c]);this.c.copy(a[d]);return this},clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.a.copy(a.a);this.b.copy(a.b);this.c.copy(a.c);return this},getArea:function(){var a=new n,b=new n;return function(){a.subVectors(this.c,
this.b);b.subVectors(this.a,this.b);return.5*a.cross(b).length()}}(),getMidpoint:function(a){void 0===a&&(console.warn("THREE.Triangle: .getMidpoint() target is now required"),a=new n);return a.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)},getNormal:function(a){return ha.getNormal(this.a,this.b,this.c,a)},getPlane:function(a){void 0===a&&(console.warn("THREE.Triangle: .getPlane() target is now required"),a=new n);return a.setFromCoplanarPoints(this.a,this.b,this.c)},getBarycoord:function(a,
b){return ha.getBarycoord(a,this.a,this.b,this.c,b)},containsPoint:function(a){return ha.containsPoint(a,this.a,this.b,this.c)},getUV:function(a,b,c,d,e){return ha.getUV(a,this.a,this.b,this.c,b,c,d,e)},intersectsBox:function(a){return a.intersectsTriangle(this)},closestPointToPoint:function(){var a=new n,b=new n,c=new n,d=new n,e=new n,f=new n;return function(g,h){void 0===h&&(console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),h=new n);var k=this.a,m=this.b,l=this.c;a.subVectors(m,
k);b.subVectors(l,k);d.subVectors(g,k);var p=a.dot(d),r=b.dot(d);if(0>=p&&0>=r)return h.copy(k);e.subVectors(g,m);var x=a.dot(e),t=b.dot(e);if(0<=x&&t<=x)return h.copy(m);var v=p*t-x*r;if(0>=v&&0<=p&&0>=x)return m=p/(p-x),h.copy(k).addScaledVector(a,m);f.subVectors(g,l);g=a.dot(f);var w=b.dot(f);if(0<=w&&g<=w)return h.copy(l);p=g*r-p*w;if(0>=p&&0<=r&&0>=w)return v=r/(r-w),h.copy(k).addScaledVector(b,v);r=x*w-g*t;if(0>=r&&0<=t-x&&0<=g-w)return c.subVectors(l,m),v=(t-x)/(t-x+(g-w)),h.copy(m).addScaledVector(c,
v);l=1/(r+p+v);m=p*l;v*=l;return h.copy(k).addScaledVector(a,m).addScaledVector(b,v)}}(),equals:function(a){return a.a.equals(this.a)&&a.b.equals(this.b)&&a.c.equals(this.c)}});Da.prototype=Object.create(L.prototype);Da.prototype.constructor=Da;Da.prototype.isMeshBasicMaterial=!0;Da.prototype.copy=function(a){L.prototype.copy.call(this,a);this.color.copy(a.color);this.map=a.map;this.lightMap=a.lightMap;this.lightMapIntensity=a.lightMapIntensity;this.aoMap=a.aoMap;this.aoMapIntensity=a.aoMapIntensity;
this.specularMap=a.specularMap;this.alphaMap=a.alphaMap;this.envMap=a.envMap;this.combine=a.combine;this.reflectivity=a.reflectivity;this.refractionRatio=a.refractionRatio;this.wireframe=a.wireframe;this.wireframeLinewidth=a.wireframeLinewidth;this.wireframeLinecap=a.wireframeLinecap;this.wireframeLinejoin=a.wireframeLinejoin;this.skinning=a.skinning;this.morphTargets=a.morphTargets;return this};pa.prototype=Object.assign(Object.create(C.prototype),{constructor:pa,isMesh:!0,setDrawMode:function(a){this.drawMode=
a},copy:function(a){C.prototype.copy.call(this,a);this.drawMode=a.drawMode;void 0!==a.morphTargetInfluences&&(this.morphTargetInfluences=a.morphTargetInfluences.slice());void 0!==a.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},a.morphTargetDictionary));return this},updateMorphTargets:function(){var a=this.geometry;if(a.isBufferGeometry){a=a.morphAttributes;var b=Object.keys(a);if(0<b.length){var c=a[b[0]];if(void 0!==c)for(this.morphTargetInfluences=[],this.morphTargetDictionary=
{},a=0,b=c.length;a<b;a++){var d=c[a].name||String(a);this.morphTargetInfluences.push(0);this.morphTargetDictionary[d]=a}}}else if(c=a.morphTargets,void 0!==c&&0<c.length)for(this.morphTargetInfluences=[],this.morphTargetDictionary={},a=0,b=c.length;a<b;a++)d=c[a].name||String(a),this.morphTargetInfluences.push(0),this.morphTargetDictionary[d]=a},raycast:function(){function a(a,b,c,d,e,f,g,h){if(null===(1===b.side?d.intersectTriangle(g,f,e,!0,h):d.intersectTriangle(e,f,g,2!==b.side,h)))return null;
v.copy(h);v.applyMatrix4(a.matrixWorld);b=c.ray.origin.distanceTo(v);return b<c.near||b>c.far?null:{distance:b,point:v.clone(),object:a}}function b(b,c,d,e,k,m,l,q,n){f.fromBufferAttribute(k,l);g.fromBufferAttribute(k,q);h.fromBufferAttribute(k,n);if(b=a(b,c,d,e,f,g,h,t))m&&(p.fromBufferAttribute(m,l),r.fromBufferAttribute(m,q),x.fromBufferAttribute(m,n),b.uv=ha.getUV(t,f,g,h,p,r,x,new z)),m=new Kb(l,q,n),ha.getNormal(f,g,h,m.normal),b.face=m;return b}var c=new O,d=new qb,e=new Ea,f=new n,g=new n,
h=new n,k=new n,m=new n,l=new n,p=new z,r=new z,x=new z,t=new n,v=new n;return function(q,n){var u=this.geometry,v=this.material,w=this.matrixWorld;if(void 0!==v&&(null===u.boundingSphere&&u.computeBoundingSphere(),e.copy(u.boundingSphere),e.applyMatrix4(w),!1!==q.ray.intersectsSphere(e)&&(c.getInverse(w),d.copy(q.ray).applyMatrix4(c),null===u.boundingBox||!1!==d.intersectsBox(u.boundingBox))))if(u.isBufferGeometry){var y=u.index,B=u.attributes.position,A=u.attributes.uv,D=u.groups;u=u.drawRange;
var C;if(null!==y)if(Array.isArray(v)){var E=0;for(C=D.length;E<C;E++){var F=D[E];var J=v[F.materialIndex];w=Math.max(F.start,u.start);var L=Math.min(F.start+F.count,u.start+u.count);for(F=w;F<L;F+=3){w=y.getX(F);var I=y.getX(F+1);var K=y.getX(F+2);if(w=b(this,J,q,d,B,A,w,I,K))w.faceIndex=Math.floor(F/3),n.push(w)}}}else for(w=Math.max(0,u.start),L=Math.min(y.count,u.start+u.count),E=w,C=L;E<C;E+=3){if(w=y.getX(E),I=y.getX(E+1),K=y.getX(E+2),w=b(this,v,q,d,B,A,w,I,K))w.faceIndex=Math.floor(E/3),n.push(w)}else if(void 0!==
B)if(Array.isArray(v))for(E=0,C=D.length;E<C;E++)for(F=D[E],J=v[F.materialIndex],w=Math.max(F.start,u.start),L=Math.min(F.start+F.count,u.start+u.count),F=w;F<L;F+=3){if(w=F,I=F+1,K=F+2,w=b(this,J,q,d,B,A,w,I,K))w.faceIndex=Math.floor(F/3),n.push(w)}else for(w=Math.max(0,u.start),L=Math.min(B.count,u.start+u.count),E=w,C=L;E<C;E+=3)if(w=E,I=E+1,K=E+2,w=b(this,v,q,d,B,A,w,I,K))w.faceIndex=Math.floor(E/3),n.push(w)}else if(u.isGeometry)for(B=Array.isArray(v),A=u.vertices,D=u.faces,w=u.faceVertexUvs[0],
0<w.length&&(y=w),F=0,L=D.length;F<L;F++)if(I=D[F],w=B?v[I.materialIndex]:v,void 0!==w){E=A[I.a];C=A[I.b];J=A[I.c];if(!0===w.morphTargets){K=u.morphTargets;var O=this.morphTargetInfluences;f.set(0,0,0);g.set(0,0,0);h.set(0,0,0);for(var Q=0,S=K.length;Q<S;Q++){var R=O[Q];if(0!==R){var T=K[Q].vertices;f.addScaledVector(k.subVectors(T[I.a],E),R);g.addScaledVector(m.subVectors(T[I.b],C),R);h.addScaledVector(l.subVectors(T[I.c],J),R)}}f.add(E);g.add(C);h.add(J);E=f;C=g;J=h}if(w=a(this,w,q,d,E,C,J,t))y&&
y[F]&&(K=y[F],p.copy(K[0]),r.copy(K[1]),x.copy(K[2]),w.uv=ha.getUV(t,E,C,J,p,r,x,new z)),w.face=I,w.faceIndex=F,n.push(w)}}}(),clone:function(){return(new this.constructor(this.geometry,this.material)).copy(this)}});Xa.prototype=Object.create(X.prototype);Xa.prototype.constructor=Xa;Xa.prototype.isCubeTexture=!0;Object.defineProperty(Xa.prototype,"images",{get:function(){return this.image},set:function(a){this.image=a}});Nb.prototype=Object.create(X.prototype);Nb.prototype.constructor=Nb;Nb.prototype.isDataTexture3D=
!0;var Re=new X,mg=new Nb,Se=new Xa,Le=[],Ne=[],Qe=new Float32Array(16),Pe=new Float32Array(9),Oe=new Float32Array(4);We.prototype.updateCache=function(a){var b=this.cache;a instanceof Float32Array&&b.length!==a.length&&(this.cache=new Float32Array(a.length));sa(b,a)};Xe.prototype.setValue=function(a,b,c){for(var d=this.seq,e=0,f=d.length;e!==f;++e){var g=d[e];g.setValue(a,b[g.id],c)}};var Zd=/([\w\d_]+)(\])?(\[|\.)?/g;cb.prototype.setValue=function(a,b,c){b=this.map[b];void 0!==b&&b.setValue(a,c,
this.renderer)};cb.prototype.setOptional=function(a,b,c){b=b[c];void 0!==b&&this.setValue(a,c,b)};cb.upload=function(a,b,c,d){for(var e=0,f=b.length;e!==f;++e){var g=b[e],h=c[g.id];!1!==h.needsUpdate&&g.setValue(a,h.value,d)}};cb.seqWithValue=function(a,b){for(var c=[],d=0,e=a.length;d!==e;++d){var f=a[d];f.id in b&&c.push(f)}return c};var Hg=0,Pg=0;db.prototype=Object.create(L.prototype);db.prototype.constructor=db;db.prototype.isMeshDepthMaterial=!0;db.prototype.copy=function(a){L.prototype.copy.call(this,
a);this.depthPacking=a.depthPacking;this.skinning=a.skinning;this.morphTargets=a.morphTargets;this.map=a.map;this.alphaMap=a.alphaMap;this.displacementMap=a.displacementMap;this.displacementScale=a.displacementScale;this.displacementBias=a.displacementBias;this.wireframe=a.wireframe;this.wireframeLinewidth=a.wireframeLinewidth;return this};eb.prototype=Object.create(L.prototype);eb.prototype.constructor=eb;eb.prototype.isMeshDistanceMaterial=!0;eb.prototype.copy=function(a){L.prototype.copy.call(this,
a);this.referencePosition.copy(a.referencePosition);this.nearDistance=a.nearDistance;this.farDistance=a.farDistance;this.skinning=a.skinning;this.morphTargets=a.morphTargets;this.map=a.map;this.alphaMap=a.alphaMap;this.displacementMap=a.displacementMap;this.displacementScale=a.displacementScale;this.displacementBias=a.displacementBias;return this};Pb.prototype=Object.assign(Object.create(C.prototype),{constructor:Pb,isGroup:!0});Ra.prototype=Object.assign(Object.create(C.prototype),{constructor:Ra,
isCamera:!0,copy:function(a,b){C.prototype.copy.call(this,a,b);this.matrixWorldInverse.copy(a.matrixWorldInverse);this.projectionMatrix.copy(a.projectionMatrix);this.projectionMatrixInverse.copy(a.projectionMatrixInverse);return this},getWorldDirection:function(a){void 0===a&&(console.warn("THREE.Camera: .getWorldDirection() target is now required"),a=new n);this.updateMatrixWorld(!0);var b=this.matrixWorld.elements;return a.set(-b[8],-b[9],-b[10]).normalize()},updateMatrixWorld:function(a){C.prototype.updateMatrixWorld.call(this,
a);this.matrixWorldInverse.getInverse(this.matrixWorld)},clone:function(){return(new this.constructor).copy(this)}});V.prototype=Object.assign(Object.create(Ra.prototype),{constructor:V,isPerspectiveCamera:!0,copy:function(a,b){Ra.prototype.copy.call(this,a,b);this.fov=a.fov;this.zoom=a.zoom;this.near=a.near;this.far=a.far;this.focus=a.focus;this.aspect=a.aspect;this.view=null===a.view?null:Object.assign({},a.view);this.filmGauge=a.filmGauge;this.filmOffset=a.filmOffset;return this},setFocalLength:function(a){a=
.5*this.getFilmHeight()/a;this.fov=2*R.RAD2DEG*Math.atan(a);this.updateProjectionMatrix()},getFocalLength:function(){var a=Math.tan(.5*R.DEG2RAD*this.fov);return.5*this.getFilmHeight()/a},getEffectiveFOV:function(){return 2*R.RAD2DEG*Math.atan(Math.tan(.5*R.DEG2RAD*this.fov)/this.zoom)},getFilmWidth:function(){return this.filmGauge*Math.min(this.aspect,1)},getFilmHeight:function(){return this.filmGauge/Math.max(this.aspect,1)},setViewOffset:function(a,b,c,d,e,f){this.aspect=a/b;null===this.view&&
(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1});this.view.enabled=!0;this.view.fullWidth=a;this.view.fullHeight=b;this.view.offsetX=c;this.view.offsetY=d;this.view.width=e;this.view.height=f;this.updateProjectionMatrix()},clearViewOffset:function(){null!==this.view&&(this.view.enabled=!1);this.updateProjectionMatrix()},updateProjectionMatrix:function(){var a=this.near,b=a*Math.tan(.5*R.DEG2RAD*this.fov)/this.zoom,c=2*b,d=this.aspect*c,e=-.5*d,f=this.view;if(null!==
this.view&&this.view.enabled){var g=f.fullWidth,h=f.fullHeight;e+=f.offsetX*d/g;b-=f.offsetY*c/h;d*=f.width/g;c*=f.height/h}f=this.filmOffset;0!==f&&(e+=a*f/this.getFilmWidth());this.projectionMatrix.makePerspective(e,e+d,b,b-c,a,this.far);this.projectionMatrixInverse.getInverse(this.projectionMatrix)},toJSON:function(a){a=C.prototype.toJSON.call(this,a);a.object.fov=this.fov;a.object.zoom=this.zoom;a.object.near=this.near;a.object.far=this.far;a.object.focus=this.focus;a.object.aspect=this.aspect;
null!==this.view&&(a.object.view=Object.assign({},this.view));a.object.filmGauge=this.filmGauge;a.object.filmOffset=this.filmOffset;return a}});Dc.prototype=Object.assign(Object.create(V.prototype),{constructor:Dc,isArrayCamera:!0});var hf=new n,jf=new n;Qb.prototype.isFogExp2=!0;Qb.prototype.clone=function(){return new Qb(this.color,this.density)};Qb.prototype.toJSON=function(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}};Rb.prototype.isFog=!0;Rb.prototype.clone=function(){return new Rb(this.color,
this.near,this.far)};Rb.prototype.toJSON=function(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}};xd.prototype=Object.assign(Object.create(C.prototype),{constructor:xd,copy:function(a,b){C.prototype.copy.call(this,a,b);null!==a.background&&(this.background=a.background.clone());null!==a.fog&&(this.fog=a.fog.clone());null!==a.overrideMaterial&&(this.overrideMaterial=a.overrideMaterial.clone());this.autoUpdate=a.autoUpdate;this.matrixAutoUpdate=a.matrixAutoUpdate;return this},
toJSON:function(a){var b=C.prototype.toJSON.call(this,a);null!==this.background&&(b.object.background=this.background.toJSON(a));null!==this.fog&&(b.object.fog=this.fog.toJSON());return b}});Object.defineProperty(rb.prototype,"needsUpdate",{set:function(a){!0===a&&this.version++}});Object.assign(rb.prototype,{isInterleavedBuffer:!0,onUploadCallback:function(){},setArray:function(a){if(Array.isArray(a))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.count=void 0!==
a?a.length/this.stride:0;this.array=a;return this},setDynamic:function(a){this.dynamic=a;return this},copy:function(a){this.array=new a.array.constructor(a.array);this.count=a.count;this.stride=a.stride;this.dynamic=a.dynamic;return this},copyAt:function(a,b,c){a*=this.stride;c*=b.stride;for(var d=0,e=this.stride;d<e;d++)this.array[a+d]=b.array[c+d];return this},set:function(a,b){void 0===b&&(b=0);this.array.set(a,b);return this},clone:function(){return(new this.constructor).copy(this)},onUpload:function(a){this.onUploadCallback=
a;return this}});Object.defineProperties(Ec.prototype,{count:{get:function(){return this.data.count}},array:{get:function(){return this.data.array}}});Object.assign(Ec.prototype,{isInterleavedBufferAttribute:!0,setX:function(a,b){this.data.array[a*this.data.stride+this.offset]=b;return this},setY:function(a,b){this.data.array[a*this.data.stride+this.offset+1]=b;return this},setZ:function(a,b){this.data.array[a*this.data.stride+this.offset+2]=b;return this},setW:function(a,b){this.data.array[a*this.data.stride+
this.offset+3]=b;return this},getX:function(a){return this.data.array[a*this.data.stride+this.offset]},getY:function(a){return this.data.array[a*this.data.stride+this.offset+1]},getZ:function(a){return this.data.array[a*this.data.stride+this.offset+2]},getW:function(a){return this.data.array[a*this.data.stride+this.offset+3]},setXY:function(a,b,c){a=a*this.data.stride+this.offset;this.data.array[a+0]=b;this.data.array[a+1]=c;return this},setXYZ:function(a,b,c,d){a=a*this.data.stride+this.offset;this.data.array[a+
0]=b;this.data.array[a+1]=c;this.data.array[a+2]=d;return this},setXYZW:function(a,b,c,d,e){a=a*this.data.stride+this.offset;this.data.array[a+0]=b;this.data.array[a+1]=c;this.data.array[a+2]=d;this.data.array[a+3]=e;return this}});gb.prototype=Object.create(L.prototype);gb.prototype.constructor=gb;gb.prototype.isSpriteMaterial=!0;gb.prototype.copy=function(a){L.prototype.copy.call(this,a);this.color.copy(a.color);this.map=a.map;this.rotation=a.rotation;this.sizeAttenuation=a.sizeAttenuation;return this};
var Sb;Fc.prototype=Object.assign(Object.create(C.prototype),{constructor:Fc,isSprite:!0,raycast:function(){function a(a,b,c,d,h,k){e.subVectors(a,c).addScalar(.5).multiply(d);void 0!==h?(f.x=k*e.x-h*e.y,f.y=h*e.x+k*e.y):f.copy(e);a.copy(b);a.x+=f.x;a.y+=f.y;a.applyMatrix4(g)}var b=new n,c=new n,d=new n,e=new z,f=new z,g=new O,h=new n,k=new n,m=new n,l=new z,p=new z,r=new z;return function(e,f){c.setFromMatrixScale(this.matrixWorld);g.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld);
d.setFromMatrixPosition(this.modelViewMatrix);var q=this.material.rotation;if(0!==q){var n=Math.cos(q);var t=Math.sin(q)}q=this.center;a(h.set(-.5,-.5,0),d,q,c,t,n);a(k.set(.5,-.5,0),d,q,c,t,n);a(m.set(.5,.5,0),d,q,c,t,n);l.set(0,0);p.set(1,0);r.set(1,1);var u=e.ray.intersectTriangle(h,k,m,!1,b);if(null===u&&(a(k.set(-.5,.5,0),d,q,c,t,n),p.set(0,1),u=e.ray.intersectTriangle(h,m,k,!1,b),null===u))return;t=e.ray.origin.distanceTo(b);t<e.near||t>e.far||f.push({distance:t,point:b.clone(),uv:ha.getUV(b,
h,k,m,l,p,r,new z),face:null,object:this})}}(),clone:function(){return(new this.constructor(this.material)).copy(this)},copy:function(a){C.prototype.copy.call(this,a);void 0!==a.center&&this.center.copy(a.center);return this}});Gc.prototype=Object.assign(Object.create(C.prototype),{constructor:Gc,copy:function(a){C.prototype.copy.call(this,a,!1);a=a.levels;for(var b=0,c=a.length;b<c;b++){var d=a[b];this.addLevel(d.object.clone(),d.distance)}return this},addLevel:function(a,b){void 0===b&&(b=0);b=
Math.abs(b);for(var c=this.levels,d=0;d<c.length&&!(b<c[d].distance);d++);c.splice(d,0,{distance:b,object:a});this.add(a)},getObjectForDistance:function(a){for(var b=this.levels,c=1,d=b.length;c<d&&!(a<b[c].distance);c++);return b[c-1].object},raycast:function(){var a=new n;return function(b,c){a.setFromMatrixPosition(this.matrixWorld);var d=b.ray.origin.distanceTo(a);this.getObjectForDistance(d).raycast(b,c)}}(),update:function(){var a=new n,b=new n;return function(c){var d=this.levels;if(1<d.length){a.setFromMatrixPosition(c.matrixWorld);
b.setFromMatrixPosition(this.matrixWorld);c=a.distanceTo(b);d[0].object.visible=!0;for(var e=1,f=d.length;e<f;e++)if(c>=d[e].distance)d[e-1].object.visible=!1,d[e].object.visible=!0;else break;for(;e<f;e++)d[e].object.visible=!1}}}(),toJSON:function(a){a=C.prototype.toJSON.call(this,a);a.object.levels=[];for(var b=this.levels,c=0,d=b.length;c<d;c++){var e=b[c];a.object.levels.push({object:e.object.uuid,distance:e.distance})}return a}});Hc.prototype=Object.assign(Object.create(pa.prototype),{constructor:Hc,
isSkinnedMesh:!0,bind:function(a,b){this.skeleton=a;void 0===b&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),b=this.matrixWorld);this.bindMatrix.copy(b);this.bindMatrixInverse.getInverse(b)},pose:function(){this.skeleton.pose()},normalizeSkinWeights:function(){for(var a=new ca,b=this.geometry.attributes.skinWeight,c=0,d=b.count;c<d;c++){a.x=b.getX(c);a.y=b.getY(c);a.z=b.getZ(c);a.w=b.getW(c);var e=1/a.manhattanLength();Infinity!==e?a.multiplyScalar(e):a.set(1,0,0,0);b.setXYZW(c,a.x,
a.y,a.z,a.w)}},updateMatrixWorld:function(a){pa.prototype.updateMatrixWorld.call(this,a);"attached"===this.bindMode?this.bindMatrixInverse.getInverse(this.matrixWorld):"detached"===this.bindMode?this.bindMatrixInverse.getInverse(this.bindMatrix):console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)},clone:function(){return(new this.constructor(this.geometry,this.material)).copy(this)}});Object.assign(yd.prototype,{calculateInverses:function(){this.boneInverses=[];for(var a=0,b=
this.bones.length;a<b;a++){var c=new O;this.bones[a]&&c.getInverse(this.bones[a].matrixWorld);this.boneInverses.push(c)}},pose:function(){var a,b;var c=0;for(b=this.bones.length;c<b;c++)(a=this.bones[c])&&a.matrixWorld.getInverse(this.boneInverses[c]);c=0;for(b=this.bones.length;c<b;c++)if(a=this.bones[c])a.parent&&a.parent.isBone?(a.matrix.getInverse(a.parent.matrixWorld),a.matrix.multiply(a.matrixWorld)):a.matrix.copy(a.matrixWorld),a.matrix.decompose(a.position,a.quaternion,a.scale)},update:function(){var a=
new O,b=new O;return function(){for(var c=this.bones,d=this.boneInverses,e=this.boneMatrices,f=this.boneTexture,g=0,h=c.length;g<h;g++)a.multiplyMatrices(c[g]?c[g].matrixWorld:b,d[g]),a.toArray(e,16*g);void 0!==f&&(f.needsUpdate=!0)}}(),clone:function(){return new yd(this.bones,this.boneInverses)},getBoneByName:function(a){for(var b=0,c=this.bones.length;b<c;b++){var d=this.bones[b];if(d.name===a)return d}}});ce.prototype=Object.assign(Object.create(C.prototype),{constructor:ce,isBone:!0});T.prototype=
Object.create(L.prototype);T.prototype.constructor=T;T.prototype.isLineBasicMaterial=!0;T.prototype.copy=function(a){L.prototype.copy.call(this,a);this.color.copy(a.color);this.linewidth=a.linewidth;this.linecap=a.linecap;this.linejoin=a.linejoin;return this};ma.prototype=Object.assign(Object.create(C.prototype),{constructor:ma,isLine:!0,computeLineDistances:function(){var a=new n,b=new n;return function(){var c=this.geometry;if(c.isBufferGeometry)if(null===c.index){for(var d=c.attributes.position,
e=[0],f=1,g=d.count;f<g;f++)a.fromBufferAttribute(d,f-1),b.fromBufferAttribute(d,f),e[f]=e[f-1],e[f]+=a.distanceTo(b);c.addAttribute("lineDistance",new B(e,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else if(c.isGeometry)for(d=c.vertices,e=c.lineDistances,e[0]=0,f=1,g=d.length;f<g;f++)e[f]=e[f-1],e[f]+=d[f-1].distanceTo(d[f]);return this}}(),raycast:function(){var a=new O,b=new qb,c=new Ea;return function(d,e){var f=d.linePrecision,
g=this.geometry,h=this.matrixWorld;null===g.boundingSphere&&g.computeBoundingSphere();c.copy(g.boundingSphere);c.applyMatrix4(h);c.radius+=f;if(!1!==d.ray.intersectsSphere(c)){a.getInverse(h);b.copy(d.ray).applyMatrix4(a);f/=(this.scale.x+this.scale.y+this.scale.z)/3;f*=f;var k=new n,m=new n;h=new n;var l=new n,p=this&&this.isLineSegments?2:1;if(g.isBufferGeometry){var r=g.index,x=g.attributes.position.array;if(null!==r){r=r.array;g=0;for(var t=r.length-1;g<t;g+=p){var v=r[g+1];k.fromArray(x,3*r[g]);
m.fromArray(x,3*v);v=b.distanceSqToSegment(k,m,l,h);v>f||(l.applyMatrix4(this.matrixWorld),v=d.ray.origin.distanceTo(l),v<d.near||v>d.far||e.push({distance:v,point:h.clone().applyMatrix4(this.matrixWorld),index:g,face:null,faceIndex:null,object:this}))}}else for(g=0,t=x.length/3-1;g<t;g+=p)k.fromArray(x,3*g),m.fromArray(x,3*g+3),v=b.distanceSqToSegment(k,m,l,h),v>f||(l.applyMatrix4(this.matrixWorld),v=d.ray.origin.distanceTo(l),v<d.near||v>d.far||e.push({distance:v,point:h.clone().applyMatrix4(this.matrixWorld),
index:g,face:null,faceIndex:null,object:this}))}else if(g.isGeometry)for(k=g.vertices,m=k.length,g=0;g<m-1;g+=p)v=b.distanceSqToSegment(k[g],k[g+1],l,h),v>f||(l.applyMatrix4(this.matrixWorld),v=d.ray.origin.distanceTo(l),v<d.near||v>d.far||e.push({distance:v,point:h.clone().applyMatrix4(this.matrixWorld),index:g,face:null,faceIndex:null,object:this}))}}}(),copy:function(a){C.prototype.copy.call(this,a);this.geometry.copy(a.geometry);this.material.copy(a.material);return this},clone:function(){return(new this.constructor).copy(this)}});
S.prototype=Object.assign(Object.create(ma.prototype),{constructor:S,isLineSegments:!0,computeLineDistances:function(){var a=new n,b=new n;return function(){var c=this.geometry;if(c.isBufferGeometry)if(null===c.index){for(var d=c.attributes.position,e=[],f=0,g=d.count;f<g;f+=2)a.fromBufferAttribute(d,f),b.fromBufferAttribute(d,f+1),e[f]=0===f?0:e[f-1],e[f+1]=e[f]+a.distanceTo(b);c.addAttribute("lineDistance",new B(e,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
else if(c.isGeometry)for(d=c.vertices,e=c.lineDistances,f=0,g=d.length;f<g;f+=2)a.copy(d[f]),b.copy(d[f+1]),e[f]=0===f?0:e[f-1],e[f+1]=e[f]+a.distanceTo(b);return this}}()});zd.prototype=Object.assign(Object.create(ma.prototype),{constructor:zd,isLineLoop:!0});Fa.prototype=Object.create(L.prototype);Fa.prototype.constructor=Fa;Fa.prototype.isPointsMaterial=!0;Fa.prototype.copy=function(a){L.prototype.copy.call(this,a);this.color.copy(a.color);this.map=a.map;this.size=a.size;this.sizeAttenuation=a.sizeAttenuation;
this.morphTargets=a.morphTargets;return this};Tb.prototype=Object.assign(Object.create(C.prototype),{constructor:Tb,isPoints:!0,raycast:function(){var a=new O,b=new qb,c=new Ea;return function(d,e){function f(a,c){var f=b.distanceSqToPoint(a);f<l&&(b.closestPointToPoint(a,p),p.applyMatrix4(k),a=d.ray.origin.distanceTo(p),a<d.near||a>d.far||e.push({distance:a,distanceToRay:Math.sqrt(f),point:p.clone(),index:c,face:null,object:g}))}var g=this,h=this.geometry,k=this.matrixWorld,m=d.params.Points.threshold;
null===h.boundingSphere&&h.computeBoundingSphere();c.copy(h.boundingSphere);c.applyMatrix4(k);c.radius+=m;if(!1!==d.ray.intersectsSphere(c)){a.getInverse(k);b.copy(d.ray).applyMatrix4(a);m/=(this.scale.x+this.scale.y+this.scale.z)/3;var l=m*m;m=new n;var p=new n;if(h.isBufferGeometry){var r=h.index;h=h.attributes.position.array;if(null!==r){var x=r.array;r=0;for(var t=x.length;r<t;r++){var v=x[r];m.fromArray(h,3*v);f(m,v)}}else for(r=0,x=h.length/3;r<x;r++)m.fromArray(h,3*r),f(m,r)}else for(m=h.vertices,
r=0,x=m.length;r<x;r++)f(m[r],r)}}}(),clone:function(){return(new this.constructor(this.geometry,this.material)).copy(this)}});de.prototype=Object.assign(Object.create(X.prototype),{constructor:de,isVideoTexture:!0,update:function(){var a=this.image;a.readyState>=a.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}});Ub.prototype=Object.create(X.prototype);Ub.prototype.constructor=Ub;Ub.prototype.isCompressedTexture=!0;Ic.prototype=Object.create(X.prototype);Ic.prototype.constructor=Ic;Ic.prototype.isCanvasTexture=
!0;Jc.prototype=Object.create(X.prototype);Jc.prototype.constructor=Jc;Jc.prototype.isDepthTexture=!0;Vb.prototype=Object.create(D.prototype);Vb.prototype.constructor=Vb;Kc.prototype=Object.create(Q.prototype);Kc.prototype.constructor=Kc;Wb.prototype=Object.create(D.prototype);Wb.prototype.constructor=Wb;Lc.prototype=Object.create(Q.prototype);Lc.prototype.constructor=Lc;xa.prototype=Object.create(D.prototype);xa.prototype.constructor=xa;Mc.prototype=Object.create(Q.prototype);Mc.prototype.constructor=
Mc;Xb.prototype=Object.create(xa.prototype);Xb.prototype.constructor=Xb;Nc.prototype=Object.create(Q.prototype);Nc.prototype.constructor=Nc;sb.prototype=Object.create(xa.prototype);sb.prototype.constructor=sb;Oc.prototype=Object.create(Q.prototype);Oc.prototype.constructor=Oc;Yb.prototype=Object.create(xa.prototype);Yb.prototype.constructor=Yb;Pc.prototype=Object.create(Q.prototype);Pc.prototype.constructor=Pc;Zb.prototype=Object.create(xa.prototype);Zb.prototype.constructor=Zb;Qc.prototype=Object.create(Q.prototype);
Qc.prototype.constructor=Qc;$b.prototype=Object.create(D.prototype);$b.prototype.constructor=$b;Rc.prototype=Object.create(Q.prototype);Rc.prototype.constructor=Rc;ac.prototype=Object.create(D.prototype);ac.prototype.constructor=ac;Sc.prototype=Object.create(Q.prototype);Sc.prototype.constructor=Sc;bc.prototype=Object.create(D.prototype);bc.prototype.constructor=bc;var ch={triangulate:function(a,b,c){c=c||2;var d=b&&b.length,e=d?b[0]*c:a.length,f=lf(a,0,e,c,!0),g=[];if(!f)return g;var h;if(d){var k=
c;d=[];var m;var l=0;for(m=b.length;l<m;l++){var p=b[l]*k;var r=l<m-1?b[l+1]*k:a.length;p=lf(a,p,r,k,!1);p===p.next&&(p.steiner=!0);d.push(Xg(p))}d.sort(Vg);for(l=0;l<d.length;l++){b=d[l];k=f;if(k=Wg(b,k))b=of(k,b),Uc(b,b.next);f=Uc(f,f.next)}}if(a.length>80*c){var n=h=a[0];var t=d=a[1];for(k=c;k<e;k+=c)l=a[k],b=a[k+1],l<n&&(n=l),b<t&&(t=b),l>h&&(h=l),b>d&&(d=b);h=Math.max(h-n,d-t);h=0!==h?1/h:0}Vc(f,g,c,n,t,h);return g}},Ya={area:function(a){for(var b=a.length,c=0,d=b-1,e=0;e<b;d=e++)c+=a[d].x*a[e].y-
a[e].x*a[d].y;return.5*c},isClockWise:function(a){return 0>Ya.area(a)},triangulateShape:function(a,b){var c=[],d=[],e=[];pf(a);qf(c,a);var f=a.length;b.forEach(pf);for(a=0;a<b.length;a++)d.push(f),f+=b[a].length,qf(c,b[a]);b=ch.triangulate(c,d);for(a=0;a<b.length;a+=3)e.push(b.slice(a,a+3));return e}};ub.prototype=Object.create(Q.prototype);ub.prototype.constructor=ub;ub.prototype.toJSON=function(){var a=Q.prototype.toJSON.call(this);return rf(this.parameters.shapes,this.parameters.options,a)};Sa.prototype=
Object.create(D.prototype);Sa.prototype.constructor=Sa;Sa.prototype.toJSON=function(){var a=D.prototype.toJSON.call(this);return rf(this.parameters.shapes,this.parameters.options,a)};var Yg={generateTopUV:function(a,b,c,d,e){a=b[3*d];d=b[3*d+1];var f=b[3*e];e=b[3*e+1];return[new z(b[3*c],b[3*c+1]),new z(a,d),new z(f,e)]},generateSideWallUV:function(a,b,c,d,e,f){a=b[3*c];var g=b[3*c+1];c=b[3*c+2];var h=b[3*d],k=b[3*d+1];d=b[3*d+2];var m=b[3*e],l=b[3*e+1];e=b[3*e+2];var p=b[3*f],r=b[3*f+1];b=b[3*f+
2];return.01>Math.abs(g-k)?[new z(a,1-c),new z(h,1-d),new z(m,1-e),new z(p,1-b)]:[new z(g,1-c),new z(k,1-d),new z(l,1-e),new z(r,1-b)]}};Xc.prototype=Object.create(Q.prototype);Xc.prototype.constructor=Xc;cc.prototype=Object.create(Sa.prototype);cc.prototype.constructor=cc;Yc.prototype=Object.create(Q.prototype);Yc.prototype.constructor=Yc;vb.prototype=Object.create(D.prototype);vb.prototype.constructor=vb;Zc.prototype=Object.create(Q.prototype);Zc.prototype.constructor=Zc;dc.prototype=Object.create(D.prototype);
dc.prototype.constructor=dc;$c.prototype=Object.create(Q.prototype);$c.prototype.constructor=$c;ec.prototype=Object.create(D.prototype);ec.prototype.constructor=ec;wb.prototype=Object.create(Q.prototype);wb.prototype.constructor=wb;wb.prototype.toJSON=function(){var a=Q.prototype.toJSON.call(this);return sf(this.parameters.shapes,a)};xb.prototype=Object.create(D.prototype);xb.prototype.constructor=xb;xb.prototype.toJSON=function(){var a=D.prototype.toJSON.call(this);return sf(this.parameters.shapes,
a)};fc.prototype=Object.create(D.prototype);fc.prototype.constructor=fc;yb.prototype=Object.create(Q.prototype);yb.prototype.constructor=yb;Za.prototype=Object.create(D.prototype);Za.prototype.constructor=Za;ad.prototype=Object.create(yb.prototype);ad.prototype.constructor=ad;bd.prototype=Object.create(Za.prototype);bd.prototype.constructor=bd;cd.prototype=Object.create(Q.prototype);cd.prototype.constructor=cd;gc.prototype=Object.create(D.prototype);gc.prototype.constructor=gc;var ia=Object.freeze({WireframeGeometry:Vb,
ParametricGeometry:Kc,ParametricBufferGeometry:Wb,TetrahedronGeometry:Mc,TetrahedronBufferGeometry:Xb,OctahedronGeometry:Nc,OctahedronBufferGeometry:sb,IcosahedronGeometry:Oc,IcosahedronBufferGeometry:Yb,DodecahedronGeometry:Pc,DodecahedronBufferGeometry:Zb,PolyhedronGeometry:Lc,PolyhedronBufferGeometry:xa,TubeGeometry:Qc,TubeBufferGeometry:$b,TorusKnotGeometry:Rc,TorusKnotBufferGeometry:ac,TorusGeometry:Sc,TorusBufferGeometry:bc,TextGeometry:Xc,TextBufferGeometry:cc,SphereGeometry:Yc,SphereBufferGeometry:vb,
RingGeometry:Zc,RingBufferGeometry:dc,PlaneGeometry:zc,PlaneBufferGeometry:pb,LatheGeometry:$c,LatheBufferGeometry:ec,ShapeGeometry:wb,ShapeBufferGeometry:xb,ExtrudeGeometry:ub,ExtrudeBufferGeometry:Sa,EdgesGeometry:fc,ConeGeometry:ad,ConeBufferGeometry:bd,CylinderGeometry:yb,CylinderBufferGeometry:Za,CircleGeometry:cd,CircleBufferGeometry:gc,BoxGeometry:Lb,BoxBufferGeometry:ob});zb.prototype=Object.create(L.prototype);zb.prototype.constructor=zb;zb.prototype.isShadowMaterial=!0;zb.prototype.copy=
function(a){L.prototype.copy.call(this,a);this.color.copy(a.color);return this};hc.prototype=Object.create(Ba.prototype);hc.prototype.constructor=hc;hc.prototype.isRawShaderMaterial=!0;Ta.prototype=Object.create(L.prototype);Ta.prototype.constructor=Ta;Ta.prototype.isMeshStandardMaterial=!0;Ta.prototype.copy=function(a){L.prototype.copy.call(this,a);this.defines={STANDARD:""};this.color.copy(a.color);this.roughness=a.roughness;this.metalness=a.metalness;this.map=a.map;this.lightMap=a.lightMap;this.lightMapIntensity=
a.lightMapIntensity;this.aoMap=a.aoMap;this.aoMapIntensity=a.aoMapIntensity;this.emissive.copy(a.emissive);this.emissiveMap=a.emissiveMap;this.emissiveIntensity=a.emissiveIntensity;this.bumpMap=a.bumpMap;this.bumpScale=a.bumpScale;this.normalMap=a.normalMap;this.normalMapType=a.normalMapType;this.normalScale.copy(a.normalScale);this.displacementMap=a.displacementMap;this.displacementScale=a.displacementScale;this.displacementBias=a.displacementBias;this.roughnessMap=a.roughnessMap;this.metalnessMap=
a.metalnessMap;this.alphaMap=a.alphaMap;this.envMap=a.envMap;this.envMapIntensity=a.envMapIntensity;this.refractionRatio=a.refractionRatio;this.wireframe=a.wireframe;this.wireframeLinewidth=a.wireframeLinewidth;this.wireframeLinecap=a.wireframeLinecap;this.wireframeLinejoin=a.wireframeLinejoin;this.skinning=a.skinning;this.morphTargets=a.morphTargets;this.morphNormals=a.morphNormals;return this};Ab.prototype=Object.create(Ta.prototype);Ab.prototype.constructor=Ab;Ab.prototype.isMeshPhysicalMaterial=
!0;Ab.prototype.copy=function(a){Ta.prototype.copy.call(this,a);this.defines={PHYSICAL:""};this.reflectivity=a.reflectivity;this.clearCoat=a.clearCoat;this.clearCoatRoughness=a.clearCoatRoughness;return this};Ga.prototype=Object.create(L.prototype);Ga.prototype.constructor=Ga;Ga.prototype.isMeshPhongMaterial=!0;Ga.prototype.copy=function(a){L.prototype.copy.call(this,a);this.color.copy(a.color);this.specular.copy(a.specular);this.shininess=a.shininess;this.map=a.map;this.lightMap=a.lightMap;this.lightMapIntensity=
a.lightMapIntensity;this.aoMap=a.aoMap;this.aoMapIntensity=a.aoMapIntensity;this.emissive.copy(a.emissive);this.emissiveMap=a.emissiveMap;this.emissiveIntensity=a.emissiveIntensity;this.bumpMap=a.bumpMap;this.bumpScale=a.bumpScale;this.normalMap=a.normalMap;this.normalMapType=a.normalMapType;this.normalScale.copy(a.normalScale);this.displacementMap=a.displacementMap;this.displacementScale=a.displacementScale;this.displacementBias=a.displacementBias;this.specularMap=a.specularMap;this.alphaMap=a.alphaMap;
this.envMap=a.envMap;this.combine=a.combine;this.reflectivity=a.reflectivity;this.refractionRatio=a.refractionRatio;this.wireframe=a.wireframe;this.wireframeLinewidth=a.wireframeLinewidth;this.wireframeLinecap=a.wireframeLinecap;this.wireframeLinejoin=a.wireframeLinejoin;this.skinning=a.skinning;this.morphTargets=a.morphTargets;this.morphNormals=a.morphNormals;return this};Bb.prototype=Object.create(Ga.prototype);Bb.prototype.constructor=Bb;Bb.prototype.isMeshToonMaterial=!0;Bb.prototype.copy=function(a){Ga.prototype.copy.call(this,
a);this.gradientMap=a.gradientMap;return this};Cb.prototype=Object.create(L.prototype);Cb.prototype.constructor=Cb;Cb.prototype.isMeshNormalMaterial=!0;Cb.prototype.copy=function(a){L.prototype.copy.call(this,a);this.bumpMap=a.bumpMap;this.bumpScale=a.bumpScale;this.normalMap=a.normalMap;this.normalMapType=a.normalMapType;this.normalScale.copy(a.normalScale);this.displacementMap=a.displacementMap;this.displacementScale=a.displacementScale;this.displacementBias=a.displacementBias;this.wireframe=a.wireframe;
this.wireframeLinewidth=a.wireframeLinewidth;this.skinning=a.skinning;this.morphTargets=a.morphTargets;this.morphNormals=a.morphNormals;return this};Db.prototype=Object.create(L.prototype);Db.prototype.constructor=Db;Db.prototype.isMeshLambertMaterial=!0;Db.prototype.copy=function(a){L.prototype.copy.call(this,a);this.color.copy(a.color);this.map=a.map;this.lightMap=a.lightMap;this.lightMapIntensity=a.lightMapIntensity;this.aoMap=a.aoMap;this.aoMapIntensity=a.aoMapIntensity;this.emissive.copy(a.emissive);
this.emissiveMap=a.emissiveMap;this.emissiveIntensity=a.emissiveIntensity;this.specularMap=a.specularMap;this.alphaMap=a.alphaMap;this.envMap=a.envMap;this.combine=a.combine;this.reflectivity=a.reflectivity;this.refractionRatio=a.refractionRatio;this.wireframe=a.wireframe;this.wireframeLinewidth=a.wireframeLinewidth;this.wireframeLinecap=a.wireframeLinecap;this.wireframeLinejoin=a.wireframeLinejoin;this.skinning=a.skinning;this.morphTargets=a.morphTargets;this.morphNormals=a.morphNormals;return this};
Eb.prototype=Object.create(L.prototype);Eb.prototype.constructor=Eb;Eb.prototype.isMeshMatcapMaterial=!0;Eb.prototype.copy=function(a){L.prototype.copy.call(this,a);this.defines={MATCAP:""};this.color.copy(a.color);this.matcap=a.matcap;this.map=a.map;this.bumpMap=a.bumpMap;this.bumpScale=a.bumpScale;this.normalMap=a.normalMap;this.normalMapType=a.normalMapType;this.normalScale.copy(a.normalScale);this.displacementMap=a.displacementMap;this.displacementScale=a.displacementScale;this.displacementBias=
a.displacementBias;this.alphaMap=a.alphaMap;this.skinning=a.skinning;this.morphTargets=a.morphTargets;this.morphNormals=a.morphNormals;return this};Fb.prototype=Object.create(T.prototype);Fb.prototype.constructor=Fb;Fb.prototype.isLineDashedMaterial=!0;Fb.prototype.copy=function(a){T.prototype.copy.call(this,a);this.scale=a.scale;this.dashSize=a.dashSize;this.gapSize=a.gapSize;return this};var dh=Object.freeze({ShadowMaterial:zb,SpriteMaterial:gb,RawShaderMaterial:hc,ShaderMaterial:Ba,PointsMaterial:Fa,
MeshPhysicalMaterial:Ab,MeshStandardMaterial:Ta,MeshPhongMaterial:Ga,MeshToonMaterial:Bb,MeshNormalMaterial:Cb,MeshLambertMaterial:Db,MeshDepthMaterial:db,MeshDistanceMaterial:eb,MeshBasicMaterial:Da,MeshMatcapMaterial:Eb,LineDashedMaterial:Fb,LineBasicMaterial:T,Material:L}),ra={arraySlice:function(a,b,c){return ra.isTypedArray(a)?new a.constructor(a.subarray(b,void 0!==c?c:a.length)):a.slice(b,c)},convertArray:function(a,b,c){return!a||!c&&a.constructor===b?a:"number"===typeof b.BYTES_PER_ELEMENT?
new b(a):Array.prototype.slice.call(a)},isTypedArray:function(a){return ArrayBuffer.isView(a)&&!(a instanceof DataView)},getKeyframeOrder:function(a){for(var b=a.length,c=Array(b),d=0;d!==b;++d)c[d]=d;c.sort(function(b,c){return a[b]-a[c]});return c},sortedArray:function(a,b,c){for(var d=a.length,e=new a.constructor(d),f=0,g=0;g!==d;++f)for(var h=c[f]*b,k=0;k!==b;++k)e[g++]=a[h+k];return e},flattenJSON:function(a,b,c,d){for(var e=1,f=a[0];void 0!==f&&void 0===f[d];)f=a[e++];if(void 0!==f){var g=f[d];
if(void 0!==g)if(Array.isArray(g)){do g=f[d],void 0!==g&&(b.push(f.time),c.push.apply(c,g)),f=a[e++];while(void 0!==f)}else if(void 0!==g.toArray){do g=f[d],void 0!==g&&(b.push(f.time),g.toArray(c,c.length)),f=a[e++];while(void 0!==f)}else{do g=f[d],void 0!==g&&(b.push(f.time),c.push(g)),f=a[e++];while(void 0!==f)}}}};Object.assign(ya.prototype,{evaluate:function(a){var b=this.parameterPositions,c=this._cachedIndex,d=b[c],e=b[c-1];a:{b:{c:{d:if(!(a<d)){for(var f=c+2;;){if(void 0===d){if(a<e)break d;
this._cachedIndex=c=b.length;return this.afterEnd_(c-1,a,e)}if(c===f)break;e=d;d=b[++c];if(a<d)break b}d=b.length;break c}if(a>=e)break a;else{f=b[1];a<f&&(c=2,e=f);for(f=c-2;;){if(void 0===e)return this._cachedIndex=0,this.beforeStart_(0,a,d);if(c===f)break;d=e;e=b[--c-1];if(a>=e)break b}d=c;c=0}}for(;c<d;)e=c+d>>>1,a<b[e]?d=e:c=e+1;d=b[c];e=b[c-1];if(void 0===e)return this._cachedIndex=0,this.beforeStart_(0,a,d);if(void 0===d)return this._cachedIndex=c=b.length,this.afterEnd_(c-1,e,a)}this._cachedIndex=
c;this.intervalChanged_(c,e,d)}return this.interpolate_(c,e,a,d)},settings:null,DefaultSettings_:{},getSettings_:function(){return this.settings||this.DefaultSettings_},copySampleValue_:function(a){var b=this.resultBuffer,c=this.sampleValues,d=this.valueSize;a*=d;for(var e=0;e!==d;++e)b[e]=c[a+e];return b},interpolate_:function(){throw Error("call to abstract method");},intervalChanged_:function(){}});Object.assign(ya.prototype,{beforeStart_:ya.prototype.copySampleValue_,afterEnd_:ya.prototype.copySampleValue_});
Bd.prototype=Object.assign(Object.create(ya.prototype),{constructor:Bd,DefaultSettings_:{endingStart:2400,endingEnd:2400},intervalChanged_:function(a,b,c){var d=this.parameterPositions,e=a-2,f=a+1,g=d[e],h=d[f];if(void 0===g)switch(this.getSettings_().endingStart){case 2401:e=a;g=2*b-c;break;case 2402:e=d.length-2;g=b+d[e]-d[e+1];break;default:e=a,g=c}if(void 0===h)switch(this.getSettings_().endingEnd){case 2401:f=a;h=2*c-b;break;case 2402:f=1;h=c+d[1]-d[0];break;default:f=a-1,h=b}a=.5*(c-b);d=this.valueSize;
this._weightPrev=a/(b-g);this._weightNext=a/(h-c);this._offsetPrev=e*d;this._offsetNext=f*d},interpolate_:function(a,b,c,d){var e=this.resultBuffer,f=this.sampleValues,g=this.valueSize;a*=g;var h=a-g,k=this._offsetPrev,m=this._offsetNext,l=this._weightPrev,p=this._weightNext,r=(c-b)/(d-b);c=r*r;d=c*r;b=-l*d+2*l*c-l*r;l=(1+l)*d+(-1.5-2*l)*c+(-.5+l)*r+1;r=(-1-p)*d+(1.5+p)*c+.5*r;p=p*d-p*c;for(c=0;c!==g;++c)e[c]=b*f[k+c]+l*f[h+c]+r*f[a+c]+p*f[m+c];return e}});dd.prototype=Object.assign(Object.create(ya.prototype),
{constructor:dd,interpolate_:function(a,b,c,d){var e=this.resultBuffer,f=this.sampleValues,g=this.valueSize;a*=g;var h=a-g;b=(c-b)/(d-b);c=1-b;for(d=0;d!==g;++d)e[d]=f[h+d]*c+f[a+d]*b;return e}});Cd.prototype=Object.assign(Object.create(ya.prototype),{constructor:Cd,interpolate_:function(a){return this.copySampleValue_(a-1)}});Object.assign(qa,{toJSON:function(a){var b=a.constructor;if(void 0!==b.toJSON)b=b.toJSON(a);else{b={name:a.name,times:ra.convertArray(a.times,Array),values:ra.convertArray(a.values,
Array)};var c=a.getInterpolation();c!==a.DefaultInterpolation&&(b.interpolation=c)}b.type=a.ValueTypeName;return b}});Object.assign(qa.prototype,{constructor:qa,TimeBufferType:Float32Array,ValueBufferType:Float32Array,DefaultInterpolation:2301,InterpolantFactoryMethodDiscrete:function(a){return new Cd(this.times,this.values,this.getValueSize(),a)},InterpolantFactoryMethodLinear:function(a){return new dd(this.times,this.values,this.getValueSize(),a)},InterpolantFactoryMethodSmooth:function(a){return new Bd(this.times,
this.values,this.getValueSize(),a)},setInterpolation:function(a){switch(a){case 2300:var b=this.InterpolantFactoryMethodDiscrete;break;case 2301:b=this.InterpolantFactoryMethodLinear;break;case 2302:b=this.InterpolantFactoryMethodSmooth}if(void 0===b){b="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant)if(a!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw Error(b);console.warn("THREE.KeyframeTrack:",
b);return this}this.createInterpolant=b;return this},getInterpolation:function(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return 2300;case this.InterpolantFactoryMethodLinear:return 2301;case this.InterpolantFactoryMethodSmooth:return 2302}},getValueSize:function(){return this.values.length/this.times.length},shift:function(a){if(0!==a)for(var b=this.times,c=0,d=b.length;c!==d;++c)b[c]+=a;return this},scale:function(a){if(1!==a)for(var b=this.times,c=0,d=b.length;c!==
d;++c)b[c]*=a;return this},trim:function(a,b){for(var c=this.times,d=c.length,e=0,f=d-1;e!==d&&c[e]<a;)++e;for(;-1!==f&&c[f]>b;)--f;++f;if(0!==e||f!==d)e>=f&&(f=Math.max(f,1),e=f-1),a=this.getValueSize(),this.times=ra.arraySlice(c,e,f),this.values=ra.arraySlice(this.values,e*a,f*a);return this},validate:function(){var a=!0,b=this.getValueSize();0!==b-Math.floor(b)&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),a=!1);var c=this.times;b=this.values;var d=c.length;0===d&&(console.error("THREE.KeyframeTrack: Track is empty.",
this),a=!1);for(var e=null,f=0;f!==d;f++){var g=c[f];if("number"===typeof g&&isNaN(g)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,f,g);a=!1;break}if(null!==e&&e>g){console.error("THREE.KeyframeTrack: Out of order keys.",this,f,g,e);a=!1;break}e=g}if(void 0!==b&&ra.isTypedArray(b))for(f=0,c=b.length;f!==c;++f)if(d=b[f],isNaN(d)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,f,d);a=!1;break}return a},optimize:function(){for(var a=this.times,b=this.values,
c=this.getValueSize(),d=2302===this.getInterpolation(),e=1,f=a.length-1,g=1;g<f;++g){var h=!1,k=a[g];if(k!==a[g+1]&&(1!==g||k!==k[0]))if(d)h=!0;else{var m=g*c,l=m-c,p=m+c;for(k=0;k!==c;++k){var r=b[m+k];if(r!==b[l+k]||r!==b[p+k]){h=!0;break}}}if(h){if(g!==e)for(a[e]=a[g],h=g*c,m=e*c,k=0;k!==c;++k)b[m+k]=b[h+k];++e}}if(0<f){a[e]=a[f];h=f*c;m=e*c;for(k=0;k!==c;++k)b[m+k]=b[h+k];++e}e!==a.length&&(this.times=ra.arraySlice(a,0,e),this.values=ra.arraySlice(b,0,e*c));return this}});Dd.prototype=Object.assign(Object.create(qa.prototype),
{constructor:Dd,ValueTypeName:"bool",ValueBufferType:Array,DefaultInterpolation:2300,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0});Ed.prototype=Object.assign(Object.create(qa.prototype),{constructor:Ed,ValueTypeName:"color"});ic.prototype=Object.assign(Object.create(qa.prototype),{constructor:ic,ValueTypeName:"number"});Fd.prototype=Object.assign(Object.create(ya.prototype),{constructor:Fd,interpolate_:function(a,b,c,d){var e=this.resultBuffer,f=this.sampleValues,g=
this.valueSize;a*=g;b=(c-b)/(d-b);for(c=a+g;a!==c;a+=4)ka.slerpFlat(e,0,f,a-g,f,a,b);return e}});ed.prototype=Object.assign(Object.create(qa.prototype),{constructor:ed,ValueTypeName:"quaternion",DefaultInterpolation:2301,InterpolantFactoryMethodLinear:function(a){return new Fd(this.times,this.values,this.getValueSize(),a)},InterpolantFactoryMethodSmooth:void 0});Gd.prototype=Object.assign(Object.create(qa.prototype),{constructor:Gd,ValueTypeName:"string",ValueBufferType:Array,DefaultInterpolation:2300,
InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0});jc.prototype=Object.assign(Object.create(qa.prototype),{constructor:jc,ValueTypeName:"vector"});Object.assign(Ha,{parse:function(a){for(var b=[],c=a.tracks,d=1/(a.fps||1),e=0,f=c.length;e!==f;++e)b.push($g(c[e]).scale(d));return new Ha(a.name,a.duration,b)},toJSON:function(a){var b=[],c=a.tracks;a={name:a.name,duration:a.duration,tracks:b,uuid:a.uuid};for(var d=0,e=c.length;d!==e;++d)b.push(qa.toJSON(c[d]));return a},CreateFromMorphTargetSequence:function(a,
b,c,d){for(var e=b.length,f=[],g=0;g<e;g++){var h=[],k=[];h.push((g+e-1)%e,g,(g+1)%e);k.push(0,1,0);var m=ra.getKeyframeOrder(h);h=ra.sortedArray(h,1,m);k=ra.sortedArray(k,1,m);d||0!==h[0]||(h.push(e),k.push(k[0]));f.push((new ic(".morphTargetInfluences["+b[g].name+"]",h,k)).scale(1/c))}return new Ha(a,-1,f)},findByName:function(a,b){var c=a;Array.isArray(a)||(c=a.geometry&&a.geometry.animations||a.animations);for(a=0;a<c.length;a++)if(c[a].name===b)return c[a];return null},CreateClipsFromMorphTargetSequences:function(a,
b,c){for(var d={},e=/^([\w-]*?)([\d]+)$/,f=0,g=a.length;f<g;f++){var h=a[f],k=h.name.match(e);if(k&&1<k.length){var m=k[1];(k=d[m])||(d[m]=k=[]);k.push(h)}}a=[];for(m in d)a.push(Ha.CreateFromMorphTargetSequence(m,d[m],b,c));return a},parseAnimation:function(a,b){if(!a)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;var c=function(a,b,c,d,e){if(0!==c.length){var f=[],g=[];ra.flattenJSON(c,f,g,d);0!==f.length&&e.push(new a(b,f,g))}},d=[],e=a.name||"default",f=a.length||
-1,g=a.fps||30;a=a.hierarchy||[];for(var h=0;h<a.length;h++){var k=a[h].keys;if(k&&0!==k.length)if(k[0].morphTargets){f={};for(var m=0;m<k.length;m++)if(k[m].morphTargets)for(var l=0;l<k[m].morphTargets.length;l++)f[k[m].morphTargets[l]]=-1;for(var p in f){var r=[],n=[];for(l=0;l!==k[m].morphTargets.length;++l){var t=k[m];r.push(t.time);n.push(t.morphTarget===p?1:0)}d.push(new ic(".morphTargetInfluence["+p+"]",r,n))}f=f.length*(g||1)}else m=".bones["+b[h].name+"]",c(jc,m+".position",k,"pos",d),c(ed,
m+".quaternion",k,"rot",d),c(jc,m+".scale",k,"scl",d)}return 0===d.length?null:new Ha(e,f,d)}});Object.assign(Ha.prototype,{resetDuration:function(){for(var a=0,b=0,c=this.tracks.length;b!==c;++b){var d=this.tracks[b];a=Math.max(a,d.times[d.times.length-1])}this.duration=a;return this},trim:function(){for(var a=0;a<this.tracks.length;a++)this.tracks[a].trim(0,this.duration);return this},validate:function(){for(var a=!0,b=0;b<this.tracks.length;b++)a=a&&this.tracks[b].validate();return a},optimize:function(){for(var a=
0;a<this.tracks.length;a++)this.tracks[a].optimize();return this}});var Hb={enabled:!1,files:{},add:function(a,b){!1!==this.enabled&&(this.files[a]=b)},get:function(a){if(!1!==this.enabled)return this.files[a]},remove:function(a){delete this.files[a]},clear:function(){this.files={}}},za=new ge,Oa={};Object.assign(Ia.prototype,{load:function(a,b,c,d){void 0===a&&(a="");void 0!==this.path&&(a=this.path+a);a=this.manager.resolveURL(a);var e=this,f=Hb.get(a);if(void 0!==f)return e.manager.itemStart(a),
setTimeout(function(){b&&b(f);e.manager.itemEnd(a)},0),f;if(void 0!==Oa[a])Oa[a].push({onLoad:b,onProgress:c,onError:d});else{var g=a.match(/^data:(.*?)(;base64)?,(.*)$/);if(g){c=g[1];var h=!!g[2];g=g[3];g=decodeURIComponent(g);h&&(g=atob(g));try{var k=(this.responseType||"").toLowerCase();switch(k){case "arraybuffer":case "blob":var m=new Uint8Array(g.length);for(h=0;h<g.length;h++)m[h]=g.charCodeAt(h);var l="blob"===k?new Blob([m.buffer],{type:c}):m.buffer;break;case "document":l=(new DOMParser).parseFromString(g,
c);break;case "json":l=JSON.parse(g);break;default:l=g}setTimeout(function(){b&&b(l);e.manager.itemEnd(a)},0)}catch(r){setTimeout(function(){d&&d(r);e.manager.itemError(a);e.manager.itemEnd(a)},0)}}else{Oa[a]=[];Oa[a].push({onLoad:b,onProgress:c,onError:d});var p=new XMLHttpRequest;p.open("GET",a,!0);p.addEventListener("load",function(b){var c=this.response;Hb.add(a,c);var d=Oa[a];delete Oa[a];if(200===this.status||0===this.status){0===this.status&&console.warn("THREE.FileLoader: HTTP Status 0 received.");
for(var f=0,g=d.length;f<g;f++){var h=d[f];if(h.onLoad)h.onLoad(c)}}else{f=0;for(g=d.length;f<g;f++)if(h=d[f],h.onError)h.onError(b);e.manager.itemError(a)}e.manager.itemEnd(a)},!1);p.addEventListener("progress",function(b){for(var c=Oa[a],d=0,e=c.length;d<e;d++){var f=c[d];if(f.onProgress)f.onProgress(b)}},!1);p.addEventListener("error",function(b){var c=Oa[a];delete Oa[a];for(var d=0,f=c.length;d<f;d++){var g=c[d];if(g.onError)g.onError(b)}e.manager.itemError(a);e.manager.itemEnd(a)},!1);p.addEventListener("abort",
function(b){var c=Oa[a];delete Oa[a];for(var d=0,f=c.length;d<f;d++){var g=c[d];if(g.onError)g.onError(b)}e.manager.itemError(a);e.manager.itemEnd(a)},!1);void 0!==this.responseType&&(p.responseType=this.responseType);void 0!==this.withCredentials&&(p.withCredentials=this.withCredentials);p.overrideMimeType&&p.overrideMimeType(void 0!==this.mimeType?this.mimeType:"text/plain");for(h in this.requestHeader)p.setRequestHeader(h,this.requestHeader[h]);p.send(null)}e.manager.itemStart(a);return p}},setPath:function(a){this.path=
a;return this},setResponseType:function(a){this.responseType=a;return this},setWithCredentials:function(a){this.withCredentials=a;return this},setMimeType:function(a){this.mimeType=a;return this},setRequestHeader:function(a){this.requestHeader=a;return this}});Object.assign(tf.prototype,{load:function(a,b,c,d){var e=this,f=new Ia(e.manager);f.setPath(e.path);f.load(a,function(a){b(e.parse(JSON.parse(a)))},c,d)},parse:function(a,b){for(var c=[],d=0;d<a.length;d++){var e=Ha.parse(a[d]);c.push(e)}b(c)},
setPath:function(a){this.path=a;return this}});Object.assign(uf.prototype,{load:function(a,b,c,d){function e(e){k.load(a[e],function(a){a=f._parser(a,!0);g[e]={width:a.width,height:a.height,format:a.format,mipmaps:a.mipmaps};m+=1;6===m&&(1===a.mipmapCount&&(h.minFilter=1006),h.format=a.format,h.needsUpdate=!0,b&&b(h))},c,d)}var f=this,g=[],h=new Ub;h.image=g;var k=new Ia(this.manager);k.setPath(this.path);k.setResponseType("arraybuffer");if(Array.isArray(a))for(var m=0,l=0,p=a.length;l<p;++l)e(l);
else k.load(a,function(a){a=f._parser(a,!0);if(a.isCubemap)for(var c=a.mipmaps.length/a.mipmapCount,d=0;d<c;d++){g[d]={mipmaps:[]};for(var e=0;e<a.mipmapCount;e++)g[d].mipmaps.push(a.mipmaps[d*a.mipmapCount+e]),g[d].format=a.format,g[d].width=a.width,g[d].height=a.height}else h.image.width=a.width,h.image.height=a.height,h.mipmaps=a.mipmaps;1===a.mipmapCount&&(h.minFilter=1006);h.format=a.format;h.needsUpdate=!0;b&&b(h)},c,d);return h},setPath:function(a){this.path=a;return this}});Object.assign(he.prototype,
{load:function(a,b,c,d){var e=this,f=new kb,g=new Ia(this.manager);g.setResponseType("arraybuffer");g.setPath(this.path);g.load(a,function(a){if(a=e._parser(a))void 0!==a.image?f.image=a.image:void 0!==a.data&&(f.image.width=a.width,f.image.height=a.height,f.image.data=a.data),f.wrapS=void 0!==a.wrapS?a.wrapS:1001,f.wrapT=void 0!==a.wrapT?a.wrapT:1001,f.magFilter=void 0!==a.magFilter?a.magFilter:1006,f.minFilter=void 0!==a.minFilter?a.minFilter:1008,f.anisotropy=void 0!==a.anisotropy?a.anisotropy:
1,void 0!==a.format&&(f.format=a.format),void 0!==a.type&&(f.type=a.type),void 0!==a.mipmaps&&(f.mipmaps=a.mipmaps),1===a.mipmapCount&&(f.minFilter=1006),f.needsUpdate=!0,b&&b(f,a)},c,d);return f},setPath:function(a){this.path=a;return this}});Object.assign(fd.prototype,{crossOrigin:"anonymous",load:function(a,b,c,d){function e(){k.removeEventListener("load",e,!1);k.removeEventListener("error",f,!1);Hb.add(a,this);b&&b(this);g.manager.itemEnd(a)}function f(b){k.removeEventListener("load",e,!1);k.removeEventListener("error",
f,!1);d&&d(b);g.manager.itemError(a);g.manager.itemEnd(a)}void 0===a&&(a="");void 0!==this.path&&(a=this.path+a);a=this.manager.resolveURL(a);var g=this,h=Hb.get(a);if(void 0!==h)return g.manager.itemStart(a),setTimeout(function(){b&&b(h);g.manager.itemEnd(a)},0),h;var k=document.createElementNS("http://www.w3.org/1999/xhtml","img");k.addEventListener("load",e,!1);k.addEventListener("error",f,!1);"data:"!==a.substr(0,5)&&void 0!==this.crossOrigin&&(k.crossOrigin=this.crossOrigin);g.manager.itemStart(a);
k.src=a;return k},setCrossOrigin:function(a){this.crossOrigin=a;return this},setPath:function(a){this.path=a;return this}});Object.assign(ie.prototype,{crossOrigin:"anonymous",load:function(a,b,c,d){function e(c){g.load(a[c],function(a){f.images[c]=a;h++;6===h&&(f.needsUpdate=!0,b&&b(f))},void 0,d)}var f=new Xa,g=new fd(this.manager);g.setCrossOrigin(this.crossOrigin);g.setPath(this.path);var h=0;for(c=0;c<a.length;++c)e(c);return f},setCrossOrigin:function(a){this.crossOrigin=a;return this},setPath:function(a){this.path=
a;return this}});Object.assign(Hd.prototype,{crossOrigin:"anonymous",load:function(a,b,c,d){var e=new X,f=new fd(this.manager);f.setCrossOrigin(this.crossOrigin);f.setPath(this.path);f.load(a,function(c){e.image=c;c=0<a.search(/\.jpe?g($|\?)/i)||0===a.search(/^data:image\/jpeg/);e.format=c?1022:1023;e.needsUpdate=!0;void 0!==b&&b(e)},c,d);return e},setCrossOrigin:function(a){this.crossOrigin=a;return this},setPath:function(a){this.path=a;return this}});Object.assign(K.prototype,{getPoint:function(){console.warn("THREE.Curve: .getPoint() not implemented.");
return null},getPointAt:function(a,b){a=this.getUtoTmapping(a);return this.getPoint(a,b)},getPoints:function(a){void 0===a&&(a=5);for(var b=[],c=0;c<=a;c++)b.push(this.getPoint(c/a));return b},getSpacedPoints:function(a){void 0===a&&(a=5);for(var b=[],c=0;c<=a;c++)b.push(this.getPointAt(c/a));return b},getLength:function(){var a=this.getLengths();return a[a.length-1]},getLengths:function(a){void 0===a&&(a=this.arcLengthDivisions);if(this.cacheArcLengths&&this.cacheArcLengths.length===a+1&&!this.needsUpdate)return this.cacheArcLengths;
this.needsUpdate=!1;var b=[],c=this.getPoint(0),d,e=0;b.push(0);for(d=1;d<=a;d++){var f=this.getPoint(d/a);e+=f.distanceTo(c);b.push(e);c=f}return this.cacheArcLengths=b},updateArcLengths:function(){this.needsUpdate=!0;this.getLengths()},getUtoTmapping:function(a,b){var c=this.getLengths(),d=c.length;b=b?b:a*c[d-1];for(var e=0,f=d-1,g;e<=f;)if(a=Math.floor(e+(f-e)/2),g=c[a]-b,0>g)e=a+1;else if(0<g)f=a-1;else{f=a;break}a=f;if(c[a]===b)return a/(d-1);e=c[a];return(a+(b-e)/(c[a+1]-e))/(d-1)},getTangent:function(a){var b=
a-1E-4;a+=1E-4;0>b&&(b=0);1<a&&(a=1);b=this.getPoint(b);return this.getPoint(a).clone().sub(b).normalize()},getTangentAt:function(a){a=this.getUtoTmapping(a);return this.getTangent(a)},computeFrenetFrames:function(a,b){var c=new n,d=[],e=[],f=[],g=new n,h=new O,k;for(k=0;k<=a;k++){var m=k/a;d[k]=this.getTangentAt(m);d[k].normalize()}e[0]=new n;f[0]=new n;k=Number.MAX_VALUE;m=Math.abs(d[0].x);var l=Math.abs(d[0].y),p=Math.abs(d[0].z);m<=k&&(k=m,c.set(1,0,0));l<=k&&(k=l,c.set(0,1,0));p<=k&&c.set(0,
0,1);g.crossVectors(d[0],c).normalize();e[0].crossVectors(d[0],g);f[0].crossVectors(d[0],e[0]);for(k=1;k<=a;k++)e[k]=e[k-1].clone(),f[k]=f[k-1].clone(),g.crossVectors(d[k-1],d[k]),g.length()>Number.EPSILON&&(g.normalize(),c=Math.acos(R.clamp(d[k-1].dot(d[k]),-1,1)),e[k].applyMatrix4(h.makeRotationAxis(g,c))),f[k].crossVectors(d[k],e[k]);if(!0===b)for(c=Math.acos(R.clamp(e[0].dot(e[a]),-1,1)),c/=a,0<d[0].dot(g.crossVectors(e[0],e[a]))&&(c=-c),k=1;k<=a;k++)e[k].applyMatrix4(h.makeRotationAxis(d[k],
c*k)),f[k].crossVectors(d[k],e[k]);return{tangents:d,normals:e,binormals:f}},clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.arcLengthDivisions=a.arcLengthDivisions;return this},toJSON:function(){var a={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};a.arcLengthDivisions=this.arcLengthDivisions;a.type=this.type;return a},fromJSON:function(a){this.arcLengthDivisions=a.arcLengthDivisions;return this}});va.prototype=Object.create(K.prototype);va.prototype.constructor=
va;va.prototype.isEllipseCurve=!0;va.prototype.getPoint=function(a,b){b=b||new z;for(var c=2*Math.PI,d=this.aEndAngle-this.aStartAngle,e=Math.abs(d)<Number.EPSILON;0>d;)d+=c;for(;d>c;)d-=c;d<Number.EPSILON&&(d=e?0:c);!0!==this.aClockwise||e||(d=d===c?-c:d-c);c=this.aStartAngle+a*d;a=this.aX+this.xRadius*Math.cos(c);var f=this.aY+this.yRadius*Math.sin(c);0!==this.aRotation&&(c=Math.cos(this.aRotation),d=Math.sin(this.aRotation),e=a-this.aX,f-=this.aY,a=e*c-f*d+this.aX,f=e*d+f*c+this.aY);return b.set(a,
f)};va.prototype.copy=function(a){K.prototype.copy.call(this,a);this.aX=a.aX;this.aY=a.aY;this.xRadius=a.xRadius;this.yRadius=a.yRadius;this.aStartAngle=a.aStartAngle;this.aEndAngle=a.aEndAngle;this.aClockwise=a.aClockwise;this.aRotation=a.aRotation;return this};va.prototype.toJSON=function(){var a=K.prototype.toJSON.call(this);a.aX=this.aX;a.aY=this.aY;a.xRadius=this.xRadius;a.yRadius=this.yRadius;a.aStartAngle=this.aStartAngle;a.aEndAngle=this.aEndAngle;a.aClockwise=this.aClockwise;a.aRotation=
this.aRotation;return a};va.prototype.fromJSON=function(a){K.prototype.fromJSON.call(this,a);this.aX=a.aX;this.aY=a.aY;this.xRadius=a.xRadius;this.yRadius=a.yRadius;this.aStartAngle=a.aStartAngle;this.aEndAngle=a.aEndAngle;this.aClockwise=a.aClockwise;this.aRotation=a.aRotation;return this};kc.prototype=Object.create(va.prototype);kc.prototype.constructor=kc;kc.prototype.isArcCurve=!0;var Ud=new n,Fe=new je,Ge=new je,He=new je;ta.prototype=Object.create(K.prototype);ta.prototype.constructor=ta;ta.prototype.isCatmullRomCurve3=
!0;ta.prototype.getPoint=function(a,b){b=b||new n;var c=this.points,d=c.length;a*=d-(this.closed?0:1);var e=Math.floor(a);a-=e;this.closed?e+=0<e?0:(Math.floor(Math.abs(e)/d)+1)*d:0===a&&e===d-1&&(e=d-2,a=1);if(this.closed||0<e)var f=c[(e-1)%d];else Ud.subVectors(c[0],c[1]).add(c[0]),f=Ud;var g=c[e%d];var h=c[(e+1)%d];this.closed||e+2<d?c=c[(e+2)%d]:(Ud.subVectors(c[d-1],c[d-2]).add(c[d-1]),c=Ud);if("centripetal"===this.curveType||"chordal"===this.curveType){var k="chordal"===this.curveType?.5:.25;
d=Math.pow(f.distanceToSquared(g),k);e=Math.pow(g.distanceToSquared(h),k);k=Math.pow(h.distanceToSquared(c),k);1E-4>e&&(e=1);1E-4>d&&(d=e);1E-4>k&&(k=e);Fe.initNonuniformCatmullRom(f.x,g.x,h.x,c.x,d,e,k);Ge.initNonuniformCatmullRom(f.y,g.y,h.y,c.y,d,e,k);He.initNonuniformCatmullRom(f.z,g.z,h.z,c.z,d,e,k)}else"catmullrom"===this.curveType&&(Fe.initCatmullRom(f.x,g.x,h.x,c.x,this.tension),Ge.initCatmullRom(f.y,g.y,h.y,c.y,this.tension),He.initCatmullRom(f.z,g.z,h.z,c.z,this.tension));b.set(Fe.calc(a),
Ge.calc(a),He.calc(a));return b};ta.prototype.copy=function(a){K.prototype.copy.call(this,a);this.points=[];for(var b=0,c=a.points.length;b<c;b++)this.points.push(a.points[b].clone());this.closed=a.closed;this.curveType=a.curveType;this.tension=a.tension;return this};ta.prototype.toJSON=function(){var a=K.prototype.toJSON.call(this);a.points=[];for(var b=0,c=this.points.length;b<c;b++)a.points.push(this.points[b].toArray());a.closed=this.closed;a.curveType=this.curveType;a.tension=this.tension;return a};
ta.prototype.fromJSON=function(a){K.prototype.fromJSON.call(this,a);this.points=[];for(var b=0,c=a.points.length;b<c;b++){var d=a.points[b];this.points.push((new n).fromArray(d))}this.closed=a.closed;this.curveType=a.curveType;this.tension=a.tension;return this};Ja.prototype=Object.create(K.prototype);Ja.prototype.constructor=Ja;Ja.prototype.isCubicBezierCurve=!0;Ja.prototype.getPoint=function(a,b){b=b||new z;var c=this.v0,d=this.v1,e=this.v2,f=this.v3;b.set(hd(a,c.x,d.x,e.x,f.x),hd(a,c.y,d.y,e.y,
f.y));return b};Ja.prototype.copy=function(a){K.prototype.copy.call(this,a);this.v0.copy(a.v0);this.v1.copy(a.v1);this.v2.copy(a.v2);this.v3.copy(a.v3);return this};Ja.prototype.toJSON=function(){var a=K.prototype.toJSON.call(this);a.v0=this.v0.toArray();a.v1=this.v1.toArray();a.v2=this.v2.toArray();a.v3=this.v3.toArray();return a};Ja.prototype.fromJSON=function(a){K.prototype.fromJSON.call(this,a);this.v0.fromArray(a.v0);this.v1.fromArray(a.v1);this.v2.fromArray(a.v2);this.v3.fromArray(a.v3);return this};
Ua.prototype=Object.create(K.prototype);Ua.prototype.constructor=Ua;Ua.prototype.isCubicBezierCurve3=!0;Ua.prototype.getPoint=function(a,b){b=b||new n;var c=this.v0,d=this.v1,e=this.v2,f=this.v3;b.set(hd(a,c.x,d.x,e.x,f.x),hd(a,c.y,d.y,e.y,f.y),hd(a,c.z,d.z,e.z,f.z));return b};Ua.prototype.copy=function(a){K.prototype.copy.call(this,a);this.v0.copy(a.v0);this.v1.copy(a.v1);this.v2.copy(a.v2);this.v3.copy(a.v3);return this};Ua.prototype.toJSON=function(){var a=K.prototype.toJSON.call(this);a.v0=this.v0.toArray();
a.v1=this.v1.toArray();a.v2=this.v2.toArray();a.v3=this.v3.toArray();return a};Ua.prototype.fromJSON=function(a){K.prototype.fromJSON.call(this,a);this.v0.fromArray(a.v0);this.v1.fromArray(a.v1);this.v2.fromArray(a.v2);this.v3.fromArray(a.v3);return this};Aa.prototype=Object.create(K.prototype);Aa.prototype.constructor=Aa;Aa.prototype.isLineCurve=!0;Aa.prototype.getPoint=function(a,b){b=b||new z;1===a?b.copy(this.v2):(b.copy(this.v2).sub(this.v1),b.multiplyScalar(a).add(this.v1));return b};Aa.prototype.getPointAt=
function(a,b){return this.getPoint(a,b)};Aa.prototype.getTangent=function(){return this.v2.clone().sub(this.v1).normalize()};Aa.prototype.copy=function(a){K.prototype.copy.call(this,a);this.v1.copy(a.v1);this.v2.copy(a.v2);return this};Aa.prototype.toJSON=function(){var a=K.prototype.toJSON.call(this);a.v1=this.v1.toArray();a.v2=this.v2.toArray();return a};Aa.prototype.fromJSON=function(a){K.prototype.fromJSON.call(this,a);this.v1.fromArray(a.v1);this.v2.fromArray(a.v2);return this};Ka.prototype=
Object.create(K.prototype);Ka.prototype.constructor=Ka;Ka.prototype.isLineCurve3=!0;Ka.prototype.getPoint=function(a,b){b=b||new n;1===a?b.copy(this.v2):(b.copy(this.v2).sub(this.v1),b.multiplyScalar(a).add(this.v1));return b};Ka.prototype.getPointAt=function(a,b){return this.getPoint(a,b)};Ka.prototype.copy=function(a){K.prototype.copy.call(this,a);this.v1.copy(a.v1);this.v2.copy(a.v2);return this};Ka.prototype.toJSON=function(){var a=K.prototype.toJSON.call(this);a.v1=this.v1.toArray();a.v2=this.v2.toArray();
return a};Ka.prototype.fromJSON=function(a){K.prototype.fromJSON.call(this,a);this.v1.fromArray(a.v1);this.v2.fromArray(a.v2);return this};La.prototype=Object.create(K.prototype);La.prototype.constructor=La;La.prototype.isQuadraticBezierCurve=!0;La.prototype.getPoint=function(a,b){b=b||new z;var c=this.v0,d=this.v1,e=this.v2;b.set(gd(a,c.x,d.x,e.x),gd(a,c.y,d.y,e.y));return b};La.prototype.copy=function(a){K.prototype.copy.call(this,a);this.v0.copy(a.v0);this.v1.copy(a.v1);this.v2.copy(a.v2);return this};
La.prototype.toJSON=function(){var a=K.prototype.toJSON.call(this);a.v0=this.v0.toArray();a.v1=this.v1.toArray();a.v2=this.v2.toArray();return a};La.prototype.fromJSON=function(a){K.prototype.fromJSON.call(this,a);this.v0.fromArray(a.v0);this.v1.fromArray(a.v1);this.v2.fromArray(a.v2);return this};Va.prototype=Object.create(K.prototype);Va.prototype.constructor=Va;Va.prototype.isQuadraticBezierCurve3=!0;Va.prototype.getPoint=function(a,b){b=b||new n;var c=this.v0,d=this.v1,e=this.v2;b.set(gd(a,c.x,
d.x,e.x),gd(a,c.y,d.y,e.y),gd(a,c.z,d.z,e.z));return b};Va.prototype.copy=function(a){K.prototype.copy.call(this,a);this.v0.copy(a.v0);this.v1.copy(a.v1);this.v2.copy(a.v2);return this};Va.prototype.toJSON=function(){var a=K.prototype.toJSON.call(this);a.v0=this.v0.toArray();a.v1=this.v1.toArray();a.v2=this.v2.toArray();return a};Va.prototype.fromJSON=function(a){K.prototype.fromJSON.call(this,a);this.v0.fromArray(a.v0);this.v1.fromArray(a.v1);this.v2.fromArray(a.v2);return this};Ma.prototype=Object.create(K.prototype);
Ma.prototype.constructor=Ma;Ma.prototype.isSplineCurve=!0;Ma.prototype.getPoint=function(a,b){b=b||new z;var c=this.points,d=(c.length-1)*a;a=Math.floor(d);d-=a;var e=c[0===a?a:a-1],f=c[a],g=c[a>c.length-2?c.length-1:a+1];c=c[a>c.length-3?c.length-1:a+2];b.set(vf(d,e.x,f.x,g.x,c.x),vf(d,e.y,f.y,g.y,c.y));return b};Ma.prototype.copy=function(a){K.prototype.copy.call(this,a);this.points=[];for(var b=0,c=a.points.length;b<c;b++)this.points.push(a.points[b].clone());return this};Ma.prototype.toJSON=function(){var a=
K.prototype.toJSON.call(this);a.points=[];for(var b=0,c=this.points.length;b<c;b++)a.points.push(this.points[b].toArray());return a};Ma.prototype.fromJSON=function(a){K.prototype.fromJSON.call(this,a);this.points=[];for(var b=0,c=a.points.length;b<c;b++){var d=a.points[b];this.points.push((new z).fromArray(d))}return this};var If=Object.freeze({ArcCurve:kc,CatmullRomCurve3:ta,CubicBezierCurve:Ja,CubicBezierCurve3:Ua,EllipseCurve:va,LineCurve:Aa,LineCurve3:Ka,QuadraticBezierCurve:La,QuadraticBezierCurve3:Va,
SplineCurve:Ma});$a.prototype=Object.assign(Object.create(K.prototype),{constructor:$a,add:function(a){this.curves.push(a)},closePath:function(){var a=this.curves[0].getPoint(0),b=this.curves[this.curves.length-1].getPoint(1);a.equals(b)||this.curves.push(new Aa(b,a))},getPoint:function(a){var b=a*this.getLength(),c=this.getCurveLengths();for(a=0;a<c.length;){if(c[a]>=b)return b=c[a]-b,a=this.curves[a],c=a.getLength(),a.getPointAt(0===c?0:1-b/c);a++}return null},getLength:function(){var a=this.getCurveLengths();
return a[a.length-1]},updateArcLengths:function(){this.needsUpdate=!0;this.cacheLengths=null;this.getCurveLengths()},getCurveLengths:function(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;for(var a=[],b=0,c=0,d=this.curves.length;c<d;c++)b+=this.curves[c].getLength(),a.push(b);return this.cacheLengths=a},getSpacedPoints:function(a){void 0===a&&(a=40);for(var b=[],c=0;c<=a;c++)b.push(this.getPoint(c/a));this.autoClose&&b.push(b[0]);return b},getPoints:function(a){a=
a||12;for(var b=[],c,d=0,e=this.curves;d<e.length;d++){var f=e[d];f=f.getPoints(f&&f.isEllipseCurve?2*a:f&&(f.isLineCurve||f.isLineCurve3)?1:f&&f.isSplineCurve?a*f.points.length:a);for(var g=0;g<f.length;g++){var h=f[g];c&&c.equals(h)||(b.push(h),c=h)}}this.autoClose&&1<b.length&&!b[b.length-1].equals(b[0])&&b.push(b[0]);return b},copy:function(a){K.prototype.copy.call(this,a);this.curves=[];for(var b=0,c=a.curves.length;b<c;b++)this.curves.push(a.curves[b].clone());this.autoClose=a.autoClose;return this},
toJSON:function(){var a=K.prototype.toJSON.call(this);a.autoClose=this.autoClose;a.curves=[];for(var b=0,c=this.curves.length;b<c;b++)a.curves.push(this.curves[b].toJSON());return a},fromJSON:function(a){K.prototype.fromJSON.call(this,a);this.autoClose=a.autoClose;this.curves=[];for(var b=0,c=a.curves.length;b<c;b++){var d=a.curves[b];this.curves.push((new If[d.type]).fromJSON(d))}return this}});Na.prototype=Object.assign(Object.create($a.prototype),{constructor:Na,setFromPoints:function(a){this.moveTo(a[0].x,
a[0].y);for(var b=1,c=a.length;b<c;b++)this.lineTo(a[b].x,a[b].y)},moveTo:function(a,b){this.currentPoint.set(a,b)},lineTo:function(a,b){var c=new Aa(this.currentPoint.clone(),new z(a,b));this.curves.push(c);this.currentPoint.set(a,b)},quadraticCurveTo:function(a,b,c,d){a=new La(this.currentPoint.clone(),new z(a,b),new z(c,d));this.curves.push(a);this.currentPoint.set(c,d)},bezierCurveTo:function(a,b,c,d,e,f){a=new Ja(this.currentPoint.clone(),new z(a,b),new z(c,d),new z(e,f));this.curves.push(a);
this.currentPoint.set(e,f)},splineThru:function(a){var b=[this.currentPoint.clone()].concat(a);b=new Ma(b);this.curves.push(b);this.currentPoint.copy(a[a.length-1])},arc:function(a,b,c,d,e,f){this.absarc(a+this.currentPoint.x,b+this.currentPoint.y,c,d,e,f)},absarc:function(a,b,c,d,e,f){this.absellipse(a,b,c,c,d,e,f)},ellipse:function(a,b,c,d,e,f,g,h){this.absellipse(a+this.currentPoint.x,b+this.currentPoint.y,c,d,e,f,g,h)},absellipse:function(a,b,c,d,e,f,g,h){a=new va(a,b,c,d,e,f,g,h);0<this.curves.length&&
(b=a.getPoint(0),b.equals(this.currentPoint)||this.lineTo(b.x,b.y));this.curves.push(a);a=a.getPoint(1);this.currentPoint.copy(a)},copy:function(a){$a.prototype.copy.call(this,a);this.currentPoint.copy(a.currentPoint);return this},toJSON:function(){var a=$a.prototype.toJSON.call(this);a.currentPoint=this.currentPoint.toArray();return a},fromJSON:function(a){$a.prototype.fromJSON.call(this,a);this.currentPoint.fromArray(a.currentPoint);return this}});hb.prototype=Object.assign(Object.create(Na.prototype),
{constructor:hb,getPointsHoles:function(a){for(var b=[],c=0,d=this.holes.length;c<d;c++)b[c]=this.holes[c].getPoints(a);return b},extractPoints:function(a){return{shape:this.getPoints(a),holes:this.getPointsHoles(a)}},copy:function(a){Na.prototype.copy.call(this,a);this.holes=[];for(var b=0,c=a.holes.length;b<c;b++)this.holes.push(a.holes[b].clone());return this},toJSON:function(){var a=Na.prototype.toJSON.call(this);a.uuid=this.uuid;a.holes=[];for(var b=0,c=this.holes.length;b<c;b++)a.holes.push(this.holes[b].toJSON());
return a},fromJSON:function(a){Na.prototype.fromJSON.call(this,a);this.uuid=a.uuid;this.holes=[];for(var b=0,c=a.holes.length;b<c;b++){var d=a.holes[b];this.holes.push((new Na).fromJSON(d))}return this}});ba.prototype=Object.assign(Object.create(C.prototype),{constructor:ba,isLight:!0,copy:function(a){C.prototype.copy.call(this,a);this.color.copy(a.color);this.intensity=a.intensity;return this},toJSON:function(a){a=C.prototype.toJSON.call(this,a);a.object.color=this.color.getHex();a.object.intensity=
this.intensity;void 0!==this.groundColor&&(a.object.groundColor=this.groundColor.getHex());void 0!==this.distance&&(a.object.distance=this.distance);void 0!==this.angle&&(a.object.angle=this.angle);void 0!==this.decay&&(a.object.decay=this.decay);void 0!==this.penumbra&&(a.object.penumbra=this.penumbra);void 0!==this.shadow&&(a.object.shadow=this.shadow.toJSON());return a}});Id.prototype=Object.assign(Object.create(ba.prototype),{constructor:Id,isHemisphereLight:!0,copy:function(a){ba.prototype.copy.call(this,
a);this.groundColor.copy(a.groundColor);return this}});Object.assign(Gb.prototype,{copy:function(a){this.camera=a.camera.clone();this.bias=a.bias;this.radius=a.radius;this.mapSize.copy(a.mapSize);return this},clone:function(){return(new this.constructor).copy(this)},toJSON:function(){var a={};0!==this.bias&&(a.bias=this.bias);1!==this.radius&&(a.radius=this.radius);if(512!==this.mapSize.x||512!==this.mapSize.y)a.mapSize=this.mapSize.toArray();a.camera=this.camera.toJSON(!1).object;delete a.camera.matrix;
return a}});Jd.prototype=Object.assign(Object.create(Gb.prototype),{constructor:Jd,isSpotLightShadow:!0,update:function(a){var b=this.camera,c=2*R.RAD2DEG*a.angle,d=this.mapSize.width/this.mapSize.height;a=a.distance||b.far;if(c!==b.fov||d!==b.aspect||a!==b.far)b.fov=c,b.aspect=d,b.far=a,b.updateProjectionMatrix()}});Kd.prototype=Object.assign(Object.create(ba.prototype),{constructor:Kd,isSpotLight:!0,copy:function(a){ba.prototype.copy.call(this,a);this.distance=a.distance;this.angle=a.angle;this.penumbra=
a.penumbra;this.decay=a.decay;this.target=a.target.clone();this.shadow=a.shadow.clone();return this}});Ld.prototype=Object.assign(Object.create(ba.prototype),{constructor:Ld,isPointLight:!0,copy:function(a){ba.prototype.copy.call(this,a);this.distance=a.distance;this.decay=a.decay;this.shadow=a.shadow.clone();return this}});id.prototype=Object.assign(Object.create(Ra.prototype),{constructor:id,isOrthographicCamera:!0,copy:function(a,b){Ra.prototype.copy.call(this,a,b);this.left=a.left;this.right=
a.right;this.top=a.top;this.bottom=a.bottom;this.near=a.near;this.far=a.far;this.zoom=a.zoom;this.view=null===a.view?null:Object.assign({},a.view);return this},setViewOffset:function(a,b,c,d,e,f){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1});this.view.enabled=!0;this.view.fullWidth=a;this.view.fullHeight=b;this.view.offsetX=c;this.view.offsetY=d;this.view.width=e;this.view.height=f;this.updateProjectionMatrix()},clearViewOffset:function(){null!==
this.view&&(this.view.enabled=!1);this.updateProjectionMatrix()},updateProjectionMatrix:function(){var a=(this.right-this.left)/(2*this.zoom),b=(this.top-this.bottom)/(2*this.zoom),c=(this.right+this.left)/2,d=(this.top+this.bottom)/2,e=c-a;c+=a;a=d+b;b=d-b;if(null!==this.view&&this.view.enabled){c=this.zoom/(this.view.width/this.view.fullWidth);b=this.zoom/(this.view.height/this.view.fullHeight);var f=(this.right-this.left)/this.view.width;d=(this.top-this.bottom)/this.view.height;e+=this.view.offsetX/
c*f;c=e+this.view.width/c*f;a-=this.view.offsetY/b*d;b=a-this.view.height/b*d}this.projectionMatrix.makeOrthographic(e,c,a,b,this.near,this.far);this.projectionMatrixInverse.getInverse(this.projectionMatrix)},toJSON:function(a){a=C.prototype.toJSON.call(this,a);a.object.zoom=this.zoom;a.object.left=this.left;a.object.right=this.right;a.object.top=this.top;a.object.bottom=this.bottom;a.object.near=this.near;a.object.far=this.far;null!==this.view&&(a.object.view=Object.assign({},this.view));return a}});
Md.prototype=Object.assign(Object.create(Gb.prototype),{constructor:Md});Nd.prototype=Object.assign(Object.create(ba.prototype),{constructor:Nd,isDirectionalLight:!0,copy:function(a){ba.prototype.copy.call(this,a);this.target=a.target.clone();this.shadow=a.shadow.clone();return this}});Od.prototype=Object.assign(Object.create(ba.prototype),{constructor:Od,isAmbientLight:!0});Pd.prototype=Object.assign(Object.create(ba.prototype),{constructor:Pd,isRectAreaLight:!0,copy:function(a){ba.prototype.copy.call(this,
a);this.width=a.width;this.height=a.height;return this},toJSON:function(a){a=ba.prototype.toJSON.call(this,a);a.object.width=this.width;a.object.height=this.height;return a}});Object.assign(Qd.prototype,{load:function(a,b,c,d){var e=this,f=new Ia(e.manager);f.setPath(e.path);f.load(a,function(a){b(e.parse(JSON.parse(a)))},c,d)},parse:function(a){function b(a){void 0===c[a]&&console.warn("THREE.MaterialLoader: Undefined texture",a);return c[a]}var c=this.textures,d=new dh[a.type];void 0!==a.uuid&&
(d.uuid=a.uuid);void 0!==a.name&&(d.name=a.name);void 0!==a.color&&d.color.setHex(a.color);void 0!==a.roughness&&(d.roughness=a.roughness);void 0!==a.metalness&&(d.metalness=a.metalness);void 0!==a.emissive&&d.emissive.setHex(a.emissive);void 0!==a.specular&&d.specular.setHex(a.specular);void 0!==a.shininess&&(d.shininess=a.shininess);void 0!==a.clearCoat&&(d.clearCoat=a.clearCoat);void 0!==a.clearCoatRoughness&&(d.clearCoatRoughness=a.clearCoatRoughness);void 0!==a.vertexColors&&(d.vertexColors=
a.vertexColors);void 0!==a.fog&&(d.fog=a.fog);void 0!==a.flatShading&&(d.flatShading=a.flatShading);void 0!==a.blending&&(d.blending=a.blending);void 0!==a.combine&&(d.combine=a.combine);void 0!==a.side&&(d.side=a.side);void 0!==a.opacity&&(d.opacity=a.opacity);void 0!==a.transparent&&(d.transparent=a.transparent);void 0!==a.alphaTest&&(d.alphaTest=a.alphaTest);void 0!==a.depthTest&&(d.depthTest=a.depthTest);void 0!==a.depthWrite&&(d.depthWrite=a.depthWrite);void 0!==a.colorWrite&&(d.colorWrite=a.colorWrite);
void 0!==a.wireframe&&(d.wireframe=a.wireframe);void 0!==a.wireframeLinewidth&&(d.wireframeLinewidth=a.wireframeLinewidth);void 0!==a.wireframeLinecap&&(d.wireframeLinecap=a.wireframeLinecap);void 0!==a.wireframeLinejoin&&(d.wireframeLinejoin=a.wireframeLinejoin);void 0!==a.rotation&&(d.rotation=a.rotation);1!==a.linewidth&&(d.linewidth=a.linewidth);void 0!==a.dashSize&&(d.dashSize=a.dashSize);void 0!==a.gapSize&&(d.gapSize=a.gapSize);void 0!==a.scale&&(d.scale=a.scale);void 0!==a.polygonOffset&&
(d.polygonOffset=a.polygonOffset);void 0!==a.polygonOffsetFactor&&(d.polygonOffsetFactor=a.polygonOffsetFactor);void 0!==a.polygonOffsetUnits&&(d.polygonOffsetUnits=a.polygonOffsetUnits);void 0!==a.skinning&&(d.skinning=a.skinning);void 0!==a.morphTargets&&(d.morphTargets=a.morphTargets);void 0!==a.dithering&&(d.dithering=a.dithering);void 0!==a.visible&&(d.visible=a.visible);void 0!==a.userData&&(d.userData=a.userData);if(void 0!==a.uniforms)for(var e in a.uniforms){var f=a.uniforms[e];d.uniforms[e]=
{};switch(f.type){case "t":d.uniforms[e].value=b(f.value);break;case "c":d.uniforms[e].value=(new J).setHex(f.value);break;case "v2":d.uniforms[e].value=(new z).fromArray(f.value);break;case "v3":d.uniforms[e].value=(new n).fromArray(f.value);break;case "v4":d.uniforms[e].value=(new ca).fromArray(f.value);break;case "m4":d.uniforms[e].value=(new O).fromArray(f.value);break;default:d.uniforms[e].value=f.value}}void 0!==a.defines&&(d.defines=a.defines);void 0!==a.vertexShader&&(d.vertexShader=a.vertexShader);
void 0!==a.fragmentShader&&(d.fragmentShader=a.fragmentShader);void 0!==a.shading&&(d.flatShading=1===a.shading);void 0!==a.size&&(d.size=a.size);void 0!==a.sizeAttenuation&&(d.sizeAttenuation=a.sizeAttenuation);void 0!==a.map&&(d.map=b(a.map));void 0!==a.alphaMap&&(d.alphaMap=b(a.alphaMap),d.transparent=!0);void 0!==a.bumpMap&&(d.bumpMap=b(a.bumpMap));void 0!==a.bumpScale&&(d.bumpScale=a.bumpScale);void 0!==a.normalMap&&(d.normalMap=b(a.normalMap));void 0!==a.normalMapType&&(d.normalMapType=a.normalMapType);
void 0!==a.normalScale&&(e=a.normalScale,!1===Array.isArray(e)&&(e=[e,e]),d.normalScale=(new z).fromArray(e));void 0!==a.displacementMap&&(d.displacementMap=b(a.displacementMap));void 0!==a.displacementScale&&(d.displacementScale=a.displacementScale);void 0!==a.displacementBias&&(d.displacementBias=a.displacementBias);void 0!==a.roughnessMap&&(d.roughnessMap=b(a.roughnessMap));void 0!==a.metalnessMap&&(d.metalnessMap=b(a.metalnessMap));void 0!==a.emissiveMap&&(d.emissiveMap=b(a.emissiveMap));void 0!==
a.emissiveIntensity&&(d.emissiveIntensity=a.emissiveIntensity);void 0!==a.specularMap&&(d.specularMap=b(a.specularMap));void 0!==a.envMap&&(d.envMap=b(a.envMap));void 0!==a.envMapIntensity&&(d.envMapIntensity=a.envMapIntensity);void 0!==a.reflectivity&&(d.reflectivity=a.reflectivity);void 0!==a.lightMap&&(d.lightMap=b(a.lightMap));void 0!==a.lightMapIntensity&&(d.lightMapIntensity=a.lightMapIntensity);void 0!==a.aoMap&&(d.aoMap=b(a.aoMap));void 0!==a.aoMapIntensity&&(d.aoMapIntensity=a.aoMapIntensity);
void 0!==a.gradientMap&&(d.gradientMap=b(a.gradientMap));return d},setPath:function(a){this.path=a;return this},setTextures:function(a){this.textures=a;return this}});var Ie={decodeText:function(a){if("undefined"!==typeof TextDecoder)return(new TextDecoder).decode(a);for(var b="",c=0,d=a.length;c<d;c++)b+=String.fromCharCode(a[c]);return decodeURIComponent(escape(b))},extractUrlBase:function(a){var b=a.lastIndexOf("/");return-1===b?"./":a.substr(0,b+1)}};Object.assign(ke.prototype,{load:function(a,
b,c,d){var e=this,f=new Ia(e.manager);f.setPath(e.path);f.load(a,function(a){b(e.parse(JSON.parse(a)))},c,d)},parse:function(a){var b=new D,c=a.data.index;void 0!==c&&(c=new Jf[c.type](c.array),b.setIndex(new E(c,1)));var d=a.data.attributes;for(f in d){var e=d[f];c=new Jf[e.type](e.array);b.addAttribute(f,new E(c,e.itemSize,e.normalized))}var f=a.data.groups||a.data.drawcalls||a.data.offsets;if(void 0!==f)for(c=0,d=f.length;c!==d;++c)e=f[c],b.addGroup(e.start,e.count,e.materialIndex);f=a.data.boundingSphere;
void 0!==f&&(c=new n,void 0!==f.center&&c.fromArray(f.center),b.boundingSphere=new Ea(c,f.radius));a.name&&(b.name=a.name);a.userData&&(b.userData=a.userData);return b},setPath:function(a){this.path=a;return this}});var Jf={Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:"undefined"!==typeof Uint8ClampedArray?Uint8ClampedArray:Uint8Array,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array};Object.assign(le.prototype,
{crossOrigin:"anonymous",load:function(a,b,c,d){var e=this,f=void 0===this.path?Ie.extractUrlBase(a):this.path;this.resourcePath=this.resourcePath||f;f=new Ia(e.manager);f.setPath(this.path);f.load(a,function(c){var f=null;try{f=JSON.parse(c)}catch(k){void 0!==d&&d(k);console.error("THREE:ObjectLoader: Can't parse "+a+".",k.message);return}c=f.metadata;void 0===c||void 0===c.type||"geometry"===c.type.toLowerCase()?console.error("THREE.ObjectLoader: Can't load "+a):e.parse(f,b)},c,d)},setPath:function(a){this.path=
a;return this},setResourcePath:function(a){this.resourcePath=a;return this},setCrossOrigin:function(a){this.crossOrigin=a;return this},parse:function(a,b){var c=this.parseShape(a.shapes);c=this.parseGeometries(a.geometries,c);var d=this.parseImages(a.images,function(){void 0!==b&&b(e)});d=this.parseTextures(a.textures,d);d=this.parseMaterials(a.materials,d);var e=this.parseObject(a.object,c,d);a.animations&&(e.animations=this.parseAnimations(a.animations));void 0!==a.images&&0!==a.images.length||
void 0===b||b(e);return e},parseShape:function(a){var b={};if(void 0!==a)for(var c=0,d=a.length;c<d;c++){var e=(new hb).fromJSON(a[c]);b[e.uuid]=e}return b},parseGeometries:function(a,b){var c={};if(void 0!==a)for(var d=new ke,e=0,f=a.length;e<f;e++){var g=a[e];switch(g.type){case "PlaneGeometry":case "PlaneBufferGeometry":var h=new ia[g.type](g.width,g.height,g.widthSegments,g.heightSegments);break;case "BoxGeometry":case "BoxBufferGeometry":case "CubeGeometry":h=new ia[g.type](g.width,g.height,
g.depth,g.widthSegments,g.heightSegments,g.depthSegments);break;case "CircleGeometry":case "CircleBufferGeometry":h=new ia[g.type](g.radius,g.segments,g.thetaStart,g.thetaLength);break;case "CylinderGeometry":case "CylinderBufferGeometry":h=new ia[g.type](g.radiusTop,g.radiusBottom,g.height,g.radialSegments,g.heightSegments,g.openEnded,g.thetaStart,g.thetaLength);break;case "ConeGeometry":case "ConeBufferGeometry":h=new ia[g.type](g.radius,g.height,g.radialSegments,g.heightSegments,g.openEnded,g.thetaStart,
g.thetaLength);break;case "SphereGeometry":case "SphereBufferGeometry":h=new ia[g.type](g.radius,g.widthSegments,g.heightSegments,g.phiStart,g.phiLength,g.thetaStart,g.thetaLength);break;case "DodecahedronGeometry":case "DodecahedronBufferGeometry":case "IcosahedronGeometry":case "IcosahedronBufferGeometry":case "OctahedronGeometry":case "OctahedronBufferGeometry":case "TetrahedronGeometry":case "TetrahedronBufferGeometry":h=new ia[g.type](g.radius,g.detail);break;case "RingGeometry":case "RingBufferGeometry":h=
new ia[g.type](g.innerRadius,g.outerRadius,g.thetaSegments,g.phiSegments,g.thetaStart,g.thetaLength);break;case "TorusGeometry":case "TorusBufferGeometry":h=new ia[g.type](g.radius,g.tube,g.radialSegments,g.tubularSegments,g.arc);break;case "TorusKnotGeometry":case "TorusKnotBufferGeometry":h=new ia[g.type](g.radius,g.tube,g.tubularSegments,g.radialSegments,g.p,g.q);break;case "LatheGeometry":case "LatheBufferGeometry":h=new ia[g.type](g.points,g.segments,g.phiStart,g.phiLength);break;case "PolyhedronGeometry":case "PolyhedronBufferGeometry":h=
new ia[g.type](g.vertices,g.indices,g.radius,g.details);break;case "ShapeGeometry":case "ShapeBufferGeometry":h=[];for(var k=0,m=g.shapes.length;k<m;k++){var l=b[g.shapes[k]];h.push(l)}h=new ia[g.type](h,g.curveSegments);break;case "ExtrudeGeometry":case "ExtrudeBufferGeometry":h=[];k=0;for(m=g.shapes.length;k<m;k++)l=b[g.shapes[k]],h.push(l);k=g.options.extrudePath;void 0!==k&&(g.options.extrudePath=(new If[k.type]).fromJSON(k));h=new ia[g.type](h,g.options);break;case "BufferGeometry":h=d.parse(g);
break;case "Geometry":"THREE"in window&&"LegacyJSONLoader"in THREE?h=(new THREE.LegacyJSONLoader).parse(g,this.resourcePath).geometry:console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');break;default:console.warn('THREE.ObjectLoader: Unsupported geometry type "'+g.type+'"');continue}h.uuid=g.uuid;void 0!==g.name&&(h.name=g.name);!0===h.isBufferGeometry&&void 0!==g.userData&&(h.userData=g.userData);c[g.uuid]=h}return c},parseMaterials:function(a,
b){var c={},d={};if(void 0!==a){var e=new Qd;e.setTextures(b);b=0;for(var f=a.length;b<f;b++){var g=a[b];if("MultiMaterial"===g.type){for(var h=[],k=0;k<g.materials.length;k++){var m=g.materials[k];void 0===c[m.uuid]&&(c[m.uuid]=e.parse(m));h.push(c[m.uuid])}d[g.uuid]=h}else d[g.uuid]=e.parse(g),c[g.uuid]=d[g.uuid]}}return d},parseAnimations:function(a){for(var b=[],c=0;c<a.length;c++){var d=a[c],e=Ha.parse(d);void 0!==d.uuid&&(e.uuid=d.uuid);b.push(e)}return b},parseImages:function(a,b){function c(a){d.manager.itemStart(a);
return f.load(a,function(){d.manager.itemEnd(a)},void 0,function(){d.manager.itemError(a);d.manager.itemEnd(a)})}var d=this,e={};if(void 0!==a&&0<a.length){b=new ge(b);var f=new fd(b);f.setCrossOrigin(this.crossOrigin);b=0;for(var g=a.length;b<g;b++){var h=a[b],k=h.url;if(Array.isArray(k)){e[h.uuid]=[];for(var m=0,l=k.length;m<l;m++){var p=k[m];p=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(p)?p:d.resourcePath+p;e[h.uuid].push(c(p))}}else p=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(h.url)?h.url:d.resourcePath+h.url,e[h.uuid]=
c(p)}}return e},parseTextures:function(a,b){function c(a,b){if("number"===typeof a)return a;console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",a);return b[a]}var d={};if(void 0!==a)for(var e=0,f=a.length;e<f;e++){var g=a[e];void 0===g.image&&console.warn('THREE.ObjectLoader: No "image" specified for',g.uuid);void 0===b[g.image]&&console.warn("THREE.ObjectLoader: Undefined image",g.image);var h=Array.isArray(b[g.image])?new Xa(b[g.image]):new X(b[g.image]);h.needsUpdate=
!0;h.uuid=g.uuid;void 0!==g.name&&(h.name=g.name);void 0!==g.mapping&&(h.mapping=c(g.mapping,eh));void 0!==g.offset&&h.offset.fromArray(g.offset);void 0!==g.repeat&&h.repeat.fromArray(g.repeat);void 0!==g.center&&h.center.fromArray(g.center);void 0!==g.rotation&&(h.rotation=g.rotation);void 0!==g.wrap&&(h.wrapS=c(g.wrap[0],Kf),h.wrapT=c(g.wrap[1],Kf));void 0!==g.format&&(h.format=g.format);void 0!==g.minFilter&&(h.minFilter=c(g.minFilter,Lf));void 0!==g.magFilter&&(h.magFilter=c(g.magFilter,Lf));
void 0!==g.anisotropy&&(h.anisotropy=g.anisotropy);void 0!==g.flipY&&(h.flipY=g.flipY);d[g.uuid]=h}return d},parseObject:function(a,b,c){function d(a){void 0===b[a]&&console.warn("THREE.ObjectLoader: Undefined geometry",a);return b[a]}function e(a){if(void 0!==a){if(Array.isArray(a)){for(var b=[],d=0,e=a.length;d<e;d++){var f=a[d];void 0===c[f]&&console.warn("THREE.ObjectLoader: Undefined material",f);b.push(c[f])}return b}void 0===c[a]&&console.warn("THREE.ObjectLoader: Undefined material",a);return c[a]}}
switch(a.type){case "Scene":var f=new xd;void 0!==a.background&&Number.isInteger(a.background)&&(f.background=new J(a.background));void 0!==a.fog&&("Fog"===a.fog.type?f.fog=new Rb(a.fog.color,a.fog.near,a.fog.far):"FogExp2"===a.fog.type&&(f.fog=new Qb(a.fog.color,a.fog.density)));break;case "PerspectiveCamera":f=new V(a.fov,a.aspect,a.near,a.far);void 0!==a.focus&&(f.focus=a.focus);void 0!==a.zoom&&(f.zoom=a.zoom);void 0!==a.filmGauge&&(f.filmGauge=a.filmGauge);void 0!==a.filmOffset&&(f.filmOffset=
a.filmOffset);void 0!==a.view&&(f.view=Object.assign({},a.view));break;case "OrthographicCamera":f=new id(a.left,a.right,a.top,a.bottom,a.near,a.far);void 0!==a.zoom&&(f.zoom=a.zoom);void 0!==a.view&&(f.view=Object.assign({},a.view));break;case "AmbientLight":f=new Od(a.color,a.intensity);break;case "DirectionalLight":f=new Nd(a.color,a.intensity);break;case "PointLight":f=new Ld(a.color,a.intensity,a.distance,a.decay);break;case "RectAreaLight":f=new Pd(a.color,a.intensity,a.width,a.height);break;
case "SpotLight":f=new Kd(a.color,a.intensity,a.distance,a.angle,a.penumbra,a.decay);break;case "HemisphereLight":f=new Id(a.color,a.groundColor,a.intensity);break;case "SkinnedMesh":console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");case "Mesh":f=d(a.geometry);var g=e(a.material);f=f.bones&&0<f.bones.length?new Hc(f,g):new pa(f,g);break;case "LOD":f=new Gc;break;case "Line":f=new ma(d(a.geometry),e(a.material),a.mode);break;case "LineLoop":f=new zd(d(a.geometry),e(a.material));
break;case "LineSegments":f=new S(d(a.geometry),e(a.material));break;case "PointCloud":case "Points":f=new Tb(d(a.geometry),e(a.material));break;case "Sprite":f=new Fc(e(a.material));break;case "Group":f=new Pb;break;default:f=new C}f.uuid=a.uuid;void 0!==a.name&&(f.name=a.name);void 0!==a.matrix?(f.matrix.fromArray(a.matrix),void 0!==a.matrixAutoUpdate&&(f.matrixAutoUpdate=a.matrixAutoUpdate),f.matrixAutoUpdate&&f.matrix.decompose(f.position,f.quaternion,f.scale)):(void 0!==a.position&&f.position.fromArray(a.position),
void 0!==a.rotation&&f.rotation.fromArray(a.rotation),void 0!==a.quaternion&&f.quaternion.fromArray(a.quaternion),void 0!==a.scale&&f.scale.fromArray(a.scale));void 0!==a.castShadow&&(f.castShadow=a.castShadow);void 0!==a.receiveShadow&&(f.receiveShadow=a.receiveShadow);a.shadow&&(void 0!==a.shadow.bias&&(f.shadow.bias=a.shadow.bias),void 0!==a.shadow.radius&&(f.shadow.radius=a.shadow.radius),void 0!==a.shadow.mapSize&&f.shadow.mapSize.fromArray(a.shadow.mapSize),void 0!==a.shadow.camera&&(f.shadow.camera=
this.parseObject(a.shadow.camera)));void 0!==a.visible&&(f.visible=a.visible);void 0!==a.frustumCulled&&(f.frustumCulled=a.frustumCulled);void 0!==a.renderOrder&&(f.renderOrder=a.renderOrder);void 0!==a.userData&&(f.userData=a.userData);void 0!==a.layers&&(f.layers.mask=a.layers);if(void 0!==a.children){g=a.children;for(var h=0;h<g.length;h++)f.add(this.parseObject(g[h],b,c))}if("LOD"===a.type)for(a=a.levels,g=0;g<a.length;g++){h=a[g];var k=f.getObjectByProperty("uuid",h.object);void 0!==k&&f.addLevel(k,
h.distance)}return f}});var eh={UVMapping:300,CubeReflectionMapping:301,CubeRefractionMapping:302,EquirectangularReflectionMapping:303,EquirectangularRefractionMapping:304,SphericalReflectionMapping:305,CubeUVReflectionMapping:306,CubeUVRefractionMapping:307},Kf={RepeatWrapping:1E3,ClampToEdgeWrapping:1001,MirroredRepeatWrapping:1002},Lf={NearestFilter:1003,NearestMipMapNearestFilter:1004,NearestMipMapLinearFilter:1005,LinearFilter:1006,LinearMipMapNearestFilter:1007,LinearMipMapLinearFilter:1008};
me.prototype={constructor:me,setOptions:function(a){this.options=a;return this},load:function(a,b,c,d){void 0===a&&(a="");void 0!==this.path&&(a=this.path+a);a=this.manager.resolveURL(a);var e=this,f=Hb.get(a);if(void 0!==f)return e.manager.itemStart(a),setTimeout(function(){b&&b(f);e.manager.itemEnd(a)},0),f;fetch(a).then(function(a){return a.blob()}).then(function(a){return createImageBitmap(a,e.options)}).then(function(c){Hb.add(a,c);b&&b(c);e.manager.itemEnd(a)}).catch(function(b){d&&d(b);e.manager.itemError(a);
e.manager.itemEnd(a)})},setCrossOrigin:function(){return this},setPath:function(a){this.path=a;return this}};Object.assign(ne.prototype,{moveTo:function(a,b){this.currentPath=new Na;this.subPaths.push(this.currentPath);this.currentPath.moveTo(a,b)},lineTo:function(a,b){this.currentPath.lineTo(a,b)},quadraticCurveTo:function(a,b,c,d){this.currentPath.quadraticCurveTo(a,b,c,d)},bezierCurveTo:function(a,b,c,d,e,f){this.currentPath.bezierCurveTo(a,b,c,d,e,f)},splineThru:function(a){this.currentPath.splineThru(a)},
toShapes:function(a,b){function c(a){for(var b=[],c=0,d=a.length;c<d;c++){var e=a[c],f=new hb;f.curves=e.curves;b.push(f)}return b}function d(a,b){for(var c=b.length,d=!1,e=c-1,f=0;f<c;e=f++){var g=b[e],h=b[f],k=h.x-g.x,l=h.y-g.y;if(Math.abs(l)>Number.EPSILON){if(0>l&&(g=b[f],k=-k,h=b[e],l=-l),!(a.y<g.y||a.y>h.y))if(a.y===g.y){if(a.x===g.x)return!0}else{e=l*(a.x-g.x)-k*(a.y-g.y);if(0===e)return!0;0>e||(d=!d)}}else if(a.y===g.y&&(h.x<=a.x&&a.x<=g.x||g.x<=a.x&&a.x<=h.x))return!0}return d}var e=Ya.isClockWise,
f=this.subPaths;if(0===f.length)return[];if(!0===b)return c(f);b=[];if(1===f.length){var g=f[0];var h=new hb;h.curves=g.curves;b.push(h);return b}var k=!e(f[0].getPoints());k=a?!k:k;h=[];var m=[],l=[],p=0;m[p]=void 0;l[p]=[];for(var n=0,x=f.length;n<x;n++){g=f[n];var t=g.getPoints();var v=e(t);(v=a?!v:v)?(!k&&m[p]&&p++,m[p]={s:new hb,p:t},m[p].s.curves=g.curves,k&&p++,l[p]=[]):l[p].push({h:g,p:t[0]})}if(!m[0])return c(f);if(1<m.length){n=!1;a=[];e=0;for(f=m.length;e<f;e++)h[e]=[];e=0;for(f=m.length;e<
f;e++)for(g=l[e],v=0;v<g.length;v++){k=g[v];p=!0;for(t=0;t<m.length;t++)d(k.p,m[t].p)&&(e!==t&&a.push({froms:e,tos:t,hole:v}),p?(p=!1,h[t].push(k)):n=!0);p&&h[e].push(k)}0<a.length&&(n||(l=h))}n=0;for(e=m.length;n<e;n++)for(h=m[n].s,b.push(h),a=l[n],f=0,g=a.length;f<g;f++)h.holes.push(a[f].h);return b}});Object.assign(oe.prototype,{isFont:!0,generateShapes:function(a,b){void 0===b&&(b=100);var c=[],d=b;b=this.data;var e=Array.from?Array.from(a):String(a).split("");d/=b.resolution;var f=(b.boundingBox.yMax-
b.boundingBox.yMin+b.underlineThickness)*d;a=[];for(var g=0,h=0,k=0;k<e.length;k++){var l=e[k];if("\n"===l)g=0,h-=f;else{var q=d;var p=g,n=h;if(l=b.glyphs[l]||b.glyphs["?"]){var x=new ne;if(l.o)for(var t=l._cachedOutline||(l._cachedOutline=l.o.split(" ")),v=0,w=t.length;v<w;)switch(t[v++]){case "m":var y=t[v++]*q+p;var u=t[v++]*q+n;x.moveTo(y,u);break;case "l":y=t[v++]*q+p;u=t[v++]*q+n;x.lineTo(y,u);break;case "q":var z=t[v++]*q+p;var B=t[v++]*q+n;var C=t[v++]*q+p;var D=t[v++]*q+n;x.quadraticCurveTo(C,
D,z,B);break;case "b":z=t[v++]*q+p,B=t[v++]*q+n,C=t[v++]*q+p,D=t[v++]*q+n,y=t[v++]*q+p,u=t[v++]*q+n,x.bezierCurveTo(C,D,y,u,z,B)}q={offsetX:l.ha*q,path:x}}else q=void 0;g+=q.offsetX;a.push(q.path)}}b=0;for(e=a.length;b<e;b++)Array.prototype.push.apply(c,a[b].toShapes());return c}});Object.assign(wf.prototype,{load:function(a,b,c,d){var e=this,f=new Ia(this.manager);f.setPath(this.path);f.load(a,function(a){try{var c=JSON.parse(a)}catch(k){console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),
c=JSON.parse(a.substring(65,a.length-2))}a=e.parse(c);b&&b(a)},c,d)},parse:function(a){return new oe(a)},setPath:function(a){this.path=a;return this}});jd.Handlers={handlers:[],add:function(a,b){this.handlers.push(a,b)},get:function(a){for(var b=this.handlers,c=0,d=b.length;c<d;c+=2){var e=b[c+1];if(b[c].test(a))return e}return null}};Object.assign(jd.prototype,{crossOrigin:"anonymous",onLoadStart:function(){},onLoadProgress:function(){},onLoadComplete:function(){},initMaterials:function(a,b,c){for(var d=
[],e=0;e<a.length;++e)d[e]=this.createMaterial(a[e],b,c);return d},createMaterial:function(){var a={NoBlending:0,NormalBlending:1,AdditiveBlending:2,SubtractiveBlending:3,MultiplyBlending:4,CustomBlending:5},b=new J,c=new Hd,d=new Qd;return function(e,f,g){function h(a,b,d,e,h){a=f+a;var l=jd.Handlers.get(a);null!==l?a=l.load(a):(c.setCrossOrigin(g),a=c.load(a));void 0!==b&&(a.repeat.fromArray(b),1!==b[0]&&(a.wrapS=1E3),1!==b[1]&&(a.wrapT=1E3));void 0!==d&&a.offset.fromArray(d);void 0!==e&&("repeat"===
e[0]&&(a.wrapS=1E3),"mirror"===e[0]&&(a.wrapS=1002),"repeat"===e[1]&&(a.wrapT=1E3),"mirror"===e[1]&&(a.wrapT=1002));void 0!==h&&(a.anisotropy=h);b=R.generateUUID();k[b]=a;return b}var k={},l={uuid:R.generateUUID(),type:"MeshLambertMaterial"},q;for(q in e){var p=e[q];switch(q){case "DbgColor":case "DbgIndex":case "opticalDensity":case "illumination":break;case "DbgName":l.name=p;break;case "blending":l.blending=a[p];break;case "colorAmbient":case "mapAmbient":console.warn("THREE.Loader.createMaterial:",
q,"is no longer supported.");break;case "colorDiffuse":l.color=b.fromArray(p).getHex();break;case "colorSpecular":l.specular=b.fromArray(p).getHex();break;case "colorEmissive":l.emissive=b.fromArray(p).getHex();break;case "specularCoef":l.shininess=p;break;case "shading":"basic"===p.toLowerCase()&&(l.type="MeshBasicMaterial");"phong"===p.toLowerCase()&&(l.type="MeshPhongMaterial");"standard"===p.toLowerCase()&&(l.type="MeshStandardMaterial");break;case "mapDiffuse":l.map=h(p,e.mapDiffuseRepeat,e.mapDiffuseOffset,
e.mapDiffuseWrap,e.mapDiffuseAnisotropy);break;case "mapDiffuseRepeat":case "mapDiffuseOffset":case "mapDiffuseWrap":case "mapDiffuseAnisotropy":break;case "mapEmissive":l.emissiveMap=h(p,e.mapEmissiveRepeat,e.mapEmissiveOffset,e.mapEmissiveWrap,e.mapEmissiveAnisotropy);break;case "mapEmissiveRepeat":case "mapEmissiveOffset":case "mapEmissiveWrap":case "mapEmissiveAnisotropy":break;case "mapLight":l.lightMap=h(p,e.mapLightRepeat,e.mapLightOffset,e.mapLightWrap,e.mapLightAnisotropy);break;case "mapLightRepeat":case "mapLightOffset":case "mapLightWrap":case "mapLightAnisotropy":break;
case "mapAO":l.aoMap=h(p,e.mapAORepeat,e.mapAOOffset,e.mapAOWrap,e.mapAOAnisotropy);break;case "mapAORepeat":case "mapAOOffset":case "mapAOWrap":case "mapAOAnisotropy":break;case "mapBump":l.bumpMap=h(p,e.mapBumpRepeat,e.mapBumpOffset,e.mapBumpWrap,e.mapBumpAnisotropy);break;case "mapBumpScale":l.bumpScale=p;break;case "mapBumpRepeat":case "mapBumpOffset":case "mapBumpWrap":case "mapBumpAnisotropy":break;case "mapNormal":l.normalMap=h(p,e.mapNormalRepeat,e.mapNormalOffset,e.mapNormalWrap,e.mapNormalAnisotropy);
break;case "mapNormalFactor":l.normalScale=p;break;case "mapNormalRepeat":case "mapNormalOffset":case "mapNormalWrap":case "mapNormalAnisotropy":break;case "mapSpecular":l.specularMap=h(p,e.mapSpecularRepeat,e.mapSpecularOffset,e.mapSpecularWrap,e.mapSpecularAnisotropy);break;case "mapSpecularRepeat":case "mapSpecularOffset":case "mapSpecularWrap":case "mapSpecularAnisotropy":break;case "mapMetalness":l.metalnessMap=h(p,e.mapMetalnessRepeat,e.mapMetalnessOffset,e.mapMetalnessWrap,e.mapMetalnessAnisotropy);
break;case "mapMetalnessRepeat":case "mapMetalnessOffset":case "mapMetalnessWrap":case "mapMetalnessAnisotropy":break;case "mapRoughness":l.roughnessMap=h(p,e.mapRoughnessRepeat,e.mapRoughnessOffset,e.mapRoughnessWrap,e.mapRoughnessAnisotropy);break;case "mapRoughnessRepeat":case "mapRoughnessOffset":case "mapRoughnessWrap":case "mapRoughnessAnisotropy":break;case "mapAlpha":l.alphaMap=h(p,e.mapAlphaRepeat,e.mapAlphaOffset,e.mapAlphaWrap,e.mapAlphaAnisotropy);break;case "mapAlphaRepeat":case "mapAlphaOffset":case "mapAlphaWrap":case "mapAlphaAnisotropy":break;
case "flipSided":l.side=1;break;case "doubleSided":l.side=2;break;case "transparency":console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity");l.opacity=p;break;case "depthTest":case "depthWrite":case "colorWrite":case "opacity":case "reflectivity":case "transparent":case "visible":case "wireframe":l[q]=p;break;case "vertexColors":!0===p&&(l.vertexColors=2);"face"===p&&(l.vertexColors=1);break;default:console.error("THREE.Loader.createMaterial: Unsupported",q,p)}}"MeshBasicMaterial"===
l.type&&delete l.emissive;"MeshPhongMaterial"!==l.type&&delete l.specular;1>l.opacity&&(l.transparent=!0);d.setTextures(k);return d.parse(l)}}()});var Vd,se={getContext:function(){void 0===Vd&&(Vd=new (window.AudioContext||window.webkitAudioContext));return Vd},setContext:function(a){Vd=a}};Object.assign(pe.prototype,{load:function(a,b,c,d){var e=new Ia(this.manager);e.setResponseType("arraybuffer");e.setPath(this.path);e.load(a,function(a){a=a.slice(0);se.getContext().decodeAudioData(a,function(a){b(a)})},
c,d)},setPath:function(a){this.path=a;return this}});Object.assign(xf.prototype,{update:function(){var a,b,c,d,e,f,g,h,k=new O,l=new O;return function(m){if(a!==this||b!==m.focus||c!==m.fov||d!==m.aspect*this.aspect||e!==m.near||f!==m.far||g!==m.zoom||h!==this.eyeSep){a=this;b=m.focus;c=m.fov;d=m.aspect*this.aspect;e=m.near;f=m.far;g=m.zoom;var p=m.projectionMatrix.clone();h=this.eyeSep/2;var n=h*e/b,q=e*Math.tan(R.DEG2RAD*c*.5)/g;l.elements[12]=-h;k.elements[12]=h;var t=-q*d+n;var v=q*d+n;p.elements[0]=
2*e/(v-t);p.elements[8]=(v+t)/(v-t);this.cameraL.projectionMatrix.copy(p);t=-q*d-n;v=q*d-n;p.elements[0]=2*e/(v-t);p.elements[8]=(v+t)/(v-t);this.cameraR.projectionMatrix.copy(p)}this.cameraL.matrixWorld.copy(m.matrixWorld).multiply(l);this.cameraR.matrixWorld.copy(m.matrixWorld).multiply(k)}}()});kd.prototype=Object.create(C.prototype);kd.prototype.constructor=kd;Object.assign(qe.prototype,{start:function(){this.oldTime=this.startTime=("undefined"===typeof performance?Date:performance).now();this.elapsedTime=
0;this.running=!0},stop:function(){this.getElapsedTime();this.autoStart=this.running=!1},getElapsedTime:function(){this.getDelta();return this.elapsedTime},getDelta:function(){var a=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){var b=("undefined"===typeof performance?Date:performance).now();a=(b-this.oldTime)/1E3;this.oldTime=b;this.elapsedTime+=a}return a}});re.prototype=Object.assign(Object.create(C.prototype),{constructor:re,getInput:function(){return this.gain},removeFilter:function(){null!==
this.filter&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null);return this},getFilter:function(){return this.filter},setFilter:function(a){null!==this.filter?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination);this.filter=a;this.gain.connect(this.filter);this.filter.connect(this.context.destination);return this},getMasterVolume:function(){return this.gain.gain.value},
setMasterVolume:function(a){this.gain.gain.setTargetAtTime(a,this.context.currentTime,.01);return this},updateMatrixWorld:function(){var a=new n,b=new ka,c=new n,d=new n,e=new qe;return function(f){C.prototype.updateMatrixWorld.call(this,f);f=this.context.listener;var g=this.up;this.timeDelta=e.getDelta();this.matrixWorld.decompose(a,b,c);d.set(0,0,-1).applyQuaternion(b);if(f.positionX){var h=this.context.currentTime+this.timeDelta;f.positionX.linearRampToValueAtTime(a.x,h);f.positionY.linearRampToValueAtTime(a.y,
h);f.positionZ.linearRampToValueAtTime(a.z,h);f.forwardX.linearRampToValueAtTime(d.x,h);f.forwardY.linearRampToValueAtTime(d.y,h);f.forwardZ.linearRampToValueAtTime(d.z,h);f.upX.linearRampToValueAtTime(g.x,h);f.upY.linearRampToValueAtTime(g.y,h);f.upZ.linearRampToValueAtTime(g.z,h)}else f.setPosition(a.x,a.y,a.z),f.setOrientation(d.x,d.y,d.z,g.x,g.y,g.z)}}()});lc.prototype=Object.assign(Object.create(C.prototype),{constructor:lc,getOutput:function(){return this.gain},setNodeSource:function(a){this.hasPlaybackControl=
!1;this.sourceType="audioNode";this.source=a;this.connect();return this},setMediaElementSource:function(a){this.hasPlaybackControl=!1;this.sourceType="mediaNode";this.source=this.context.createMediaElementSource(a);this.connect();return this},setBuffer:function(a){this.buffer=a;this.sourceType="buffer";this.autoplay&&this.play();return this},play:function(){if(!0===this.isPlaying)console.warn("THREE.Audio: Audio is already playing.");else if(!1===this.hasPlaybackControl)console.warn("THREE.Audio: this Audio has no playback control.");
else{var a=this.context.createBufferSource();a.buffer=this.buffer;a.detune.value=this.detune;a.loop=this.loop;a.onended=this.onEnded.bind(this);a.playbackRate.setValueAtTime(this.playbackRate,this.startTime);this.startTime=this.context.currentTime;a.start(this.startTime,this.offset);this.isPlaying=!0;this.source=a;return this.connect()}},pause:function(){if(!1===this.hasPlaybackControl)console.warn("THREE.Audio: this Audio has no playback control.");else return!0===this.isPlaying&&(this.source.stop(),
this.source.onended=null,this.offset+=(this.context.currentTime-this.startTime)*this.playbackRate,this.isPlaying=!1),this},stop:function(){if(!1===this.hasPlaybackControl)console.warn("THREE.Audio: this Audio has no playback control.");else return this.source.stop(),this.source.onended=null,this.offset=0,this.isPlaying=!1,this},connect:function(){if(0<this.filters.length){this.source.connect(this.filters[0]);for(var a=1,b=this.filters.length;a<b;a++)this.filters[a-1].connect(this.filters[a]);this.filters[this.filters.length-
1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this},disconnect:function(){if(0<this.filters.length){this.source.disconnect(this.filters[0]);for(var a=1,b=this.filters.length;a<b;a++)this.filters[a-1].disconnect(this.filters[a]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this},getFilters:function(){return this.filters},setFilters:function(a){a||(a=[]);!0===this.isPlaying?(this.disconnect(),this.filters=
a,this.connect()):this.filters=a;return this},setDetune:function(a){this.detune=a;!0===this.isPlaying&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01);return this},getDetune:function(){return this.detune},getFilter:function(){return this.getFilters()[0]},setFilter:function(a){return this.setFilters(a?[a]:[])},setPlaybackRate:function(a){if(!1===this.hasPlaybackControl)console.warn("THREE.Audio: this Audio has no playback control.");else return this.playbackRate=a,!0===
this.isPlaying&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this},getPlaybackRate:function(){return this.playbackRate},onEnded:function(){this.isPlaying=!1},getLoop:function(){return!1===this.hasPlaybackControl?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop},setLoop:function(a){if(!1===this.hasPlaybackControl)console.warn("THREE.Audio: this Audio has no playback control.");else return this.loop=a,!0===this.isPlaying&&(this.source.loop=
this.loop),this},getVolume:function(){return this.gain.gain.value},setVolume:function(a){this.gain.gain.setTargetAtTime(a,this.context.currentTime,.01);return this}});te.prototype=Object.assign(Object.create(lc.prototype),{constructor:te,getOutput:function(){return this.panner},getRefDistance:function(){return this.panner.refDistance},setRefDistance:function(a){this.panner.refDistance=a;return this},getRolloffFactor:function(){return this.panner.rolloffFactor},setRolloffFactor:function(a){this.panner.rolloffFactor=
a;return this},getDistanceModel:function(){return this.panner.distanceModel},setDistanceModel:function(a){this.panner.distanceModel=a;return this},getMaxDistance:function(){return this.panner.maxDistance},setMaxDistance:function(a){this.panner.maxDistance=a;return this},setDirectionalCone:function(a,b,c){this.panner.coneInnerAngle=a;this.panner.coneOuterAngle=b;this.panner.coneOuterGain=c;return this},updateMatrixWorld:function(){var a=new n,b=new ka,c=new n,d=new n;return function(e){C.prototype.updateMatrixWorld.call(this,
e);e=this.panner;this.matrixWorld.decompose(a,b,c);d.set(0,0,1).applyQuaternion(b);if(e.positionX){var f=this.context.currentTime+this.listener.timeDelta;e.positionX.linearRampToValueAtTime(a.x,f);e.positionY.linearRampToValueAtTime(a.y,f);e.positionZ.linearRampToValueAtTime(a.z,f);e.orientationX.linearRampToValueAtTime(d.x,f);e.orientationY.linearRampToValueAtTime(d.y,f);e.orientationZ.linearRampToValueAtTime(d.z,f)}else e.setPosition(a.x,a.y,a.z),e.setOrientation(d.x,d.y,d.z)}}()});Object.assign(ue.prototype,
{getFrequencyData:function(){this.analyser.getByteFrequencyData(this.data);return this.data},getAverageFrequency:function(){for(var a=0,b=this.getFrequencyData(),c=0;c<b.length;c++)a+=b[c];return a/b.length}});Object.assign(ve.prototype,{accumulate:function(a,b){var c=this.buffer,d=this.valueSize;a=a*d+d;var e=this.cumulativeWeight;if(0===e){for(e=0;e!==d;++e)c[a+e]=c[e];e=b}else e+=b,this._mixBufferRegion(c,a,0,b/e,d);this.cumulativeWeight=e},apply:function(a){var b=this.valueSize,c=this.buffer;
a=a*b+b;var d=this.cumulativeWeight,e=this.binding;this.cumulativeWeight=0;1>d&&this._mixBufferRegion(c,a,3*b,1-d,b);d=b;for(var f=b+b;d!==f;++d)if(c[d]!==c[d+b]){e.setValue(c,a);break}},saveOriginalState:function(){var a=this.buffer,b=this.valueSize,c=3*b;this.binding.getValue(a,c);for(var d=b;d!==c;++d)a[d]=a[c+d%b];this.cumulativeWeight=0},restoreOriginalState:function(){this.binding.setValue(this.buffer,3*this.valueSize)},_select:function(a,b,c,d,e){if(.5<=d)for(d=0;d!==e;++d)a[b+d]=a[c+d]},_slerp:function(a,
b,c,d){ka.slerpFlat(a,b,a,b,a,c,d)},_lerp:function(a,b,c,d,e){for(var f=1-d,g=0;g!==e;++g){var h=b+g;a[h]=a[h]*f+a[c+g]*d}}});Object.assign(yf.prototype,{getValue:function(a,b){this.bind();var c=this._bindings[this._targetGroup.nCachedObjects_];void 0!==c&&c.getValue(a,b)},setValue:function(a,b){for(var c=this._bindings,d=this._targetGroup.nCachedObjects_,e=c.length;d!==e;++d)c[d].setValue(a,b)},bind:function(){for(var a=this._bindings,b=this._targetGroup.nCachedObjects_,c=a.length;b!==c;++b)a[b].bind()},
unbind:function(){for(var a=this._bindings,b=this._targetGroup.nCachedObjects_,c=a.length;b!==c;++b)a[b].unbind()}});Object.assign(oa,{Composite:yf,create:function(a,b,c){return a&&a.isAnimationObjectGroup?new oa.Composite(a,b,c):new oa(a,b,c)},sanitizeNodeName:function(){var a=/[\[\]\.:\/]/g;return function(b){return b.replace(/\s/g,"_").replace(a,"")}}(),parseTrackName:function(){var a="[^"+"\\[\\]\\.:\\/".replace("\\.","")+"]",b=/((?:WC+[\/:])*)/.source.replace("WC","[^\\[\\]\\.:\\/]");a=/(WCOD+)?/.source.replace("WCOD",
a);var c=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC","[^\\[\\]\\.:\\/]"),d=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC","[^\\[\\]\\.:\\/]"),e=new RegExp("^"+b+a+c+d+"$"),f=["material","materials","bones"];return function(a){var b=e.exec(a);if(!b)throw Error("PropertyBinding: Cannot parse trackName: "+a);b={nodeName:b[2],objectName:b[3],objectIndex:b[4],propertyName:b[5],propertyIndex:b[6]};var c=b.nodeName&&b.nodeName.lastIndexOf(".");if(void 0!==c&&-1!==c){var d=b.nodeName.substring(c+1);-1!==
f.indexOf(d)&&(b.nodeName=b.nodeName.substring(0,c),b.objectName=d)}if(null===b.propertyName||0===b.propertyName.length)throw Error("PropertyBinding: can not parse propertyName from trackName: "+a);return b}}(),findNode:function(a,b){if(!b||""===b||"root"===b||"."===b||-1===b||b===a.name||b===a.uuid)return a;if(a.skeleton){var c=a.skeleton.getBoneByName(b);if(void 0!==c)return c}if(a.children){var d=function(a){for(var c=0;c<a.length;c++){var e=a[c];if(e.name===b||e.uuid===b||(e=d(e.children)))return e}return null};
if(a=d(a.children))return a}return null}});Object.assign(oa.prototype,{_getValue_unavailable:function(){},_setValue_unavailable:function(){},BindingType:{Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Versioning:{None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},GetterByBindingType:[function(a,b){a[b]=this.node[this.propertyName]},function(a,b){for(var c=this.resolvedProperty,d=0,e=c.length;d!==e;++d)a[b++]=c[d]},function(a,b){a[b]=this.resolvedProperty[this.propertyIndex]},function(a,b){this.resolvedProperty.toArray(a,
b)}],SetterByBindingTypeAndVersioning:[[function(a,b){this.targetObject[this.propertyName]=a[b]},function(a,b){this.targetObject[this.propertyName]=a[b];this.targetObject.needsUpdate=!0},function(a,b){this.targetObject[this.propertyName]=a[b];this.targetObject.matrixWorldNeedsUpdate=!0}],[function(a,b){for(var c=this.resolvedProperty,d=0,e=c.length;d!==e;++d)c[d]=a[b++]},function(a,b){for(var c=this.resolvedProperty,d=0,e=c.length;d!==e;++d)c[d]=a[b++];this.targetObject.needsUpdate=!0},function(a,
b){for(var c=this.resolvedProperty,d=0,e=c.length;d!==e;++d)c[d]=a[b++];this.targetObject.matrixWorldNeedsUpdate=!0}],[function(a,b){this.resolvedProperty[this.propertyIndex]=a[b]},function(a,b){this.resolvedProperty[this.propertyIndex]=a[b];this.targetObject.needsUpdate=!0},function(a,b){this.resolvedProperty[this.propertyIndex]=a[b];this.targetObject.matrixWorldNeedsUpdate=!0}],[function(a,b){this.resolvedProperty.fromArray(a,b)},function(a,b){this.resolvedProperty.fromArray(a,b);this.targetObject.needsUpdate=
!0},function(a,b){this.resolvedProperty.fromArray(a,b);this.targetObject.matrixWorldNeedsUpdate=!0}]],getValue:function(a,b){this.bind();this.getValue(a,b)},setValue:function(a,b){this.bind();this.setValue(a,b)},bind:function(){var a=this.node,b=this.parsedPath,c=b.objectName,d=b.propertyName,e=b.propertyIndex;a||(this.node=a=oa.findNode(this.rootNode,b.nodeName)||this.rootNode);this.getValue=this._getValue_unavailable;this.setValue=this._setValue_unavailable;if(a){if(c){var f=b.objectIndex;switch(c){case "materials":if(!a.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",
this);return}if(!a.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}a=a.material.materials;break;case "bones":if(!a.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}a=a.skeleton.bones;for(c=0;c<a.length;c++)if(a[c].name===f){f=c;break}break;default:if(void 0===a[c]){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",
this);return}a=a[c]}if(void 0!==f){if(void 0===a[f]){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,a);return}a=a[f]}}f=a[d];if(void 0===f)console.error("THREE.PropertyBinding: Trying to update property for track: "+b.nodeName+"."+d+" but it wasn't found.",a);else{b=this.Versioning.None;this.targetObject=a;void 0!==a.needsUpdate?b=this.Versioning.NeedsUpdate:void 0!==a.matrixWorldNeedsUpdate&&(b=this.Versioning.MatrixWorldNeedsUpdate);c=
this.BindingType.Direct;if(void 0!==e){if("morphTargetInfluences"===d){if(!a.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(a.geometry.isBufferGeometry){if(!a.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}for(c=0;c<this.node.geometry.morphAttributes.position.length;c++)if(a.geometry.morphAttributes.position[c].name===
e){e=c;break}}else{if(!a.geometry.morphTargets){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.",this);return}for(c=0;c<this.node.geometry.morphTargets.length;c++)if(a.geometry.morphTargets[c].name===e){e=c;break}}}c=this.BindingType.ArrayElement;this.resolvedProperty=f;this.propertyIndex=e}else void 0!==f.fromArray&&void 0!==f.toArray?(c=this.BindingType.HasFromToArray,this.resolvedProperty=f):Array.isArray(f)?(c=this.BindingType.EntireArray,
this.resolvedProperty=f):this.propertyName=d;this.getValue=this.GetterByBindingType[c];this.setValue=this.SetterByBindingTypeAndVersioning[c][b]}}else console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.")},unbind:function(){this.node=null;this.getValue=this._getValue_unbound;this.setValue=this._setValue_unbound}});Object.assign(oa.prototype,{_getValue_unbound:oa.prototype.getValue,_setValue_unbound:oa.prototype.setValue});Object.assign(zf.prototype,
{isAnimationObjectGroup:!0,add:function(){for(var a=this._objects,b=a.length,c=this.nCachedObjects_,d=this._indicesByUUID,e=this._paths,f=this._parsedPaths,g=this._bindings,h=g.length,k=void 0,l=0,n=arguments.length;l!==n;++l){var p=arguments[l],r=p.uuid,x=d[r];if(void 0===x){x=b++;d[r]=x;a.push(p);r=0;for(var t=h;r!==t;++r)g[r].push(new oa(p,e[r],f[r]))}else if(x<c){k=a[x];var v=--c;t=a[v];d[t.uuid]=x;a[x]=t;d[r]=v;a[v]=p;r=0;for(t=h;r!==t;++r){var w=g[r],y=w[x];w[x]=w[v];void 0===y&&(y=new oa(p,
e[r],f[r]));w[v]=y}}else a[x]!==k&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=c},remove:function(){for(var a=this._objects,b=this.nCachedObjects_,c=this._indicesByUUID,d=this._bindings,e=d.length,f=0,g=arguments.length;f!==g;++f){var h=arguments[f],k=h.uuid,l=c[k];if(void 0!==l&&l>=b){var n=b++,p=a[n];c[p.uuid]=l;a[l]=p;c[k]=n;a[n]=h;h=0;for(k=e;h!==k;++h){p=
d[h];var r=p[l];p[l]=p[n];p[n]=r}}}this.nCachedObjects_=b},uncache:function(){for(var a=this._objects,b=a.length,c=this.nCachedObjects_,d=this._indicesByUUID,e=this._bindings,f=e.length,g=0,h=arguments.length;g!==h;++g){var k=arguments[g].uuid,l=d[k];if(void 0!==l)if(delete d[k],l<c){k=--c;var n=a[k],p=--b,r=a[p];d[n.uuid]=l;a[l]=n;d[r.uuid]=k;a[k]=r;a.pop();n=0;for(r=f;n!==r;++n){var x=e[n],t=x[p];x[l]=x[k];x[k]=t;x.pop()}}else for(p=--b,r=a[p],d[r.uuid]=l,a[l]=r,a.pop(),n=0,r=f;n!==r;++n)x=e[n],
x[l]=x[p],x.pop()}this.nCachedObjects_=c},subscribe_:function(a,b){var c=this._bindingsIndicesByPath,d=c[a],e=this._bindings;if(void 0!==d)return e[d];var f=this._paths,g=this._parsedPaths,h=this._objects,k=this.nCachedObjects_,l=Array(h.length);d=e.length;c[a]=d;f.push(a);g.push(b);e.push(l);c=k;for(d=h.length;c!==d;++c)l[c]=new oa(h[c],a,b);return l},unsubscribe_:function(a){var b=this._bindingsIndicesByPath,c=b[a];if(void 0!==c){var d=this._paths,e=this._parsedPaths,f=this._bindings,g=f.length-
1,h=f[g];b[a[g]]=c;f[c]=h;f.pop();e[c]=e[g];e.pop();d[c]=d[g];d.pop()}}});Object.assign(Af.prototype,{play:function(){this._mixer._activateAction(this);return this},stop:function(){this._mixer._deactivateAction(this);return this.reset()},reset:function(){this.paused=!1;this.enabled=!0;this.time=0;this._loopCount=-1;this._startTime=null;return this.stopFading().stopWarping()},isRunning:function(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)},
isScheduled:function(){return this._mixer._isActiveAction(this)},startAt:function(a){this._startTime=a;return this},setLoop:function(a,b){this.loop=a;this.repetitions=b;return this},setEffectiveWeight:function(a){this.weight=a;this._effectiveWeight=this.enabled?a:0;return this.stopFading()},getEffectiveWeight:function(){return this._effectiveWeight},fadeIn:function(a){return this._scheduleFading(a,0,1)},fadeOut:function(a){return this._scheduleFading(a,1,0)},crossFadeFrom:function(a,b,c){a.fadeOut(b);
this.fadeIn(b);if(c){c=this._clip.duration;var d=a._clip.duration,e=c/d;a.warp(1,d/c,b);this.warp(e,1,b)}return this},crossFadeTo:function(a,b,c){return a.crossFadeFrom(this,b,c)},stopFading:function(){var a=this._weightInterpolant;null!==a&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(a));return this},setEffectiveTimeScale:function(a){this.timeScale=a;this._effectiveTimeScale=this.paused?0:a;return this.stopWarping()},getEffectiveTimeScale:function(){return this._effectiveTimeScale},
setDuration:function(a){this.timeScale=this._clip.duration/a;return this.stopWarping()},syncWith:function(a){this.time=a.time;this.timeScale=a.timeScale;return this.stopWarping()},halt:function(a){return this.warp(this._effectiveTimeScale,0,a)},warp:function(a,b,c){var d=this._mixer,e=d.time,f=this._timeScaleInterpolant,g=this.timeScale;null===f&&(this._timeScaleInterpolant=f=d._lendControlInterpolant());d=f.parameterPositions;f=f.sampleValues;d[0]=e;d[1]=e+c;f[0]=a/g;f[1]=b/g;return this},stopWarping:function(){var a=
this._timeScaleInterpolant;null!==a&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(a));return this},getMixer:function(){return this._mixer},getClip:function(){return this._clip},getRoot:function(){return this._localRoot||this._mixer._root},_update:function(a,b,c,d){if(this.enabled){var e=this._startTime;if(null!==e){b=(a-e)*c;if(0>b||0===c)return;this._startTime=null;b*=c}b*=this._updateTimeScale(a);c=this._updateTime(b);a=this._updateWeight(a);if(0<a){b=this._interpolants;
e=this._propertyBindings;for(var f=0,g=b.length;f!==g;++f)b[f].evaluate(c),e[f].accumulate(d,a)}}else this._updateWeight(a)},_updateWeight:function(a){var b=0;if(this.enabled){b=this.weight;var c=this._weightInterpolant;if(null!==c){var d=c.evaluate(a)[0];b*=d;a>c.parameterPositions[1]&&(this.stopFading(),0===d&&(this.enabled=!1))}}return this._effectiveWeight=b},_updateTimeScale:function(a){var b=0;if(!this.paused){b=this.timeScale;var c=this._timeScaleInterpolant;if(null!==c){var d=c.evaluate(a)[0];
b*=d;a>c.parameterPositions[1]&&(this.stopWarping(),0===b?this.paused=!0:this.timeScale=b)}}return this._effectiveTimeScale=b},_updateTime:function(a){var b=this.time+a,c=this._clip.duration,d=this.loop,e=this._loopCount,f=2202===d;if(0===a)return-1===e?b:f&&1===(e&1)?c-b:b;if(2200===d)a:{if(-1===e&&(this._loopCount=0,this._setEndings(!0,!0,!1)),b>=c)b=c;else if(0>b)b=0;else break a;this.clampWhenFinished?this.paused=!0:this.enabled=!1;this._mixer.dispatchEvent({type:"finished",action:this,direction:0>
a?-1:1})}else{-1===e&&(0<=a?(e=0,this._setEndings(!0,0===this.repetitions,f)):this._setEndings(0===this.repetitions,!0,f));if(b>=c||0>b){d=Math.floor(b/c);b-=c*d;e+=Math.abs(d);var g=this.repetitions-e;0>=g?(this.clampWhenFinished?this.paused=!0:this.enabled=!1,b=0<a?c:0,this._mixer.dispatchEvent({type:"finished",action:this,direction:0<a?1:-1})):(1===g?(a=0>a,this._setEndings(a,!a,f)):this._setEndings(!1,!1,f),this._loopCount=e,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:d}))}if(f&&
1===(e&1))return this.time=b,c-b}return this.time=b},_setEndings:function(a,b,c){var d=this._interpolantSettings;c?(d.endingStart=2401,d.endingEnd=2401):(d.endingStart=a?this.zeroSlopeAtStart?2401:2400:2402,d.endingEnd=b?this.zeroSlopeAtEnd?2401:2400:2402)},_scheduleFading:function(a,b,c){var d=this._mixer,e=d.time,f=this._weightInterpolant;null===f&&(this._weightInterpolant=f=d._lendControlInterpolant());d=f.parameterPositions;f=f.sampleValues;d[0]=e;f[0]=b;d[1]=e+a;f[1]=c;return this}});we.prototype=
Object.assign(Object.create(ja.prototype),{constructor:we,_bindAction:function(a,b){var c=a._localRoot||this._root,d=a._clip.tracks,e=d.length,f=a._propertyBindings;a=a._interpolants;var g=c.uuid,h=this._bindingsByRootAndName,k=h[g];void 0===k&&(k={},h[g]=k);for(h=0;h!==e;++h){var l=d[h],n=l.name,p=k[n];if(void 0===p){p=f[h];if(void 0!==p){null===p._cacheIndex&&(++p.referenceCount,this._addInactiveBinding(p,g,n));continue}p=new ve(oa.create(c,n,b&&b._propertyBindings[h].binding.parsedPath),l.ValueTypeName,
l.getValueSize());++p.referenceCount;this._addInactiveBinding(p,g,n)}f[h]=p;a[h].resultBuffer=p.buffer}},_activateAction:function(a){if(!this._isActiveAction(a)){if(null===a._cacheIndex){var b=(a._localRoot||this._root).uuid,c=a._clip.uuid,d=this._actionsByClip[c];this._bindAction(a,d&&d.knownActions[0]);this._addInactiveAction(a,c,b)}b=a._propertyBindings;c=0;for(d=b.length;c!==d;++c){var e=b[c];0===e.useCount++&&(this._lendBinding(e),e.saveOriginalState())}this._lendAction(a)}},_deactivateAction:function(a){if(this._isActiveAction(a)){for(var b=
a._propertyBindings,c=0,d=b.length;c!==d;++c){var e=b[c];0===--e.useCount&&(e.restoreOriginalState(),this._takeBackBinding(e))}this._takeBackAction(a)}},_initMemoryManager:function(){this._actions=[];this._nActiveActions=0;this._actionsByClip={};this._bindings=[];this._nActiveBindings=0;this._bindingsByRootAndName={};this._controlInterpolants=[];this._nActiveControlInterpolants=0;var a=this;this.stats={actions:{get total(){return a._actions.length},get inUse(){return a._nActiveActions}},bindings:{get total(){return a._bindings.length},
get inUse(){return a._nActiveBindings}},controlInterpolants:{get total(){return a._controlInterpolants.length},get inUse(){return a._nActiveControlInterpolants}}}},_isActiveAction:function(a){a=a._cacheIndex;return null!==a&&a<this._nActiveActions},_addInactiveAction:function(a,b,c){var d=this._actions,e=this._actionsByClip,f=e[b];void 0===f?(f={knownActions:[a],actionByRoot:{}},a._byClipCacheIndex=0,e[b]=f):(b=f.knownActions,a._byClipCacheIndex=b.length,b.push(a));a._cacheIndex=d.length;d.push(a);
f.actionByRoot[c]=a},_removeInactiveAction:function(a){var b=this._actions,c=b[b.length-1],d=a._cacheIndex;c._cacheIndex=d;b[d]=c;b.pop();a._cacheIndex=null;b=a._clip.uuid;c=this._actionsByClip;d=c[b];var e=d.knownActions,f=e[e.length-1],g=a._byClipCacheIndex;f._byClipCacheIndex=g;e[g]=f;e.pop();a._byClipCacheIndex=null;delete d.actionByRoot[(a._localRoot||this._root).uuid];0===e.length&&delete c[b];this._removeInactiveBindingsForAction(a)},_removeInactiveBindingsForAction:function(a){a=a._propertyBindings;
for(var b=0,c=a.length;b!==c;++b){var d=a[b];0===--d.referenceCount&&this._removeInactiveBinding(d)}},_lendAction:function(a){var b=this._actions,c=a._cacheIndex,d=this._nActiveActions++,e=b[d];a._cacheIndex=d;b[d]=a;e._cacheIndex=c;b[c]=e},_takeBackAction:function(a){var b=this._actions,c=a._cacheIndex,d=--this._nActiveActions,e=b[d];a._cacheIndex=d;b[d]=a;e._cacheIndex=c;b[c]=e},_addInactiveBinding:function(a,b,c){var d=this._bindingsByRootAndName,e=d[b],f=this._bindings;void 0===e&&(e={},d[b]=
e);e[c]=a;a._cacheIndex=f.length;f.push(a)},_removeInactiveBinding:function(a){var b=this._bindings,c=a.binding,d=c.rootNode.uuid;c=c.path;var e=this._bindingsByRootAndName,f=e[d],g=b[b.length-1];a=a._cacheIndex;g._cacheIndex=a;b[a]=g;b.pop();delete f[c];a:{for(var h in f)break a;delete e[d]}},_lendBinding:function(a){var b=this._bindings,c=a._cacheIndex,d=this._nActiveBindings++,e=b[d];a._cacheIndex=d;b[d]=a;e._cacheIndex=c;b[c]=e},_takeBackBinding:function(a){var b=this._bindings,c=a._cacheIndex,
d=--this._nActiveBindings,e=b[d];a._cacheIndex=d;b[d]=a;e._cacheIndex=c;b[c]=e},_lendControlInterpolant:function(){var a=this._controlInterpolants,b=this._nActiveControlInterpolants++,c=a[b];void 0===c&&(c=new dd(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),c.__cacheIndex=b,a[b]=c);return c},_takeBackControlInterpolant:function(a){var b=this._controlInterpolants,c=a.__cacheIndex,d=--this._nActiveControlInterpolants,e=b[d];a.__cacheIndex=d;b[d]=a;e.__cacheIndex=
c;b[c]=e},_controlInterpolantsResultBuffer:new Float32Array(1),clipAction:function(a,b){var c=b||this._root,d=c.uuid;c="string"===typeof a?Ha.findByName(c,a):a;a=null!==c?c.uuid:a;var e=this._actionsByClip[a],f=null;if(void 0!==e){f=e.actionByRoot[d];if(void 0!==f)return f;f=e.knownActions[0];null===c&&(c=f._clip)}if(null===c)return null;b=new Af(this,c,b);this._bindAction(b,f);this._addInactiveAction(b,a,d);return b},existingAction:function(a,b){var c=b||this._root;b=c.uuid;c="string"===typeof a?
Ha.findByName(c,a):a;a=this._actionsByClip[c?c.uuid:a];return void 0!==a?a.actionByRoot[b]||null:null},stopAllAction:function(){for(var a=this._actions,b=this._nActiveActions,c=this._bindings,d=this._nActiveBindings,e=this._nActiveBindings=this._nActiveActions=0;e!==b;++e)a[e].reset();for(e=0;e!==d;++e)c[e].useCount=0;return this},update:function(a){a*=this.timeScale;for(var b=this._actions,c=this._nActiveActions,d=this.time+=a,e=Math.sign(a),f=this._accuIndex^=1,g=0;g!==c;++g)b[g]._update(d,a,e,
f);a=this._bindings;b=this._nActiveBindings;for(g=0;g!==b;++g)a[g].apply(f);return this},getRoot:function(){return this._root},uncacheClip:function(a){var b=this._actions;a=a.uuid;var c=this._actionsByClip,d=c[a];if(void 0!==d){d=d.knownActions;for(var e=0,f=d.length;e!==f;++e){var g=d[e];this._deactivateAction(g);var h=g._cacheIndex,k=b[b.length-1];g._cacheIndex=null;g._byClipCacheIndex=null;k._cacheIndex=h;b[h]=k;b.pop();this._removeInactiveBindingsForAction(g)}delete c[a]}},uncacheRoot:function(a){a=
a.uuid;var b=this._actionsByClip;for(d in b){var c=b[d].actionByRoot[a];void 0!==c&&(this._deactivateAction(c),this._removeInactiveAction(c))}var d=this._bindingsByRootAndName[a];if(void 0!==d)for(var e in d)a=d[e],a.restoreOriginalState(),this._removeInactiveBinding(a)},uncacheAction:function(a,b){a=this.existingAction(a,b);null!==a&&(this._deactivateAction(a),this._removeInactiveAction(a))}});Rd.prototype.clone=function(){return new Rd(void 0===this.value.clone?this.value:this.value.clone())};xe.prototype=
Object.assign(Object.create(D.prototype),{constructor:xe,isInstancedBufferGeometry:!0,copy:function(a){D.prototype.copy.call(this,a);this.maxInstancedCount=a.maxInstancedCount;return this},clone:function(){return(new this.constructor).copy(this)}});ye.prototype=Object.assign(Object.create(rb.prototype),{constructor:ye,isInstancedInterleavedBuffer:!0,copy:function(a){rb.prototype.copy.call(this,a);this.meshPerAttribute=a.meshPerAttribute;return this}});ze.prototype=Object.assign(Object.create(E.prototype),
{constructor:ze,isInstancedBufferAttribute:!0,copy:function(a){E.prototype.copy.call(this,a);this.meshPerAttribute=a.meshPerAttribute;return this}});Object.assign(Bf.prototype,{linePrecision:1,set:function(a,b){this.ray.set(a,b)},setFromCamera:function(a,b){b&&b.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(b.matrixWorld),this.ray.direction.set(a.x,a.y,.5).unproject(b).sub(this.ray.origin).normalize()):b&&b.isOrthographicCamera?(this.ray.origin.set(a.x,a.y,(b.near+b.far)/(b.near-b.far)).unproject(b),
this.ray.direction.set(0,0,-1).transformDirection(b.matrixWorld)):console.error("THREE.Raycaster: Unsupported camera type.")},intersectObject:function(a,b,c){c=c||[];Ae(a,this,c,b);c.sort(Cf);return c},intersectObjects:function(a,b,c){c=c||[];if(!1===Array.isArray(a))return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."),c;for(var d=0,e=a.length;d<e;d++)Ae(a[d],this,c,b);c.sort(Cf);return c}});Object.assign(Df.prototype,{set:function(a,b,c){this.radius=a;this.phi=b;this.theta=
c;return this},clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.radius=a.radius;this.phi=a.phi;this.theta=a.theta;return this},makeSafe:function(){this.phi=Math.max(1E-6,Math.min(Math.PI-1E-6,this.phi));return this},setFromVector3:function(a){return this.setFromCartesianCoords(a.x,a.y,a.z)},setFromCartesianCoords:function(a,b,c){this.radius=Math.sqrt(a*a+b*b+c*c);0===this.radius?this.phi=this.theta=0:(this.theta=Math.atan2(a,c),this.phi=Math.acos(R.clamp(b/this.radius,
-1,1)));return this}});Object.assign(Ef.prototype,{set:function(a,b,c){this.radius=a;this.theta=b;this.y=c;return this},clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.radius=a.radius;this.theta=a.theta;this.y=a.y;return this},setFromVector3:function(a){return this.setFromCartesianCoords(a.x,a.y,a.z)},setFromCartesianCoords:function(a,b,c){this.radius=Math.sqrt(a*a+c*c);this.theta=Math.atan2(a,c);this.y=b;return this}});Object.assign(Be.prototype,{set:function(a,b){this.min.copy(a);
this.max.copy(b);return this},setFromPoints:function(a){this.makeEmpty();for(var b=0,c=a.length;b<c;b++)this.expandByPoint(a[b]);return this},setFromCenterAndSize:function(){var a=new z;return function(b,c){c=a.copy(c).multiplyScalar(.5);this.min.copy(b).sub(c);this.max.copy(b).add(c);return this}}(),clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.min.copy(a.min);this.max.copy(a.max);return this},makeEmpty:function(){this.min.x=this.min.y=Infinity;this.max.x=this.max.y=
-Infinity;return this},isEmpty:function(){return this.max.x<this.min.x||this.max.y<this.min.y},getCenter:function(a){void 0===a&&(console.warn("THREE.Box2: .getCenter() target is now required"),a=new z);return this.isEmpty()?a.set(0,0):a.addVectors(this.min,this.max).multiplyScalar(.5)},getSize:function(a){void 0===a&&(console.warn("THREE.Box2: .getSize() target is now required"),a=new z);return this.isEmpty()?a.set(0,0):a.subVectors(this.max,this.min)},expandByPoint:function(a){this.min.min(a);this.max.max(a);
return this},expandByVector:function(a){this.min.sub(a);this.max.add(a);return this},expandByScalar:function(a){this.min.addScalar(-a);this.max.addScalar(a);return this},containsPoint:function(a){return a.x<this.min.x||a.x>this.max.x||a.y<this.min.y||a.y>this.max.y?!1:!0},containsBox:function(a){return this.min.x<=a.min.x&&a.max.x<=this.max.x&&this.min.y<=a.min.y&&a.max.y<=this.max.y},getParameter:function(a,b){void 0===b&&(console.warn("THREE.Box2: .getParameter() target is now required"),b=new z);
return b.set((a.x-this.min.x)/(this.max.x-this.min.x),(a.y-this.min.y)/(this.max.y-this.min.y))},intersectsBox:function(a){return a.max.x<this.min.x||a.min.x>this.max.x||a.max.y<this.min.y||a.min.y>this.max.y?!1:!0},clampPoint:function(a,b){void 0===b&&(console.warn("THREE.Box2: .clampPoint() target is now required"),b=new z);return b.copy(a).clamp(this.min,this.max)},distanceToPoint:function(){var a=new z;return function(b){return a.copy(b).clamp(this.min,this.max).sub(b).length()}}(),intersect:function(a){this.min.max(a.min);
this.max.min(a.max);return this},union:function(a){this.min.min(a.min);this.max.max(a.max);return this},translate:function(a){this.min.add(a);this.max.add(a);return this},equals:function(a){return a.min.equals(this.min)&&a.max.equals(this.max)}});Object.assign(Ce.prototype,{set:function(a,b){this.start.copy(a);this.end.copy(b);return this},clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.start.copy(a.start);this.end.copy(a.end);return this},getCenter:function(a){void 0===
a&&(console.warn("THREE.Line3: .getCenter() target is now required"),a=new n);return a.addVectors(this.start,this.end).multiplyScalar(.5)},delta:function(a){void 0===a&&(console.warn("THREE.Line3: .delta() target is now required"),a=new n);return a.subVectors(this.end,this.start)},distanceSq:function(){return this.start.distanceToSquared(this.end)},distance:function(){return this.start.distanceTo(this.end)},at:function(a,b){void 0===b&&(console.warn("THREE.Line3: .at() target is now required"),b=
new n);return this.delta(b).multiplyScalar(a).add(this.start)},closestPointToPointParameter:function(){var a=new n,b=new n;return function(c,d){a.subVectors(c,this.start);b.subVectors(this.end,this.start);c=b.dot(b);c=b.dot(a)/c;d&&(c=R.clamp(c,0,1));return c}}(),closestPointToPoint:function(a,b,c){a=this.closestPointToPointParameter(a,b);void 0===c&&(console.warn("THREE.Line3: .closestPointToPoint() target is now required"),c=new n);return this.delta(c).multiplyScalar(a).add(this.start)},applyMatrix4:function(a){this.start.applyMatrix4(a);
this.end.applyMatrix4(a);return this},equals:function(a){return a.start.equals(this.start)&&a.end.equals(this.end)}});ld.prototype=Object.create(C.prototype);ld.prototype.constructor=ld;ld.prototype.isImmediateRenderObject=!0;md.prototype=Object.create(S.prototype);md.prototype.constructor=md;md.prototype.update=function(){var a=new n,b=new n,c=new da;return function(){var d=["a","b","c"];this.object.updateMatrixWorld(!0);c.getNormalMatrix(this.object.matrixWorld);var e=this.object.matrixWorld,f=
this.geometry.attributes.position,g=this.object.geometry;if(g&&g.isGeometry)for(var h=g.vertices,k=g.faces,l=g=0,n=k.length;l<n;l++)for(var p=k[l],r=0,x=p.vertexNormals.length;r<x;r++){var t=p.vertexNormals[r];a.copy(h[p[d[r]]]).applyMatrix4(e);b.copy(t).applyMatrix3(c).normalize().multiplyScalar(this.size).add(a);f.setXYZ(g,a.x,a.y,a.z);g+=1;f.setXYZ(g,b.x,b.y,b.z);g+=1}else if(g&&g.isBufferGeometry)for(d=g.attributes.position,h=g.attributes.normal,r=g=0,x=d.count;r<x;r++)a.set(d.getX(r),d.getY(r),
d.getZ(r)).applyMatrix4(e),b.set(h.getX(r),h.getY(r),h.getZ(r)),b.applyMatrix3(c).normalize().multiplyScalar(this.size).add(a),f.setXYZ(g,a.x,a.y,a.z),g+=1,f.setXYZ(g,b.x,b.y,b.z),g+=1;f.needsUpdate=!0}}();mc.prototype=Object.create(C.prototype);mc.prototype.constructor=mc;mc.prototype.dispose=function(){this.cone.geometry.dispose();this.cone.material.dispose()};mc.prototype.update=function(){var a=new n;return function(){this.light.updateMatrixWorld();var b=this.light.distance?this.light.distance:
1E3,c=b*Math.tan(this.light.angle);this.cone.scale.set(c,c,b);a.setFromMatrixPosition(this.light.target.matrixWorld);this.cone.lookAt(a);void 0!==this.color?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}();nc.prototype=Object.create(S.prototype);nc.prototype.constructor=nc;nc.prototype.updateMatrixWorld=function(){var a=new n,b=new O,c=new O;return function(d){var e=this.bones,f=this.geometry,g=f.getAttribute("position");c.getInverse(this.root.matrixWorld);
for(var h=0,k=0;h<e.length;h++){var l=e[h];l.parent&&l.parent.isBone&&(b.multiplyMatrices(c,l.matrixWorld),a.setFromMatrixPosition(b),g.setXYZ(k,a.x,a.y,a.z),b.multiplyMatrices(c,l.parent.matrixWorld),a.setFromMatrixPosition(b),g.setXYZ(k+1,a.x,a.y,a.z),k+=2)}f.getAttribute("position").needsUpdate=!0;C.prototype.updateMatrixWorld.call(this,d)}}();oc.prototype=Object.create(pa.prototype);oc.prototype.constructor=oc;oc.prototype.dispose=function(){this.geometry.dispose();this.material.dispose()};oc.prototype.update=
function(){void 0!==this.color?this.material.color.set(this.color):this.material.color.copy(this.light.color)};pc.prototype=Object.create(C.prototype);pc.prototype.constructor=pc;pc.prototype.dispose=function(){this.children[0].geometry.dispose();this.children[0].material.dispose()};pc.prototype.update=function(){var a=.5*this.light.width,b=.5*this.light.height,c=this.line.geometry.attributes.position,d=c.array;d[0]=a;d[1]=-b;d[2]=0;d[3]=a;d[4]=b;d[5]=0;d[6]=-a;d[7]=b;d[8]=0;d[9]=-a;d[10]=-b;d[11]=
0;d[12]=a;d[13]=-b;d[14]=0;c.needsUpdate=!0;void 0!==this.color?this.line.material.color.set(this.color):this.line.material.color.copy(this.light.color)};qc.prototype=Object.create(C.prototype);qc.prototype.constructor=qc;qc.prototype.dispose=function(){this.children[0].geometry.dispose();this.children[0].material.dispose()};qc.prototype.update=function(){var a=new n,b=new J,c=new J;return function(){var d=this.children[0];if(void 0!==this.color)this.material.color.set(this.color);else{var e=d.geometry.getAttribute("color");
b.copy(this.light.color);c.copy(this.light.groundColor);for(var f=0,g=e.count;f<g;f++){var h=f<g/2?b:c;e.setXYZ(f,h.r,h.g,h.b)}e.needsUpdate=!0}d.lookAt(a.setFromMatrixPosition(this.light.matrixWorld).negate())}}();nd.prototype=Object.create(S.prototype);nd.prototype.constructor=nd;Sd.prototype=Object.create(S.prototype);Sd.prototype.constructor=Sd;od.prototype=Object.create(S.prototype);od.prototype.constructor=od;od.prototype.update=function(){var a=new n,b=new n,c=new da;return function(){this.object.updateMatrixWorld(!0);
c.getNormalMatrix(this.object.matrixWorld);var d=this.object.matrixWorld,e=this.geometry.attributes.position,f=this.object.geometry,g=f.vertices;f=f.faces;for(var h=0,k=0,l=f.length;k<l;k++){var n=f[k],p=n.normal;a.copy(g[n.a]).add(g[n.b]).add(g[n.c]).divideScalar(3).applyMatrix4(d);b.copy(p).applyMatrix3(c).normalize().multiplyScalar(this.size).add(a);e.setXYZ(h,a.x,a.y,a.z);h+=1;e.setXYZ(h,b.x,b.y,b.z);h+=1}e.needsUpdate=!0}}();rc.prototype=Object.create(C.prototype);rc.prototype.constructor=rc;
rc.prototype.dispose=function(){this.lightPlane.geometry.dispose();this.lightPlane.material.dispose();this.targetLine.geometry.dispose();this.targetLine.material.dispose()};rc.prototype.update=function(){var a=new n,b=new n,c=new n;return function(){a.setFromMatrixPosition(this.light.matrixWorld);b.setFromMatrixPosition(this.light.target.matrixWorld);c.subVectors(b,a);this.lightPlane.lookAt(b);void 0!==this.color?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):
(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color));this.targetLine.lookAt(b);this.targetLine.scale.z=c.length()}}();pd.prototype=Object.create(S.prototype);pd.prototype.constructor=pd;pd.prototype.update=function(){function a(a,g,h,k){d.set(g,h,k).unproject(e);a=c[a];if(void 0!==a)for(g=b.getAttribute("position"),h=0,k=a.length;h<k;h++)g.setXYZ(a[h],d.x,d.y,d.z)}var b,c,d=new n,e=new Ra;return function(){b=this.geometry;c=this.pointMap;e.projectionMatrix.copy(this.camera.projectionMatrix);
a("c",0,0,-1);a("t",0,0,1);a("n1",-1,-1,-1);a("n2",1,-1,-1);a("n3",-1,1,-1);a("n4",1,1,-1);a("f1",-1,-1,1);a("f2",1,-1,1);a("f3",-1,1,1);a("f4",1,1,1);a("u1",.7,1.1,-1);a("u2",-.7,1.1,-1);a("u3",0,2,-1);a("cf1",-1,0,1);a("cf2",1,0,1);a("cf3",0,-1,1);a("cf4",0,1,1);a("cn1",-1,0,-1);a("cn2",1,0,-1);a("cn3",0,-1,-1);a("cn4",0,1,-1);b.getAttribute("position").needsUpdate=!0}}();ab.prototype=Object.create(S.prototype);ab.prototype.constructor=ab;ab.prototype.update=function(){var a=new Wa;return function(b){void 0!==
b&&console.warn("THREE.BoxHelper: .update() has no longer arguments.");void 0!==this.object&&a.setFromObject(this.object);if(!a.isEmpty()){b=a.min;var c=a.max,d=this.geometry.attributes.position,e=d.array;e[0]=c.x;e[1]=c.y;e[2]=c.z;e[3]=b.x;e[4]=c.y;e[5]=c.z;e[6]=b.x;e[7]=b.y;e[8]=c.z;e[9]=c.x;e[10]=b.y;e[11]=c.z;e[12]=c.x;e[13]=c.y;e[14]=b.z;e[15]=b.x;e[16]=c.y;e[17]=b.z;e[18]=b.x;e[19]=b.y;e[20]=b.z;e[21]=c.x;e[22]=b.y;e[23]=b.z;d.needsUpdate=!0;this.geometry.computeBoundingSphere()}}}();ab.prototype.setFromObject=
function(a){this.object=a;this.update();return this};ab.prototype.copy=function(a){S.prototype.copy.call(this,a);this.object=a.object;return this};ab.prototype.clone=function(){return(new this.constructor).copy(this)};qd.prototype=Object.create(S.prototype);qd.prototype.constructor=qd;qd.prototype.updateMatrixWorld=function(a){var b=this.box;b.isEmpty()||(b.getCenter(this.position),b.getSize(this.scale),this.scale.multiplyScalar(.5),C.prototype.updateMatrixWorld.call(this,a))};rd.prototype=Object.create(ma.prototype);
rd.prototype.constructor=rd;rd.prototype.updateMatrixWorld=function(a){var b=-this.plane.constant;1E-8>Math.abs(b)&&(b=1E-8);this.scale.set(.5*this.size,.5*this.size,b);this.children[0].material.side=0>b?1:0;this.lookAt(this.plane.normal);C.prototype.updateMatrixWorld.call(this,a)};var Td,De;bb.prototype=Object.create(C.prototype);bb.prototype.constructor=bb;bb.prototype.setDirection=function(){var a=new n,b;return function(c){.99999<c.y?this.quaternion.set(0,0,0,1):-.99999>c.y?this.quaternion.set(1,
0,0,0):(a.set(c.z,0,-c.x).normalize(),b=Math.acos(c.y),this.quaternion.setFromAxisAngle(a,b))}}();bb.prototype.setLength=function(a,b,c){void 0===b&&(b=.2*a);void 0===c&&(c=.2*b);this.line.scale.set(1,Math.max(0,a-b),1);this.line.updateMatrix();this.cone.scale.set(c,b,c);this.cone.position.y=a;this.cone.updateMatrix()};bb.prototype.setColor=function(a){this.line.material.color.copy(a);this.cone.material.color.copy(a)};bb.prototype.copy=function(a){C.prototype.copy.call(this,a,!1);this.line.copy(a.line);
this.cone.copy(a.cone);return this};bb.prototype.clone=function(){return(new this.constructor).copy(this)};sd.prototype=Object.create(S.prototype);sd.prototype.constructor=sd;K.create=function(a,b){console.log("THREE.Curve.create() has been deprecated");a.prototype=Object.create(K.prototype);a.prototype.constructor=a;a.prototype.getPoint=b;return a};Object.assign($a.prototype,{createPointsGeometry:function(a){console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
a=this.getPoints(a);return this.createGeometry(a)},createSpacedPointsGeometry:function(a){console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");a=this.getSpacedPoints(a);return this.createGeometry(a)},createGeometry:function(a){console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");for(var b=new Q,c=0,d=a.length;c<d;c++){var e=a[c];b.vertices.push(new n(e.x,
e.y,e.z||0))}return b}});Object.assign(Na.prototype,{fromPoints:function(a){console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");this.setFromPoints(a)}});Gf.prototype=Object.create(ta.prototype);Hf.prototype=Object.create(ta.prototype);Ee.prototype=Object.create(ta.prototype);Object.assign(Ee.prototype,{initFromArray:function(){console.error("THREE.Spline: .initFromArray() has been removed.")},getControlPointsArray:function(){console.error("THREE.Spline: .getControlPointsArray() has been removed.")},
reparametrizeByArcLength:function(){console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")}});nd.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")};nc.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")};Object.assign(jd.prototype,{extractUrlBase:function(a){console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
return Ie.extractUrlBase(a)}});Object.assign(le.prototype,{setTexturePath:function(a){console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().");return this.setResourcePath(a)}});Object.assign(Be.prototype,{center:function(a){console.warn("THREE.Box2: .center() has been renamed to .getCenter().");return this.getCenter(a)},empty:function(){console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");return this.isEmpty()},isIntersectionBox:function(a){console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
return this.intersectsBox(a)},size:function(a){console.warn("THREE.Box2: .size() has been renamed to .getSize().");return this.getSize(a)}});Object.assign(Wa.prototype,{center:function(a){console.warn("THREE.Box3: .center() has been renamed to .getCenter().");return this.getCenter(a)},empty:function(){console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");return this.isEmpty()},isIntersectionBox:function(a){console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
return this.intersectsBox(a)},isIntersectionSphere:function(a){console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");return this.intersectsSphere(a)},size:function(a){console.warn("THREE.Box3: .size() has been renamed to .getSize().");return this.getSize(a)}});Ce.prototype.center=function(a){console.warn("THREE.Line3: .center() has been renamed to .getCenter().");return this.getCenter(a)};Object.assign(R,{random16:function(){console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead.");
return Math.random()},nearestPowerOfTwo:function(a){console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().");return R.floorPowerOfTwo(a)},nextPowerOfTwo:function(a){console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().");return R.ceilPowerOfTwo(a)}});Object.assign(da.prototype,{flattenToArrayOffset:function(a,b){console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");return this.toArray(a,b)},
multiplyVector3:function(a){console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");return a.applyMatrix3(this)},multiplyVector3Array:function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")},applyToBuffer:function(a){console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.");return this.applyToBufferAttribute(a)},applyToVector3Array:function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")}});
Object.assign(O.prototype,{extractPosition:function(a){console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");return this.copyPosition(a)},flattenToArrayOffset:function(a,b){console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");return this.toArray(a,b)},getPosition:function(){var a;return function(){void 0===a&&(a=new n);console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
return a.setFromMatrixColumn(this,3)}}(),setRotationFromQuaternion:function(a){console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");return this.makeRotationFromQuaternion(a)},multiplyToArray:function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")},multiplyVector3:function(a){console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");return a.applyMatrix4(this)},multiplyVector4:function(a){console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
return a.applyMatrix4(this)},multiplyVector3Array:function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")},rotateAxis:function(a){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");a.transformDirection(this)},crossVector:function(a){console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");return a.applyMatrix4(this)},translate:function(){console.error("THREE.Matrix4: .translate() has been removed.")},
rotateX:function(){console.error("THREE.Matrix4: .rotateX() has been removed.")},rotateY:function(){console.error("THREE.Matrix4: .rotateY() has been removed.")},rotateZ:function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")},rotateByAxis:function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")},applyToBuffer:function(a){console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.");return this.applyToBufferAttribute(a)},
applyToVector3Array:function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")},makeFrustum:function(a,b,c,d,e,f){console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");return this.makePerspective(a,b,d,c,e,f)}});Pa.prototype.isIntersectionLine=function(a){console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");return this.intersectsLine(a)};ka.prototype.multiplyVector3=
function(a){console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");return a.applyQuaternion(this)};Object.assign(qb.prototype,{isIntersectionBox:function(a){console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");return this.intersectsBox(a)},isIntersectionPlane:function(a){console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");return this.intersectsPlane(a)},isIntersectionSphere:function(a){console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
return this.intersectsSphere(a)}});Object.assign(ha.prototype,{area:function(){console.warn("THREE.Triangle: .area() has been renamed to .getArea().");return this.getArea()},barycoordFromPoint:function(a,b){console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");return this.getBarycoord(a,b)},midpoint:function(a){console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");return this.getMidpoint(a)},normal:function(a){console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
return this.getNormal(a)},plane:function(a){console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");return this.getPlane(a)}});Object.assign(ha,{barycoordFromPoint:function(a,b,c,d,e){console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");return ha.getBarycoord(a,b,c,d,e)},normal:function(a,b,c,d){console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");return ha.getNormal(a,b,c,d)}});Object.assign(hb.prototype,{extractAllPoints:function(a){console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");
return this.extractPoints(a)},extrude:function(a){console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");return new ub(this,a)},makeGeometry:function(a){console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");return new wb(this,a)}});Object.assign(z.prototype,{fromAttribute:function(a,b,c){console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");return this.fromBufferAttribute(a,b,c)},distanceToManhattan:function(a){console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
return this.manhattanDistanceTo(a)},lengthManhattan:function(){console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");return this.manhattanLength()}});Object.assign(n.prototype,{setEulerFromRotationMatrix:function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")},setEulerFromQuaternion:function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")},
getPositionFromMatrix:function(a){console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");return this.setFromMatrixPosition(a)},getScaleFromMatrix:function(a){console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");return this.setFromMatrixScale(a)},getColumnFromMatrix:function(a,b){console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");return this.setFromMatrixColumn(b,
a)},applyProjection:function(a){console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");return this.applyMatrix4(a)},fromAttribute:function(a,b,c){console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");return this.fromBufferAttribute(a,b,c)},distanceToManhattan:function(a){console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");return this.manhattanDistanceTo(a)},lengthManhattan:function(){console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
return this.manhattanLength()}});Object.assign(ca.prototype,{fromAttribute:function(a,b,c){console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");return this.fromBufferAttribute(a,b,c)},lengthManhattan:function(){console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");return this.manhattanLength()}});Object.assign(Q.prototype,{computeTangents:function(){console.error("THREE.Geometry: .computeTangents() has been removed.")},computeLineDistances:function(){console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")}});
Object.assign(C.prototype,{getChildByName:function(a){console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");return this.getObjectByName(a)},renderDepth:function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")},translate:function(a,b){console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");return this.translateOnAxis(b,a)},getWorldRotation:function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")}});
Object.defineProperties(C.prototype,{eulerOrder:{get:function(){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");return this.rotation.order},set:function(a){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");this.rotation.order=a}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}});
Object.defineProperties(Gc.prototype,{objects:{get:function(){console.warn("THREE.LOD: .objects has been renamed to .levels.");return this.levels}}});Object.defineProperty(yd.prototype,"useVertexTexture",{get:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")},set:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")}});Hc.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")};Object.defineProperty(K.prototype,
"__arcLengthDivisions",{get:function(){console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");return this.arcLengthDivisions},set:function(a){console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");this.arcLengthDivisions=a}});V.prototype.setLens=function(a,b){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");void 0!==b&&(this.filmGauge=b);this.setFocalLength(a)};Object.defineProperties(ba.prototype,
{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(a){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");this.shadow.camera.fov=a}},shadowCameraLeft:{set:function(a){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");this.shadow.camera.left=a}},shadowCameraRight:{set:function(a){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");this.shadow.camera.right=a}},shadowCameraTop:{set:function(a){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
this.shadow.camera.top=a}},shadowCameraBottom:{set:function(a){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");this.shadow.camera.bottom=a}},shadowCameraNear:{set:function(a){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");this.shadow.camera.near=a}},shadowCameraFar:{set:function(a){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");this.shadow.camera.far=a}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},
shadowBias:{set:function(a){console.warn("THREE.Light: .shadowBias is now .shadow.bias.");this.shadow.bias=a}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(a){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");this.shadow.mapSize.width=a}},shadowMapHeight:{set:function(a){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");this.shadow.mapSize.height=a}}});Object.defineProperties(E.prototype,
{length:{get:function(){console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");return this.array.length}},copyIndicesArray:function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")}});Object.assign(D.prototype,{addIndex:function(a){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");this.setIndex(a)},addDrawCall:function(a,b,c){void 0!==c&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");this.addGroup(a,b)},clearDrawCalls:function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");this.clearGroups()},computeTangents:function(){console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")},computeOffsets:function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")}});Object.defineProperties(D.prototype,{drawcalls:{get:function(){console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
return this.groups}},offsets:{get:function(){console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");return this.groups}}});Object.assign(Sa.prototype,{getArrays:function(){console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")},addShapeList:function(){console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")},addShape:function(){console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")}});Object.defineProperties(Rd.prototype,
{dynamic:{set:function(){console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")}},onUpdate:{value:function(){console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");return this}}});Object.defineProperties(L.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},
set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){console.warn("THREE.Material: .wrapRGB has been removed.");return new J}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(a){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.");this.flatShading=1===a}}});Object.defineProperties(Ga.prototype,{metal:{get:function(){console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.");
return!1},set:function(){console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")}}});Object.defineProperties(Ba.prototype,{derivatives:{get:function(){console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");return this.extensions.derivatives},set:function(a){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");this.extensions.derivatives=a}}});Object.assign(be.prototype,
{clearTarget:function(a,b,c,d){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.");this.setRenderTarget(a);this.clear(b,c,d)},animate:function(a){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");this.setAnimationLoop(a)},getCurrentRenderTarget:function(){console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");return this.getRenderTarget()},getMaxAnisotropy:function(){console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
return this.capabilities.getMaxAnisotropy()},getPrecision:function(){console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");return this.capabilities.precision},resetGLState:function(){console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");return this.state.reset()},supportsFloatTextures:function(){console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");return this.extensions.get("OES_texture_float")},
supportsHalfFloatTextures:function(){console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");return this.extensions.get("OES_texture_half_float")},supportsStandardDerivatives:function(){console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");return this.extensions.get("OES_standard_derivatives")},supportsCompressedTextureS3TC:function(){console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
return this.extensions.get("WEBGL_compressed_texture_s3tc")},supportsCompressedTexturePVRTC:function(){console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");return this.extensions.get("WEBGL_compressed_texture_pvrtc")},supportsBlendMinMax:function(){console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");return this.extensions.get("EXT_blend_minmax")},supportsVertexTextures:function(){console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
return this.capabilities.vertexTextures},supportsInstancedArrays:function(){console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");return this.extensions.get("ANGLE_instanced_arrays")},enableScissorTest:function(a){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");this.setScissorTest(a)},initMaterial:function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")},addPrePlugin:function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")},
addPostPlugin:function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")},updateShadowMap:function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")},setFaceCulling:function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")}});Object.defineProperties(be.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(a){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
this.shadowMap.enabled=a}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(a){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");this.shadowMap.type=a}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}}});Object.defineProperties(ef.prototype,
{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},
renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}});Object.defineProperties(jb.prototype,{wrapS:{get:function(){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");return this.texture.wrapS},set:function(a){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
this.texture.wrapS=a}},wrapT:{get:function(){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");return this.texture.wrapT},set:function(a){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");this.texture.wrapT=a}},magFilter:{get:function(){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");return this.texture.magFilter},set:function(a){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");this.texture.magFilter=
a}},minFilter:{get:function(){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");return this.texture.minFilter},set:function(a){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");this.texture.minFilter=a}},anisotropy:{get:function(){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");return this.texture.anisotropy},set:function(a){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");this.texture.anisotropy=
a}},offset:{get:function(){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");return this.texture.offset},set:function(a){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");this.texture.offset=a}},repeat:{get:function(){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");return this.texture.repeat},set:function(a){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");this.texture.repeat=a}},format:{get:function(){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
return this.texture.format},set:function(a){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");this.texture.format=a}},type:{get:function(){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");return this.texture.type},set:function(a){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");this.texture.type=a}},generateMipmaps:{get:function(){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");return this.texture.generateMipmaps},
set:function(a){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");this.texture.generateMipmaps=a}}});Object.defineProperties(kf.prototype,{standing:{set:function(){console.warn("THREE.WebVRManager: .standing has been removed.")}},userHeight:{set:function(){console.warn("THREE.WebVRManager: .userHeight has been removed.")}}});lc.prototype.load=function(a){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");var b=this;(new pe).load(a,
function(a){b.setBuffer(a)});return this};ue.prototype.getData=function(){console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");return this.getFrequencyData()};kd.prototype.updateCubeMap=function(a,b){console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");return this.update(a,b)};ib.crossOrigin=void 0;ib.loadTexture=function(a,b,c,d){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");var e=new Hd;e.setCrossOrigin(this.crossOrigin);
a=e.load(a,c,void 0,d);b&&(a.mapping=b);return a};ib.loadTextureCube=function(a,b,c,d){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");var e=new ie;e.setCrossOrigin(this.crossOrigin);a=e.load(a,c,void 0,d);b&&(a.mapping=b);return a};ib.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")};ib.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};
l.WebGLRenderTargetCube=Ib;l.WebGLRenderTarget=jb;l.WebGLRenderer=be;l.ShaderLib=Qa;l.UniformsLib=F;l.UniformsUtils=ah;l.ShaderChunk=I;l.FogExp2=Qb;l.Fog=Rb;l.Scene=xd;l.Sprite=Fc;l.LOD=Gc;l.SkinnedMesh=Hc;l.Skeleton=yd;l.Bone=ce;l.Mesh=pa;l.LineSegments=S;l.LineLoop=zd;l.Line=ma;l.Points=Tb;l.Group=Pb;l.VideoTexture=de;l.DataTexture=kb;l.DataTexture3D=Nb;l.CompressedTexture=Ub;l.CubeTexture=Xa;l.CanvasTexture=Ic;l.DepthTexture=Jc;l.Texture=X;l.AnimationLoader=tf;l.CompressedTextureLoader=uf;l.DataTextureLoader=
he;l.CubeTextureLoader=ie;l.TextureLoader=Hd;l.ObjectLoader=le;l.MaterialLoader=Qd;l.BufferGeometryLoader=ke;l.DefaultLoadingManager=za;l.LoadingManager=ge;l.ImageLoader=fd;l.ImageBitmapLoader=me;l.FontLoader=wf;l.FileLoader=Ia;l.Loader=jd;l.LoaderUtils=Ie;l.Cache=Hb;l.AudioLoader=pe;l.SpotLightShadow=Jd;l.SpotLight=Kd;l.PointLight=Ld;l.RectAreaLight=Pd;l.HemisphereLight=Id;l.DirectionalLightShadow=Md;l.DirectionalLight=Nd;l.AmbientLight=Od;l.LightShadow=Gb;l.Light=ba;l.StereoCamera=xf;l.PerspectiveCamera=
V;l.OrthographicCamera=id;l.CubeCamera=kd;l.ArrayCamera=Dc;l.Camera=Ra;l.AudioListener=re;l.PositionalAudio=te;l.AudioContext=se;l.AudioAnalyser=ue;l.Audio=lc;l.VectorKeyframeTrack=jc;l.StringKeyframeTrack=Gd;l.QuaternionKeyframeTrack=ed;l.NumberKeyframeTrack=ic;l.ColorKeyframeTrack=Ed;l.BooleanKeyframeTrack=Dd;l.PropertyMixer=ve;l.PropertyBinding=oa;l.KeyframeTrack=qa;l.AnimationUtils=ra;l.AnimationObjectGroup=zf;l.AnimationMixer=we;l.AnimationClip=Ha;l.Uniform=Rd;l.InstancedBufferGeometry=xe;l.BufferGeometry=
D;l.Geometry=Q;l.InterleavedBufferAttribute=Ec;l.InstancedInterleavedBuffer=ye;l.InterleavedBuffer=rb;l.InstancedBufferAttribute=ze;l.Face3=Kb;l.Object3D=C;l.Raycaster=Bf;l.Layers=Xd;l.EventDispatcher=ja;l.Clock=qe;l.QuaternionLinearInterpolant=Fd;l.LinearInterpolant=dd;l.DiscreteInterpolant=Cd;l.CubicInterpolant=Bd;l.Interpolant=ya;l.Triangle=ha;l.Math=R;l.Spherical=Df;l.Cylindrical=Ef;l.Plane=Pa;l.Frustum=td;l.Sphere=Ea;l.Ray=qb;l.Matrix4=O;l.Matrix3=da;l.Box3=Wa;l.Box2=Be;l.Line3=Ce;l.Euler=lb;
l.Vector4=ca;l.Vector3=n;l.Vector2=z;l.Quaternion=ka;l.Color=J;l.ImmediateRenderObject=ld;l.VertexNormalsHelper=md;l.SpotLightHelper=mc;l.SkeletonHelper=nc;l.PointLightHelper=oc;l.RectAreaLightHelper=pc;l.HemisphereLightHelper=qc;l.GridHelper=nd;l.PolarGridHelper=Sd;l.FaceNormalsHelper=od;l.DirectionalLightHelper=rc;l.CameraHelper=pd;l.BoxHelper=ab;l.Box3Helper=qd;l.PlaneHelper=rd;l.ArrowHelper=bb;l.AxesHelper=sd;l.Shape=hb;l.Path=Na;l.ShapePath=ne;l.Font=oe;l.CurvePath=$a;l.Curve=K;l.ImageUtils=
ib;l.ShapeUtils=Ya;l.WebGLUtils=ff;l.WireframeGeometry=Vb;l.ParametricGeometry=Kc;l.ParametricBufferGeometry=Wb;l.TetrahedronGeometry=Mc;l.TetrahedronBufferGeometry=Xb;l.OctahedronGeometry=Nc;l.OctahedronBufferGeometry=sb;l.IcosahedronGeometry=Oc;l.IcosahedronBufferGeometry=Yb;l.DodecahedronGeometry=Pc;l.DodecahedronBufferGeometry=Zb;l.PolyhedronGeometry=Lc;l.PolyhedronBufferGeometry=xa;l.TubeGeometry=Qc;l.TubeBufferGeometry=$b;l.TorusKnotGeometry=Rc;l.TorusKnotBufferGeometry=ac;l.TorusGeometry=Sc;
l.TorusBufferGeometry=bc;l.TextGeometry=Xc;l.TextBufferGeometry=cc;l.SphereGeometry=Yc;l.SphereBufferGeometry=vb;l.RingGeometry=Zc;l.RingBufferGeometry=dc;l.PlaneGeometry=zc;l.PlaneBufferGeometry=pb;l.LatheGeometry=$c;l.LatheBufferGeometry=ec;l.ShapeGeometry=wb;l.ShapeBufferGeometry=xb;l.ExtrudeGeometry=ub;l.ExtrudeBufferGeometry=Sa;l.EdgesGeometry=fc;l.ConeGeometry=ad;l.ConeBufferGeometry=bd;l.CylinderGeometry=yb;l.CylinderBufferGeometry=Za;l.CircleGeometry=cd;l.CircleBufferGeometry=gc;l.BoxGeometry=
Lb;l.BoxBufferGeometry=ob;l.ShadowMaterial=zb;l.SpriteMaterial=gb;l.RawShaderMaterial=hc;l.ShaderMaterial=Ba;l.PointsMaterial=Fa;l.MeshPhysicalMaterial=Ab;l.MeshStandardMaterial=Ta;l.MeshPhongMaterial=Ga;l.MeshToonMaterial=Bb;l.MeshNormalMaterial=Cb;l.MeshLambertMaterial=Db;l.MeshDepthMaterial=db;l.MeshDistanceMaterial=eb;l.MeshBasicMaterial=Da;l.MeshMatcapMaterial=Eb;l.LineDashedMaterial=Fb;l.LineBasicMaterial=T;l.Material=L;l.Float64BufferAttribute=yc;l.Float32BufferAttribute=B;l.Uint32BufferAttribute=
nb;l.Int32BufferAttribute=xc;l.Uint16BufferAttribute=mb;l.Int16BufferAttribute=wc;l.Uint8ClampedBufferAttribute=vc;l.Uint8BufferAttribute=uc;l.Int8BufferAttribute=tc;l.BufferAttribute=E;l.ArcCurve=kc;l.CatmullRomCurve3=ta;l.CubicBezierCurve=Ja;l.CubicBezierCurve3=Ua;l.EllipseCurve=va;l.LineCurve=Aa;l.LineCurve3=Ka;l.QuadraticBezierCurve=La;l.QuadraticBezierCurve3=Va;l.SplineCurve=Ma;l.REVISION="99";l.MOUSE={LEFT:0,MIDDLE:1,RIGHT:2};l.CullFaceNone=0;l.CullFaceBack=1;l.CullFaceFront=2;l.CullFaceFrontBack=
3;l.FrontFaceDirectionCW=0;l.FrontFaceDirectionCCW=1;l.BasicShadowMap=0;l.PCFShadowMap=1;l.PCFSoftShadowMap=2;l.FrontSide=0;l.BackSide=1;l.DoubleSide=2;l.FlatShading=1;l.SmoothShading=2;l.NoColors=0;l.FaceColors=1;l.VertexColors=2;l.NoBlending=0;l.NormalBlending=1;l.AdditiveBlending=2;l.SubtractiveBlending=3;l.MultiplyBlending=4;l.CustomBlending=5;l.AddEquation=100;l.SubtractEquation=101;l.ReverseSubtractEquation=102;l.MinEquation=103;l.MaxEquation=104;l.ZeroFactor=200;l.OneFactor=201;l.SrcColorFactor=
202;l.OneMinusSrcColorFactor=203;l.SrcAlphaFactor=204;l.OneMinusSrcAlphaFactor=205;l.DstAlphaFactor=206;l.OneMinusDstAlphaFactor=207;l.DstColorFactor=208;l.OneMinusDstColorFactor=209;l.SrcAlphaSaturateFactor=210;l.NeverDepth=0;l.AlwaysDepth=1;l.LessDepth=2;l.LessEqualDepth=3;l.EqualDepth=4;l.GreaterEqualDepth=5;l.GreaterDepth=6;l.NotEqualDepth=7;l.MultiplyOperation=0;l.MixOperation=1;l.AddOperation=2;l.NoToneMapping=0;l.LinearToneMapping=1;l.ReinhardToneMapping=2;l.Uncharted2ToneMapping=3;l.CineonToneMapping=
4;l.ACESFilmicToneMapping=5;l.UVMapping=300;l.CubeReflectionMapping=301;l.CubeRefractionMapping=302;l.EquirectangularReflectionMapping=303;l.EquirectangularRefractionMapping=304;l.SphericalReflectionMapping=305;l.CubeUVReflectionMapping=306;l.CubeUVRefractionMapping=307;l.RepeatWrapping=1E3;l.ClampToEdgeWrapping=1001;l.MirroredRepeatWrapping=1002;l.NearestFilter=1003;l.NearestMipMapNearestFilter=1004;l.NearestMipMapLinearFilter=1005;l.LinearFilter=1006;l.LinearMipMapNearestFilter=1007;l.LinearMipMapLinearFilter=
1008;l.UnsignedByteType=1009;l.ByteType=1010;l.ShortType=1011;l.UnsignedShortType=1012;l.IntType=1013;l.UnsignedIntType=1014;l.FloatType=1015;l.HalfFloatType=1016;l.UnsignedShort4444Type=1017;l.UnsignedShort5551Type=1018;l.UnsignedShort565Type=1019;l.UnsignedInt248Type=1020;l.AlphaFormat=1021;l.RGBFormat=1022;l.RGBAFormat=1023;l.LuminanceFormat=1024;l.LuminanceAlphaFormat=1025;l.RGBEFormat=1023;l.DepthFormat=1026;l.DepthStencilFormat=1027;l.RedFormat=1028;l.RGB_S3TC_DXT1_Format=33776;l.RGBA_S3TC_DXT1_Format=
33777;l.RGBA_S3TC_DXT3_Format=33778;l.RGBA_S3TC_DXT5_Format=33779;l.RGB_PVRTC_4BPPV1_Format=35840;l.RGB_PVRTC_2BPPV1_Format=35841;l.RGBA_PVRTC_4BPPV1_Format=35842;l.RGBA_PVRTC_2BPPV1_Format=35843;l.RGB_ETC1_Format=36196;l.RGBA_ASTC_4x4_Format=37808;l.RGBA_ASTC_5x4_Format=37809;l.RGBA_ASTC_5x5_Format=37810;l.RGBA_ASTC_6x5_Format=37811;l.RGBA_ASTC_6x6_Format=37812;l.RGBA_ASTC_8x5_Format=37813;l.RGBA_ASTC_8x6_Format=37814;l.RGBA_ASTC_8x8_Format=37815;l.RGBA_ASTC_10x5_Format=37816;l.RGBA_ASTC_10x6_Format=
37817;l.RGBA_ASTC_10x8_Format=37818;l.RGBA_ASTC_10x10_Format=37819;l.RGBA_ASTC_12x10_Format=37820;l.RGBA_ASTC_12x12_Format=37821;l.LoopOnce=2200;l.LoopRepeat=2201;l.LoopPingPong=2202;l.InterpolateDiscrete=2300;l.InterpolateLinear=2301;l.InterpolateSmooth=2302;l.ZeroCurvatureEnding=2400;l.ZeroSlopeEnding=2401;l.WrapAroundEnding=2402;l.TrianglesDrawMode=0;l.TriangleStripDrawMode=1;l.TriangleFanDrawMode=2;l.LinearEncoding=3E3;l.sRGBEncoding=3001;l.GammaEncoding=3007;l.RGBEEncoding=3002;l.LogLuvEncoding=
3003;l.RGBM7Encoding=3004;l.RGBM16Encoding=3005;l.RGBDEncoding=3006;l.BasicDepthPacking=3200;l.RGBADepthPacking=3201;l.TangentSpaceNormalMap=0;l.ObjectSpaceNormalMap=1;l.CubeGeometry=Lb;l.Face4=function(a,b,c,d,e,f,g){console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead.");return new Kb(a,b,c,e,f,g)};l.LineStrip=0;l.LinePieces=1;l.MeshFaceMaterial=function(a){console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead.");return a};l.MultiMaterial=function(a){void 0===
a&&(a=[]);console.warn("THREE.MultiMaterial has been removed. Use an Array instead.");a.isMultiMaterial=!0;a.materials=a;a.clone=function(){return a.slice()};return a};l.PointCloud=function(a,b){console.warn("THREE.PointCloud has been renamed to THREE.Points.");return new Tb(a,b)};l.Particle=function(a){console.warn("THREE.Particle has been renamed to THREE.Sprite.");return new Fc(a)};l.ParticleSystem=function(a,b){console.warn("THREE.ParticleSystem has been renamed to THREE.Points.");return new Tb(a,
b)};l.PointCloudMaterial=function(a){console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.");return new Fa(a)};l.ParticleBasicMaterial=function(a){console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.");return new Fa(a)};l.ParticleSystemMaterial=function(a){console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.");return new Fa(a)};l.Vertex=function(a,b,c){console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead.");
return new n(a,b,c)};l.DynamicBufferAttribute=function(a,b){console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.");return(new E(a,b)).setDynamic(!0)};l.Int8Attribute=function(a,b){console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.");return new tc(a,b)};l.Uint8Attribute=function(a,b){console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.");return new uc(a,
b)};l.Uint8ClampedAttribute=function(a,b){console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.");return new vc(a,b)};l.Int16Attribute=function(a,b){console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.");return new wc(a,b)};l.Uint16Attribute=function(a,b){console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.");return new mb(a,b)};l.Int32Attribute=
function(a,b){console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.");return new xc(a,b)};l.Uint32Attribute=function(a,b){console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.");return new nb(a,b)};l.Float32Attribute=function(a,b){console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.");return new B(a,b)};l.Float64Attribute=function(a,b){console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.");
return new yc(a,b)};l.ClosedSplineCurve3=Gf;l.SplineCurve3=Hf;l.Spline=Ee;l.AxisHelper=function(a){console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper.");return new sd(a)};l.BoundingBoxHelper=function(a,b){console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.");return new ab(a,b)};l.EdgesHelper=function(a,b){console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.");return new S(new fc(a.geometry),new T({color:void 0!==
b?b:16777215}))};l.WireframeHelper=function(a,b){console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.");return new S(new Vb(a.geometry),new T({color:void 0!==b?b:16777215}))};l.XHRLoader=function(a){console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader.");return new Ia(a)};l.BinaryTextureLoader=function(a){console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.");return new he(a)};l.GeometryUtils={merge:function(a,b,c){console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
if(b.isMesh){b.matrixAutoUpdate&&b.updateMatrix();var d=b.matrix;b=b.geometry}a.merge(b,d,c)},center:function(a){console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.");return a.center()}};l.Projector=function(){console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js.");this.projectVector=function(a,b){console.warn("THREE.Projector: .projectVector() is now vector.project().");a.project(b)};this.unprojectVector=function(a,
b){console.warn("THREE.Projector: .unprojectVector() is now vector.unproject().");a.unproject(b)};this.pickingRay=function(){console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")}};l.CanvasRenderer=function(){console.error("THREE.CanvasRenderer has been removed")};l.JSONLoader=function(){console.error("THREE.JSONLoader has been removed.")};l.SceneUtils={createMultiMaterialObject:function(){console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")},
detach:function(){console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")},attach:function(){console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")}};l.LensFlare=function(){console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js")};Object.defineProperty(l,"__esModule",{value:!0})});

;/*! The file full_ui_all.js contains the following files: Detector.js,
 * CanvasRenderer.js, TrackballControls.js, OrthographicTrackballControls.js,
 * Projector.js, marchingcube.js, ProteinSurface4.js, setupsurface.js, icn3d.js,
 * and full_ui.js.
 * The file simple_ui_all.js contains the following files: Detector.js,
 * CanvasRenderer.js, TrackballControls.js, OrthographicTrackballControls.js,
 * Projector.js, marchingcube.js, ProteinSurface4.js, setupsurface.js, icn3d.js,
 * and simple_ui.js.
 */

/*! Detector.js from http://threejs.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mr.doob / http://mrdoob.com/
 */

var Detector = {

    canvas: !! window.CanvasRenderingContext2D,
    webgl: ( function () {

        try {

            var canvas = document.createElement( 'canvas' ); return !! ( window.WebGLRenderingContext && ( canvas.getContext( 'webgl' ) || canvas.getContext( 'experimental-webgl' ) ) );

        } catch ( e ) {

            return false;

        }

    } )(),
    workers: !! window.Worker,
    fileapi: window.File && window.FileReader && window.FileList && window.Blob,

    getWebGLErrorMessage: function () {

        var element = document.createElement( 'div' );
        element.id = 'webgl-error-message';
        element.style.fontFamily = 'monospace';
        element.style.fontSize = '13px';
        element.style.fontWeight = 'normal';
        element.style.textAlign = 'center';
        element.style.background = '#fff';
        element.style.color = '#000';
        element.style.padding = '1.5em';
        element.style.width = '400px';
        element.style.margin = '5em auto 0';

        if ( ! this.webgl ) {

            element.innerHTML = window.WebGLRenderingContext ? [
                'Your graphics card does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">WebGL</a>.<br />',
                'Find out how to get it <a href="http://get.webgl.org/" style="color:#000">here</a>.'
            ].join( '\n' ) : [
                'Your browser does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">WebGL</a>.<br/>',
                'Find out how to get it <a href="http://get.webgl.org/" style="color:#000">here</a>.'
            ].join( '\n' );

        }

        return element;

    },

    addGetWebGLMessage: function ( parameters ) {

        var parent, id, element;

        parameters = parameters || {};

        parent = parameters.parent !== undefined ? parameters.parent : document.body;
        id = parameters.id !== undefined ? parameters.id : 'oldie';

        element = Detector.getWebGLErrorMessage();
        element.id = id;

        parent.appendChild( element );

    }

};

// browserify support
if ( typeof module === 'object' ) {

    module.exports = Detector;

}

/*! TrackballControls.js from http://threejs.org/
 * @author Eberhard Graether / http://egraether.com/
 * @author Mark Lundin  / http://mark-lundin.com
 * modified by Jiyao Wang
 */

THREE.TrackballControls = function ( object, domElement, icn3d ) {

    var _this = this;

    this.STATE = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 };

    this.object = object;
    this.domElement = ( domElement !== undefined ) ? domElement : document;

    // API
    this.enabled = true;

    this.screen = { left: 0, top: 0, width: 0, height: 0 };

    this.rotateSpeed = 1.0;
    this.zoomSpeed = 1.2;
    this.panSpeed = 0.3;

    this.noRotate = false;
    this.noZoom = false;
    this.noPan = false;
    this.noRoll = false;

    this.staticMoving = false;
    this.dynamicDampingFactor = 0.2;

    this.minDistance = 0;
    this.maxDistance = Infinity;

    this.keys = [ 65 /*A*/, 83 /*S*/, 68 /*D*/ ];

    // internals

    this.target = new THREE.Vector3();

    var EPS = 0.000001;

    var lastPosition = new THREE.Vector3();

    this._state = this.STATE.NONE;
    var _prevState = this.STATE.NONE;

    var _eye = new THREE.Vector3();

    this._rotateStart = new THREE.Vector3();
    this._rotateEnd = new THREE.Vector3();

    this._zoomStart = new THREE.Vector2();
    this._zoomEnd = new THREE.Vector2();

    var _touchZoomDistanceStart = 0;
    var _touchZoomDistanceEnd = 0;

    this._panStart = new THREE.Vector2();
    this._panEnd = new THREE.Vector2();

    // for reset

    this.target0 = this.target.clone();
    this.position0 = this.object.position.clone();
    this.up0 = this.object.up.clone();

    // events

    var changeEvent = { type: 'change' };
    var startEvent = { type: 'start'};
    var endEvent = { type: 'end'};


    // methods

    this.handleResize = function () {

        if ( this.domElement === document ) {

            this.screen.left = 0;
            this.screen.top = 0;
            this.screen.width = window.innerWidth;
            this.screen.height = window.innerHeight;

        } else {

            var box = this.domElement.getBoundingClientRect();
            // adjustments come from similar code in the jquery offset() function
            var d = this.domElement.ownerDocument.documentElement;
            this.screen.left = box.left + window.pageXOffset - d.clientLeft;
            this.screen.top = box.top + window.pageYOffset - d.clientTop;
            this.screen.width = box.width;
            this.screen.height = box.height;

        }

    };

    this.handleEvent = function ( event ) {

        if ( typeof this[ event.type ] === 'function' ) {

            this[ event.type ]( event );

        }

    };

    var getMouseOnScreen = ( function () {

        var vector = new THREE.Vector2();

        return function ( pageX, pageY ) {

            vector.set(
                ( pageX - _this.screen.left ) / _this.screen.width,
                ( pageY - _this.screen.top ) / _this.screen.height
            );

            return vector;

        };

    }() );

    var getMouseProjectionOnBall = ( function () {

        var vector = new THREE.Vector3();
        var objectUp = new THREE.Vector3();
        var mouseOnBall = new THREE.Vector3();

        return function ( pageX, pageY ) {

            mouseOnBall.set(
                ( pageX - _this.screen.width * 0.5 - _this.screen.left ) / (_this.screen.width*.5),
                ( _this.screen.height * 0.5 + _this.screen.top - pageY ) / (_this.screen.height*.5),
                0.0
            );

            var length = mouseOnBall.length();

            if ( _this.noRoll ) {

                if ( length < Math.SQRT1_2 ) {

                    mouseOnBall.z = Math.sqrt( 1.0 - length*length );

                } else {

                    mouseOnBall.z = .5 / length;

                }

            } else if ( length > 1.0 ) {

                mouseOnBall.normalize();

            } else {

                mouseOnBall.z = Math.sqrt( 1.0 - length * length );

            }

            _eye.copy( _this.object.position ).sub( _this.target );

            vector.copy( _this.object.up ).setLength( mouseOnBall.y )
            vector.add( objectUp.copy( _this.object.up ).cross( _eye ).setLength( mouseOnBall.x ) );
            vector.add( _eye.setLength( mouseOnBall.z ) );

            return vector;

        };

    }() );

    this.rotateCamera = (function(quaternionIn, bUpdate){

        var axis = new THREE.Vector3(),
            quaternion = new THREE.Quaternion();


        return function (quaternionIn, bUpdate) {

            var angle;
            if(quaternionIn === undefined) {
              angle = Math.acos( _this._rotateStart.dot( _this._rotateEnd ) / _this._rotateStart.length() / _this._rotateEnd.length() );
            }

            //var angle = Math.acos( _this._rotateStart.dot( _this._rotateEnd ) / _this._rotateStart.length() / _this._rotateEnd.length() );

            if ( angle || quaternionIn !== undefined) {
                if(quaternionIn === undefined) {
                  axis.crossVectors( _this._rotateStart, _this._rotateEnd ).normalize();

                  angle *= _this.rotateSpeed;

                  quaternion.setFromAxisAngle( axis, -angle );
                }
                else {
                  quaternion.copy(quaternionIn);
                }

                // order matters in quaernion multiplication: http://www.cprogramming.com/tutorial/3d/quaternions.html
                if(bUpdate === undefined || bUpdate === true) icn3d.quaternion.multiplyQuaternions(quaternion, icn3d.quaternion);

                _eye.applyQuaternion( quaternion );
                _this.object.up.applyQuaternion( quaternion );

                _this._rotateEnd.applyQuaternion( quaternion );

                if ( _this.staticMoving ) {

                    _this._rotateStart.copy( _this._rotateEnd );

                } else {

                    quaternion.setFromAxisAngle( axis, angle * ( _this.dynamicDampingFactor - 1.0 ) );
                    _this._rotateStart.applyQuaternion( quaternion );

                }
            }

        }

    }());

    this.zoomCamera = function (zoomFactor, bUpdate) {
        if ( _this._state === _this.STATE.TOUCH_ZOOM_PAN ) {

            var factor;

            if(zoomFactor !== undefined) {
              factor = zoomFactor;
            }
            else {

              factor = _touchZoomDistanceStart / _touchZoomDistanceEnd;
              _touchZoomDistanceStart = _touchZoomDistanceEnd;
            }

            _eye.multiplyScalar( factor );

            if(bUpdate === undefined || bUpdate === true) icn3d._zoomFactor *= factor;

        } else {

            var factor;

            if(zoomFactor !== undefined) {
              factor = zoomFactor;
            }
            else {
              factor = 1.0 + ( _this._zoomEnd.y - _this._zoomStart.y ) * _this.zoomSpeed;
            }

            if(bUpdate === undefined || bUpdate === true) icn3d._zoomFactor *= factor;

            //if ( factor !== 1.0 && factor > 0.0 ) {
            if ( factor !== 1.0 ) {

                _eye.multiplyScalar( factor );

                if ( _this.staticMoving ) {

                    _this._zoomStart.copy( _this._zoomEnd );

                } else {

                    _this._zoomStart.y += ( _this._zoomEnd.y - _this._zoomStart.y ) * this.dynamicDampingFactor;
                }
            }

        }

    };

    this.panCamera = (function(mouseChangeIn, bUpdate){

        var mouseChange = new THREE.Vector2(),
            objectUp = new THREE.Vector3(),
            pan = new THREE.Vector3();

        return function (mouseChangeIn, bUpdate) {

            if(mouseChangeIn !== undefined) {
              mouseChange = mouseChangeIn;

              if(bUpdate === undefined || bUpdate === true) icn3d.mouseChange.add(mouseChangeIn);
            }
            else {
              mouseChange.copy( _this._panEnd ).sub( _this._panStart );

              if(bUpdate === undefined || bUpdate === true) icn3d.mouseChange.add( _this._panEnd ).sub( _this._panStart );
            }

            if ( mouseChange.lengthSq() ) {
                mouseChange.multiplyScalar( _eye.length() * _this.panSpeed );

                pan.copy( _eye ).cross( _this.object.up ).setLength( mouseChange.x );
                pan.add( objectUp.copy( _this.object.up ).setLength( mouseChange.y ) );

                _this.object.position.add( pan );
                _this.target.add( pan );

                if ( _this.staticMoving ) {

                    _this._panStart.copy( _this._panEnd );

                } else {

                    _this._panStart.add( mouseChange.subVectors( _this._panEnd, _this._panStart ).multiplyScalar( _this.dynamicDampingFactor ) );

                }

            }
        }

    }());

    this.checkDistances = function () {

        if ( !_this.noZoom || !_this.noPan ) {

            if ( _eye.lengthSq() > _this.maxDistance * _this.maxDistance ) {

                _this.object.position.addVectors( _this.target, _eye.setLength( _this.maxDistance ) );

            }

            if ( _eye.lengthSq() < _this.minDistance * _this.minDistance ) {

                _this.object.position.addVectors( _this.target, _eye.setLength( _this.minDistance ) );

            }

        }

    };

    this.update = function (para) {

        _eye.subVectors( _this.object.position, _this.target );

        if ( !_this.noRotate ) {

            if(para !== undefined && para.quaternion !== undefined) {
              _this.rotateCamera(para.quaternion, para.update);
            }
            else {
              _this.rotateCamera();
            }

        }

        if ( !_this.noZoom ) {

            if(para !== undefined && para._zoomFactor !== undefined) {
              _this.zoomCamera(para._zoomFactor, para.update);
            }
            else {
              _this.zoomCamera();
            }

        }

        if ( !_this.noPan ) {

            if(para !== undefined && para.mouseChange !== undefined) {
              _this.panCamera(para.mouseChange, para.update);
            }
            else {
              _this.panCamera();
            }

        }

        _this.object.position.addVectors( _this.target, _eye );

        _this.checkDistances();

        _this.object.lookAt( _this.target );

        if ( lastPosition.distanceToSquared( _this.object.position ) > EPS ) {

            _this.dispatchEvent( changeEvent );

            lastPosition.copy( _this.object.position );

        }

    };

    this.reset = function () {

        _this._state = _this.STATE.NONE;
        _prevState = _this.STATE.NONE;

        _this.target.copy( _this.target0 );
        _this.object.position.copy( _this.position0 );
        _this.object.up.copy( _this.up0 );

        _eye.subVectors( _this.object.position, _this.target );

        _this.object.lookAt( _this.target );

        _this.dispatchEvent( changeEvent );

        lastPosition.copy( _this.object.position );

    };

    // listeners

    function keydown( event ) {
//console.log("keydown");

        if ( _this.enabled === false ) return;

        window.removeEventListener( 'keydown', keydown );

        _prevState = _this._state;


        if ( _this._state !== _this.STATE.NONE ) {

            return;

        } else if ( event.keyCode === _this.keys[ _this.STATE.ROTATE ] &&  !_this.noRotate) {

            _this._state = _this.STATE.ROTATE;

        } else if ( (event.keyCode === _this.keys[ _this.STATE.ZOOM ]) && !_this.noZoom ) {

            _this._state = _this.STATE.ZOOM;

        } else if ( (event.keyCode === _this.keys[ _this.STATE.PAN ]) && !_this.noPan ) {

            _this._state = _this.STATE.PAN;

        }


    }

    function keyup( event ) {
//console.log("keyup");

        if ( _this.enabled === false ) return;

        _this._state = _prevState;

        window.addEventListener( 'keydown', keydown, false );

    }

    function mousedown( event ) {

        if ( _this.enabled === false ) return;

        event.preventDefault();
        event.stopPropagation();

        if ( _this._state === _this.STATE.NONE ) {

            _this._state = event.button;

        }

        if ( _this._state === _this.STATE.ROTATE && !_this.noRotate ) {

            _this._rotateStart.copy( getMouseProjectionOnBall( event.pageX, event.pageY ) );
            _this._rotateEnd.copy( _this._rotateStart );

        } else if ( _this._state === _this.STATE.ZOOM && !_this.noZoom ) {

            _this._zoomStart.copy( getMouseOnScreen( event.pageX, event.pageY ) );
            _this._zoomEnd.copy(_this._zoomStart);

        } else if ( _this._state === _this.STATE.PAN && !_this.noPan ) {

            _this._panStart.copy( getMouseOnScreen( event.pageX, event.pageY ) );
            _this._panEnd.copy(_this._panStart)

        }

        document.addEventListener( 'mousemove', mousemove, false );
        document.addEventListener( 'mouseup', mouseup, false );

        _this.dispatchEvent( startEvent );

    }

    function mousemove( event ) {

        if ( _this.enabled === false ) return;

        event.preventDefault();
        event.stopPropagation();

        if ( _this._state === _this.STATE.ROTATE && !_this.noRotate ) {

//console.log("ROTATE");
            _this._rotateEnd.copy( getMouseProjectionOnBall( event.pageX, event.pageY ) );

        } else if ( _this._state === _this.STATE.ZOOM && !_this.noZoom ) {

            _this._zoomEnd.copy( getMouseOnScreen( event.pageX, event.pageY ) );

        } else if ( _this._state === _this.STATE.PAN && !_this.noPan ) {

            _this._panEnd.copy( getMouseOnScreen( event.pageX, event.pageY ) );

        }

    }

    function mouseup( event ) {
        if ( _this.enabled === false ) return;

        event.preventDefault();
        event.stopPropagation();

        _this._state = _this.STATE.NONE;

        document.removeEventListener( 'mousemove', mousemove );
        document.removeEventListener( 'mouseup', mouseup );
        _this.dispatchEvent( endEvent );

    }

    function mousewheel( event ) {

        if ( _this.enabled === false ) return;

        event.preventDefault();
        event.stopPropagation();

        var delta = 0;

        if ( event.wheelDelta ) { // WebKit / Opera / Explorer 9

            delta = event.wheelDelta / 40;

        } else if ( event.detail ) { // Firefox

            delta = - event.detail / 3;

        }

        //_this._zoomStart.y += delta * 0.01;
        //_this._zoomStart.y = delta * 0.01;
        _this._zoomStart.y = delta * 0.005;
        _this.dispatchEvent( startEvent );
        _this.dispatchEvent( endEvent );

    }

    function touchstart( event ) {

        if ( _this.enabled === false ) return;

        switch ( event.touches.length ) {
            case 1:
                _this._state = _this.STATE.TOUCH_ROTATE;
                _this._rotateStart.copy( getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ) );
                _this._rotateEnd.copy( _this._rotateStart );
                break;

            case 2:
                _this._state = _this.STATE.TOUCH_ZOOM_PAN;
                var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
                var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
                _touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt( dx * dx + dy * dy );

                var x = ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX ) / 2;
                var y = ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY ) / 2;
                _this._panStart.copy( getMouseOnScreen( x, y ) );
                _this._panEnd.copy( _this._panStart );
                break;

            default:
                _this._state = _this.STATE.NONE;

        }
        _this.dispatchEvent( startEvent );


    }

    function touchmove( event ) {

        if ( _this.enabled === false ) return;

        event.preventDefault();
        event.stopPropagation();

        switch ( event.touches.length ) {

            case 1:
                _this._rotateEnd.copy( getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ) );
                break;

            case 2:
                var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
                var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
                _touchZoomDistanceEnd = Math.sqrt( dx * dx + dy * dy );

                var x = ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX ) / 2;
                var y = ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY ) / 2;
                _this._panEnd.copy( getMouseOnScreen( x, y ) );
                break;

            default:
                _this._state = _this.STATE.NONE;

        }

    }

    function touchend( event ) {

        if ( _this.enabled === false ) return;

        switch ( event.touches.length ) {

            case 1:
                _this._rotateEnd.copy( getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ) );
                _this._rotateStart.copy( _this._rotateEnd );
                break;

            case 2:
                _touchZoomDistanceStart = _touchZoomDistanceEnd = 0;

                var x = ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX ) / 2;
                var y = ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY ) / 2;
                _this._panEnd.copy( getMouseOnScreen( x, y ) );
                _this._panStart.copy( _this._panEnd );
                break;

        }

        _this._state = _this.STATE.NONE;
        _this.dispatchEvent( endEvent );

    }

    this.domElement.addEventListener( 'contextmn', function ( event ) { event.preventDefault(); }, false );

    this.domElement.addEventListener( 'mousedown', mousedown, false );

    this.domElement.addEventListener( 'mousewheel', mousewheel, false );
    this.domElement.addEventListener( 'DOMMouseScroll', mousewheel, false ); // firefox

    this.domElement.addEventListener( 'touchstart', touchstart, false );
    this.domElement.addEventListener( 'touchend', touchend, false );
    this.domElement.addEventListener( 'touchmove', touchmove, false );

    window.addEventListener( 'keydown', keydown, false );
    window.addEventListener( 'keyup', keyup, false );

    this.handleResize();

    // force an update at start
    this.update();

};

THREE.TrackballControls.prototype = Object.create( THREE.EventDispatcher.prototype );
THREE.TrackballControls.prototype.constructor = THREE.TrackballControls;

/*! OrthographicTrackballControls.js from http://threejs.org/
 * @author Eberhard Graether / http://egraether.com/
 * @author Mark Lundin  / http://mark-lundin.com
 * @author Patrick Fuller / http://patrick-fuller.com
 * modified by Jiyao Wang
 */

THREE.OrthographicTrackballControls = function ( object, domElement, icn3d ) {

    var _this = this;
    var STATE = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 };

    this.object = object;
    this.domElement = ( domElement !== undefined ) ? domElement : document;

    // API
    this.enabled = true;

    this.screen = { left: 0, top: 0, width: 0, height: 0 };

    // JW: the rotation speed of orthographic should be much less than that of perspective
    //this.rotateSpeed = 1.0;
    this.rotateSpeed = 0.5;
    this.zoomSpeed = 1.2;

    var zoomSpeedAdjust = 0.01;
    this.zoomSpeed *= zoomSpeedAdjust;

    //this.panSpeed = 0.3;
    this.panSpeed = 0.03;

    this.noRotate = false;
    this.noZoom = false;
    this.noPan = false;
    this.noRoll = false;

    this.staticMoving = false;
    this.dynamicDampingFactor = 0.2;

    this.keys = [ 65 /*A*/, 83 /*S*/, 68 /*D*/ ];

    // internals

    this.target = new THREE.Vector3();

    var EPS = 0.000001;

    var lastPosition = new THREE.Vector3();

    this._state = STATE.NONE;
    var _prevState = STATE.NONE;

    var _eye = new THREE.Vector3();

    this._rotateStart = new THREE.Vector3();
    this._rotateEnd = new THREE.Vector3();

    this._zoomStart = new THREE.Vector2();
    this._zoomEnd = new THREE.Vector2();
    var _zoomFactor = 1;

    var _touchZoomDistanceStart = 0;
    var _touchZoomDistanceEnd = 0;

    this._panStart = new THREE.Vector2();
    this._panEnd = new THREE.Vector2();

    // for reset

    this.target0 = this.target.clone();
    this.position0 = this.object.position.clone();
    this.up0 = this.object.up.clone();

    this.left0 = this.object.left;
    this.right0 = this.object.right;
    this.top0 = this.object.top;
    this.bottom0 = this.object.bottom;
    this.center0 = new THREE.Vector2((this.left0 + this.right0) / 2.0, (this.top0 + this.bottom0) / 2.0);

    // events

    var changeEvent = { type: 'change' };
    var startEvent = { type: 'start'};
    var endEvent = { type: 'end'};


    // methods

    this.handleResize = function () {

        if ( this.domElement === document ) {

            this.screen.left = 0;
            this.screen.top = 0;
            this.screen.width = window.innerWidth;
            this.screen.height = window.innerHeight;

        } else {

            var box = this.domElement.getBoundingClientRect();
            // adjustments come from similar code in the jquery offset() function
            var d = this.domElement.ownerDocument.documentElement;
            this.screen.left = box.left + window.pageXOffset - d.clientLeft;
            this.screen.top = box.top + window.pageYOffset - d.clientTop;
            this.screen.width = box.width;
            this.screen.height = box.height;
        }

        this.left0 = this.object.left;
        this.right0 = this.object.right;
        this.top0 = this.object.top;
        this.bottom0 = this.object.bottom;
        this.center0.set((this.left0 + this.right0) / 2.0, (this.top0 + this.bottom0) / 2.0);

    };

    this.handleEvent = function ( event ) {

        if ( typeof this[ event.type ] === 'function' ) {

            this[ event.type ]( event );

        }

    };

    var getMouseOnScreen = ( function () {

        var vector = new THREE.Vector2();

        return function ( pageX, pageY ) {

            vector.set(
                ( pageX - _this.screen.left ) / _this.screen.width,
                ( pageY - _this.screen.top ) / _this.screen.height
            );

            return vector;

        };

    }() );

    var getMouseProjectionOnBall = ( function () {

        var vector = new THREE.Vector3();
        var objectUp = new THREE.Vector3();
        var mouseOnBall = new THREE.Vector3();

        return function ( pageX, pageY ) {

            mouseOnBall.set(
                ( pageX - _this.screen.width * 0.5 - _this.screen.left ) / (_this.screen.width*.5),
                ( _this.screen.height * 0.5 + _this.screen.top - pageY ) / (_this.screen.height*.5),
                0.0
            );

            var length = mouseOnBall.length();

            if ( _this.noRoll ) {

                if ( length < Math.SQRT1_2 ) {

                    mouseOnBall.z = Math.sqrt( 1.0 - length*length );

                } else {

                    mouseOnBall.z = .5 / length;

                }

            } else if ( length > 1.0 ) {

                mouseOnBall.normalize();

            } else {

                mouseOnBall.z = Math.sqrt( 1.0 - length * length );

            }

            _eye.copy( _this.object.position ).sub( _this.target );

            vector.copy( _this.object.up ).setLength( mouseOnBall.y )
            vector.add( objectUp.copy( _this.object.up ).cross( _eye ).setLength( mouseOnBall.x ) );
            vector.add( _eye.setLength( mouseOnBall.z ) );

            return vector;

        };

    }() );

    this.rotateCamera = (function(quaternionIn, bUpdate){

        var axis = new THREE.Vector3(),
            quaternion = new THREE.Quaternion();

        return function (quaternionIn, bUpdate) {

            var angle;
            if(quaternionIn === undefined) {
              angle = Math.acos( _this._rotateStart.dot( _this._rotateEnd ) / _this._rotateStart.length() / _this._rotateEnd.length() );
            }

            //var angle = Math.acos( _this._rotateStart.dot( _this._rotateEnd ) / _this._rotateStart.length() / _this._rotateEnd.length() );

            if ( angle || quaternionIn !== undefined) {
                if(quaternionIn === undefined) {
                  axis.crossVectors( _this._rotateStart, _this._rotateEnd ).normalize();

                  angle *= _this.rotateSpeed;

                  quaternion.setFromAxisAngle( axis, -angle );
                }
                else {
                  quaternion.copy(quaternionIn);
                }

                // order matters in quaernion multiplication: http://www.cprogramming.com/tutorial/3d/quaternions.html
                if(bUpdate === undefined || bUpdate === true) icn3d.quaternion.multiplyQuaternions(quaternion, icn3d.quaternion);

                _eye.applyQuaternion( quaternion );
                _this.object.up.applyQuaternion( quaternion );

                _this._rotateEnd.applyQuaternion( quaternion );

                if ( _this.staticMoving ) {

                    _this._rotateStart.copy( _this._rotateEnd );

                } else {

                    quaternion.setFromAxisAngle( axis, angle * ( _this.dynamicDampingFactor - 1.0 ) );
                    _this._rotateStart.applyQuaternion( quaternion );

                }

            }
        }

    }());

    this.zoomCamera = function (zoomFactor, bUpdate) {

        var factor;
        if ( _this._state === STATE.TOUCH_ZOOM_PAN ) {

            if(zoomFactor !== undefined) {
              factor = zoomFactor;
            }
            else {

              factor = _touchZoomDistanceStart / _touchZoomDistanceEnd;
              _touchZoomDistanceStart = _touchZoomDistanceEnd;
            }

        } else {

            if(zoomFactor !== undefined) {
              factor = zoomFactor;
            }
            else {

              factor = 1.0 + ( _this._zoomEnd.y - _this._zoomStart.y ) * _this.zoomSpeed / zoomSpeedAdjust;
            }
        }

        if(bUpdate === undefined || bUpdate === true) icn3d._zoomFactor *= factor;

        //if ( factor !== 1.0 && factor > 0.0 ) {
        if ( factor !== 1.0 ) {

            //_zoomFactor *= factor;
            _zoomFactor = factor;

            _this.object.left = _zoomFactor * _this.left0 + ( 1 - _zoomFactor ) *  _this.center0.x;
            _this.object.right = _zoomFactor * _this.right0 + ( 1 - _zoomFactor ) *  _this.center0.x;
            _this.object.top = _zoomFactor * _this.top0 + ( 1 - _zoomFactor ) *  _this.center0.y;
            _this.object.bottom = _zoomFactor * _this.bottom0 + ( 1 - _zoomFactor ) *  _this.center0.y;

            if ( _this.staticMoving ) {

                _this._zoomStart.copy( _this._zoomEnd );

            } else {

                _this._zoomStart.y += ( _this._zoomEnd.y - _this._zoomStart.y ) * this.dynamicDampingFactor;

            }

        }

    };

    this.panCamera = (function(mouseChangeIn, bUpdate){

        var mouseChange = new THREE.Vector2(),
            objectUp = new THREE.Vector3(),
            pan = new THREE.Vector3();

        return function (mouseChangeIn, bUpdate) {

            if(mouseChangeIn !== undefined) {
              mouseChange = mouseChangeIn;

              if(bUpdate === undefined || bUpdate === true) icn3d.mouseChange.add(mouseChangeIn);
            }
            else {
              mouseChange.copy( _this._panEnd ).sub( _this._panStart );

              if(bUpdate === undefined || bUpdate === true) icn3d.mouseChange.add( _this._panEnd ).sub( _this._panStart );
            }

            if ( mouseChange.lengthSq() ) {

                mouseChange.multiplyScalar( _eye.length() * _this.panSpeed );

                pan.copy( _eye ).cross( _this.object.up ).setLength( mouseChange.x );
                pan.add( objectUp.copy( _this.object.up ).setLength( mouseChange.y ) );

                _this.object.position.add( pan );
                _this.target.add( pan );

                if ( _this.staticMoving ) {

                    _this._panStart.copy( _this._panEnd );

                } else {

                    _this._panStart.add( mouseChange.subVectors( _this._panEnd, _this._panStart ).multiplyScalar( _this.dynamicDampingFactor ) );

                }

            }
        }

    }());

    this.update = function (para) {

        _eye.subVectors( _this.object.position, _this.target );

        if ( !_this.noRotate ) {

            if(para !== undefined && para.quaternion !== undefined) {
              _this.rotateCamera(para.quaternion, para.update);
            }
            else {
              _this.rotateCamera();
            }

        }

        if ( !_this.noZoom ) {

            if(para !== undefined && para._zoomFactor !== undefined) {
              _this.zoomCamera(para._zoomFactor, para.update);
            }
            else {
              _this.zoomCamera();
            }

            _this.object.updateProjectionMatrix();

        }

        if ( !_this.noPan ) {

            if(para !== undefined && para.mouseChange !== undefined) {
              _this.panCamera(para.mouseChange, para.update);
            }
            else {
              _this.panCamera();
            }

        }

        _this.object.position.addVectors( _this.target, _eye );

        _this.object.lookAt( _this.target );

        if ( lastPosition.distanceToSquared( _this.object.position ) > EPS ) {

            _this.dispatchEvent( changeEvent );

            lastPosition.copy( _this.object.position );

        }

    };

    this.reset = function () {

        _this._state = STATE.NONE;
        _prevState = STATE.NONE;

        _this.target.copy( _this.target0 );
        _this.object.position.copy( _this.position0 );
        _this.object.up.copy( _this.up0 );

        _eye.subVectors( _this.object.position, _this.target );

        _this.object.left = _this.left0;
        _this.object.right = _this.right0;
        _this.object.top = _this.top0;
        _this.object.bottom = _this.bottom0;

        _this.object.lookAt( _this.target );

        _this.dispatchEvent( changeEvent );

        lastPosition.copy( _this.object.position );

    };

    // listeners

    function keydown( event ) {

        if ( _this.enabled === false ) return;

        window.removeEventListener( 'keydown', keydown );

        _prevState = _this._state;

        if ( _this._state !== STATE.NONE ) {

            return;

        } else if ( event.keyCode === _this.keys[ STATE.ROTATE ] && !_this.noRotate ) {

            _this._state = STATE.ROTATE;

        } else if ( (event.keyCode === _this.keys[ STATE.ZOOM ]) && !_this.noZoom ) {

            _this._state = STATE.ZOOM;

        } else if ( (event.keyCode === _this.keys[ STATE.PAN ]) && !_this.noPan ) {

            _this._state = STATE.PAN;

        }

    }

    function keyup( event ) {

        if ( _this.enabled === false ) return;

        _this._state = _prevState;

        window.addEventListener( 'keydown', keydown, false );

    }

    function mousedown( event ) {

        if ( _this.enabled === false ) return;

        event.preventDefault();
        event.stopPropagation();

        if ( _this._state === STATE.NONE ) {

            _this._state = event.button;

        }

        if ( _this._state === STATE.ROTATE && !_this.noRotate ) {

            _this._rotateStart.copy( getMouseProjectionOnBall( event.pageX, event.pageY ) );
            _this._rotateEnd.copy( _this._rotateStart );

        } else if ( _this._state === STATE.ZOOM && !_this.noZoom ) {

            _this._zoomStart.copy( getMouseOnScreen( event.pageX, event.pageY ) );
            _this._zoomEnd.copy(_this._zoomStart);

        } else if ( _this._state === STATE.PAN && !_this.noPan ) {

            _this._panStart.copy( getMouseOnScreen( event.pageX, event.pageY ) );
            _this._panEnd.copy(_this._panStart)

        }

        document.addEventListener( 'mousemove', mousemove, false );
        document.addEventListener( 'mouseup', mouseup, false );

        _this.dispatchEvent( startEvent );

    }

    function mousemove( event ) {

        if ( _this.enabled === false ) return;

        event.preventDefault();
        event.stopPropagation();

        if ( _this._state === STATE.ROTATE && !_this.noRotate ) {

            _this._rotateEnd.copy( getMouseProjectionOnBall( event.pageX, event.pageY ) );

        } else if ( _this._state === STATE.ZOOM && !_this.noZoom ) {

            _this._zoomEnd.copy( getMouseOnScreen( event.pageX, event.pageY ) );

        } else if ( _this._state === STATE.PAN && !_this.noPan ) {

            _this._panEnd.copy( getMouseOnScreen( event.pageX, event.pageY ) );

        }

    }

    function mouseup( event ) {

        if ( _this.enabled === false ) return;

        event.preventDefault();
        event.stopPropagation();

        _this._state = STATE.NONE;

        document.removeEventListener( 'mousemove', mousemove );
        document.removeEventListener( 'mouseup', mouseup );
        _this.dispatchEvent( endEvent );

    }

    function mousewheel( event ) {

        if ( _this.enabled === false ) return;

        event.preventDefault();
        event.stopPropagation();

        var delta = 0;

        if ( event.wheelDelta ) { // WebKit / Opera / Explorer 9

            delta = event.wheelDelta / 40;

        } else if ( event.detail ) { // Firefox

            delta = - event.detail / 3;

        }

        //_this._zoomStart.y += delta * 0.01;
        _this._zoomStart.y = delta * 0.01;
        _this.dispatchEvent( startEvent );
        _this.dispatchEvent( endEvent );

    }

    function touchstart( event ) {

        if ( _this.enabled === false ) return;

        switch ( event.touches.length ) {

            case 1:
                _this._state = STATE.TOUCH_ROTATE;
                _this._rotateStart.copy( getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ) );
                _this._rotateEnd.copy( _this._rotateStart );
                break;

            case 2:
                _this._state = STATE.TOUCH_ZOOM_PAN;
                var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
                var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
                _touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt( dx * dx + dy * dy );

                var x = ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX ) / 2;
                var y = ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY ) / 2;
                _this._panStart.copy( getMouseOnScreen( x, y ) );
                _this._panEnd.copy( _this._panStart );
                break;

            default:
                _this._state = STATE.NONE;

        }
        _this.dispatchEvent( startEvent );


    }

    function touchmove( event ) {

        if ( _this.enabled === false ) return;

        event.preventDefault();
        event.stopPropagation();

        switch ( event.touches.length ) {

            case 1:
                _this._rotateEnd.copy( getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ) );
                break;

            case 2:
                var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
                var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
                _touchZoomDistanceEnd = Math.sqrt( dx * dx + dy * dy );

                var x = ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX ) / 2;
                var y = ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY ) / 2;
                _this._panEnd.copy( getMouseOnScreen( x, y ) );
                break;

            default:
                _this._state = STATE.NONE;

        }

    }

    function touchend( event ) {

        if ( _this.enabled === false ) return;

        switch ( event.touches.length ) {

            case 1:
                _this._rotateEnd.copy( getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ) );
                _this._rotateStart.copy( _this._rotateEnd );
                break;

            case 2:
                _touchZoomDistanceStart = _touchZoomDistanceEnd = 0;

                var x = ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX ) / 2;
                var y = ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY ) / 2;
                _this._panEnd.copy( getMouseOnScreen( x, y ) );
                _this._panStart.copy( _this._panEnd );
                break;

        }

        _this._state = STATE.NONE;
        _this.dispatchEvent( endEvent );

    }

    this.domElement.addEventListener( 'contextmn', function ( event ) { event.preventDefault(); }, false );

    this.domElement.addEventListener( 'mousedown', mousedown, false );

    this.domElement.addEventListener( 'mousewheel', mousewheel, false );
    this.domElement.addEventListener( 'DOMMouseScroll', mousewheel, false ); // firefox

    this.domElement.addEventListener( 'touchstart', touchstart, false );
    this.domElement.addEventListener( 'touchend', touchend, false );
    this.domElement.addEventListener( 'touchmove', touchmove, false );

    window.addEventListener( 'keydown', keydown, false );
    window.addEventListener( 'keyup', keyup, false );

    this.handleResize();

    // force an update at start
    this.update();

};

THREE.OrthographicTrackballControls.prototype = Object.create( THREE.EventDispatcher.prototype );
THREE.OrthographicTrackballControls.prototype.constructor = THREE.OrthographicTrackballControls;

/*! Projector.js from http://threejs.org/
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author julianwa / https://github.com/julianwa
 */

THREE.RenderableObject = function () {

    this.id = 0;

    this.object = null;
    this.z = 0;

};

//

THREE.RenderableFace = function () {

    this.id = 0;

    this.v1 = new THREE.RenderableVertex();
    this.v2 = new THREE.RenderableVertex();
    this.v3 = new THREE.RenderableVertex();

    this.normalModel = new THREE.Vector3();

    this.vertexNormalsModel = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];
    this.vertexNormalsLength = 0;

    this.color = new THREE.Color();
    this.material = null;
    this.uvs = [ new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() ];

    this.z = 0;

};

//

THREE.RenderableVertex = function () {

    this.position = new THREE.Vector3();
    this.positionWorld = new THREE.Vector3();
    this.positionScreen = new THREE.Vector4();

    this.visible = true;

};

THREE.RenderableVertex.prototype.copy = function ( vertex ) {

    this.positionWorld.copy( vertex.positionWorld );
    this.positionScreen.copy( vertex.positionScreen );

};

//

THREE.RenderableLine = function () {

    this.id = 0;

    this.v1 = new THREE.RenderableVertex();
    this.v2 = new THREE.RenderableVertex();

    this.vertexColors = [ new THREE.Color(), new THREE.Color() ];
    this.material = null;

    this.z = 0;

};

//

THREE.RenderableSprite = function () {

    this.id = 0;

    this.object = null;

    this.x = 0;
    this.y = 0;
    this.z = 0;

    this.rotation = 0;
    this.scale = new THREE.Vector2();

    this.material = null;

};

//

THREE.Projector = function () {

    var _object, _objectCount, _objectPool = [], _objectPoolLength = 0,
    _vertex, _vertexCount, _vertexPool = [], _vertexPoolLength = 0,
    _face, _faceCount, _facePool = [], _facePoolLength = 0,
    _line, _lineCount, _linePool = [], _linePoolLength = 0,
    _sprite, _spriteCount, _spritePool = [], _spritePoolLength = 0,

    _renderData = { objects: [], lights: [], elements: [] },

    _vA = new THREE.Vector3(),
    _vB = new THREE.Vector3(),
    _vC = new THREE.Vector3(),

    _vector3 = new THREE.Vector3(),
    _vector4 = new THREE.Vector4(),

    _clipBox = new THREE.Box3( new THREE.Vector3( - 1, - 1, - 1 ), new THREE.Vector3( 1, 1, 1 ) ),
    _boundingBox = new THREE.Box3(),
    _pnts3 = new Array( 3 ),
    _pnts4 = new Array( 4 ),

    _viewMatrix = new THREE.Matrix4(),
    _viewProjectionMatrix = new THREE.Matrix4(),

    _modelMatrix,
    _modelViewProjectionMatrix = new THREE.Matrix4(),

    _normalMatrix = new THREE.Matrix3(),

    _frustum = new THREE.Frustum(),

    _clippedVertex1PositionScreen = new THREE.Vector4(),
    _clippedVertex2PositionScreen = new THREE.Vector4();

    //

    this.projectVector = function ( vector, camera ) {

        console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
        vector.project( camera );

    };

    this.unprojectVector = function ( vector, camera ) {

        console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
        vector.unproject( camera );

    };

    this.pkRay = function ( vector, camera ) {

        console.error( 'THREE.Projector: .pkRay() is now raycaster.setFromCamera().' );

    };

    //

    var RenderList = function () {

        var normals = [];
        var uvs = [];

        var object = null;
        var material = null;

        var normalMatrix = new THREE.Matrix3();

        var setObject = function ( value ) {

            object = value;
            material = object.material;

            normalMatrix.getNormalMatrix( object.matrixWorld );

            normals.length = 0;
            uvs.length = 0;

        };

        var projectVertex = function ( vertex ) {

            var position = vertex.position;
            var positionWorld = vertex.positionWorld;
            var positionScreen = vertex.positionScreen;

            positionWorld.copy( position ).applyMatrix4( _modelMatrix );
            positionScreen.copy( positionWorld ).applyMatrix4( _viewProjectionMatrix );

            var invW = 1 / positionScreen.w;

            positionScreen.x *= invW;
            positionScreen.y *= invW;
            positionScreen.z *= invW;

            vertex.visible = positionScreen.x >= - 1 && positionScreen.x <= 1 &&
                     positionScreen.y >= - 1 && positionScreen.y <= 1 &&
                     positionScreen.z >= - 1 && positionScreen.z <= 1;

        };

        var pushVertex = function ( x, y, z ) {

            _vertex = getNextVertexInPool();
            _vertex.position.set( x, y, z );

            projectVertex( _vertex );

        };

        var pushNormal = function ( x, y, z ) {

            normals.push( x, y, z );

        };

        var pushUv = function ( x, y ) {

            uvs.push( x, y );

        };

        var checkTriangleVisibility = function ( v1, v2, v3 ) {

            if ( v1.visible === true || v2.visible === true || v3.visible === true ) return true;

            _pnts3[ 0 ] = v1.positionScreen;
            _pnts3[ 1 ] = v2.positionScreen;
            _pnts3[ 2 ] = v3.positionScreen;

            return _clipBox.isIntersectionBox( _boundingBox.setFromPoints( _pnts3 ) );

        };

        var checkBackfaceCulling = function ( v1, v2, v3 ) {

            return ( ( v3.positionScreen.x - v1.positionScreen.x ) *
                    ( v2.positionScreen.y - v1.positionScreen.y ) -
                    ( v3.positionScreen.y - v1.positionScreen.y ) *
                    ( v2.positionScreen.x - v1.positionScreen.x ) ) < 0;

        };

        var pushLine = function ( a, b ) {

            var v1 = _vertexPool[ a ];
            var v2 = _vertexPool[ b ];

            _line = getNextLineInPool();

            _line.id = object.id;
            _line.v1.copy( v1 );
            _line.v2.copy( v2 );
            _line.z = ( v1.positionScreen.z + v2.positionScreen.z ) / 2;

            _line.material = object.material;

            _renderData.elements.push( _line );

        };

        var pushTriangle = function ( a, b, c ) {

            var v1 = _vertexPool[ a ];
            var v2 = _vertexPool[ b ];
            var v3 = _vertexPool[ c ];

            if ( checkTriangleVisibility( v1, v2, v3 ) === false ) return;

            if ( material.side === THREE.DoubleSide || checkBackfaceCulling( v1, v2, v3 ) === true ) {

                _face = getNextFaceInPool();

                _face.id = object.id;
                _face.v1.copy( v1 );
                _face.v2.copy( v2 );
                _face.v3.copy( v3 );
                _face.z = ( v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z ) / 3;

                for ( var i = 0; i < 3; i ++ ) {

                    var offset = arguments[ i ] * 3;
                    var normal = _face.vertexNormalsModel[ i ];

                    normal.set( normals[ offset ], normals[ offset + 1 ], normals[ offset + 2 ] );
                    normal.applyMatrix3( normalMatrix ).normalize();

                    var offset2 = arguments[ i ] * 2;

                    var uv = _face.uvs[ i ];
                    uv.set( uvs[ offset2 ], uvs[ offset2 + 1 ] );

                }

                _face.vertexNormalsLength = 3;

                _face.material = object.material;

                _renderData.elements.push( _face );

            }

        };

        return {
            setObject: setObject,
            projectVertex: projectVertex,
            checkTriangleVisibility: checkTriangleVisibility,
            checkBackfaceCulling: checkBackfaceCulling,
            pushVertex: pushVertex,
            pushNormal: pushNormal,
            pushUv: pushUv,
            pushLine: pushLine,
            pushTriangle: pushTriangle
        }

    };

    var renderList = new RenderList();

    this.projectScene = function ( scene, camera, sortObjects, sortElements ) {

        _faceCount = 0;
        _lineCount = 0;
        _spriteCount = 0;

        _renderData.elements.length = 0;

        if ( scene.autoUpdate === true ) scene.updateMatrixWorld();
        if ( camera.parent === undefined ) camera.updateMatrixWorld();

        _viewMatrix.copy( camera.matrixWorldInverse.getInverse( camera.matrixWorld ) );
        _viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, _viewMatrix );

        _frustum.setFromMatrix( _viewProjectionMatrix );

        //

        _objectCount = 0;

        _renderData.objects.length = 0;
        _renderData.lights.length = 0;

        scene.traverseVisible( function ( object ) {

            if ( object instanceof THREE.Light ) {

                _renderData.lights.push( object );

            } else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Sprite ) {

                if ( object.material.visible === false ) return;

                if ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {

                    _object = getNextObjectInPool();
                    _object.id = object.id;
                    _object.object = object;

                    _vector3.setFromMatrixPosition( object.matrixWorld );
                    _vector3.applyProjection( _viewProjectionMatrix );
                    _object.z = _vector3.z;

                    _renderData.objects.push( _object );

                }

            }

        } );

        if ( sortObjects === true ) {

            _renderData.objects.sort( painterSort );

        }

        //

        for ( var o = 0, ol = _renderData.objects.length; o < ol; o ++ ) {

            var object = _renderData.objects[ o ].object;
            var geometry = object.geometry;

            renderList.setObject( object );

            _modelMatrix = object.matrixWorld;

            _vertexCount = 0;

            if ( object instanceof THREE.Mesh ) {

                if ( geometry instanceof THREE.BufferGeometry ) {

                    var attributes = geometry.attributes;
                    var offsets = geometry.offsets;

                    if ( attributes.position === undefined ) continue;

                    var positions = attributes.position.array;

                    for ( var i = 0, l = positions.length; i < l; i += 3 ) {

                        renderList.pushVertex( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );

                    }

                    if ( attributes.normal !== undefined ) {

                        var normals = attributes.normal.array;

                        for ( var i = 0, l = normals.length; i < l; i += 3 ) {

                            renderList.pushNormal( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] );

                        }

                    }

                    if ( attributes.uv !== undefined ) {

                        var uvs = attributes.uv.array;

                        for ( var i = 0, l = uvs.length; i < l; i += 2 ) {

                            renderList.pushUv( uvs[ i ], uvs[ i + 1 ] );

                        }

                    }

                    if ( attributes.index !== undefined ) {

                        var indices = attributes.index.array;

                        if ( offsets.length > 0 ) {

                            for ( var o = 0; o < offsets.length; o ++ ) {

                                var offset = offsets[ o ];
                                var index = offset.index;

                                for ( var i = offset.start, l = offset.start + offset.count; i < l; i += 3 ) {

                                    renderList.pushTriangle( indices[ i ] + index, indices[ i + 1 ] + index, indices[ i + 2 ] + index );

                                }

                            }

                        } else {

                            for ( var i = 0, l = indices.length; i < l; i += 3 ) {

                                renderList.pushTriangle( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

                            }

                        }

                    } else {

                        for ( var i = 0, l = positions.length / 3; i < l; i += 3 ) {

                            renderList.pushTriangle( i, i + 1, i + 2 );

                        }

                    }

                } else if ( geometry instanceof THREE.Geometry ) {

                    var vertices = geometry.vertices;
                    var faces = geometry.faces;
                    var faceVertexUvs = geometry.faceVertexUvs[ 0 ];

                    _normalMatrix.getNormalMatrix( _modelMatrix );

                    var isFaceMaterial = object.material instanceof THREE.MeshFaceMaterial;
                    var objectMaterials = isFaceMaterial === true ? object.material : null;

                    for ( var v = 0, vl = vertices.length; v < vl; v ++ ) {

                        var vertex = vertices[ v ];
                        renderList.pushVertex( vertex.x, vertex.y, vertex.z );

                    }

                    for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

                        var face = faces[ f ];

                        var material = isFaceMaterial === true
                             ? objectMaterials.materials[ face.materialIndex ]
                             : object.material;

                        if ( material === undefined ) continue;

                        var side = material.side;

                        var v1 = _vertexPool[ face.a ];
                        var v2 = _vertexPool[ face.b ];
                        var v3 = _vertexPool[ face.c ];

                        if ( material.morphTargets === true ) {

                            var morphTargets = geometry.morphTargets;
                            var morphInfluences = object.morphTargetInfluences;

                            var v1p = v1.position;
                            var v2p = v2.position;
                            var v3p = v3.position;

                            _vA.set( 0, 0, 0 );
                            _vB.set( 0, 0, 0 );
                            _vC.set( 0, 0, 0 );

                            for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

                                var influence = morphInfluences[ t ];

                                if ( influence === 0 ) continue;

                                var targets = morphTargets[ t ].vertices;

                                _vA.x += ( targets[ face.a ].x - v1p.x ) * influence;
                                _vA.y += ( targets[ face.a ].y - v1p.y ) * influence;
                                _vA.z += ( targets[ face.a ].z - v1p.z ) * influence;

                                _vB.x += ( targets[ face.b ].x - v2p.x ) * influence;
                                _vB.y += ( targets[ face.b ].y - v2p.y ) * influence;
                                _vB.z += ( targets[ face.b ].z - v2p.z ) * influence;

                                _vC.x += ( targets[ face.c ].x - v3p.x ) * influence;
                                _vC.y += ( targets[ face.c ].y - v3p.y ) * influence;
                                _vC.z += ( targets[ face.c ].z - v3p.z ) * influence;

                            }

                            v1.position.add( _vA );
                            v2.position.add( _vB );
                            v3.position.add( _vC );

                            renderList.projectVertex( v1 );
                            renderList.projectVertex( v2 );
                            renderList.projectVertex( v3 );

                        }

                        if ( renderList.checkTriangleVisibility( v1, v2, v3 ) === false ) continue;

                        var visible = renderList.checkBackfaceCulling( v1, v2, v3 );

                        if ( side !== THREE.DoubleSide ) {
                            if ( side === THREE.FrontSide && visible === false ) continue;
                            if ( side === THREE.BackSide && visible === true ) continue;
                        }

                        _face = getNextFaceInPool();

                        _face.id = object.id;
                        _face.v1.copy( v1 );
                        _face.v2.copy( v2 );
                        _face.v3.copy( v3 );

                        _face.normalModel.copy( face.normal );

                        if ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {

                            _face.normalModel.negate();

                        }

                        _face.normalModel.applyMatrix3( _normalMatrix ).normalize();

                        var faceVertexNormals = face.vertexNormals;

                        for ( var n = 0, nl = Math.min( faceVertexNormals.length, 3 ); n < nl; n ++ ) {

                            var normalModel = _face.vertexNormalsModel[ n ];
                            normalModel.copy( faceVertexNormals[ n ] );

                            if ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {

                                normalModel.negate();

                            }

                            normalModel.applyMatrix3( _normalMatrix ).normalize();

                        }

                        _face.vertexNormalsLength = faceVertexNormals.length;

                        var vertexUvs = faceVertexUvs[ f ];

                        if ( vertexUvs !== undefined ) {

                            for ( var u = 0; u < 3; u ++ ) {

                                _face.uvs[ u ].copy( vertexUvs[ u ] );

                            }

                        }

                        _face.color = face.color;
                        _face.material = material;

                        _face.z = ( v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z ) / 3;

                        _renderData.elements.push( _face );

                    }

                }

            } else if ( object instanceof THREE.Line ) {

                if ( geometry instanceof THREE.BufferGeometry ) {

                    var attributes = geometry.attributes;

                    if ( attributes.position !== undefined ) {

                        var positions = attributes.position.array;

                        for ( var i = 0, l = positions.length; i < l; i += 3 ) {

                            renderList.pushVertex( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );

                        }

                        if ( attributes.index !== undefined ) {

                            var indices = attributes.index.array;

                            for ( var i = 0, l = indices.length; i < l; i += 2 ) {

                                renderList.pushLine( indices[ i ], indices[ i + 1 ] );

                            }

                        } else {

                            var step = object.mode === THREE.LinePieces ? 2 : 1;

                            for ( var i = 0, l = ( positions.length / 3 ) - 1; i < l; i += step ) {

                                renderList.pushLine( i, i + 1 );

                            }

                        }

                    }

                } else if ( geometry instanceof THREE.Geometry ) {

                    _modelViewProjectionMatrix.multiplyMatrices( _viewProjectionMatrix, _modelMatrix );

                    var vertices = object.geometry.vertices;

                    if ( vertices.length === 0 ) continue;

                    v1 = getNextVertexInPool();
                    v1.positionScreen.copy( vertices[ 0 ] ).applyMatrix4( _modelViewProjectionMatrix );

                    // Handle LineStrip and LinePieces
                    var step = object.mode === THREE.LinePieces ? 2 : 1;

                    for ( var v = 1, vl = vertices.length; v < vl; v ++ ) {

                        v1 = getNextVertexInPool();
                        v1.positionScreen.copy( vertices[ v ] ).applyMatrix4( _modelViewProjectionMatrix );

                        if ( ( v + 1 ) % step > 0 ) continue;

                        v2 = _vertexPool[ _vertexCount - 2 ];

                        _clippedVertex1PositionScreen.copy( v1.positionScreen );
                        _clippedVertex2PositionScreen.copy( v2.positionScreen );

                        if ( clipLine( _clippedVertex1PositionScreen, _clippedVertex2PositionScreen ) === true ) {

                            // Perform the perspective divide
                            _clippedVertex1PositionScreen.multiplyScalar( 1 / _clippedVertex1PositionScreen.w );
                            _clippedVertex2PositionScreen.multiplyScalar( 1 / _clippedVertex2PositionScreen.w );

                            _line = getNextLineInPool();

                            _line.id = object.id;
                            _line.v1.positionScreen.copy( _clippedVertex1PositionScreen );
                            _line.v2.positionScreen.copy( _clippedVertex2PositionScreen );

                            _line.z = Math.max( _clippedVertex1PositionScreen.z, _clippedVertex2PositionScreen.z );

                            _line.material = object.material;

                            if ( object.material.vertexColors === THREE.VertexColors ) {

                                _line.vertexColors[ 0 ].copy( object.geometry.colors[ v ] );
                                _line.vertexColors[ 1 ].copy( object.geometry.colors[ v - 1 ] );

                            }

                            _renderData.elements.push( _line );

                        }

                    }

                }

            } else if ( object instanceof THREE.Sprite ) {

                _vector4.set( _modelMatrix.elements[ 12 ], _modelMatrix.elements[ 13 ], _modelMatrix.elements[ 14 ], 1 );
                _vector4.applyMatrix4( _viewProjectionMatrix );

                var invW = 1 / _vector4.w;

                _vector4.z *= invW;

                if ( _vector4.z >= - 1 && _vector4.z <= 1 ) {

                    _sprite = getNextSpriteInPool();
                    _sprite.id = object.id;
                    _sprite.x = _vector4.x * invW;
                    _sprite.y = _vector4.y * invW;
                    _sprite.z = _vector4.z;
                    _sprite.object = object;

                    _sprite.rotation = object.rotation;

                    _sprite.scale.x = object.scale.x * Math.abs( _sprite.x - ( _vector4.x + camera.projectionMatrix.elements[ 0 ] ) / ( _vector4.w + camera.projectionMatrix.elements[ 12 ] ) );
                    _sprite.scale.y = object.scale.y * Math.abs( _sprite.y - ( _vector4.y + camera.projectionMatrix.elements[ 5 ] ) / ( _vector4.w + camera.projectionMatrix.elements[ 13 ] ) );

                    _sprite.material = object.material;

                    _renderData.elements.push( _sprite );

                }

            }

        }

        if ( sortElements === true ) {

            _renderData.elements.sort( painterSort );

        }

        return _renderData;

    };

    // Pools

    function getNextObjectInPool() {

        if ( _objectCount === _objectPoolLength ) {

            var object = new THREE.RenderableObject();
            _objectPool.push( object );
            _objectPoolLength ++;
            _objectCount ++;
            return object;

        }

        return _objectPool[ _objectCount ++ ];

    }

    function getNextVertexInPool() {

        if ( _vertexCount === _vertexPoolLength ) {

            var vertex = new THREE.RenderableVertex();
            _vertexPool.push( vertex );
            _vertexPoolLength ++;
            _vertexCount ++;
            return vertex;

        }

        return _vertexPool[ _vertexCount ++ ];

    }

    function getNextFaceInPool() {

        if ( _faceCount === _facePoolLength ) {

            var face = new THREE.RenderableFace();
            _facePool.push( face );
            _facePoolLength ++;
            _faceCount ++;
            return face;

        }

        return _facePool[ _faceCount ++ ];


    }

    function getNextLineInPool() {

        if ( _lineCount === _linePoolLength ) {

            var line = new THREE.RenderableLine();
            _linePool.push( line );
            _linePoolLength ++;
            _lineCount ++
            return line;

        }

        return _linePool[ _lineCount ++ ];

    }

    function getNextSpriteInPool() {

        if ( _spriteCount === _spritePoolLength ) {

            var sprite = new THREE.RenderableSprite();
            _spritePool.push( sprite );
            _spritePoolLength ++;
            _spriteCount ++
            return sprite;

        }

        return _spritePool[ _spriteCount ++ ];

    }

    //

    function painterSort( a, b ) {

        if ( a.z !== b.z ) {

            return b.z - a.z;

        } else if ( a.id !== b.id ) {

            return a.id - b.id;

        } else {

            return 0;

        }

    }

    function clipLine( s1, s2 ) {

        var alpha1 = 0, alpha2 = 1,

        // Calculate the boundary coordinate of each vertex for the near and far clip planes,
        // Z = -1 and Z = +1, respectively.
        bc1near =  s1.z + s1.w,
        bc2near =  s2.z + s2.w,
        bc1far =  - s1.z + s1.w,
        bc2far =  - s2.z + s2.w;

        if ( bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0 ) {

            // Both vertices lie entirely within all clip planes.
            return true;

        } else if ( ( bc1near < 0 && bc2near < 0 ) || ( bc1far < 0 && bc2far < 0 ) ) {

            // Both vertices lie entirely outside one of the clip planes.
            return false;

        } else {

            // The line segment spans at least one clip plane.

            if ( bc1near < 0 ) {

                // v1 lies outside the near plane, v2 inside
                alpha1 = Math.max( alpha1, bc1near / ( bc1near - bc2near ) );

            } else if ( bc2near < 0 ) {

                // v2 lies outside the near plane, v1 inside
                alpha2 = Math.min( alpha2, bc1near / ( bc1near - bc2near ) );

            }

            if ( bc1far < 0 ) {

                // v1 lies outside the far plane, v2 inside
                alpha1 = Math.max( alpha1, bc1far / ( bc1far - bc2far ) );

            } else if ( bc2far < 0 ) {

                // v2 lies outside the far plane, v2 inside
                alpha2 = Math.min( alpha2, bc1far / ( bc1far - bc2far ) );

            }

            if ( alpha2 < alpha1 ) {

                // The line segment spans two boundaries, but is outside both of them.
                // (This can't happen when we're only clipping against just near/far but good
                //  to leave the check here for future usage if other clip planes are added.)
                return false;

            } else {

                // Update the s1 and s2 vertices to match the clipped line segment.
                s1.lerp( s2, alpha1 );
                s2.lerp( s1, 1 - alpha2 );

                return true;

            }

        }

    }

};

!function(r,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t(r.MMTF=r.MMTF||{})}(this,function(r){"use strict";function t(r,t,n){for(var e=(r.byteLength,0),i=n.length;i>e;e++){var o=n.charCodeAt(e);if(128>o)r.setUint8(t++,o>>>0&127|0);else if(2048>o)r.setUint8(t++,o>>>6&31|192),r.setUint8(t++,o>>>0&63|128);else if(65536>o)r.setUint8(t++,o>>>12&15|224),r.setUint8(t++,o>>>6&63|128),r.setUint8(t++,o>>>0&63|128);else{if(!(1114112>o))throw new Error("bad codepoint "+o);r.setUint8(t++,o>>>18&7|240),r.setUint8(t++,o>>>12&63|128),r.setUint8(t++,o>>>6&63|128),r.setUint8(t++,o>>>0&63|128)}}}function n(r){for(var t=0,n=0,e=r.length;e>n;n++){var i=r.charCodeAt(n);if(128>i)t+=1;else if(2048>i)t+=2;else if(65536>i)t+=3;else{if(!(1114112>i))throw new Error("bad codepoint "+i);t+=4}}return t}function e(r,i,o){var a=typeof r;if("string"===a){var u=n(r);if(32>u)return i.setUint8(o,160|u),t(i,o+1,r),1+u;if(256>u)return i.setUint8(o,217),i.setUint8(o+1,u),t(i,o+2,r),2+u;if(65536>u)return i.setUint8(o,218),i.setUint16(o+1,u),t(i,o+3,r),3+u;if(4294967296>u)return i.setUint8(o,219),i.setUint32(o+1,u),t(i,o+5,r),5+u}if(r instanceof Uint8Array){var u=r.byteLength,s=new Uint8Array(i.buffer);if(256>u)return i.setUint8(o,196),i.setUint8(o+1,u),s.set(r,o+2),2+u;if(65536>u)return i.setUint8(o,197),i.setUint16(o+1,u),s.set(r,o+3),3+u;if(4294967296>u)return i.setUint8(o,198),i.setUint32(o+1,u),s.set(r,o+5),5+u}if("number"===a){if(!isFinite(r))throw new Error("Number not finite: "+r);if(Math.floor(r)!==r)return i.setUint8(o,203),i.setFloat64(o+1,r),9;if(r>=0){if(128>r)return i.setUint8(o,r),1;if(256>r)return i.setUint8(o,204),i.setUint8(o+1,r),2;if(65536>r)return i.setUint8(o,205),i.setUint16(o+1,r),3;if(4294967296>r)return i.setUint8(o,206),i.setUint32(o+1,r),5;throw new Error("Number too big 0x"+r.toString(16))}if(r>=-32)return i.setInt8(o,r),1;if(r>=-128)return i.setUint8(o,208),i.setInt8(o+1,r),2;if(r>=-32768)return i.setUint8(o,209),i.setInt16(o+1,r),3;if(r>=-2147483648)return i.setUint8(o,210),i.setInt32(o+1,r),5;throw new Error("Number too small -0x"+(-r).toString(16).substr(1))}if(null===r)return i.setUint8(o,192),1;if("boolean"===a)return i.setUint8(o,r?195:194),1;if("object"===a){var u,f=0,c=Array.isArray(r);if(c)u=r.length;else{var d=Object.keys(r);u=d.length}var f;if(16>u?(i.setUint8(o,u|(c?144:128)),f=1):65536>u?(i.setUint8(o,c?220:222),i.setUint16(o+1,u),f=3):4294967296>u&&(i.setUint8(o,c?221:223),i.setUint32(o+1,u),f=5),c)for(var l=0;u>l;l++)f+=e(r[l],i,o+f);else for(var l=0;u>l;l++){var g=d[l];f+=e(g,i,o+f),f+=e(r[g],i,o+f)}return f}throw new Error("Unknown type "+a)}function i(r){var t=typeof r;if("string"===t){var e=n(r);if(32>e)return 1+e;if(256>e)return 2+e;if(65536>e)return 3+e;if(4294967296>e)return 5+e}if(r instanceof Uint8Array){var e=r.byteLength;if(256>e)return 2+e;if(65536>e)return 3+e;if(4294967296>e)return 5+e}if("number"===t){if(Math.floor(r)!==r)return 9;if(r>=0){if(128>r)return 1;if(256>r)return 2;if(65536>r)return 3;if(4294967296>r)return 5;throw new Error("Number too big 0x"+r.toString(16))}if(r>=-32)return 1;if(r>=-128)return 2;if(r>=-32768)return 3;if(r>=-2147483648)return 5;throw new Error("Number too small -0x"+r.toString(16).substr(1))}if("boolean"===t||null===r)return 1;if("object"===t){var e,o=0;if(Array.isArray(r)){e=r.length;for(var a=0;e>a;a++)o+=i(r[a])}else{var u=Object.keys(r);e=u.length;for(var a=0;e>a;a++){var s=u[a];o+=i(s)+i(r[s])}}if(16>e)return 1+o;if(65536>e)return 3+o;if(4294967296>e)return 5+o;throw new Error("Array or object too long 0x"+e.toString(16))}throw new Error("Unknown type "+t)}function o(r){var t=new ArrayBuffer(i(r)),n=new DataView(t);return e(r,n,0),new Uint8Array(t)}function a(r,t,n){return t?new r(t.buffer,t.byteOffset,t.byteLength/(n||1)):void 0}function u(r){return a(DataView,r)}function s(r){return a(Uint8Array,r)}function f(r){return a(Int8Array,r)}function c(r){return a(Int32Array,r,4)}function d(r){return a(Float32Array,r,4)}function l(r,t){var n=r.length/2;t||(t=new Int16Array(n));for(var e=0,i=0;n>e;++e,i+=2)t[e]=r[i]<<8^r[i+1]<<0;return t}function g(r,t){var n=r.length;t||(t=new Uint8Array(2*n));for(var e=u(t),i=0;n>i;++i)e.setInt16(2*i,r[i]);return s(t)}function v(r,t){var n=r.length/4;t||(t=new Int32Array(n));for(var e=0,i=0;n>e;++e,i+=4)t[e]=r[i]<<24^r[i+1]<<16^r[i+2]<<8^r[i+3]<<0;return t}function L(r,t){var n=r.length;t||(t=new Uint8Array(4*n));for(var e=u(t),i=0;n>i;++i)e.setInt32(4*i,r[i]);return s(t)}function h(r,t){var n=r.length;t||(t=new Float32Array(n/4));for(var e=u(t),i=u(r),o=0,a=0,s=n/4;s>o;++o,a+=4)e.setFloat32(a,i.getFloat32(a),!0);return t}function y(r,t,n){var e=r.length,i=1/t;n||(n=new Float32Array(e));for(var o=0;e>o;++o)n[o]=r[o]*i;return n}function m(r,t,n){var e=r.length;n||(n=new Int32Array(e));for(var i=0;e>i;++i)n[i]=Math.round(r[i]*t);return n}function p(r,t){var n,e;if(!t){var i=0;for(n=0,e=r.length;e>n;n+=2)i+=r[n+1];t=new r.constructor(i)}var o=0;for(n=0,e=r.length;e>n;n+=2)for(var a=r[n],u=r[n+1],s=0;u>s;++s)t[o]=a,++o;return t}function U(r){if(0===r.length)return new Int32Array;var t,n,e=2;for(t=1,n=r.length;n>t;++t)r[t-1]!==r[t]&&(e+=2);var i=new Int32Array(e),o=0,a=1;for(t=1,n=r.length;n>t;++t)r[t-1]!==r[t]?(i[o]=r[t-1],i[o+1]=a,a=1,o+=2):++a;return i[o]=r[r.length-1],i[o+1]=a,i}function b(r,t){var n=r.length;t||(t=new r.constructor(n)),n&&(t[0]=r[0]);for(var e=1;n>e;++e)t[e]=r[e]+t[e-1];return t}function I(r,t){var n=r.length;t||(t=new r.constructor(n)),t[0]=r[0];for(var e=1;n>e;++e)t[e]=r[e]-r[e-1];return t}function w(r,t){var n,e,i=r instanceof Int8Array?127:32767,o=-i-1,a=r.length;if(!t){var u=0;for(n=0;a>n;++n)r[n]<i&&r[n]>o&&++u;t=new Int32Array(u)}for(n=0,e=0;a>n;){for(var s=0;r[n]===i||r[n]===o;)s+=r[n],++n;s+=r[n],++n,t[e]=s,++e}return t}function C(r,t){var n,e=t?127:32767,i=-e-1,o=r.length,a=0;for(n=0;o>n;++n){var u=r[n];0===u?++a:u>0?(a+=Math.ceil(u/e),u%e===0&&(a+=1)):(a+=Math.ceil(u/i),u%i===0&&(a+=1))}var s=t?new Int8Array(a):new Int16Array(a),f=0;for(n=0;o>n;++n){var u=r[n];if(u>=0)for(;u>=e;)s[f]=e,++f,u-=e;else for(;i>=u;)s[f]=i,++f,u-=i;s[f]=u,++f}return s}function A(r,t){return b(p(r),t)}function x(r){return U(I(r))}function M(r,t,n){return y(p(r,c(n)),t,n)}function F(r,t){return U(m(r,t))}function S(r,t,n){return y(b(r,c(n)),t,n)}function E(r,t,n){return I(m(r,t),n)}function N(r,t,n){return y(w(r,c(n)),t,n)}function O(r,t,n){var e=w(r,c(n));return S(e,t,d(e))}function T(r,t,n){return C(E(r,t),n)}function k(r){var t=u(r),n=t.getInt32(0),e=t.getInt32(4),i=r.subarray(8,12),r=r.subarray(12);return[n,r,e,i]}function j(r,t,n,e){var i=new ArrayBuffer(12+e.byteLength),o=new Uint8Array(i),a=new DataView(i);return a.setInt32(0,r),a.setInt32(4,t),n&&o.set(n,8),o.set(e,12),o}function q(r){var t=r.length,n=s(r);return j(2,t,void 0,n)}function D(r){var t=r.length,n=L(r);return j(4,t,void 0,n)}function P(r,t){var n=r.length/t,e=L([t]),i=s(r);return j(5,n,e,i)}function z(r){var t=r.length,n=L(U(r));return j(6,t,void 0,n)}function B(r){var t=r.length,n=L(x(r));return j(8,t,void 0,n)}function V(r,t){var n=r.length,e=L([t]),i=L(F(r,t));return j(9,n,e,i)}function G(r,t){var n=r.length,e=L([t]),i=g(T(r,t));return j(10,n,e,i)}function R(r){var t={};return rr.forEach(function(n){void 0!==r[n]&&(t[n]=r[n])}),r.bondAtomList&&(t.bondAtomList=D(r.bondAtomList)),r.bondOrderList&&(t.bondOrderList=q(r.bondOrderList)),t.xCoordList=G(r.xCoordList,1e3),t.yCoordList=G(r.yCoordList,1e3),t.zCoordList=G(r.zCoordList,1e3),r.bFactorList&&(t.bFactorList=G(r.bFactorList,100)),r.atomIdList&&(t.atomIdList=B(r.atomIdList)),r.altLocList&&(t.altLocList=z(r.altLocList)),r.occupancyList&&(t.occupancyList=V(r.occupancyList,100)),t.groupIdList=B(r.groupIdList),t.groupTypeList=D(r.groupTypeList),r.secStructList&&(t.secStructList=q(r.secStructList)),r.insCodeList&&(t.insCodeList=z(r.insCodeList)),r.sequenceIndexList&&(t.sequenceIndexList=B(r.sequenceIndexList)),t.chainIdList=P(r.chainIdList,4),r.chainNameList&&(t.chainNameList=P(r.chainNameList,4)),t}function H(r){function t(r){for(var t={},n=0;r>n;n++){var e=o();t[e]=o()}return t}function n(t){var n=r.subarray(a,a+t);return a+=t,n}function e(t){var n=r.subarray(a,a+t);a+=t;var e=65535;if(t>e){for(var i=[],o=0;o<n.length;o+=e)i.push(String.fromCharCode.apply(null,n.subarray(o,o+e)));return i.join("")}return String.fromCharCode.apply(null,n)}function i(r){for(var t=new Array(r),n=0;r>n;n++)t[n]=o();return t}function o(){var o,s,f=r[a];if(0===(128&f))return a++,f;if(128===(240&f))return s=15&f,a++,t(s);if(144===(240&f))return s=15&f,a++,i(s);if(160===(224&f))return s=31&f,a++,e(s);if(224===(224&f))return o=u.getInt8(a),a++,o;switch(f){case 192:return a++,null;case 194:return a++,!1;case 195:return a++,!0;case 196:return s=u.getUint8(a+1),a+=2,n(s);case 197:return s=u.getUint16(a+1),a+=3,n(s);case 198:return s=u.getUint32(a+1),a+=5,n(s);case 202:return o=u.getFloat32(a+1),a+=5,o;case 203:return o=u.getFloat64(a+1),a+=9,o;case 204:return o=r[a+1],a+=2,o;case 205:return o=u.getUint16(a+1),a+=3,o;case 206:return o=u.getUint32(a+1),a+=5,o;case 208:return o=u.getInt8(a+1),a+=2,o;case 209:return o=u.getInt16(a+1),a+=3,o;case 210:return o=u.getInt32(a+1),a+=5,o;case 217:return s=u.getUint8(a+1),a+=2,e(s);case 218:return s=u.getUint16(a+1),a+=3,e(s);case 219:return s=u.getUint32(a+1),a+=5,e(s);case 220:return s=u.getUint16(a+1),a+=3,i(s);case 221:return s=u.getUint32(a+1),a+=5,i(s);case 222:return s=u.getUint16(a+1),a+=3,t(s);case 223:return s=u.getUint32(a+1),a+=5,t(s)}throw new Error("Unknown type 0x"+f.toString(16))}var a=0,u=new DataView(r.buffer);return o()}function W(r,t,n,e){switch(r){case 1:return h(t);case 2:return f(t);case 3:return l(t);case 4:return v(t);case 5:return s(t);case 6:return p(v(t),new Uint8Array(n));case 7:return p(v(t));case 8:return A(v(t));case 9:return M(v(t),v(e)[0]);case 10:return O(l(t),v(e)[0]);case 11:return y(l(t),v(e)[0]);case 12:return N(l(t),v(e)[0]);case 13:return N(f(t),v(e)[0]);case 14:return w(l(t));case 15:return w(f(t))}}function X(r,t){t=t||{};var n=t.ignoreFields,e={};return nr.forEach(function(t){var i=n?-1!==n.indexOf(t):!1,o=r[t];i||void 0===o||(o instanceof Uint8Array?e[t]=W.apply(null,k(o)):e[t]=o)}),e}function J(r){return String.fromCharCode.apply(null,r).replace(/\0/g,"")}function K(r,t,n){n=n||{};var e,i,o,a,u,s,f=n.firstModelOnly,c=t.onModel,d=t.onChain,l=t.onGroup,g=t.onAtom,v=t.onBond,L=0,h=0,y=0,m=0,p=0,U=-1,b=r.chainNameList,I=r.secStructList,w=r.insCodeList,C=r.sequenceIndexList,A=r.atomIdList,x=r.bFactorList,M=r.altLocList,F=r.occupancyList,S=r.bondAtomList,E=r.bondOrderList;for(e=0,i=r.chainsPerModel.length;i>e&&!(f&&L>0);++e){var N=r.chainsPerModel[L];for(c&&c({chainCount:N,modelIndex:L}),o=0;N>o;++o){var O=r.groupsPerChain[h];if(d){var T=J(r.chainIdList.subarray(4*h,4*h+4)),k=null;b&&(k=J(b.subarray(4*h,4*h+4))),d({groupCount:O,chainIndex:h,modelIndex:L,chainId:T,chainName:k})}for(a=0;O>a;++a){var j=r.groupList[r.groupTypeList[y]],q=j.atomNameList.length;if(l){var D=null;I&&(D=I[y]);var P=null;r.insCodeList&&(P=String.fromCharCode(w[y]));var z=null;C&&(z=C[y]),l({atomCount:q,groupIndex:y,chainIndex:h,modelIndex:L,groupId:r.groupIdList[y],groupType:r.groupTypeList[y],groupName:j.groupName,singleLetterCode:j.singleLetterCode,chemCompType:j.chemCompType,secStruct:D,insCode:P,sequenceIndex:z})}for(u=0;q>u;++u){if(g){var B=null;A&&(B=A[m]);var V=null;x&&(V=x[m]);var G=null;M&&(G=String.fromCharCode(M[m]));var R=null;F&&(R=F[m]),g({atomIndex:m,groupIndex:y,chainIndex:h,modelIndex:L,atomId:B,element:j.elementList[u],atomName:j.atomNameList[u],formalCharge:j.formalChargeList[u],xCoord:r.xCoordList[m],yCoord:r.yCoordList[m],zCoord:r.zCoordList[m],bFactor:V,altLoc:G,occupancy:R})}m+=1}if(v){var H=j.bondAtomList;for(u=0,s=j.bondOrderList.length;s>u;++u)v({atomIndex1:m-q+H[2*u],atomIndex2:m-q+H[2*u+1],bondOrder:j.bondOrderList[u]})}y+=1}h+=1}if(p=U+1,U=m-1,v&&S)for(u=0,s=S.length;s>u;u+=2){var W=S[u],X=S[u+1];(W>=p&&U>=W||X>=p&&U>=X)&&v({atomIndex1:W,atomIndex2:X,bondOrder:E?E[u/2]:null})}L+=1}}function Q(r){return o(R(r))}function Y(r,t){r instanceof ArrayBuffer&&(r=new Uint8Array(r));var n;return n=r instanceof Uint8Array?H(r):r,X(n,t)}function Z(r,t,n,e){function i(){try{var r=Y(o.response);n(r)}catch(t){e(t)}}var o=new XMLHttpRequest;o.addEventListener("load",i,!0),o.addEventListener("error",e,!0),o.responseType="arraybuffer",o.open("GET",t+r.toUpperCase()),o.send()}function $(r,t,n){Z(r,or,t,n)}function _(r,t,n){Z(r,ar,t,n)}var rr=["mmtfVersion","mmtfProducer","unitCell","spaceGroup","structureId","title","depositionDate","releaseDate","experimentalMethods","resolution","rFree","rWork","bioAssemblyList","ncsOperatorList","entityList","groupList","numBonds","numAtoms","numGroups","numChains","numModels","groupsPerChain","chainsPerModel"],tr=["xCoordList","yCoordList","zCoordList","groupIdList","groupTypeList","chainIdList","bFactorList","atomIdList","altLocList","occupancyList","secStructList","insCodeList","sequenceIndexList","chainNameList","bondAtomList","bondOrderList"],nr=rr.concat(tr),er="v1.0.1",ir="//mmtf.rcsb.org/v1.0/",or=ir+"full/",ar=ir+"reduced/";r.encode=Q,r.decode=Y,r.traverse=K,r.fetch=$,r.fetchReduced=_,r.version=er,r.fetchUrl=or,r.fetchReducedUrl=ar,r.encodeMsgpack=o,r.encodeMmtf=R,r.decodeMsgpack=H,r.decodeMmtf=X});
var $NGL_shaderTextHash = {};

$NGL_shaderTextHash['SphereImpostor.frag'] = ["#define STANDARD",
"#define IMPOSTOR",
"",
"uniform vec3 diffuse;",
"uniform vec3 emissive;",
"uniform float roughness;",
"uniform float metalness;",
"uniform float opacity;",
"uniform float nearClip;",
"uniform mat4 projectionMatrix;",
"uniform float ortho;",
"",
"varying float vRadius;",
"varying float vRadiusSq;",
"varying vec3 vPoint;",
"varying vec3 vPointViewPosition;",
"",
"#ifdef PICKING",
"    uniform float objectId;",
"    varying vec3 vPickingColor;",
"#else",
"    #include common",
"    #include color_pars_fragment",
"    #include fog_pars_fragment",
"    #include bsdfs",
"    #include lights_pars_begin",
"    #include lights_physical_pars_fragment",
"#endif",
"",
"bool flag2 = false;",
"bool interior = false;",
"vec3 cameraPos;",
"vec3 cameraNormal;",
"",
"// Calculate depth based on the given camera position.",
"float calcDepth( in vec3 cameraPos ){",
"    vec2 clipZW = cameraPos.z * projectionMatrix[2].zw + projectionMatrix[3].zw;",
"    return 0.5 + 0.5 * clipZW.x / clipZW.y;",
"}",
"",
"float calcClip( vec3 cameraPos ){",
"    return dot( vec4( cameraPos, 1.0 ), vec4( 0.0, 0.0, 1.0, nearClip - 0.5 ) );",
"}",
"",
"bool Impostor( out vec3 cameraPos, out vec3 cameraNormal ){",
"",
"    vec3 cameraSpherePos = -vPointViewPosition;",
"    cameraSpherePos.z += vRadius;",
"",
"    vec3 rayOrigin = mix( vec3( 0.0, 0.0, 0.0 ), vPoint, ortho );",
"    vec3 rayDirection = mix( normalize( vPoint ), vec3( 0.0, 0.0, 1.0 ), ortho );",
"    vec3 cameraSphereDir = mix( cameraSpherePos, rayOrigin - cameraSpherePos, ortho );",
"",
"    float B = dot( rayDirection, cameraSphereDir );",
"    float det = B * B + vRadiusSq - dot( cameraSphereDir, cameraSphereDir );",
"",
"    if( det < 0.0 ){",
"        discard;",
"        return false;",
"    }",
"        float sqrtDet = sqrt( det );",
"        float posT = mix( B + sqrtDet, B + sqrtDet, ortho );",
"        float negT = mix( B - sqrtDet, sqrtDet - B, ortho );",
"",
"        cameraPos = rayDirection * negT + rayOrigin;",
"",
"        #ifdef NEAR_CLIP",
"if( calcDepth( cameraPos ) <= 0.0 ){",
"    cameraPos = rayDirection * posT + rayOrigin;",
"    interior = true;",
"    return false;",
"}else if( calcClip( cameraPos ) > 0.0 ){",
"    cameraPos = rayDirection * posT + rayOrigin;",
"    interior = true;",
"    flag2 = true;",
"    return false;",
"}else{",
"    cameraNormal = normalize( cameraPos - cameraSpherePos );",
"}",
"        #else",
"if( calcDepth( cameraPos ) <= 0.0 ){",
"    cameraPos = rayDirection * posT + rayOrigin;",
"    interior = true;",
"    return false;",
"}else{",
"    cameraNormal = normalize( cameraPos - cameraSpherePos );",
"}",
"        #endif",
"",
"        cameraNormal = normalize( cameraPos - cameraSpherePos );",
"        cameraNormal *= float(!interior) * 2.0 - 1.0;",
"         return !interior;",
"",
"}",
"",
"void main(void){",
"",
"    bool flag = Impostor( cameraPos, cameraNormal );",
"",
"    #ifdef NEAR_CLIP",
"        if( calcClip( cameraPos ) > 0.0 )",
"            discard;",
"    #endif",
"",
"    // FIXME not compatible with custom clipping plane",
"    //Set the depth based on the new cameraPos.",
"    gl_FragDepthEXT = calcDepth( cameraPos );",
"    if( !flag ){",
"",
"        // clamp to near clipping plane and add a tiny value to",
"        // make spheres with a greater radius occlude smaller ones",
"        #ifdef NEAR_CLIP",
"if( flag2 ){",
"    gl_FragDepthEXT = max( 0.0, calcDepth( vec3( - ( nearClip - 0.5 ) ) ) + ( 0.0000001 / vRadius ) );",
"}else if( gl_FragDepthEXT >= 0.0 ){",
"    gl_FragDepthEXT = 0.0 + ( 0.0000001 / vRadius );",
"}",
"        #else",
"if( gl_FragDepthEXT >= 0.0 ){",
"    gl_FragDepthEXT = 0.0 + ( 0.0000001 / vRadius );",
"}",
"        #endif",
"",
"    }",
"",
"    // bugfix (mac only?)",
"    if (gl_FragDepthEXT < 0.0)",
"        discard;",
"    if (gl_FragDepthEXT > 1.0)",
"        discard;",
"",
"    #ifdef PICKING",
"",
"        gl_FragColor = vec4( vPickingColor, objectId );",
"",
"    #else",
"",
"        vec3 vNormal = cameraNormal;",
"        vec3 vViewPosition = -cameraPos;",
"",
"        vec4 diffuseColor = vec4( diffuse, opacity );",
"        ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
"        vec3 totalEmissiveLight = emissive;",
"",
"        #include color_fragment",
"        #include roughnessmap_fragment",
"        #include metalnessmap_fragment",
"",
"        // don't use include normal_fragment",
"        vec3 normal = normalize( vNormal );",
"",
"        #include lights_physical_fragment",
"        //include lights_template",
"        #include lights_fragment_begin",
"        #include lights_fragment_end",
"",
"        vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveLight;",
"",
"        gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
"        //gl_FragColor = vec4( reflectedLight.directSpecular, diffuseColor.a );",
"",
"        #include premultiplied_alpha_fragment",
"        #include tonemapping_fragment",
"        #include encodings_fragment",
"        #include fog_fragment",
"",
"    #endif",
"",
"}"
].join("\n");

$NGL_shaderTextHash['SphereImpostor.vert'] = ["uniform mat4 projectionMatrixInverse;",
"uniform float nearClip;",
"",
"varying float vRadius;",
"varying float vRadiusSq;",
"varying vec3 vPoint;",
"varying vec3 vPointViewPosition;",
"varying float fogDepth;",
"",
"attribute vec2 mapping;",
"//attribute vec3 position;",
"attribute float radius;",
"",
"#ifdef PICKING",
"    #include unpack_clr",
"    attribute float primitiveId;",
"    varying vec3 vPickingColor;",
"#else",
"    #include color_pars_vertex",
"#endif",
"",
"//include matrix_scale",
"float matrixScale( in mat4 m ){",
"    vec4 r = m[ 0 ];",
"    return sqrt( r[ 0 ] * r[ 0 ] + r[ 1 ] * r[ 1 ] + r[ 2 ] * r[ 2 ] );",
"}",
"",
"const mat4 D = mat4(",
"    1.0, 0.0, 0.0, 0.0,",
"    0.0, 1.0, 0.0, 0.0,",
"    0.0, 0.0, 1.0, 0.0,",
"    0.0, 0.0, 0.0, -1.0",
");",
"",
"mat4 transpose( in mat4 inMatrix ) {",
"    vec4 i0 = inMatrix[0];",
"    vec4 i1 = inMatrix[1];",
"    vec4 i2 = inMatrix[2];",
"    vec4 i3 = inMatrix[3];",
"",
"    mat4 outMatrix = mat4(",
"        vec4(i0.x, i1.x, i2.x, i3.x),",
"        vec4(i0.y, i1.y, i2.y, i3.y),",
"        vec4(i0.z, i1.z, i2.z, i3.z),",
"        vec4(i0.w, i1.w, i2.w, i3.w)",
"    );",
"    return outMatrix;",
"}",
"",
"//------------------------------------------------------------------------------",
"// Compute point size and center using the technique described in:",
"// 'GPU-Based Ray-Casting of Quadratic Surfaces'",
"// by Christian Sigg, Tim Weyrich, Mario Botsch, Markus Gross.",
"//",
"// Code based on",
"/*=========================================================================",
"",
" Program:   Visualization Toolkit",
" Module:    Quadrics_fs.glsl and Quadrics_vs.glsl",
"",
" Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen",
" All rights reserved.",
" See Copyright.txt or http://www.kitware.com/Copyright.htm for details.",
"",
" This software is distributed WITHOUT ANY WARRANTY; without even",
" the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR",
" PURPOSE.  See the above copyright notice for more information.",
"",
" =========================================================================*/",
"",
"// .NAME Quadrics_fs.glsl and Quadrics_vs.glsl",
"// .SECTION Thanks",
"// <verbatim>",
"//",
"//  This file is part of the PointSprites plugin developed and contributed by",
"//",
"//  Copyright (c) CSCS - Swiss National Supercomputing Centre",
"//                EDF - Electricite de France",
"//",
"//  John Biddiscombe, Ugo Varetto (CSCS)",
"//  Stephane Ploix (EDF)",
"//",
"// </verbatim>",
"//",
"// Contributions by Alexander Rose",
"// - ported to WebGL",
"// - adapted to work with quads",
"void ComputePointSizeAndPositionInClipCoordSphere(){",
"",
"    vec2 xbc;",
"    vec2 ybc;",
"",
"    mat4 T = mat4(",
"        radius, 0.0, 0.0, 0.0,",
"        0.0, radius, 0.0, 0.0,",
"        0.0, 0.0, radius, 0.0,",
"        position.x, position.y, position.z, 1.0",
"    );",
"",
"    mat4 R = transpose( projectionMatrix * modelViewMatrix * T );",
"    float A = dot( R[ 3 ], D * R[ 3 ] );",
"    float B = -2.0 * dot( R[ 0 ], D * R[ 3 ] );",
"    float C = dot( R[ 0 ], D * R[ 0 ] );",
"    xbc[ 0 ] = ( -B - sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );",
"    xbc[ 1 ] = ( -B + sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );",
"    float sx = abs( xbc[ 0 ] - xbc[ 1 ] ) * 0.5;",
"",
"    A = dot( R[ 3 ], D * R[ 3 ] );",
"    B = -2.0 * dot( R[ 1 ], D * R[ 3 ] );",
"    C = dot( R[ 1 ], D * R[ 1 ] );",
"    ybc[ 0 ] = ( -B - sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );",
"    ybc[ 1 ] = ( -B + sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );",
"    float sy = abs( ybc[ 0 ] - ybc[ 1 ]  ) * 0.5;",
"",
"    gl_Position.xy = vec2( 0.5 * ( xbc.x + xbc.y ), 0.5 * ( ybc.x + ybc.y ) );",
"    gl_Position.xy -= mapping * vec2( sx, sy );",
"    gl_Position.xy *= gl_Position.w;",
"",
"}",
"",
"void main(void){",
"",
"    #ifdef PICKING",
"        vPickingColor = unpackColor( primitiveId );",
"    #else",
"        #include color_vertex",
"    #endif",
"",
"    vRadius = radius * matrixScale( modelViewMatrix );",
"",
"    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
"    // avoid clipping, added again in fragment shader",
"    mvPosition.z -= vRadius;",
"",
"    gl_Position = projectionMatrix * vec4( mvPosition.xyz, 1.0 );",
"    ComputePointSizeAndPositionInClipCoordSphere();",
"",
"",
"    vRadiusSq = vRadius * vRadius;",
"    vec4 vPoint4 = projectionMatrixInverse * gl_Position;",
"    vPoint = vPoint4.xyz / vPoint4.w;",
"    vPointViewPosition = -mvPosition.xyz / mvPosition.w;",
"",
"}"
].join("\n");

$NGL_shaderTextHash['CylinderImpostor.frag'] = ["#define STANDARD",
"#define IMPOSTOR",
"",
"// Open-Source PyMOL is Copyright (C) Schrodinger, LLC.",
"//",
"//  All Rights Reserved",
"//",
"//  Permission to use, copy, modify, distribute, and distribute modified",
"//  versions of this software and its built-in documentation for any",
"//  purpose and without fee is hereby granted, provided that the above",
"//  copyright notice appears in all copies and that both the copyright",
"//  notice and this permission notice appear in supporting documentation,",
"//  and that the name of Schrodinger, LLC not be used in advertising or",
"//  publicity pertaining to distribution of the software without specific,",
"//  written prior permission.",
"//",
"//  SCHRODINGER, LLC DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,",
"//  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN",
"//  NO EVENT SHALL SCHRODINGER, LLC BE LIABLE FOR ANY SPECIAL, INDIRECT OR",
"//  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS",
"//  OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE",
"//  OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE",
"//  USE OR PERFORMANCE OF THIS SOFTWARE.",
"",
"// Contributions by Alexander Rose",
"// - ported to WebGL",
"// - dual color",
"// - pk color",
"// - custom clipping",
"// - three.js lighting",
"",
"uniform vec3 diffuse;",
"uniform vec3 emissive;",
"uniform float roughness;",
"uniform float metalness;",
"uniform float opacity;",
"uniform float nearClip;",
"uniform mat4 projectionMatrix;",
"uniform float ortho;",
"",
"varying vec3 axis;",
"varying vec4 base_radius;",
"varying vec4 end_b;",
"varying vec3 U;",
"varying vec3 V;",
"varying vec4 w;",
"",
"#ifdef PICKING",
"    uniform float objectId;",
"    varying vec3 vPickingColor;",
"#else",
"    varying vec3 vColor1;",
"    varying vec3 vColor2;",
"    #include common",
"    #include fog_pars_fragment",
"    #include bsdfs",
"    #include lights_pars_begin",
"    #include lights_physical_pars_fragment",
"#endif",
"",
"bool interior = false;",
"",
"float distSq3( vec3 v3a, vec3 v3b ){",
"    return (",
"        ( v3a.x - v3b.x ) * ( v3a.x - v3b.x ) +",
"        ( v3a.y - v3b.y ) * ( v3a.y - v3b.y ) +",
"        ( v3a.z - v3b.z ) * ( v3a.z - v3b.z )",
"    );",
"}",
"",
"// Calculate depth based on the given camera position.",
"float calcDepth( in vec3 cameraPos ){",
"    vec2 clipZW = cameraPos.z * projectionMatrix[2].zw + projectionMatrix[3].zw;",
"    return 0.5 + 0.5 * clipZW.x / clipZW.y;",
"}",
"",
"float calcClip( vec3 cameraPos ){",
"    return dot( vec4( cameraPos, 1.0 ), vec4( 0.0, 0.0, 1.0, nearClip - 0.5 ) );",
"}",
"",
"void main(){",
"",
"    vec3 point = w.xyz / w.w;",
"",
"    // unpacking",
"    vec3 base = base_radius.xyz;",
"    float vRadius = base_radius.w;",
"    vec3 end = end_b.xyz;",
"    float b = end_b.w;",
"",
"    vec3 end_cyl = end;",
"    vec3 surface_point = point;",
"",
"    vec3 ray_target = surface_point;",
"    vec3 ray_origin = vec3(0.0);",
"    vec3 ray_direction = mix(normalize(ray_origin - ray_target), vec3(0.0, 0.0, 1.0), ortho);",
"    mat3 basis = mat3( U, V, axis );",
"",
"    vec3 diff = ray_target - 0.5 * (base + end_cyl);",
"    vec3 P = diff * basis;",
"",
"    // angle (cos) between cylinder cylinder_axis and ray direction",
"    float dz = dot( axis, ray_direction );",
"",
"    float radius2 = vRadius*vRadius;",
"",
"    // calculate distance to the cylinder from ray origin",
"    vec3 D = vec3(dot(U, ray_direction),",
"                dot(V, ray_direction),",
"                dz);",
"    float a0 = P.x*P.x + P.y*P.y - radius2;",
"    float a1 = P.x*D.x + P.y*D.y;",
"    float a2 = D.x*D.x + D.y*D.y;",
"",
"    // calculate a dicriminant of the above quadratic equation",
"    float d = a1*a1 - a0*a2;",
"    if (d < 0.0)",
"        // outside of the cylinder",
"        discard;",
"",
"    float dist = (-a1 + sqrt(d)) / a2;",
"",
"    // point of intersection on cylinder surface",
"    vec3 new_point = ray_target + dist * ray_direction;",
"",
"    vec3 tmp_point = new_point - base;",
"    vec3 _normal = normalize( tmp_point - axis * dot(tmp_point, axis) );",
"",
"    ray_origin = mix( ray_origin, surface_point, ortho );",
"",
"    // test caps",
"    float front_cap_test = dot( tmp_point, axis );",
"    float end_cap_test = dot((new_point - end_cyl), axis);",
"",
"    // to calculate caps, simply check the angle between",
"    // the point of intersection - cylinder end vector",
"    // and a cap plane normal (which is the cylinder cylinder_axis)",
"    // if the angle < 0, the point is outside of cylinder",
"    // test front cap",
"",
"    #ifndef CAP",
"        vec3 new_point2 = ray_target + ( (-a1 - sqrt(d)) / a2 ) * ray_direction;",
"        vec3 tmp_point2 = new_point2 - base;",
"    #endif",
"",
"    // flat",
"    if (front_cap_test < 0.0)",
"    {",
"        // ray-plane intersection",
"        float dNV = dot(-axis, ray_direction);",
"        if (dNV < 0.0)",
"            discard;",
"        float near = dot(-axis, (base)) / dNV;",
"        vec3 front_point = ray_direction * near + ray_origin;",
"        // within the cap radius?",
"        if (dot(front_point - base, front_point-base) > radius2)",
"            discard;",
"",
"        #ifdef CAP",
"            new_point = front_point;",
"            _normal = axis;",
"        #else",
"            new_point = ray_target + ( (-a1 - sqrt(d)) / a2 ) * ray_direction;",
"            dNV = dot(-axis, ray_direction);",
"            near = dot(axis, end_cyl) / dNV;",
"            new_point2 = ray_direction * near + ray_origin;",
"            if (dot(new_point2 - end_cyl, new_point2-base) < radius2)",
"                discard;",
"            interior = true;",
"        #endif",
"    }",
"",
"    // test end cap",
"",
"",
"    // flat",
"    if( end_cap_test > 0.0 )",
"    {",
"        // ray-plane intersection",
"        float dNV = dot(axis, ray_direction);",
"        if (dNV < 0.0)",
"            discard;",
"        float near = dot(axis, end_cyl) / dNV;",
"        vec3 end_point = ray_direction * near + ray_origin;",
"        // within the cap radius?",
"        if( dot(end_point - end_cyl, end_point-base) > radius2 )",
"            discard;",
"",
"        #ifdef CAP",
"            new_point = end_point;",
"            _normal = axis;",
"        #else",
"            new_point = ray_target + ( (-a1 - sqrt(d)) / a2 ) * ray_direction;",
"            dNV = dot(-axis, ray_direction);",
"            near = dot(-axis, (base)) / dNV;",
"            new_point2 = ray_direction * near + ray_origin;",
"            if (dot(new_point2 - base, new_point2-base) < radius2)",
"                discard;",
"            interior = true;",
"        #endif",
"    }",
"",
"    gl_FragDepthEXT = calcDepth( new_point );",
"",
"    #ifdef NEAR_CLIP",
"        if( calcClip( new_point ) > 0.0 ){",
"            dist = (-a1 - sqrt(d)) / a2;",
"            new_point = ray_target + dist * ray_direction;",
"            if( calcClip( new_point ) > 0.0 )",
"                discard;",
"            interior = true;",
"            gl_FragDepthEXT = calcDepth( new_point );",
"            if( gl_FragDepthEXT >= 0.0 ){",
"                gl_FragDepthEXT = max( 0.0, calcDepth( vec3( - ( nearClip - 0.5 ) ) ) + ( 0.0000001 / vRadius ) );",
"            }",
"        }else if( gl_FragDepthEXT <= 0.0 ){",
"            dist = (-a1 - sqrt(d)) / a2;",
"            new_point = ray_target + dist * ray_direction;",
"            interior = true;",
"            gl_FragDepthEXT = calcDepth( new_point );",
"            if( gl_FragDepthEXT >= 0.0 ){",
"                gl_FragDepthEXT = 0.0 + ( 0.0000001 / vRadius );",
"            }",
"        }",
"    #else",
"        if( gl_FragDepthEXT <= 0.0 ){",
"            dist = (-a1 - sqrt(d)) / a2;",
"            new_point = ray_target + dist * ray_direction;",
"            interior = true;",
"            gl_FragDepthEXT = calcDepth( new_point );",
"            if( gl_FragDepthEXT >= 0.0 ){",
"                gl_FragDepthEXT = 0.0 + ( 0.0000001 / vRadius );",
"            }",
"        }",
"    #endif",
"",
"    // this is a workaround necessary for Mac",
"    // otherwise the modified fragment won't clip properly",
"    if (gl_FragDepthEXT < 0.0)",
"        discard;",
"    if (gl_FragDepthEXT > 1.0)",
"        discard;",
"",
"    #ifdef PICKING",
"",
"        gl_FragColor = vec4( vPickingColor, objectId );",
"",
"    #else",
"",
"        vec3 vViewPosition = -new_point;",
"        vec3 vNormal = _normal;",
"        vec3 vColor;",
"",
"        if( distSq3( new_point, end_cyl ) < distSq3( new_point, base ) ){",
"            if( b < 0.0 ){",
"                vColor = vColor1;",
"            }else{",
"                vColor = vColor2;",
"            }",
"        }else{",
"            if( b > 0.0 ){",
"                vColor = vColor1;",
"            }else{",
"                vColor = vColor2;",
"            }",
"        }",
"",
"        vec4 diffuseColor = vec4( diffuse, opacity );",
"        ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
"        vec3 totalEmissiveLight = emissive;",
"",
"        #include color_fragment",
"     //ifdef USE_COLOR",
"     //diffuseColor.r *= vColor[0];",
"     //diffuseColor.g *= vColor[1];",
"     //diffuseColor.b *= vColor[2];",
"     //endif",
"        #include roughnessmap_fragment",
"        #include metalnessmap_fragment",
"",
"        // don't use include normal_fragment",
"        vec3 normal = normalize( vNormal );",
"",
"        #include lights_physical_fragment",
"        //include lights_template",
"        #include lights_fragment_begin",
"        #include lights_fragment_end",
"",
"        vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveLight;",
"",
"        gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
"        //gl_FragColor = vec4( reflectedLight.directSpecular, diffuseColor.a );",
"",
"        #include premultiplied_alpha_fragment",
"        #include tonemapping_fragment",
"        #include encodings_fragment",
"        #include fog_fragment",
"    #endif",
"",
"}"
].join("\n");

$NGL_shaderTextHash['CylinderImpostor.vert'] = ["// Open-Source PyMOL is Copyright (C) Schrodinger, LLC.",
"//",
"//  All Rights Reserved",
"//",
"//  Permission to use, copy, modify, distribute, and distribute modified",
"//  versions of this software and its built-in documentation for any",
"//  purpose and without fee is hereby granted, provided that the above",
"//  copyright notice appears in all copies and that both the copyright",
"//  notice and this permission notice appear in supporting documentation,",
"//  and that the name of Schrodinger, LLC not be used in advertising or",
"//  publicity pertaining to distribution of the software without specific,",
"//  written prior permission.",
"//",
"//  SCHRODINGER, LLC DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,",
"//  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN",
"//  NO EVENT SHALL SCHRODINGER, LLC BE LIABLE FOR ANY SPECIAL, INDIRECT OR",
"//  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS",
"//  OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE",
"//  OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE",
"//  USE OR PERFORMANCE OF THIS SOFTWARE.",
"",
"// Contributions by Alexander Rose",
"// - ported to WebGL",
"// - dual color",
"// - pk color",
"// - shift",
"",
"attribute vec3 mapping;",
"attribute vec3 position1;",
"attribute vec3 position2;",
"attribute float radius;",
"",
"varying vec3 axis;",
"varying vec4 base_radius;",
"varying vec4 end_b;",
"varying vec3 U;",
"varying vec3 V;",
"varying vec4 w;",
"varying float fogDepth;",
"",
"#ifdef PICKING",
"    #include unpack_clr",
"    attribute float primitiveId;",
"    varying vec3 vPickingColor;",
"#else",
"    //attribute vec3 color;",
"    attribute vec3 color2;",
"    varying vec3 vColor1;",
"    varying vec3 vColor2;",
"#endif",
"",
"uniform mat4 modelViewMatrixInverse;",
"uniform float ortho;",
"",
"//include matrix_scale",
"float matrixScale( in mat4 m ){",
"    vec4 r = m[ 0 ];",
"    return sqrt( r[ 0 ] * r[ 0 ] + r[ 1 ] * r[ 1 ] + r[ 2 ] * r[ 2 ] );",
"}",
"",
"void main(){",
"",
"    #ifdef PICKING",
"        vPickingColor = unpackColor( primitiveId );",
"    #else",
"        vColor1 = color;",
"        vColor2 = color2;",
"    #endif",
"",
"    // vRadius = radius;",
"    base_radius.w = radius * matrixScale( modelViewMatrix );",
"",
"    //vec3 center = position;",
"    vec3 center = ( position2 + position1 ) / 2.0;",
"    vec3 dir = normalize( position2 - position1 );",
"    float ext = length( position2 - position1 ) / 2.0;",
"",
"    // using cameraPosition fails on some machines, not sure why",
"    // vec3 cam_dir = normalize( cameraPosition - mix( center, vec3( 0.0 ), ortho ) );",
"    vec3 cam_dir;",
"    if( ortho == 0.0 ){",
"        cam_dir = ( modelViewMatrixInverse * vec4( 0, 0, 0, 1 ) ).xyz - center;",
"    }else{",
"        cam_dir = ( modelViewMatrixInverse * vec4( 0, 0, 1, 0 ) ).xyz;",
"    }",
"    cam_dir = normalize( cam_dir );",
"",
"    vec3 ldir;",
"",
"    float b = dot( cam_dir, dir );",
"    end_b.w = b;",
"    // direction vector looks away, so flip",
"    if( b < 0.0 )",
"        ldir = -ext * dir;",
"    // direction vector already looks in my direction",
"    else",
"        ldir = ext * dir;",
"",
"    vec3 left = normalize( cross( cam_dir, ldir ) );",
"    left = radius * left;",
"    vec3 up = radius * normalize( cross( left, ldir ) );",
"",
"    // transform to modelview coordinates",
"    axis = normalize( normalMatrix * ldir );",
"    U = normalize( normalMatrix * up );",
"    V = normalize( normalMatrix * left );",
"",
"    vec4 base4 = modelViewMatrix * vec4( center - ldir, 1.0 );",
"    base_radius.xyz = base4.xyz / base4.w;",
"",
"    vec4 top_position = modelViewMatrix * vec4( center + ldir, 1.0 );",
"    vec4 end4 = top_position;",
"    end_b.xyz = end4.xyz / end4.w;",
"",
"    w = modelViewMatrix * vec4(",
"        center + mapping.x*ldir + mapping.y*left + mapping.z*up, 1.0",
"    );",
"",
"    gl_Position = projectionMatrix * w;",
"",
"    // avoid clipping (1.0 seems to induce flickering with some drivers)",
"    gl_Position.z = 0.99;",
"",
"}"
].join("\n");

$NGL_shaderTextHash['SphereInstancing.frag'] = $NGL_shaderTextHash['SphereImpostor.frag'];

$NGL_shaderTextHash['SphereInstancing.vert'] = ["uniform mat4 projectionMatrixInverse;",
"uniform float nearClip;",
"",
"varying float vRadius;",
"varying float vRadiusSq;",
"varying vec3 vPoint;",
"varying vec3 vPointViewPosition;",
"varying float fogDepth;",
"",
"attribute vec2 mapping;",
"//attribute vec3 position;",
"attribute float radius;",
"attribute vec4 matrix1;",
"attribute vec4 matrix2;",
"attribute vec4 matrix3;",
"attribute vec4 matrix4;",
"",
"#ifdef PICKING",
"    #include unpack_clr",
"    attribute float primitiveId;",
"    varying vec3 vPickingColor;",
"#else",
"    #include color_pars_vertex",
"#endif",
"",
"//include matrix_scale",
"float matrixScale( in mat4 m ){",
"    vec4 r = m[ 0 ];",
"    return sqrt( r[ 0 ] * r[ 0 ] + r[ 1 ] * r[ 1 ] + r[ 2 ] * r[ 2 ] );",
"}",
"",
"const mat4 D = mat4(",
"    1.0, 0.0, 0.0, 0.0,",
"    0.0, 1.0, 0.0, 0.0,",
"    0.0, 0.0, 1.0, 0.0,",
"    0.0, 0.0, 0.0, -1.0",
");",
"",
"mat4 transpose( in mat4 inMatrix ) {",
"    vec4 i0 = inMatrix[0];",
"    vec4 i1 = inMatrix[1];",
"    vec4 i2 = inMatrix[2];",
"    vec4 i3 = inMatrix[3];",
"",
"    mat4 outMatrix = mat4(",
"        vec4(i0.x, i1.x, i2.x, i3.x),",
"        vec4(i0.y, i1.y, i2.y, i3.y),",
"        vec4(i0.z, i1.z, i2.z, i3.z),",
"        vec4(i0.w, i1.w, i2.w, i3.w)",
"    );",
"    return outMatrix;",
"}",
"",
"//------------------------------------------------------------------------------",
"// Compute point size and center using the technique described in:",
"// 'GPU-Based Ray-Casting of Quadratic Surfaces'",
"// by Christian Sigg, Tim Weyrich, Mario Botsch, Markus Gross.",
"//",
"// Code based on",
"/*=========================================================================",
"",
" Program:   Visualization Toolkit",
" Module:    Quadrics_fs.glsl and Quadrics_vs.glsl",
"",
" Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen",
" All rights reserved.",
" See Copyright.txt or http://www.kitware.com/Copyright.htm for details.",
"",
" This software is distributed WITHOUT ANY WARRANTY; without even",
" the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR",
" PURPOSE.  See the above copyright notice for more information.",
"",
" =========================================================================*/",
"",
"// .NAME Quadrics_fs.glsl and Quadrics_vs.glsl",
"// .SECTION Thanks",
"// <verbatim>",
"//",
"//  This file is part of the PointSprites plugin developed and contributed by",
"//",
"//  Copyright (c) CSCS - Swiss National Supercomputing Centre",
"//                EDF - Electricite de France",
"//",
"//  John Biddiscombe, Ugo Varetto (CSCS)",
"//  Stephane Ploix (EDF)",
"//",
"// </verbatim>",
"//",
"// Contributions by Alexander Rose",
"// - ported to WebGL",
"// - adapted to work with quads",
"void ComputePointSizeAndPositionInClipCoordSphere(vec4 updatePosition){",
"",
"    vec2 xbc;",
"    vec2 ybc;",
"",
"    mat4 T = mat4(",
"        radius, 0.0, 0.0, 0.0,",
"        0.0, radius, 0.0, 0.0,",
"        0.0, 0.0, radius, 0.0,",
"        updatePosition.x, updatePosition.y, updatePosition.z, 1.0",
"    );",
"",
"    mat4 R = transpose( projectionMatrix * modelViewMatrix * T );",
"    float A = dot( R[ 3 ], D * R[ 3 ] );",
"    float B = -2.0 * dot( R[ 0 ], D * R[ 3 ] );",
"    float C = dot( R[ 0 ], D * R[ 0 ] );",
"    xbc[ 0 ] = ( -B - sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );",
"    xbc[ 1 ] = ( -B + sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );",
"    float sx = abs( xbc[ 0 ] - xbc[ 1 ] ) * 0.5;",
"",
"    A = dot( R[ 3 ], D * R[ 3 ] );",
"    B = -2.0 * dot( R[ 1 ], D * R[ 3 ] );",
"    C = dot( R[ 1 ], D * R[ 1 ] );",
"    ybc[ 0 ] = ( -B - sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );",
"    ybc[ 1 ] = ( -B + sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );",
"    float sy = abs( ybc[ 0 ] - ybc[ 1 ]  ) * 0.5;",
"",
"    gl_Position.xy = vec2( 0.5 * ( xbc.x + xbc.y ), 0.5 * ( ybc.x + ybc.y ) );",
"    gl_Position.xy -= mapping * vec2( sx, sy );",
"    gl_Position.xy *= gl_Position.w;",
"",
"}",
"",
"  mat4 computeMat(vec4 v1, vec4 v2, vec4 v3, vec4 v4) {",
"    return mat4(",
"      v1.x, v1.y, v1.z, v1.w,",
"      v2.x, v2.y, v2.z, v2.w,",
"      v3.x, v3.y, v3.z, v3.w,",
"      v4.x, v4.y, v4.z, v4.w",
"    );",
"  }",
"",
"void main(void){",
"",
"    #ifdef PICKING",
"        vPickingColor = unpackColor( primitiveId );",
"    #else",
"        #include color_vertex",
"    #endif",
"",
"    vRadius = radius * matrixScale( modelViewMatrix );",
"",
"    mat4 matrix = computeMat(matrix1, matrix2, matrix3, matrix4);",
"    vec4 updatePosition = matrix * vec4(position, 1.0);",
"",
"//    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
"    vec4 mvPosition = modelViewMatrix * vec4( updatePosition.xyz, 1.0 );",
"    // avoid clipping, added again in fragment shader",
"    mvPosition.z -= vRadius;",
"",
"//    gl_Position = projectionMatrix * vec4( mvPosition.xyz, 1.0 );",
"    gl_Position = projectionMatrix * vec4( mvPosition.xyz, 1.0 );",
"    ComputePointSizeAndPositionInClipCoordSphere(updatePosition);",
"",
"",
"    vRadiusSq = vRadius * vRadius;",
"    vec4 vPoint4 = projectionMatrixInverse * gl_Position;",
"    vPoint = vPoint4.xyz / vPoint4.w;",
"    vPointViewPosition = -mvPosition.xyz / mvPosition.w;",
"",
"}"
].join("\n");

$NGL_shaderTextHash['CylinderInstancing.frag'] = $NGL_shaderTextHash['CylinderImpostor.frag'];
$NGL_shaderTextHash['CylinderInstancing.vert'] = ["// Open-Source PyMOL is Copyright (C) Schrodinger, LLC.",
"//",
"//  All Rights Reserved",
"//",
"//  Permission to use, copy, modify, distribute, and distribute modified",
"//  versions of this software and its built-in documentation for any",
"//  purpose and without fee is hereby granted, provided that the above",
"//  copyright notice appears in all copies and that both the copyright",
"//  notice and this permission notice appear in supporting documentation,",
"//  and that the name of Schrodinger, LLC not be used in advertising or",
"//  publicity pertaining to distribution of the software without specific,",
"//  written prior permission.",
"//",
"//  SCHRODINGER, LLC DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,",
"//  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN",
"//  NO EVENT SHALL SCHRODINGER, LLC BE LIABLE FOR ANY SPECIAL, INDIRECT OR",
"//  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS",
"//  OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE",
"//  OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE",
"//  USE OR PERFORMANCE OF THIS SOFTWARE.",
"",
"// Contributions by Alexander Rose",
"// - ported to WebGL",
"// - dual color",
"// - pk color",
"// - shift",
"",
"attribute vec3 mapping;",
"attribute vec3 position1;",
"attribute vec3 position2;",
"attribute float radius;",
"attribute vec4 matrix1;",
"attribute vec4 matrix2;",
"attribute vec4 matrix3;",
"attribute vec4 matrix4;",
"",
"varying vec3 axis;",
"varying vec4 base_radius;",
"varying vec4 end_b;",
"varying vec3 U;",
"varying vec3 V;",
"varying vec4 w;",
"varying float fogDepth;",
"",
"#ifdef PICKING",
"    #include unpack_clr",
"    attribute float primitiveId;",
"    varying vec3 vPickingColor;",
"#else",
"    //attribute vec3 color;",
"    attribute vec3 color2;",
"    varying vec3 vColor1;",
"    varying vec3 vColor2;",
"#endif",
"",
"uniform mat4 modelViewMatrixInverse;",
"uniform float ortho;",
"",
"//include matrix_scale",
"float matrixScale( in mat4 m ){",
"    vec4 r = m[ 0 ];",
"    return sqrt( r[ 0 ] * r[ 0 ] + r[ 1 ] * r[ 1 ] + r[ 2 ] * r[ 2 ] );",
"}",
"",
"  mat4 computeMat(vec4 v1, vec4 v2, vec4 v3, vec4 v4) {",
"    return mat4(",
"      v1.x, v1.y, v1.z, v1.w,",
"      v2.x, v2.y, v2.z, v2.w,",
"      v3.x, v3.y, v3.z, v3.w,",
"      v4.x, v4.y, v4.z, v4.w",
"    );",
"  }",
"",
"void main(){",
"",
"    #ifdef PICKING",
"        vPickingColor = unpackColor( primitiveId );",
"    #else",
"        vColor1 = color;",
"        vColor2 = color2;",
"    #endif",
"",
"    // vRadius = radius;",
"    base_radius.w = radius * matrixScale( modelViewMatrix );",
"",
"    //vec3 center = ( position2 + position1 ) / 2.0;",
"",
"    mat4 matrix = computeMat(matrix1, matrix2, matrix3, matrix4);",
"    vec4 updatePosition1 = matrix * vec4(position1, 1.0);",
"    vec4 updatePosition2 = matrix * vec4(position2, 1.0);",
"    vec3 center = ( updatePosition2.xyz + updatePosition1.xyz ) / 2.0;",
"",
"    //vec3 dir = normalize( position2 - position1 );",
"    vec3 dir = normalize( updatePosition2.xyz - updatePosition1.xyz );",
"    float ext = length( position2 - position1 ) / 2.0;",
"",
"    // using cameraPosition fails on some machines, not sure why",
"    // vec3 cam_dir = normalize( cameraPosition - mix( center, vec3( 0.0 ), ortho ) );",
"    vec3 cam_dir;",
"    if( ortho == 0.0 ){",
"        cam_dir = ( modelViewMatrixInverse * vec4( 0, 0, 0, 1 ) ).xyz - center;",
"    }else{",
"        cam_dir = ( modelViewMatrixInverse * vec4( 0, 0, 1, 0 ) ).xyz;",
"    }",
"    cam_dir = normalize( cam_dir );",
"",
"    vec3 ldir;",
"",
"    float b = dot( cam_dir, dir );",
"    end_b.w = b;",
"    // direction vector looks away, so flip",
"    if( b < 0.0 )",
"        ldir = -ext * dir;",
"    // direction vector already looks in my direction",
"    else",
"        ldir = ext * dir;",
"",
"    vec3 left = normalize( cross( cam_dir, ldir ) );",
"    left = radius * left;",
"    vec3 up = radius * normalize( cross( left, ldir ) );",
"",
"    // transform to modelview coordinates",
"    axis = normalize( normalMatrix * ldir );",
"    U = normalize( normalMatrix * up );",
"    V = normalize( normalMatrix * left );",
"",
"    vec4 base4 = modelViewMatrix * vec4( center - ldir, 1.0 );",
"    base_radius.xyz = base4.xyz / base4.w;",
"",
"    vec4 top_position = modelViewMatrix * vec4( center + ldir, 1.0 );",
"    vec4 end4 = top_position;",
"    end_b.xyz = end4.xyz / end4.w;",
"",
"    w = modelViewMatrix * vec4(",
"        center + mapping.x*ldir + mapping.y*left + mapping.z*up, 1.0",
"    );",
"",
"    gl_Position = projectionMatrix * w;",
"",
"    // avoid clipping (1.0 seems to induce flickering with some drivers)",
"    gl_Position.z = 0.99;",
"",
"}"
].join("\n");

$NGL_shaderTextHash['Instancing.frag'] = ["#define STANDARD",
"uniform vec3 diffuse;",
"uniform vec3 emissive;",
"uniform float roughness;",
"uniform float metalness;",
"uniform float opacity;",
"uniform float nearClip;",
"uniform float clipRadius;",
"uniform mat4 projectionMatrix;",
"uniform float ortho;",
"varying float bCylinder;",
"",
"#if defined( NEAR_CLIP ) || defined( RADIUS_CLIP ) || ( !defined( PICKING ) && !defined( NOLIGHT ) )",
"    varying vec3 vViewPosition;",
"#endif",
"",
"#if defined( RADIUS_CLIP )",
"    varying vec3 vClipCenter;",
"#endif",
"",
"#if defined( PICKING )",
"    uniform float objectId;",
"    varying vec3 vPickingColor;",
"#elif defined( NOLIGHT )",
"    varying vec3 vColor;",
"#else",
"    #ifndef FLAT_SHADED",
"        varying vec3 vNormal;",
"    #endif",
"    #include common",
"    #include color_pars_fragment",
"    #include fog_pars_fragment",
"    #include bsdfs",
"    #include lights_pars_begin",
"    #include lights_physical_pars_fragment",
"#endif",
"",
"void main(){",
"    #include nearclip_fragment",
"    #include radiusclip_fragment",
"",
"    #if defined( PICKING )",
"",
"        gl_FragColor = vec4( vPickingColor, objectId );",
"",
"    #elif defined( NOLIGHT )",
"",
"        gl_FragColor = vec4( vColor, opacity );",
"",
"    #else",
"",
"        vec4 diffuseColor = vec4( diffuse, opacity );",
"        ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
"        vec3 totalEmissiveLight = emissive;",
"",
"        #include color_fragment",
"        #include roughnessmap_fragment",
"        #include metalnessmap_fragment",
"        #include normal_flip",
"        #include normal_fragment_begin",
"",
"        //include dull_interior_fragment",
"",
"        #include lights_physical_fragment",
"        //include lights_template",
"        #include lights_fragment_begin",
"        #include lights_fragment_end",
"",
"        vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveLight;",
"",
"        #include interior_fragment",
"",
"        gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
"",
"        #include premultiplied_alpha_fragment",
"        #include tonemapping_fragment",
"        #include encodings_fragment",
"        #include fog_fragment",
"",
"        #include opaque_back_fragment",
"",
"    #endif",
"",
"}"
].join("\n");

$NGL_shaderTextHash['Instancing.vert'] = ["#define STANDARD",
"",
"uniform mat4 projectionMatrixInverse;",
"uniform float nearClip;",
"uniform vec3 clipCenter;",
"attribute vec4 matrix1;",
"attribute vec4 matrix2;",
"attribute vec4 matrix3;",
"attribute vec4 matrix4;",
"attribute float cylinder;",
"varying float bCylinder;",
"",
"#if defined( NEAR_CLIP ) || defined( RADIUS_CLIP ) || ( !defined( PICKING ) && !defined( NOLIGHT ) )",
"    varying vec3 vViewPosition;",
"#endif",
"",
"#if defined( RADIUS_CLIP )",
"    varying vec3 vClipCenter;",
"#endif",
"",
"#if defined( PICKING )",
"    #include unpack_color",
"    attribute float primitiveId;",
"    varying vec3 vPickingColor;",
"#elif defined( NOLIGHT )",
"    varying vec3 vColor;",
"#else",
"    #include color_pars_vertex",
"    #ifndef FLAT_SHADED",
"        varying vec3 vNormal;",
"    #endif",
"#endif",
"",
"#include common",
"",
"  mat4 computeMat(vec4 v1, vec4 v2, vec4 v3, vec4 v4) {",
"    return mat4(",
"      v1.x, v1.y, v1.z, v1.w,",
"      v2.x, v2.y, v2.z, v2.w,",
"      v3.x, v3.y, v3.z, v3.w,",
"      v4.x, v4.y, v4.z, v4.w",
"    );",
"  }",
"",
"void main(){",
"    bCylinder = cylinder;",
"",
"    mat4 matrix = computeMat(matrix1, matrix2, matrix3, matrix4);",
"    vec4 updatePosition = matrix * vec4(position, 1.0);",
"",
"    #if defined( PICKING )",
"        vPickingColor = unpackColor( primitiveId );",
"    #elif defined( NOLIGHT )",
"        vColor = color;",
"    #else",
"        #include color_vertex",
"        //include beginnormal_vertex",
"        //vec3 objectNormal = vec3( normal );",
"        vec3 objectNormal = vec3(matrix * vec4(normal,0.0));",
"        #include defaultnormal_vertex",
"        // Normal computed with derivatives when FLAT_SHADED",
"        #ifndef FLAT_SHADED",
"            vNormal = normalize( transformedNormal );",
"        #endif",
"    #endif",
"",
"    //include begin_vertex",
"    vec3 transformed = updatePosition.xyz;",
"    //include project_vertex",
"    vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );",
"    gl_Position = projectionMatrix * mvPosition;",
"",
"    #if defined( NEAR_CLIP ) || defined( RADIUS_CLIP ) || ( !defined( PICKING ) && !defined( NOLIGHT ) )",
"        vViewPosition = -mvPosition.xyz;",
"    #endif",
"",
"    #if defined( RADIUS_CLIP )",
"        vClipCenter = -( modelViewMatrix * vec4( clipCenter, 1.0 ) ).xyz;",
"    #endif",
"",
"    #include nearclip_vertex",
"",
"}"
].join("\n");

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

if (typeof jQuery === 'undefined') { throw new Error('iCn3D requires jQuery') }

var iCn3D = function (id) {
    this.id = id;

    this.container = $('#' + id);

    this.maxatomcnt = 100000; // for a biological assembly, use instancing when the total number of atomsis greater than "maxatomcnt"

    this.overdraw = 0;

    this.bDrawn = false;

    this.bSecondaryStructure = false;

    this.bHighlight = 1; // undefined: no highlight, 1: highlight by outline, 2: highlight by 3D object
    this.renderOrderPicking = -1; // less than 0, the default order is 0

    this.ALTERNATE_STRUCTURE = -1;

    if(Detector.webgl){
        this.renderer = new THREE.WebGLRenderer({
            canvas: this.container.get(0),
            antialias: true,
            preserveDrawingBuffer: true,
            sortObjects: false,
            alpha: true
        });

        this.overdraw = 0;
    }
    else {
        alert("Currently your web browser has a problem on WebGL. If you are using Chrome, open a new tab for the same URL and WebGL may work again.");
/*
        alert("Currently your web browser has a problem on WebGL, and CanvasRenderer instead of WebGLRenderer is used. If you are using Chrome, open a new tab for the same URL and WebGL may work again.");

        this.renderer = new THREE.CanvasRenderer({
            canvas: this.container.get(0)
        });

        //http://threejs.org/docs/api/materials/Material.html
        this.overdraw = 0.5;

        // only WebGL support outlines using ShaderMaterial
        this.bHighlight = 2;
*/
    }

    this.matShader = this.setOutlineColor('yellow');
    this.frac = new THREE.Color(0.1, 0.1, 0.1);

    // mobile has a problem when the scaleFactor is 2.0
    // the scaleFactor improve the image quality
    this.scaleFactor = 1.5;

    // Impostor shaders
    this.bImpo = true;
    this.bExtFragDepth = this.renderer.extensions.get( "EXT_frag_depth" );
    if(!this.bExtFragDepth) {
        this.bImpo = false;
        console.log('EXT_frag_depth is NOT supported. All spheres and cylinders are drawn using geometry.');
    }
    else {
        console.log('EXT_frag_depth is supported. All spheres and cylinders are drawn using shaders.');
    }

    this.bInstanced = this.renderer.extensions.get( "ANGLE_instanced_arrays" );
    if(!this.bInstanced) {
        console.log('ANGLE_instanced_arrays is NOT supported. Assembly is drawn by making copies of the asymmetric unit.');
    }
    else {
        console.log('ANGLE_instanced_arrays is supported. Assembly is drawn with one copy of the asymmetric unit using hardware instancing.');
    }

        // cylinder impostor
    this.posArray = new Array();
    this.colorArray = new Array();

    this.pos2Array = new Array();
    this.color2Array = new Array();

    this.radiusArray = new Array();

        // sphere impostor
    this.posArraySphere = new Array();
    this.colorArraySphere = new Array();
    this.radiusArraySphere = new Array();

    // adjust the size
    this.WIDTH = this.container.width(), this.HEIGHT = this.container.height();
    this.setWidthHeight(this.WIDTH, this.HEIGHT);

    this.axis = false;  // used to turn on and off xyz axes

    // pk
    this.pk = 1; // 0: no pk, 1: pk on atoms, 2: pk on residues, 3: pk on strand/helix/coil, 4: pk on chain
    this.highlightlevel = 1; // 1: highlight on atoms, 2: highlight on residues, 3: highlight on strand/helix/coil 4: highlight on chain 5: highlight on structure

    this.pickpair = false; // used for pk pair of atoms for label and distance
    this.pAtomNum = 0;

    this.pAtom = undefined;
    this.pAtom2 = undefined;

    this.bCtrl = false; // if true, union selection on sequence window or on 3D structure
    this.bShift = false; // if true, select a range on 3D structure

    this.bStopRotate = false; // by default, do not stop the possible automatic rotation
    this.bCalphaOnly = false; // by default the input has both Calpha and O, used for drawing strands. If atoms have Calpha only, the orientation of the strands is random
//    this.bSSOnly = false; // a flag to turn on when only helix and bricks are available to draw 3D dgm

    this.bAllAtoms = true; // no need to adjust atom for strand style

    this.bConsiderNeighbors = false; // a flag to show surface considering the neighboring atoms or not

    this.bShowCrossResidueBond = false;

    this.effects = {
        //'anaglyph': new THREE.AnaglyphEffect(this.renderer),
        //'parallax barrier': new THREE.ParallaxBarrierEffect(this.renderer),
        //'oculus rift': new THREE.OculusRiftEffect(this.renderer),
        //'stereo': new THREE.StereoEffect(this.renderer),
        'none': this.renderer
    };

    this.maxD = 500; // size of the molecule
    this.oriMaxD = this.maxD; // size of the molecule
    //this.cam_z = -150;

    this.cam_z = this.maxD * 2; // when zooming in, it gets dark if the camera is in front
    //this.cam_z = -this.maxD * 2;

    // these variables will not be cleared for each structure
    this.commands = []; // a list of commands, ordered by the operation steps. Each operation will be converted into a command. this command list can be used to go backward and forward.
    this.optsHistory = []; // a list of options corresponding to this.commands.
    this.logs = []; // a list of comands and other logs, ordered by the operation steps.

    this.bRender = true; // a flag to turn off rendering when loading state file

    // Default values
    this.hColor = new THREE.Color(0xFFFF00);

    this.sphereGeometry = new THREE.SphereGeometry(1, 32, 32);
    this.boxGeometry = new THREE.BoxGeometry(1, 1, 1);
    this.cylinderGeometry = new THREE.CylinderGeometry(1, 1, 1, 32, 1);
    this.cylinderGeometryOutline = new THREE.CylinderGeometry(1, 1, 1, 32, 1, true);
    this.axisDIV = 5; // 3
    this.strandDIV = 6;
    this.tubeDIV = 8;
    this.nucleicAcidStrandDIV = 6; //4;

    this.linewidth = 1;
    this.hlLineRadius = 0.1; // style line, highlight
    //this.curveWidth = 3;

    this.lineRadius = 0.1; // hbonds, distance lines
    this.coilWidth = 0.3; //0.4; // style cartoon-coil
    this.cylinderRadius = 0.4; // style stick
    this.traceRadius = 0.4; //0.2; // c alpha trace, nucleotide stick
    this.dotSphereScale = 0.3; // style ball and stick, dot
    this.sphereRadius = 1.5; // style sphere
    this.cylinderHelixRadius = 1.6; // style sylinder and plate

    this.ribbonthickness = 0.2; // 0.4; // style ribbon, nucleotide cartoon, stand thickness
    this.helixSheetWidth = 1.3; // style ribbon, nucleotide cartoon, stand thickness
    this.nucleicAcidWidth = 0.8; // nucleotide cartoon

    this.threshbox = 180; // maximum possible boxsize, default 180
    this.maxAtoms3DMultiFile = 40000; // above the threshold, multiple files wil be output for 3D printing

    this.LABELSIZE = 30;

    this.opts = {
        camera: 'perspective',
        background: 'transparent',
        color: 'chain',
        sidec: 'nothing',
        proteins: 'ribbon',
        nucleotides: 'nucleotide cartoon',
        surface: 'nothing',
        wireframe: 'no',
        map: 'nothing',
        mapwireframe: 'yes',
        emmap: 'nothing',
        emmapwireframe: 'yes',
        opacity: '1.0',
        chemicals: 'stick',
        water: 'nothing',
        ions: 'sphere',
        //labels: 'no',
        //effect: 'none',
        hbonds: 'no',
        //stabilizer: 'no',
        ssbonds: 'no',
        //ncbonds: 'no',
        labels: 'no',
        lines: 'no',
        rotationcenter: 'molecule center',
        axis: 'no',
        fog: 'no',
        slab: 'no',
        pk: 'residue',
        nucleotides: 'nucleotide cartoon',
        chemicalbinding: 'hide'
    };

    this._zoomFactor = 1.0;
    this.mouseChange = new THREE.Vector2(0,0);
    this.quaternion = new THREE.Quaternion(0,0,0,1);

    var me = this;
    this.container.bind('contextmn', function (e) {
        e.preventDefault();
    });

    //me.switchHighlightLevel();

    // key event has to use the document because it requires the focus
    me.typetext = false;

    //http://unixpapa.com/js/key.html
    $(document).bind('keyup', function (e) {
      if(e.keyCode === 16) { // shiftKey
          me.bShift = false;
      }
      if(e.keyCode === 17 || e.keyCode === 224 || e.keyCode === 91) { // ctrlKey or apple command key
          me.bCtrl = false;
      }
    });

    $('input[type=text], textarea').focus(function() {
        me.typetext = true;
    });

    $('input[type=text], textarea').blur(function() {
        me.typetext = false;
    });

    $(document).bind('keydown', function (e) {
      if(e.shiftKey || e.keyCode === 16) {
          me.bShift = true;
      }
      if(e.ctrlKey || e.keyCode === 17 || e.keyCode === 224 || e.keyCode === 91) {
          me.bCtrl = true;
      }

      if (!me.controls) return;

      me.bStopRotate = true;

      if(!me.typetext) {
        // zoom
        if(e.keyCode === 90 ) { // Z
          var para = {};

          if(me.cam === me.perspectiveCamera) { // perspective
            para._zoomFactor = 0.9;
          }
          else if(me.cam === me.orthographicCamera) {  // orthographics
            if(me._zoomFactor < 0.1) {
              me._zoomFactor = 0.1;
            }
            else if(me._zoomFactor > 1) {
              me._zoomFactor = 1;
            }

            para._zoomFactor = me._zoomFactor * 0.8;
            if(para._zoomFactor < 0.1) para._zoomFactor = 0.1;
          }

          para.update = true;
          me.controls.update(para);
          me.render();
        }
        else if(e.keyCode === 88 ) { // X
          var para = {};

          if(me.cam === me.perspectiveCamera) { // perspective
            //para._zoomFactor = 1.1;
            para._zoomFactor = 1.03;
          }
          else if(me.cam === me.orthographicCamera) {  // orthographics
            if(me._zoomFactor > 10) {
              me._zoomFactor = 10;
            }
            else if(me._zoomFactor < 1) {
              me._zoomFactor = 1;
            }

            para._zoomFactor = me._zoomFactor * 1.01;
            if(para._zoomFactor > 10) para._zoomFactor = 10;
          }

          para.update = true;
          me.controls.update(para);
          me.render();
        }

        // rotate
        else if(e.keyCode === 76 ) { // L, rotate left
          var axis = new THREE.Vector3(0,1,0);
          var angle = -5.0 / 180.0 * Math.PI;

          me.setRotation(axis, angle);
        }
        else if(e.keyCode === 74 ) { // J, rotate right
          var axis = new THREE.Vector3(0,1,0);
          var angle = 5.0 / 180.0 * Math.PI;

          me.setRotation(axis, angle);
        }
        else if(e.keyCode === 73 ) { // I, rotate up
          var axis = new THREE.Vector3(1,0,0);
          var angle = -5.0 / 180.0 * Math.PI;

          me.setRotation(axis, angle);
        }
        else if(e.keyCode === 77 ) { // M, rotate down
          var axis = new THREE.Vector3(1,0,0);
          var angle = 5.0 / 180.0 * Math.PI;

          me.setRotation(axis, angle);
        }

        else if(e.keyCode === 65 ) { // A, alternate
           if(Object.keys(me.structures).length > 1) {
               me.alternateStructures();
           }
        }

      }
    });

    this.container.bind('mouseup touchend', function (e) {
        me.isDragging = false;
    });
    //this.container.bind('mousedown touchstart', function (e) {
    this.container.bind('mousedown', function (e) {
        e.preventDefault();
        me.isDragging = true;

        if (!me.scene) return;

        me.bStopRotate = true;

        if(me.pk && (e.altKey || e.ctrlKey || e.shiftKey || e.keyCode === 18 || e.keyCode === 16 || e.keyCode === 17 || e.keyCode === 224 || e.keyCode === 91) ) {
            me.highlightlevel = me.pk;

            var bClick = true;
            me.rayCaster(e, bClick);
        }

        me.controls.handleResize();
        me.controls.update();
        me.render();
    });

    this.container.bind('touchstart', function (e) {
        e.preventDefault();
        me.isDragging = true;

        if (!me.scene) return;

        me.bStopRotate = true;

        $("[id$=popup]").hide();

        //var bClick = false;
        var bClick = true;
        me.rayCaster(e, bClick);

        me.controls.handleResize();
        me.controls.update();
        me.render();
    });

    this.container.bind('mousemove touchmove', function (e) {
        e.preventDefault();
        if (!me.scene) return;
        // no action when no mouse button is clicked and no key was down
        //if (!me.isDragging) return;

        $("[id$=popup]").hide();

        var bClick = false;
        me.rayCaster(e, bClick);

        if(me.isDragging) {
            me.controls.handleResize();
            me.controls.update();
            me.render();
        }
    });
    this.container.bind('mousewheel', function (e) {
        e.preventDefault();
        if (!me.scene) return;

        me.bStopRotate = true;

        me.controls.handleResize();
        me.controls.update();

        me.render();
    });
    this.container.bind('DOMMouseScroll', function (e) {
        e.preventDefault();
        if (!me.scene) return;

        me.bStopRotate = true;

        me.controls.handleResize();
        me.controls.update();

        me.render();
    });
};

iCn3D.prototype = {

    constructor: iCn3D,

    rayCaster: function(e, bClick) { var me = this;
        var x = e.pageX, y = e.pageY;
        if (e.originalEvent.targetTouches && e.originalEvent.targetTouches[0]) {
            x = e.originalEvent.targetTouches[0].pageX;
            y = e.originalEvent.targetTouches[0].pageY;
        }

        var popupX = x - me.container.offset().left;
        var popupY = y - me.container.offset().top;

        //me.isDragging = true;

        // see ref http://soledadpenades.com/articles/three-js-tutorials/object-pk/
        //if(me.pk && (e.altKey || e.ctrlKey || e.shiftKey || e.keyCode === 18 || e.keyCode === 16 || e.keyCode === 17 || e.keyCode === 224 || e.keyCode === 91) ) {
        //    me.highlightlevel = me.pk;

            me.mouse.x = ( (x - me.container.offset().left) / me.container.width() ) * 2 - 1;
            me.mouse.y = - ( (y - me.container.offset().top) / me.container.height() ) * 2 + 1;

            var mouse3 = new THREE.Vector3();
            mouse3.x = me.mouse.x;
            mouse3.y = me.mouse.y;
            //mouse3.z = 0.5;
            if(this.cam_z > 0) {
              mouse3.z = -1.0; // between -1 to 1. The z positio of mouse in the real world should be between the camera and the target."-1" worked in our case.
            }
            else {
              mouse3.z = 1.0; // between -1 to 1. The z positio of mouse in the real world should be between the camera and the target."-1" worked in our case.
            }

            // similar to setFromCamera() except mouse3.z is the opposite sign from the value in setFromCamera()
            if(me.cam === me.perspectiveCamera) { // perspective
                if(this.cam_z > 0) {
                  mouse3.z = -1.0;
                }
                else {
                  mouse3.z = 1.0;
                }
                //me.projector.unprojectVector( mouse3, me.cam );  // works for all versions
                mouse3.unproject(me.cam );  // works for all versions
                me.raycaster.set(me.cam.position, mouse3.sub(me.cam.position).normalize()); // works for all versions
            }
            else if(me.cam === me.orthographicCamera) {  // orthographics
                if(this.cam_z > 0) {
                  mouse3.z = 1.0;
                }
                else {
                  mouse3.z = -1.0;
                }
                //me.projector.unprojectVector( mouse3, me.cam );  // works for all versions
                mouse3.unproject(me.cam );  // works for all versions
                me.raycaster.set(mouse3, new THREE.Vector3(0,0,-1).transformDirection( me.cam.matrixWorld )); // works for all versions
            }

            var intersects = me.raycaster.intersectObjects( me.objects ); // not all "mdl" group will be used for pk

            var bFound = false;

            var position = me.mdl.position;
            if ( intersects.length > 0 ) {
                // the intersections are sorted so that the closest point is the first one.
                intersects[ 0 ].point.sub(position); // mdl.position was moved to the original (0,0,0) after reading the molecule coordinates. The raycasting was done based on the original. The positio of the ooriginal should be substracted.

                var threshold = 0.5;
                var atom = me.getAtomsFromPosition(intersects[ 0 ].point, threshold); // the second parameter is the distance threshold. The first matched atom will be returned. Use 1 angstrom, not 2 angstrom. If it's 2 angstrom, other atom will be returned.

                while(!atom && threshold < 10) {
                    threshold = threshold + 0.5;
                    atom = me.getAtomsFromPosition(intersects[ 0 ].point, threshold);
                }

                if(atom) {
                    bFound = true;
                    if(me.pickpair) {
                        if(bClick) {
                          if(me.pAtomNum % 2 === 0) {
                            me.pAtom = atom;
                          }
                          else {
                            me.pAtom2 = atom;
                          }

                          ++me.pAtomNum;
                        }
                    }
                    else {
                      me.pAtom = atom;
                    }

                    if(bClick) {
                      me.showPicking(atom);
                    }
                    else {
                      me.showPicking(atom, popupX, popupY);
                    }
                }
                else {
                    console.log("No atoms were found in 10 andstrom range");
                }
            } // end if

            if(!bFound) {
                intersects = me.raycaster.intersectObjects( me.objects_ghost ); // not all "mdl" group will be used for pk

                position = me.mdl_ghost.position;
                if ( intersects.length > 0 ) {
                    // the intersections are sorted so that the closest point is the first one.
                    intersects[ 0 ].point.sub(position); // mdl.position was moved to the original (0,0,0) after reading the molecule coordinates. The raycasting was done based on the original. The positio of the ooriginal should be substracted.

                    var threshold = 0.5;
                    var atom = me.getAtomsFromPosition(intersects[ 0 ].point, threshold); // the second parameter is the distance threshold. The first matched atom will be returned. Use 1 angstrom, not 2 angstrom. If it's 2 angstrom, other atom will be returned.

                    while(!atom && threshold < 10) {
                        threshold = threshold + 0.5;
                        atom = me.getAtomsFromPosition(intersects[ 0 ].point, threshold);
                    }

                    if(atom) {
                        if(me.pickpair) {
                            if(bClick) {
                              if(me.pAtomNum % 2 === 0) {
                                me.pAtom = atom;
                              }
                              else {
                                me.pAtom2 = atom;
                              }

                              ++me.pAtomNum;
                            }
                        }
                        else {
                          me.pAtom = atom;
                        }

                        if(bClick) {
                          me.showPicking(atom);
                        }
                        else {
                          me.showPicking(atom, popupX, popupY);
                        }
                    }
                    else {
                        console.log("No atoms were found in 10 andstrom range");
                    }
                } // end if
            }
        //}
    },

    setRotation: function(axis, angle) { var me = this;
          axis.applyQuaternion( me.cam.quaternion ).normalize();

          var quaternion = new THREE.Quaternion();
          quaternion.setFromAxisAngle( axis, -angle );

          var para = {};
          para.quaternion = quaternion;
          para.update = true;

          me.controls.update(para);
          me.render();
    },

    setOutlineColor: function(colorStr) {
        // outline using ShaderMaterial: http://jsfiddle.net/Eskel/g593q/9/
        var shader = {
            'outline' : {
                vertex_shader: [
                    "uniform float offset;",
                    "void main() {",
                        "vec4 pos = modelViewMatrix * vec4( position + normal * offset, 1.0 );",
                        "gl_Position = projectionMatrix * pos;",
                    "}"
                ].join("\n"),

                fragment_shader: [
                    "void main(){",
                        "gl_FragColor = vec4( 1.0, 1.0, 0.0, 1.0 );",
                    "}"
                ].join("\n")
            }
        };

        if(colorStr === 'yellow') {
           shader.outline.fragment_shader = [
               "void main(){",
                   "gl_FragColor = vec4( 1.0, 1.0, 0.0, 1.0 );",
               "}"
           ].join("\n");
        }
        else if(colorStr === 'green') {
           shader.outline.fragment_shader = [
               "void main(){",
                   "gl_FragColor = vec4( 0.0, 1.0, 0.0, 1.0 );",
               "}"
           ].join("\n");
        }
        else if(colorStr === 'red') {
           shader.outline.fragment_shader = [
               "void main(){",
                   "gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );",
               "}"
           ].join("\n");
        }

        // shader
        var uniforms = {offset: {
            type: "f",
            //value: 1
            value: 0.5
          }
        };

        var outShader = shader['outline'];

        var matShader = new THREE.ShaderMaterial({
            uniforms: uniforms,
            vertexShader: outShader.vertex_shader,
            fragmentShader: outShader.fragment_shader,
            depthTest: false,
            depthWrite: false,
            needsUpdate: true
        });

        return matShader;
    },

    // modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
    setWidthHeight: function(width, height) {
        //this.renderer.setSize(width, height);

        //antialiasing by render twice large:
        //https://stackoverflow.com/questions/17224795/antialiasing-not-working-in-three-js
        this.renderer.setSize(width*this.scaleFactor, height*this.scaleFactor);
        this.renderer.domElement.style.width = width + "px";
        this.renderer.domElement.style.height = height + "px";
        this.renderer.domElement.width = width*this.scaleFactor;
        this.renderer.domElement.height = height*this.scaleFactor;

        this.container.widthInv  = 1 / (this.scaleFactor*width);
        this.container.heightInv = 1 / (this.scaleFactor*height);
        this.container.whratio = width / height;
    },

    // added nucleotides and ions
    nucleotidesArray: ['  G', '  A', '  T', '  C', '  U', ' DG', ' DA', ' DT', ' DC', ' DU'],

    ionsArray: ['  K', ' NA', ' MG', ' AL', ' CA', ' TI', ' MN', ' FE', ' NI', ' CU', ' ZN', ' AG', ' BA', '  F', ' CL', ' BR', '  I'],

    vdwRadii: { // Hu, S.Z.; Zhou, Z.H.; Tsai, K.R. Acta Phys.-Chim. Sin., 2003, 19:1073.
         H: 1.08,
        HE: 1.34,
        LI: 1.75,
        BE: 2.05,
         B: 1.47,
         C: 1.49,
         N: 1.41,
         O: 1.40,
         F: 1.39,
        NE: 1.68,
        NA: 1.84,
        MG: 2.05,
        AL: 2.11,
        SI: 2.07,
         P: 1.92,
         S: 1.82,
        CL: 1.83,
        AR: 1.93,
         K: 2.05,
        CA: 2.21,
        SC: 2.16,
        TI: 1.87,
         V: 1.79,
        CR: 1.89,
        MN: 1.97,
        FE: 1.94,
        CO: 1.92,
        NI: 1.84,
        CU: 1.86,
        ZN: 2.10,
        GA: 2.08,
        GE: 2.15,
        AS: 2.06,
        SE: 1.93,
        BR: 1.98,
        KR: 2.12,
        RB: 2.16,
        SR: 2.24,
         Y: 2.19,
        ZR: 1.86,
        NB: 2.07,
        MO: 2.09,
        TC: 2.09,
        RU: 2.07,
        RH: 1.95,
        PD: 2.02,
        AG: 2.03,
        CD: 2.30,
        IN: 2.36,
        SN: 2.33,
        SB: 2.25,
        TE: 2.23,
         I: 2.23,
        XE: 2.21,
        CS: 2.22,
        BA: 2.51,
        LA: 2.40,
        CE: 2.35,
        PR: 2.39,
        ND: 2.29,
        PM: 2.36,
        SM: 2.29,
        EU: 2.33,
        GD: 2.37,
        TB: 2.21,
        DY: 2.29,
        HO: 2.16,
        ER: 2.35,
        TM: 2.27,
        YB: 2.42,
        LU: 2.21,
        HF: 2.12,
        TA: 2.17,
         W: 2.10,
        RE: 2.17,
        OS: 2.16,
        IR: 2.02,
        PT: 2.09,
        AU: 2.17,
        HG: 2.09,
        TL: 2.35,
        PB: 2.32,
        BI: 2.43,
        PO: 2.29,
        AT: 2.36,
        RN: 2.43,
        FR: 2.56,
        RA: 2.43,
        AC: 2.60,
        TH: 2.37,
        PA: 2.43,
         U: 2.40,
        NP: 2.21,
        PU: 2.56,
        AM: 2.56,
        CM: 2.56,
        BK: 2.56,
        CF: 2.56,
        ES: 2.56,
        FM: 2.56,
    },

    covalentRadii: { // http://en.wikipedia.org/wiki/Covalent_radius
         H: 0.31,
        HE: 0.28,
        LI: 1.28,
        BE: 0.96,
         B: 0.84,
         C: 0.76,
         N: 0.71,
         O: 0.66,
         F: 0.57,
        NE: 0.58,
        NA: 1.66,
        MG: 1.41,
        AL: 1.21,
        SI: 1.11,
         P: 1.07,
         S: 1.05,
        CL: 1.02,
        AR: 1.06,
         K: 2.03,
        CA: 1.76,
        SC: 1.70,
        TI: 1.60,
         V: 1.53,
        CR: 1.39,
        MN: 1.39,
        FE: 1.32,
        CO: 1.26,
        NI: 1.24,
        CU: 1.32,
        ZN: 1.22,
        GA: 1.22,
        GE: 1.20,
        AS: 1.19,
        SE: 1.20,
        BR: 1.20,
        KR: 1.16,
        RB: 2.20,
        SR: 1.95,
         Y: 1.90,
        ZR: 1.75,
        NB: 1.64,
        MO: 1.54,
        TC: 1.47,
        RU: 1.46,
        RH: 1.42,
        PD: 1.39,
        AG: 1.45,
        CD: 1.44,
        IN: 1.42,
        SN: 1.39,
        SB: 1.39,
        TE: 1.38,
         I: 1.39,
        XE: 1.40,
        CS: 2.44,
        BA: 2.15,
        LA: 2.07,
        CE: 2.04,
        PR: 2.03,
        ND: 2.01,
        PM: 1.99,
        SM: 1.98,
        EU: 1.98,
        GD: 1.96,
        TB: 1.94,
        DY: 1.92,
        HO: 1.92,
        ER: 1.89,
        TM: 1.90,
        YB: 1.87,
        LU: 1.87,
        HF: 1.75,
        TA: 1.70,
         W: 1.62,
        RE: 1.51,
        OS: 1.44,
        IR: 1.41,
        PT: 1.36,
        AU: 1.36,
        HG: 1.32,
        TL: 1.45,
        PB: 1.46,
        BI: 1.48,
        PO: 1.40,
        AT: 1.50,
        RN: 1.50,
        FR: 2.60,
        RA: 2.21,
        AC: 2.15,
        TH: 2.06,
        PA: 2.00,
         U: 1.96,
        NP: 1.90,
        PU: 1.87,
        AM: 1.80,
        CM: 1.69,
    },

    //rasmol-like element colors
    atomColors: {
        'H': new THREE.Color(0xFFFFFF),
        'He': new THREE.Color(0xFFC0CB),
        'HE': new THREE.Color(0xFFC0CB),
        'Li': new THREE.Color(0xB22222),
        'LI': new THREE.Color(0xB22222),
        'B': new THREE.Color(0x00FF00),
        'C': new THREE.Color(0xC8C8C8),
        'N': new THREE.Color(0x8F8FFF),
        'O': new THREE.Color(0xF00000),
        'F': new THREE.Color(0xDAA520),
        'Na': new THREE.Color(0x0000FF),
        'NA': new THREE.Color(0x0000FF),
        'Mg': new THREE.Color(0x228B22),
        'MG': new THREE.Color(0x228B22),
        'Al': new THREE.Color(0x808090),
        'AL': new THREE.Color(0x808090),
        'Si': new THREE.Color(0xDAA520),
        'SI': new THREE.Color(0xDAA520),
        'P': new THREE.Color(0xFFA500),
        'S': new THREE.Color(0xFFC832),
        'Cl': new THREE.Color(0x00FF00),
        'CL': new THREE.Color(0x00FF00),
        'Ca': new THREE.Color(0x808090),
        'CA': new THREE.Color(0x808090),
        'Ti': new THREE.Color(0x808090),
        'TI': new THREE.Color(0x808090),
        'Cr': new THREE.Color(0x808090),
        'CR': new THREE.Color(0x808090),
        'Mn': new THREE.Color(0x808090),
        'MN': new THREE.Color(0x808090),
        'Fe': new THREE.Color(0xFFA500),
        'FE': new THREE.Color(0xFFA500),
        'Ni': new THREE.Color(0xA52A2A),
        'NI': new THREE.Color(0xA52A2A),
        'Cu': new THREE.Color(0xA52A2A),
        'CU': new THREE.Color(0xA52A2A),
        'Zn': new THREE.Color(0xA52A2A),
        'ZN': new THREE.Color(0xA52A2A),
        'Br': new THREE.Color(0xA52A2A),
        'BR': new THREE.Color(0xA52A2A),
        'Ag': new THREE.Color(0x808090),
        'AG': new THREE.Color(0x808090),
        'I': new THREE.Color(0xA020F0),
        'Ba': new THREE.Color(0xFFA500),
        'BA': new THREE.Color(0xFFA500),
        'Au': new THREE.Color(0xDAA520),
        'AU': new THREE.Color(0xDAA520)
    },

    defaultAtomColor: new THREE.Color(0xCCCCCC),

    stdChainColors: [
            // first 6 colors from MMDB
            new THREE.Color(0xFF00FF),
            new THREE.Color(0x0000FF),
            new THREE.Color(0x996633),
            new THREE.Color(0x00FF99),
            new THREE.Color(0xFF9900),
            new THREE.Color(0xFF6666),

            new THREE.Color(0x32CD32),
            new THREE.Color(0x1E90FF),
            new THREE.Color(0xFA8072),
            new THREE.Color(0xFFA500),
            new THREE.Color(0x00CED1),
            new THREE.Color(0xFF69B4),

            new THREE.Color(0x00FF00),
            new THREE.Color(0x0000FF),
            new THREE.Color(0xFF0000),
            new THREE.Color(0xFFFF00),
            new THREE.Color(0x00FFFF),
            new THREE.Color(0xFF00FF),

            new THREE.Color(0x3CB371),
            new THREE.Color(0x4682B4),
            new THREE.Color(0xCD5C5C),
            new THREE.Color(0xFFE4B5),
            new THREE.Color(0xAFEEEE),
            new THREE.Color(0xEE82EE),

            new THREE.Color(0x006400),
            new THREE.Color(0x00008B),
            new THREE.Color(0x8B0000),
            new THREE.Color(0xCD853F),
            new THREE.Color(0x008B8B),
            new THREE.Color(0x9400D3)
        ],

    backgroundColors: {
        black: new THREE.Color(0x000000),
         grey: new THREE.Color(0xCCCCCC),
        white: new THREE.Color(0xFFFFFF),
        transparent: new THREE.Color(0x000000)
    },

    residueColors: {
        ALA: new THREE.Color(0xC8C8C8),
        ARG: new THREE.Color(0x145AFF),
        ASN: new THREE.Color(0x00DCDC),
        ASP: new THREE.Color(0xE60A0A),
        CYS: new THREE.Color(0xE6E600),
        GLN: new THREE.Color(0x00DCDC),
        GLU: new THREE.Color(0xE60A0A),
        GLY: new THREE.Color(0xEBEBEB),
        HIS: new THREE.Color(0x8282D2),
        ILE: new THREE.Color(0x0F820F),
        LEU: new THREE.Color(0x0F820F),
        LYS: new THREE.Color(0x145AFF),
        MET: new THREE.Color(0xE6E600),
        PHE: new THREE.Color(0x3232AA),
        PRO: new THREE.Color(0xDC9682),
        SER: new THREE.Color(0xFA9600),
        THR: new THREE.Color(0xFA9600),
        TRP: new THREE.Color(0xB45AB4),
        TYR: new THREE.Color(0x3232AA),
        VAL: new THREE.Color(0x0F820F),
        ASX: new THREE.Color(0xFF69B4),
        GLX: new THREE.Color(0xFF69B4),
          'G': new THREE.Color(0x008000),
          'A': new THREE.Color(0x6080FF),
          'T': new THREE.Color(0xFF8000),
          'C': new THREE.Color(0xFF0000),
          'U': new THREE.Color(0xFF8000),
         'DG': new THREE.Color(0x008000),
         'DA': new THREE.Color(0x6080FF),
         'DT': new THREE.Color(0xFF8000),
         'DC': new THREE.Color(0xFF0000),
         'DU': new THREE.Color(0xFF8000)
    },

    defaultResidueColor: new THREE.Color(0xBEA06E),

    chargeColors: {
// charged residues
        '  G': new THREE.Color(0xFF0000),
        '  A': new THREE.Color(0xFF0000),
        '  T': new THREE.Color(0xFF0000),
        '  C': new THREE.Color(0xFF0000),
        '  U': new THREE.Color(0xFF0000),
        ' DG': new THREE.Color(0xFF0000),
        ' DA': new THREE.Color(0xFF0000),
        ' DT': new THREE.Color(0xFF0000),
        ' DC': new THREE.Color(0xFF0000),
        ' DU': new THREE.Color(0xFF0000),
          'G': new THREE.Color(0xFF0000),
          'A': new THREE.Color(0xFF0000),
          'T': new THREE.Color(0xFF0000),
          'C': new THREE.Color(0xFF0000),
          'U': new THREE.Color(0xFF0000),
         'DG': new THREE.Color(0xFF0000),
         'DA': new THREE.Color(0xFF0000),
         'DT': new THREE.Color(0xFF0000),
         'DC': new THREE.Color(0xFF0000),
         'DU': new THREE.Color(0xFF0000),
        'ARG': new THREE.Color(0x0000FF),
        'LYS': new THREE.Color(0x0000FF),
        'ASP': new THREE.Color(0xFF0000),
        'GLU': new THREE.Color(0xFF0000),

// hydrophobic
        'GLY': new THREE.Color(0x888888),
        'PRO': new THREE.Color(0x888888),
        'ALA': new THREE.Color(0x888888),
        'VAL': new THREE.Color(0x888888),
        'LEU': new THREE.Color(0x888888),
        'ILE': new THREE.Color(0x888888),
        'PHE': new THREE.Color(0x888888),

// polar
        'HIS': new THREE.Color(0x888888),
        'SER': new THREE.Color(0x888888),
        'THR': new THREE.Color(0x888888),
        'ASN': new THREE.Color(0x888888),
        'GLN': new THREE.Color(0x888888),
        'TYR': new THREE.Color(0x888888),
        'MET': new THREE.Color(0x888888),
        'CYS': new THREE.Color(0x888888),
        'TRP': new THREE.Color(0x888888)
    },

    hydrophobicColors: {
// charged residues
        '  G': new THREE.Color(0x888888),
        '  A': new THREE.Color(0x888888),
        '  T': new THREE.Color(0x888888),
        '  C': new THREE.Color(0x888888),
        '  U': new THREE.Color(0x888888),
        ' DG': new THREE.Color(0x888888),
        ' DA': new THREE.Color(0x888888),
        ' DT': new THREE.Color(0x888888),
        ' DC': new THREE.Color(0x888888),
        ' DU': new THREE.Color(0x888888),
          'G': new THREE.Color(0x888888),
          'A': new THREE.Color(0x888888),
          'T': new THREE.Color(0x888888),
          'C': new THREE.Color(0x888888),
          'U': new THREE.Color(0x888888),
         'DG': new THREE.Color(0x888888),
         'DA': new THREE.Color(0x888888),
         'DT': new THREE.Color(0x888888),
         'DC': new THREE.Color(0x888888),
         'DU': new THREE.Color(0x888888),
        'ARG': new THREE.Color(0x888888),
        'LYS': new THREE.Color(0x888888),
        'ASP': new THREE.Color(0x888888),
        'GLU': new THREE.Color(0x888888),

// hydrophobic
        'GLY': new THREE.Color(0x00FF00),
        'PRO': new THREE.Color(0x00FF00),
        'ALA': new THREE.Color(0x00FF00),
        'VAL': new THREE.Color(0x00FF00),
        'LEU': new THREE.Color(0x00FF00),
        'ILE': new THREE.Color(0x00FF00),
        'PHE': new THREE.Color(0x00FF00),

// polar
        'HIS': new THREE.Color(0x888888),
        'SER': new THREE.Color(0x888888),
        'THR': new THREE.Color(0x888888),
        'ASN': new THREE.Color(0x888888),
        'GLN': new THREE.Color(0x888888),
        'TYR': new THREE.Color(0x888888),
        'MET': new THREE.Color(0x888888),
        'CYS': new THREE.Color(0x888888),
        'TRP': new THREE.Color(0x888888)
    },

    sheetcolor: 'green',

    ssColors: {
        //helix: new THREE.Color(0xFF0080),
        helix: new THREE.Color(0xFF0000),
        //sheet: new THREE.Color(0xFFC800),
        sheet: new THREE.Color(0x008000),
         coil: new THREE.Color(0x6080FF)
    },

    ssColors2: {
        //helix: new THREE.Color(0xFF0080),
        helix: new THREE.Color(0xFF0000),
        sheet: new THREE.Color(0xFFC800),
        //sheet: new THREE.Color(0x008000),
         coil: new THREE.Color(0x6080FF)
    },

    //defaultBondColor: new THREE.Color(0x2194D6),
    defaultBondColor: new THREE.Color(0xBBBBBB), // cross residue bonds

    surfaces: {
        1: undefined,
        2: undefined,
        3: undefined,
        4: undefined
    },

    mapData: {},

    // from iview (http://istar.cse.cuhk.edu.hk/iview/)
    hasCovalentBond: function (atom0, atom1) {
        var r = this.covalentRadii[atom0.elem] + this.covalentRadii[atom1.elem];
        return atom0.coord.distanceToSquared(atom1.coord) < 1.3 * r * r;
    },

    init_base: function () {
        this.structures = {}; // structure name -> array of chains
        this.chains = {}; // structure_chain name -> atom hash
        this.residues = {}; // structure_chain_resi name -> atom hash
        this.secondaries = {}; // structure_chain_resi name -> secondary structure: 'c', 'H', or 'E'
        this.alnChains = {}; // structure_chain name -> atom hash

        this.chainsSeq = {}; // structure_chain name -> array of sequence
        this.chainsColor = {}; // structure_chain name -> color, show chain color in sequence display for mmdbid and align input
        this.chainsGene = {}; // structure_chain name -> gene, show chain gene symbol in sequence display for mmdbid and align input
        this.chainsAn = {}; // structure_chain name -> array of annotations, such as residue number
        this.chainsAnTitle = {}; // structure_chain name -> array of annotation title

        this.alnChainsSeq = {}; // structure_chain name -> array of residue object: {mmdbid, chain, resi, resn, aligned}
        this.alnChainsAnno = {}; // structure_chain name -> array of annotations, such as residue number
        this.alnChainsAnTtl = {}; // structure_chain name -> array of annotation title

        this.dAtoms = {}; // show selected atoms
        this.hAtoms = {}; // used to change color or dislay type for certain atoms

        this.pickedAtomList = {}; // used to switch among different highlight levels

        this.prevHighlightObjects = [];
        this.prevHighlightObjects_ghost = [];
        this.prevSurfaces = [];
        this.prevMaps = [];
        this.prevEmmaps = [];

        this.defNames2Residues = {}; // custom defined selection name -> residue array
        this.defNames2Atoms = {}; // custom defined selection name -> atom array
        this.defNames2Descr = {}; // custom defined selection name -> description
        this.defNames2Command = {}; // custom defined selection name -> command

        this.residueId2Name = {}; // structure_chain_resi -> one letter abbreviation

        this.atoms = {};
        this.dAtoms = {};
        this.hAtoms = {};
        this.proteins = {};
        this.sidec = {};
        this.nucleotides = {};
        this.nucleotidesO3 = {};

        this.chemicals = {};
        this.ions = {};
        this.water = {};
        this.calphas = {};

        this.hbondpnts = [];
        this.stabilizerpnts = [];
        //this.ncbondpnts = []; // non-covalent bonds

        this.doublebonds = {};
        this.triplebonds = {};
        this.aromaticbonds = {};

        this.atomPrevColors = {};

        this.style2atoms = {}; // style -> atom hash, 13 styles: ribbon, strand, cylinder and plate, nucleotide cartoon, o3 trace, schematic, c alpha trace, b factor tube, lines, stick, ball and stick, sphere, dot, nothing
        this.labels = {};     // hash of name -> a list of labels. Each label contains 'position', 'text', 'size', 'color', 'background'
                            // label name could be custom, residue, schmatic, distance
        this.lines = {};     // hash of name -> a list of solid or dashed lines. Each line contains 'position1', 'position2', 'color', and a boolean of 'dashed'
                            // line name could be custom, hbond, ssbond, distance

        this.rotateCount = 0;
        this.rotateCountMax = 20;
    },

    init: function () {
        this.init_base();

        this.molTitle = "";

        this.ssbondpnts = {}; // disulfide bonds for each structure

        this.inputid = {"idtype": undefined, "id":undefined}; // support pdbid, mmdbid

        this.biomtMatrices = [];
        this.bAssembly = true;

        this.bDrawn = false;
        this.bSecondaryStructure = false;
        this.bHighlight = 1; // undefined: no highlight, 1: highlight by outline, 2: highlight by 3D object
    },

    reinitAfterLoad: function () {
        this.dAtoms = this.cloneHash(this.atoms); // show selected atoms
        this.hAtoms = this.cloneHash(this.atoms); // used to change color or dislay type for certain atoms

        this.prevHighlightObjects = [];
        this.prevHighlightObjects_ghost = [];
        this.prevSurfaces = [];
        this.prevMaps = [];
        this.prevEmmaps = [];

        this.labels = {};   // hash of name -> a list of labels. Each label contains 'position', 'text', 'size', 'color', 'background'
                            // label name could be custom, residue, schmatic, distance
        this.lines = {};    // hash of name -> a list of solid or dashed lines. Each line contains 'position1', 'position2', 'color', and a boolean of 'dashed'
                            // line name could be custom, hbond, ssbond, distance

        this.bAssembly = true;
    }
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

// modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
iCn3D.prototype.loadPDB = function (src) {
    var helices = [], sheets = [];
    //this.atoms = {};
    var lines = src.split('\n');

    var chainsTmp = {}; // serial -> atom
    var residuesTmp = {}; // serial -> atom

    this.init();

    var sheetArray = [], sheetStart = [], sheetEnd = [], helixArray = [], helixStart = [], helixEnd = [];

    // Concatenation of two pdbs will have several atoms for the same serial
    var serial = 0;

    var moleculeNum = 1;
    var chainNum, residueNum, oriResidueNum;
    var prevChainNum = '', prevResidueNum = '', prevOriResidueNum = '', prevResi = 0;
    var prevRecord = '';
    var bModifyResi = false;

    var oriSerial2NewSerial = {};

    var chainMissingResidueArray = {};

    var id = 'stru';

    var maxMissingResi = 0, prevMissingChain = '';

    for (var i in lines) {
        var line = lines[i];
        var record = line.substr(0, 6);

        if (record === 'HEADER') {
            id = line.substr(62, 4);

            this.molTitle = '';

        } else if (record === 'TITLE ') {
            var name = line.substr(10);
            this.molTitle += name.trim() + " ";

        } else if (record === 'HELIX ') {
            this.bSecondaryStructure = true;

            var startChain = line.substr(19, 1);
            var startResi = parseInt(line.substr(21, 4));
            var endResi = parseInt(line.substr(33, 4));

            var chain_resi;
            for(var j = startResi; j <= endResi; ++j) {
              chain_resi = startChain + "_" + j;
              helixArray.push(chain_resi);

              if(j === startResi) helixStart.push(chain_resi);
              if(j === endResi) helixEnd.push(chain_resi);
            }

            helices.push({
                chain: startChain,
                initialResidue: startResi,
                initialInscode: line.substr(25, 1),
                terminalResidue: endResi,
                terminalInscode: line.substr(37, 1),
            });
        } else if (record === 'SHEET ') {
            this.bSecondaryStructure = true;

            var startChain = line.substr(21, 1);
            var startResi = parseInt(line.substr(22, 4));
            var endResi = parseInt(line.substr(33, 4));

            for(var j = startResi; j <= endResi; ++j) {
              var chain_resi = startChain + "_" + j;
              sheetArray.push(chain_resi);

              if(j === startResi) sheetStart.push(chain_resi);
              if(j === endResi) sheetEnd.push(chain_resi);
            }

            sheets.push({
                chain: startChain,
                initialResidue: startResi,
                initialInscode: line.substr(26, 1),
                terminalResidue: endResi,
                terminalInscode: line.substr(37, 1),
            });

        } else if (record === 'HBOND ') {
/*
            //HBOND A 1536   N2 A   59  ND2  -19.130  83.151  52.266 -18.079  81.613  49.427    3.40
            bCalculateHbond = false;

            var chemicalChain = line.substr(6, 1);
            var chemicalResi = line.substr(8, 4).replace(/ /g, "");
            var chemicalAtom = line.substr(14, 4).replace(/ /g, "");
            var proteinChain = line.substr(18, 1);
            var proteinResi = line.substr(20, 4).replace(/ /g, "");
            var proteinAtom = line.substr(25, 4).replace(/ /g, "");

            var chemical_x = parseFloat(line.substr(30, 8));
            var chemical_y = parseFloat(line.substr(38, 8));
            var chemical_z = parseFloat(line.substr(46, 8));
            var protein_x = parseFloat(line.substr(54, 8));
            var protein_y = parseFloat(line.substr(62, 8));
            var protein_z = parseFloat(line.substr(70, 8));

            var dist = line.substr(78, 8).replace(/ /g, "");

            this.hbondpnts.push(new THREE.Vector3(chemical_x, chemical_y, chemical_z));
            this.hbondpnts.push(new THREE.Vector3(protein_x, protein_y, protein_z));
*/
        } else if (record === 'SSBOND') {
            //SSBOND   1 CYS E   48    CYS E   51                          2555
            var chain1 = line.substr(15, 1);
            var resi1 = line.substr(17, 4).replace(/ /g, "");
            var resid1 = id + '_' + chain1 + '_' + resi1;

            var chain2 = line.substr(29, 1);
            var resi2 = line.substr(31, 4).replace(/ /g, "");
            var resid2 = id + '_' + chain2 + '_' + resi2;

            if(this.ssbondpnts[id] === undefined) this.ssbondpnts[id] = [];

            this.ssbondpnts[id].push(resid1);
            this.ssbondpnts[id].push(resid2);
        } else if (record === 'REMARK') {
             var type = parseInt(line.substr(7, 3));
             // from GLMol
             if (type == 350 && line.substr(13, 5) == 'BIOMT') {
                var n = parseInt(line[18]) - 1;
                //var m = parseInt(line.substr(21, 2));
                var m = parseInt(line.substr(21, 2)) - 1; // start from 1
                if (this.biomtMatrices[m] == undefined) this.biomtMatrices[m] = new THREE.Matrix4().identity();
                this.biomtMatrices[m].elements[n] = parseFloat(line.substr(24, 9));
                this.biomtMatrices[m].elements[n + 4] = parseFloat(line.substr(34, 9));
                this.biomtMatrices[m].elements[n + 8] = parseFloat(line.substr(44, 9));
                this.biomtMatrices[m].elements[n + 12] = parseFloat(line.substr(54, 10));
             }
             // missing residues
             else if (type == 465 && line.substr(18, 1) == ' ' && line.substr(20, 1) == ' ' && line.substr(21, 1) != 'S') {
                var resn = line.substr(15, 3);
                var chain = line.substr(19, 1);
                var resi = parseInt(line.substr(21, 5));

                //var structure = parseInt(line.substr(13, 1));
                //if(line.substr(13, 1) == ' ') structure = 1;

                //var chainNum = structure + '_' + chain;
                var chainNum = id + '_' + chain;

                if(chainMissingResidueArray[chainNum] === undefined) chainMissingResidueArray[chainNum] = [];
                var resObject = {};
                resObject.resi = resi;
                resObject.name = this.residueName2Abbr(resn).toLowerCase();

                if(chain != prevMissingChain) {
                    maxMissingResi = 0;
                }

                // not all listed residues are considered missing, e.g., PDB ID 4OR2, only the firts four residues are considered missing
                if(!isNaN(resi) && (prevMissingChain == '' || (chain != prevMissingChain) || (chain == prevMissingChain && resi > maxMissingResi)) ) {
                    chainMissingResidueArray[chainNum].push(resObject);

                    maxMissingResi = resi;
                    prevMissingChain = chain;
                }

             }
             else if (type == 900 && this.emd === undefined && line.substr(34).trim() == 'RELATED DB: EMDB') {
                 //REMARK 900 RELATED ID: EMD-3906   RELATED DB: EMDB
                 this.emd = line.substr(23, 11).trim();
             }
        } else if (record === 'ENDMDL') {
            ++moleculeNum;
        } else if (record === 'JRNL  ') {
            if(line.substr(12, 4) === 'PMID') {
                this.pmid = line.substr(19).trim();
            }
        } else if (record === 'ATOM  ' || record === 'HETATM') {
            var structure = (moleculeNum === 1) ? id : id + moleculeNum.toString();

            var alt = line.substr(16, 1);
            //if (alt !== " " && alt !== "A") continue;

            // "CA" has to appear before "O". Otherwise the cartoon of secondary structure will have breaks
            // Concatenation of two pdbs will have several atoms for the same serial
            ++serial;

            var serial2 = parseInt(line.substr(6, 5));
            oriSerial2NewSerial[serial2] = serial;

            var elem = line.substr(76, 2).replace(/ /g, "");
            if (elem === '') { // for some incorrect PDB files
               elem = line.substr(12, 2).replace(/ /g,"");
            }

            var chain = line.substr(21, 1);
            if(chain === '') chain = 1;

            chainNum = structure + "_" + chain;
            if(chainNum !== prevChainNum) {
                prevResi = 0;
                bModifyResi = false;
            }

            //var oriResi = line.substr(22, 4).trim();
            var oriResi = line.substr(22, 5).trim();
            oriResidueNum = chainNum + "_" + oriResi;
            //if(oriResidueNum !== prevOriResidueNum) {
            //    if(bModifyResi) {
            //      ++prevResi;
            //    }
            //    else {
            //      prevResi = (chainNum !== prevChainNum) ? 0 : parseInt(prevResidueNum.substr(prevResidueNum.lastIndexOf("_") + 1));
            //    }
            //}

            var resi = parseInt(oriResi);
            if(oriResi != resi || bModifyResi) { // e.g., 99A and 99
              bModifyResi = true;
              //resi = (prevResi == 0) ? resi : prevResi + 1;
            }

            residueNum = chainNum + "_" + resi;

            var atom = line.substr(12, 4).replace(/ /g, '');
            var chain_resi = chain + "_" + resi;

            var x = parseFloat(line.substr(30, 8));
            var y = parseFloat(line.substr(38, 8));
            var z = parseFloat(line.substr(46, 8));
            var resn = line.substr(17, 3);
            var coord = new THREE.Vector3(x, y, z);

            var atomDetails = {
                het: record[0] === 'H', // optional, used to determine chemicals, water, ions, etc
                serial: serial,         // required, unique atom id
                name: atom,             // required, atom name
                alt: alt,               // optional, some alternative coordinates
                resn: resn,             // optional, used to determine protein or nucleotide
                structure: structure,   // optional, used to identify structure
                chain: chain,           // optional, used to identify chain
                resi: resi,             // optional, used to identify residue ID
                //insc: line.substr(26, 1),
                coord: coord,           // required, used to draw 3D shape
                b: parseFloat(line.substr(60, 8)), // optional, used to draw B-factor tube
                elem: elem,             // optional, used to determine hydrogen bond
                bonds: [],              // required, used to connect atoms
                ss: 'coil',             // optional, used to show secondary structures
                ssbegin: false,         // optional, used to show the beginning of secondary structures
                ssend: false            // optional, used to show the end of secondary structures
            };

            this.atoms[serial] = atomDetails;

            this.dAtoms[serial] = 1;
            this.hAtoms[serial] = 1;

            // Assign secondary structures from the input
            // if a residue is assigned both sheet and helix, it is assigned as sheet
            if($.inArray(chain_resi, sheetArray) !== -1) {
              this.atoms[serial].ss = 'sheet';

              if($.inArray(chain_resi, sheetStart) !== -1) {
                this.atoms[serial].ssbegin = true;
              }

              // do not use else if. Some residues are both start and end of secondary structure
              if($.inArray(chain_resi, sheetEnd) !== -1) {
                this.atoms[serial].ssend = true;
              }
            }
            else if($.inArray(chain_resi, helixArray) !== -1) {
              this.atoms[serial].ss = 'helix';

              if($.inArray(chain_resi, helixStart) !== -1) {
                this.atoms[serial].ssbegin = true;
              }

              // do not use else if. Some residues are both start and end of secondary structure
              if($.inArray(chain_resi, helixEnd) !== -1) {
                this.atoms[serial].ssend = true;
              }
            }

            var secondaries = '-';
            if(this.atoms[serial].ss === 'helix') {
                secondaries = 'H';
            }
            else if(this.atoms[serial].ss === 'sheet') {
                secondaries = 'E';
            }
            //else if(this.atoms[serial].ss === 'coil') {
            //    secondaries = 'c';
            //}
            else if(!this.atoms[serial].het && this.residueColors.hasOwnProperty(this.atoms[serial].resn.toUpperCase()) ) {
                secondaries = 'c';
            }
            else {
                secondaries = 'o';
            }

            this.secondaries[residueNum] = secondaries;

            // different residue
            //if(residueNum !== prevResidueNum) {
            if(oriResidueNum !== prevOriResidueNum) {
                var residue = this.residueName2Abbr(resn);

                this.residueId2Name[residueNum] = residue;

                if(serial !== 1) this.residues[prevResidueNum] = residuesTmp;

                if(residueNum !== prevResidueNum) {
                    residuesTmp = {};
                }

                // different chain
                if(chainNum !== prevChainNum) {
                    // a chain could be separated in two sections
                    if(serial !== 1) {
                        //this.chains[prevChainNum] = this.unionHash2Atoms(this.chains[prevChainNum], chainsTmp);
                        this.chains[prevChainNum] = this.unionHash(this.chains[prevChainNum], chainsTmp);
                    }

                    chainsTmp = {};

                    if(this.structures[structure.toString()] === undefined) this.structures[structure.toString()] = [];
                    this.structures[structure.toString()].push(chainNum);

                    if(this.chainsSeq[chainNum] === undefined) this.chainsSeq[chainNum] = [];
/*
                    if(this.chainsAn[chainNum] === undefined ) this.chainsAn[chainNum] = [];
                    if(this.chainsAn[chainNum][0] === undefined ) this.chainsAn[chainNum][0] = [];
                    if(this.chainsAn[chainNum][1] === undefined ) this.chainsAn[chainNum][1] = [];
                    if(this.chainsAnTitle[chainNum] === undefined ) this.chainsAnTitle[chainNum] = [];
                    if(this.chainsAnTitle[chainNum][0] === undefined ) this.chainsAnTitle[chainNum][0] = [];
                    if(this.chainsAnTitle[chainNum][1] === undefined ) this.chainsAnTitle[chainNum][1] = [];
*/
                      var resObject = {};
                      resObject.resi = resi;
                      resObject.name = residue;

                    this.chainsSeq[chainNum].push(resObject);

/*
                      var numberStr = '';
                      if(resi % 10 === 0) numberStr = resi.toString();

                    this.chainsAn[chainNum][0].push(numberStr);
                    this.chainsAn[chainNum][1].push(secondaries);
                    this.chainsAnTitle[chainNum][0].push("");
                    this.chainsAnTitle[chainNum][1].push("SS");
*/
                }
                else {
                      var resObject = {};
                      resObject.resi = resi;
                      resObject.name = residue;

                    this.chainsSeq[chainNum].push(resObject);

/*
                      var numberStr = '';
                      if(resi % 10 === 0) numberStr = resi.toString();

                    this.chainsAn[chainNum][0].push(numberStr);
                    this.chainsAn[chainNum][1].push(secondaries);
*/
                }
            }

            chainsTmp[serial] = 1;
            residuesTmp[serial] = 1;

            prevRecord = record;

            prevChainNum = chainNum;
            prevResidueNum = residueNum;
            prevOriResidueNum = oriResidueNum;

        } else if (record === 'CONECT') {
            var from = parseInt(line.substr(6, 5));
            for (var j = 0; j < 4; ++j) {
                var to = parseInt(line.substr([11, 16, 21, 26][j], 5));
                if (isNaN(to)) continue;

                if(this.atoms[oriSerial2NewSerial[from]] !== undefined) this.atoms[oriSerial2NewSerial[from]].bonds.push(oriSerial2NewSerial[to]);
            }
        } else if (record.substr(0,3) === 'TER') {
            // Concatenation of two pdbs will have several atoms for the same serial
            ++serial;
        }
    }

    // copy disulfide bonds
    var structureArray = Object.keys(this.structures);
    for(var s = 0, sl = structureArray.length; s < sl; ++s) {
        var structure = structureArray[s];

        if(structure == id) continue;

        if(this.ssbondpnts[structure] === undefined) this.ssbondpnts[structure] = [];

        if(this.ssbondpnts[id] !== undefined) {
            for(var j = 0, jl = this.ssbondpnts[id].length; j < jl; ++j) {
                var ori_resid = this.ssbondpnts[id][j];
                var pos = ori_resid.indexOf('_');
                var resid = structure + ori_resid.substr(pos);

                this.ssbondpnts[structure].push(resid);
            }
        }
    }

    this.adjustSeq(chainMissingResidueArray);

//    this.missingResidues = [];
//    for(var chainid in chainMissingResidueArray) {
//        var resArray = chainMissingResidueArray[chainid];
//        for(var i = 0; i < resArray.length; ++i) {
//            this.missingResidues.push(chainid + '_' + resArray[i].resi);
//        }
//    }

    // remove the reference
    lines = null;

    // add the last residue set
    this.residues[residueNum] = residuesTmp;
    this.chains[chainNum] = this.unionHash2Atoms(this.chains[chainNum], chainsTmp);

    var curChain, curResi, curInsc, curResAtoms = [], me = this;
    // refresh for atoms in each residue
    var refreshBonds = function (f) {
        var n = curResAtoms.length;
        for (var j = 0; j < n; ++j) {
            var atom0 = curResAtoms[j];
            for (var k = j + 1; k < n; ++k) {
                var atom1 = curResAtoms[k];
                if (atom0.alt === atom1.alt && me.hasCovalentBond(atom0, atom1)) {
                //if (me.hasCovalentBond(atom0, atom1)) {
                    atom0.bonds.push(atom1.serial);
                    atom1.bonds.push(atom0.serial);
                }
            }
            f && f(atom0);
        }
    };
    var pmin = new THREE.Vector3( 9999, 9999, 9999);
    var pmax = new THREE.Vector3(-9999,-9999,-9999);
    var psum = new THREE.Vector3();
    var cnt = 0;

    // lipids may be considered as protein if "ATOM" instead of "HETATM" was used
    var lipidResidHash = {};

    // assign atoms
    for (var i in this.atoms) {
        var atom = this.atoms[i];
        var coord = atom.coord;
        psum.add(coord);
        pmin.min(coord);
        pmax.max(coord);
        ++cnt;

        if(!atom.het) {
          if($.inArray(atom.resn, this.nucleotidesArray) !== -1) {
            this.nucleotides[atom.serial] = 1;
            //if (atom.name === 'P') {
            if (atom.name === "O3'" || atom.name === "O3*") {
                this.nucleotidesO3[atom.serial] = 1;

                this.secondaries[atom.structure + '_' + atom.chain + '_' + atom.resi] = 'o'; // nucleotide
            }
          }
          else {
            if (atom.elem === 'P') {
                lipidResidHash[atom.structure + '_' + atom.chain + '_' + atom.resi] = 1;
            }

            this.proteins[atom.serial] = 1;
            if (atom.name === 'CA') this.calphas[atom.serial] = 1;
            if (atom.name !== 'N' && atom.name !== 'CA' && atom.name !== 'C' && atom.name !== 'O') this.sidec[atom.serial] = 1;
          }
        }
        else if(atom.het) {
          if(atom.resn === 'HOH' || atom.resn === 'WAT' || atom.resn === 'SOL') {
            this.water[atom.serial] = 1;
          }
          else if($.inArray(atom.resn, this.ionsArray) !== -1 || atom.elem.trim() === atom.resn.trim()) {
            this.ions[atom.serial] = 1;
          }
          else {
            this.chemicals[atom.serial] = 1;
          }
        }

        if (!(curChain === atom.chain && curResi === atom.resi)) {
            // a new residue, add the residue-residue bond beides the regular bonds
            refreshBonds(function (atom0) {
                if (((atom0.name === 'C' && atom.name === 'N') || (atom0.name === 'O3\'' && atom.name === 'P')) && me.hasCovalentBond(atom0, atom)) {
                    atom0.bonds.push(atom.serial);
                    atom.bonds.push(atom0.serial);
                }
            });
            curChain = atom.chain;
            curResi = atom.resi;
            //curInsc = atom.insc;
            curResAtoms.length = 0;
        }
        curResAtoms.push(atom);
    } // end of for

    // reset lipid
    for(resid in lipidResidHash) {
        var atomHash = this.residues[resid];
        for(serial in atomHash) {
            var atom = this.atoms[serial];

            atom.het = true;
            this.chemicals[atom.serial] = 1;
            this.secondaries[resid] = 'o'; // nucleotide

            delete this.proteins[atom.serial];
            if (atom.name === 'CA') delete this.calphas[atom.serial];
            if (atom.name !== 'N' && atom.name !== 'CA' && atom.name !== 'C' && atom.name !== 'O') delete this.sidec[atom.serial];
        }
    }

    // last residue
    refreshBonds();

    this.pmin = pmin;
    this.pmax = pmax;

    this.cnt = cnt;

    this.maxD = this.pmax.distanceTo(this.pmin);
    this.center = psum.multiplyScalar(1.0 / this.cnt);

    if (this.maxD < 5) this.maxD = 5;

    this.oriMaxD = this.maxD;
    this.oriCenter = this.center.clone();
};

iCn3D.prototype.adjustSeq = function (chainMissingResidueArray) {
    // adjust sequences
    for(var chainNum in this.chainsSeq) {
        if(chainMissingResidueArray[chainNum] === undefined) continue;

        var A = this.chainsSeq[chainNum];
        //var A2 = this.chainsAn[chainNum][0];
        //var A3 = this.chainsAn[chainNum][1];
        var B = chainMissingResidueArray[chainNum];

        var m = A.length;
        var n = B.length;

        var C = new Array(m + n);
        //var C2 = new Array(m + n);
        //var C3 = new Array(m + n);

        // http://www.algolist.net/Algorithms/Merge/Sorted_arrays
        // m - size of A
        // n - size of B
        // size of C array must be equal or greater than m + n
          var i, j, k;
          i = 0;
          j = 0;
          k = 0;
          while (i < m && j < n) {
                if (A[i].resi <= B[j].resi) {
                      C[k] = A[i];
                      //C2[k] = A2[i];
                      //C3[k] = A3[i];
                      i++;
                } else {
                      C[k] = B[j];
                      //if(B[j].resi % 10 === 0) {
                      //    C2[k] = B[j].resi.toString();
                      //}
                      //else {
                      //    C2[k] = '';
                      //}
                      //C3[k] = '-';
                      j++;
                }
                k++;
          }
          if (i < m) {
                for (var p = i; p < m; p++) {
                      C[k] = A[p];
                      //C2[k] = A2[p];
                      //C3[k] = A3[p];
                      k++;
                }
          } else {
                for (var p = j; p < n; p++) {
                      C[k] = B[p];
                      //if(B[p].resi % 10 === 0) {
                      //    C2[k] = B[p].resi.toString();
                      //}
                      //else {
                      //    C2[k] = '';
                      //}
                      //C3[k] = '-';
                      k++;
                }
          }

        this.chainsSeq[chainNum] = C;
        //this.chainsAn[chainNum][0] = C2;
        //this.chainsAn[chainNum][1] = C3;
    }
};
/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

// modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
iCn3D.prototype.createSphere = function (atom, defaultRadius, forceDefault, scale, bHighlight) {
    var mesh;

    if(defaultRadius === undefined) defaultRadius = 0.8;
    if(forceDefault === undefined) forceDefault = false;
    if(scale === undefined) scale = 1.0;

    var radius = (this.vdwRadii[atom.elem] || defaultRadius);

    if(bHighlight === 2) {
      //if(scale > 0.9) { // sphere
      //  scale = 1.5;
      //}
      //else if(scale < 0.5) { // dot
      //  scale = 1.0;
      //}

      scale *= 1.5;

      var color = this.hColor;

      mesh = new THREE.Mesh(this.sphereGeometry, new THREE.MeshPhongMaterial({ transparent: true, opacity: 0.5, specular: this.frac, shininess: 30, emissive: 0x000000, color: color }));

      mesh.scale.x = mesh.scale.y = mesh.scale.z = forceDefault ? defaultRadius :  radius * (scale ? scale : 1);
      mesh.position.copy(atom.coord);
      this.mdl.add(mesh);
    }
    else if(bHighlight === 1) {
      mesh = new THREE.Mesh(this.sphereGeometry, this.matShader);

      mesh.scale.x = mesh.scale.y = mesh.scale.z = forceDefault ? defaultRadius :  radius * (scale ? scale : 1);
      mesh.position.copy(atom.coord);
      mesh.renderOrder = this.renderOrderPicking;
      //this.mdlPicking.add(mesh);
      this.mdl.add(mesh);
    }
    else {
      if(atom.color === undefined) {
          atom.color = this.defaultAtomColor;
      }

      var color = atom.color;

      mesh = new THREE.Mesh(this.sphereGeometry, new THREE.MeshPhongMaterial({ specular: this.frac, shininess: 30, emissive: 0x000000, color: color }));
      mesh.scale.x = mesh.scale.y = mesh.scale.z = forceDefault ? defaultRadius :  radius * (scale ? scale : 1);
      mesh.position.copy(atom.coord);

      if(this.bImpo) {
          this.posArraySphere.push(atom.coord.x);
          this.posArraySphere.push(atom.coord.y);
          this.posArraySphere.push(atom.coord.z);

          this.colorArraySphere.push(atom.color.r);
          this.colorArraySphere.push(atom.color.g);
          this.colorArraySphere.push(atom.color.b);

          var realRadius = forceDefault ? defaultRadius :  radius * (scale ? scale : 1);
          this.radiusArraySphere.push(realRadius);

          if(this.cnt <= this.maxatomcnt) this.mdl_ghost.add(mesh);
      }
      else {
          this.mdl.add(mesh);
      }
    }

    //this.mdl.add(mesh);

    if(bHighlight === 1 || bHighlight === 2) {
        if(this.bImpo) {
            if(this.cnt <= this.maxatomcnt) this.prevHighlightObjects_ghost.push(mesh);
        }
        else {
            this.prevHighlightObjects.push(mesh);
        }
    }
    else {
        if(this.bImpo) {
            if(this.cnt <= this.maxatomcnt) this.objects_ghost.push(mesh);
        }
        else {
            this.objects.push(mesh);
        }
    }
};

// modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
iCn3D.prototype.createCylinder = function (p0, p1, radius, color, bHighlight, color2, bPicking) {
    var mesh;
    if(bHighlight === 1) {
        mesh = new THREE.Mesh(this.cylinderGeometryOutline, this.matShader);

        mesh.position.copy(p0).add(p1).multiplyScalar(0.5);
        mesh.matrixAutoUpdate = false;
        mesh.lookAt(p1.clone().sub(p0));
        mesh.updateMatrix();

        mesh.matrix.multiply(new THREE.Matrix4().makeScale(radius, radius, p0.distanceTo(p1))).multiply(new THREE.Matrix4().makeRotationX(Math.PI * 0.5));

        mesh.renderOrder = this.renderOrderPicking;
        //this.mdlPicking.add(mesh);
        this.mdl.add(mesh);

        this.prevHighlightObjects.push(mesh);
    }
    else {
        if(bHighlight === 2) {
          mesh = new THREE.Mesh(this.cylinderGeometry, new THREE.MeshPhongMaterial({ transparent: true, opacity: 0.5, specular: this.frac, shininess: 30, emissive: 0x000000, color: color }));

          radius *= 1.5;
        }
        else {
          mesh = new THREE.Mesh(this.cylinderGeometry, new THREE.MeshPhongMaterial({ specular: this.frac, shininess: 30, emissive: 0x000000, color: color }));
        }

        mesh.position.copy(p0).add(p1).multiplyScalar(0.5);
        mesh.matrixAutoUpdate = false;
        //mesh.lookAt(p0);
        mesh.lookAt(p1.clone().sub(p0));
        mesh.updateMatrix();

        mesh.matrix.multiply(new THREE.Matrix4().makeScale(radius, radius, p0.distanceTo(p1))).multiply(new THREE.Matrix4().makeRotationX(Math.PI * 0.5));

        if(this.bImpo) {
          this.posArray.push(p0.x);
          this.posArray.push(p0.y);
          this.posArray.push(p0.z);

          this.colorArray.push(color.r);
          this.colorArray.push(color.g);
          this.colorArray.push(color.b);

          this.pos2Array.push(p1.x);
          this.pos2Array.push(p1.y);
          this.pos2Array.push(p1.z);

          if(color2 !== undefined) {
              this.color2Array.push(color2.r);
              this.color2Array.push(color2.g);
              this.color2Array.push(color2.b);
          }
          else {
              this.color2Array.push(color.r);
              this.color2Array.push(color.g);
              this.color2Array.push(color.b);
          }

          this.radiusArray.push(radius);

          if(this.cnt <= this.maxatomcnt) this.mdl_ghost.add(mesh);
        }
        else {
            this.mdl.add(mesh);
        }

        if(bHighlight === 2) {
            if(this.bImpo) {
                if(this.cnt <= this.maxatomcnt) this.prevHighlightObjects_ghost.push(mesh);
            }
            else {
                this.prevHighlightObjects.push(mesh);
            }
        }
        else {
            if(this.bImpo) {
                if(this.cnt <= this.maxatomcnt) this.objects_ghost.push(mesh);
            }
            else {
                if(bPicking === undefined || bPicking) this.objects.push(mesh);
            }
        }
    }
};

// from iview (http://istar.cse.cuhk.edu.hk/iview/)
iCn3D.prototype.createRepresentationSub = function (atoms, f0, f01) {
    var me = this;

    //var ged = new THREE.Geometry();
    var clbondArray = [];
    for (var i in atoms) {
        var atom0 = atoms[i];
        f0 && f0(atom0);

        for (var j in atom0.bonds) {
            var atom1 = this.atoms[atom0.bonds[j]];
            if (atom1 === undefined || atom1.serial < atom0.serial) continue;
            if (atom1.chain === atom0.chain && ((atom1.resi === atom0.resi) || (atom0.name === 'C' && atom1.name === 'N') || (atom0.name === 'O3\'' && atom1.name === 'P') || (atom0.name === 'O3*' && atom1.name === 'P') || (atom0.name === 'SG' && atom1.name === 'SG'))) {
                f01 && f01(atom0, atom1);
            } else {
                //ged.vertices.push(atom0.coord);
                //ged.vertices.push(atom1.coord);
                clbondArray.push([atom0.coord, atom1.coord]);
            }
        }
    }
    //if (ged.vertices.length && this.bShowCrossResidueBond) {
    if (clbondArray.length > 0 && this.bShowCrossResidueBond) {
        //ged.computeLineDistances();
        //this.mdl.add(new THREE.Line(ged, new THREE.LineDashedMaterial({ linewidth: this.linewidth, color: this.defaultBondColor, dashSize: 0.3, gapSize: 0.15 }), THREE.LineSegments));
        var color = new THREE.Color(0x00FF00);

        for(var i = 0, il = clbondArray.length; i < il; ++i) {
            me.createCylinder(clbondArray[i][0], clbondArray[i][1], this.cylinderRadius, color, 0);
        }
    }
};

// modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
iCn3D.prototype.createSphereRepresentation = function (atoms, defaultRadius, forceDefault, scale, bHighlight) {
    var me = this;

    this.createRepresentationSub(atoms, function (atom0) {
        me.createSphere(atom0, defaultRadius, forceDefault, scale, bHighlight);
    });
};

iCn3D.prototype.createBoxRepresentation_P_CA = function (atoms, scale, bHighlight) {
    var me = this;
    this.createRepresentationSub(atoms, function (atom0) {
        if(atom0.name === 'CA' || atom0.name === "O3'" || atom0.name === "O3*") {
            me.createBox(atom0, undefined, undefined, scale, undefined, bHighlight);
        }
    });
};

// modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
iCn3D.prototype.createStickRepresentation = function (atoms, atomR, bondR, scale, bHighlight, bSchematic) {
    var me = this;
    var factor = (bSchematic !== undefined && bSchematic) ? atomR / me.cylinderRadius : 1;

//        if(bHighlight !== 2) {
        this.createRepresentationSub(atoms, function (atom0) {
                me.createSphere(atom0, atomR, !scale, scale, bHighlight);
        }, function (atom0, atom1) {
            var mp = atom0.coord.clone().add(atom1.coord).multiplyScalar(0.5);
            var pair = atom0.serial + '_' + atom1.serial;

            if(me.doublebonds.hasOwnProperty(pair)) { // show double bond
                var a0, a1, a2;

                var v0;
                var random = new THREE.Vector3(Math.random(),Math.random(),Math.random());
                if(atom0.bonds.length == 1 && atom1.bonds.length == 1) {
                    v0 = atom1.coord.clone();
                    v0.sub(atom0.coord);

                    var v = random.clone();
                    v0.cross(v).normalize().multiplyScalar(0.2 * factor);
                }
                else {
                    if(atom0.bonds.length >= atom1.bonds.length && atom0.bonds.length > 1) {
                        a0 = atom0.serial;
                        a1 = atom0.bonds[0];
                        a2 = atom0.bonds[1];
                    }
                    //else {
                    else if(atom1.bonds.length >= atom0.bonds.length && atom1.bonds.length > 1) {
                        a0 = atom1.serial;
                        a1 = atom1.bonds[0];
                        a2 = atom1.bonds[1];
                    }
                    else {
                        console.log("Double bond was not drawn due to the undefined cross plane");
                        return;
                    }

                    var v1 = me.atoms[a0].coord.clone();
                    v1.sub(me.atoms[a1].coord);
                    var v2 = me.atoms[a0].coord.clone();
                    v2.sub(me.atoms[a2].coord);

                    v1.cross(v2);

                    // parallel
                    if(parseInt(v1.length() * 10000) == 0) {
                        //v1 = random.clone();
                        // use a constant so that they are fixed,e.g., in CO2
                        v1 = new THREE.Vector3(0.2, 0.3, 0.5);
                    }

                    v0 = atom1.coord.clone();
                    v0.sub(atom0.coord);

                    v0.cross(v1).normalize().multiplyScalar(0.2 * factor);
                    // parallel
                    if(parseInt(v0.length() * 10000) == 0) {
                        //v1 = random.clone();
                        // use a constant so that they are fixed,e.g., in CO2
                        v1 = new THREE.Vector3(0.5, 0.3, 0.2);
                        v0.cross(v1).normalize().multiplyScalar(0.2 * factor);
                    }
                }

                if (atom0.color === atom1.color) {
                    me.createCylinder(atom0.coord.clone().add(v0), atom1.coord.clone().add(v0), me.cylinderRadius * factor * 0.3, atom0.color, bHighlight);
                    me.createCylinder(atom0.coord.clone().sub(v0), atom1.coord.clone().sub(v0), me.cylinderRadius * factor * 0.3, atom0.color, bHighlight);
                } else {
                    if(me.bImpo) {
                        me.createCylinder(atom0.coord.clone().add(v0), atom1.coord.clone().add(v0), me.cylinderRadius * factor * 0.3, atom0.color, bHighlight, atom1.color);
                        me.createCylinder(atom0.coord.clone().sub(v0), atom1.coord.clone().sub(v0), me.cylinderRadius * factor * 0.3, atom0.color, bHighlight, atom1.color);
                    }
                    else {
                        me.createCylinder(atom0.coord.clone().add(v0), mp.clone().add(v0), me.cylinderRadius * factor * 0.3, atom0.color, bHighlight);
                        me.createCylinder(atom1.coord.clone().add(v0), mp.clone().add(v0), me.cylinderRadius * factor * 0.3, atom1.color, bHighlight);

                        me.createCylinder(atom0.coord.clone().sub(v0), mp.clone().sub(v0), me.cylinderRadius * factor * 0.3, atom0.color, bHighlight);
                        me.createCylinder(atom1.coord.clone().sub(v0), mp.clone().sub(v0), me.cylinderRadius * factor * 0.3, atom1.color, bHighlight);
                    }
                }
            }
            else if(me.aromaticbonds.hasOwnProperty(pair)) { // show aromatic bond
                var a0, a1, a2;
                if(atom0.bonds.length > atom1.bonds.length && atom0.bonds.length > 1) {
                    a0 = atom0.serial;
                    a1 = atom0.bonds[0];
                    a2 = atom0.bonds[1];
                }
                else if(atom1.bonds.length > 1) {
                    a0 = atom1.serial;
                    a1 = atom1.bonds[0];
                    a2 = atom1.bonds[1];
                }
                else {
                    return;
                }

                var v1 = me.atoms[a0].coord.clone();
                v1.sub(me.atoms[a1].coord);
                var v2 = me.atoms[a0].coord.clone();
                v2.sub(me.atoms[a2].coord);

                v1.cross(v2);

                var v0 = atom1.coord.clone();
                v0.sub(atom0.coord);

                v0.cross(v1).normalize().multiplyScalar(0.2 * factor);

                // find an aromatic neighbor
                var aromaticNeighbor = 0;
                for(var i = 0, il = atom0.bondOrder.length; i < il; ++i) {
                    if(atom0.bondOrder[i] === '1.5' && atom0.bonds[i] !== atom1.serial) {
                        aromaticNeighbor = atom0.bonds[i];
                    }
                }

                var dashed = "add";
                if(aromaticNeighbor === 0 ) { // no neighbor found, atom order does not matter
                    dashed = "add";
                }
                else {
                    // calculate the angle between atom1, atom0add, atomNeighbor and the angle atom1, atom0sub, atomNeighbor
                    var atom0add = atom0.coord.clone().add(v0);
                    var atom0sub = atom0.coord.clone().sub(v0);

                    var a = atom1.coord.clone().sub(atom0add).normalize();
                    var b = me.atoms[aromaticNeighbor].coord.clone().sub(atom0add).normalize();

                    var c = atom1.coord.clone().sub(atom0sub).normalize();
                    var d = me.atoms[aromaticNeighbor].coord.clone().sub(atom0sub).normalize();

                    var angleadd = Math.acos(a.dot(b));
                    var anglesub = Math.acos(c.dot(d));

                    if(angleadd < anglesub) {
                        dashed = 'sub';
                    }
                    else {
                        dashed = 'add';
                    }
                }

                if (atom0.color === atom1.color) {
                    var base, step;
                    if(dashed === 'add') {
                        me.createCylinder(atom0.coord.clone().sub(v0), atom1.coord.clone().sub(v0), me.cylinderRadius * factor * 0.3, atom0.color, bHighlight);

                        base = atom0.coord.clone().add(v0);
                        step = atom1.coord.clone().add(v0).sub(base).multiplyScalar(1.0/11);
                    }
                    else {
                        me.createCylinder(atom0.coord.clone().add(v0), atom1.coord.clone().add(v0), me.cylinderRadius * factor * 0.3, atom0.color, bHighlight);

                        base = atom0.coord.clone().sub(v0);
                        step = atom1.coord.clone().sub(v0).sub(base).multiplyScalar(1.0/11);
                    }

                    for(var i = 0; i <= 10; ++i) {
                        if(i % 2 == 0) {
                            var pos1 = base.clone().add(step.clone().multiplyScalar(i));
                            var pos2 = base.clone().add(step.clone().multiplyScalar(i + 1));
                            me.createCylinder(pos1, pos2, me.cylinderRadius * factor * 0.3, atom0.color, bHighlight);
                        }
                    }

                } else {
                    var base, step;
                    if(dashed === 'add') {
                        me.createCylinder(atom0.coord.clone().sub(v0), mp.clone().sub(v0), me.cylinderRadius * factor * 0.3, atom0.color, bHighlight);
                        me.createCylinder(atom1.coord.clone().sub(v0), mp.clone().sub(v0), me.cylinderRadius * factor * 0.3, atom1.color, bHighlight);

                        base = atom0.coord.clone().add(v0);
                        step = atom1.coord.clone().add(v0).sub(base).multiplyScalar(1.0/11);
                    }
                    else {
                        me.createCylinder(atom0.coord.clone().add(v0), mp.clone().add(v0), me.cylinderRadius * factor * 0.3, atom0.color, bHighlight);
                        me.createCylinder(atom1.coord.clone().add(v0), mp.clone().add(v0), me.cylinderRadius * factor * 0.3, atom1.color, bHighlight);

                        base = atom0.coord.clone().sub(v0);
                        step = atom1.coord.clone().sub(v0).sub(base).multiplyScalar(1.0/11);
                    }

                    for(var i = 0; i <= 10; ++i) {
                        if(i % 2 == 0) {
                            var pos1 = base.clone().add(step.clone().multiplyScalar(i));
                            var pos2 = base.clone().add(step.clone().multiplyScalar(i + 1));
                            if(i < 5) {
                                me.createCylinder(pos1, pos2, me.cylinderRadius * factor * 0.3, atom0.color, bHighlight);
                            }
                            else {
                                me.createCylinder(pos1, pos2, me.cylinderRadius * factor * 0.3, atom1.color, bHighlight);
                            }
                        }
                    }
                }
            }
            else if(me.triplebonds.hasOwnProperty(pair)) { // show triple bond
                var random = new THREE.Vector3(Math.random(),Math.random(),Math.random());
                var v = atom1.coord.clone();
                v.sub(atom0.coord);

                var c = random.clone();
                c.cross(v).normalize().multiplyScalar(0.3 * factor);

                if (atom0.color === atom1.color) {
                    me.createCylinder(atom0.coord, atom1.coord, me.cylinderRadius * factor * 0.2, atom0.color, bHighlight);
                    me.createCylinder(atom0.coord.clone().add(c), atom1.coord.clone().add(c), me.cylinderRadius * factor * 0.2, atom0.color, bHighlight);
                    me.createCylinder(atom0.coord.clone().sub(c), atom1.coord.clone().sub(c), me.cylinderRadius * factor * 0.2, atom0.color, bHighlight);
                } else {
                    if(me.bImpo) {
                        me.createCylinder(atom0.coord, atom1.coord, me.cylinderRadius * factor * 0.2, atom0.color, bHighlight, atom1.color);
                        me.createCylinder(atom0.coord.clone().add(c), atom1.coord.clone().add(c), me.cylinderRadius * factor * 0.2, atom0.color, bHighlight, atom1.color);
                        me.createCylinder(atom0.coord.clone().sub(c), atom1.coord.clone().sub(c), me.cylinderRadius * factor * 0.2, atom0.color, bHighlight, atom1.color);
                    }
                    else {
                        me.createCylinder(atom0.coord, mp, me.cylinderRadius * factor * 0.2, atom0.color, bHighlight);
                        me.createCylinder(atom1.coord, mp, me.cylinderRadius * factor * 0.2, atom1.color, bHighlight);

                        me.createCylinder(atom0.coord.clone().add(c), mp.clone().add(c), me.cylinderRadius * factor * 0.2, atom0.color, bHighlight);
                        me.createCylinder(atom1.coord.clone().add(c), mp.clone().add(c), me.cylinderRadius * factor * 0.2, atom1.color, bHighlight);

                        me.createCylinder(atom0.coord.clone().sub(c), mp.clone().sub(c), me.cylinderRadius * factor * 0.2, atom0.color, bHighlight);
                        me.createCylinder(atom1.coord.clone().sub(c), mp.clone().sub(c), me.cylinderRadius * factor * 0.2, atom1.color, bHighlight);
                    }
                }
            }
            else {
                if (atom0.color === atom1.color) {
                    me.createCylinder(atom0.coord, atom1.coord, bondR, atom0.color, bHighlight);
                } else {
                    if(me.bImpo) {
                        me.createCylinder(atom0.coord, atom1.coord, bondR, atom0.color, bHighlight, atom1.color);
                    }
                    else {
                        me.createCylinder(atom0.coord, mp, bondR, atom0.color, bHighlight);
                        me.createCylinder(atom1.coord, mp, bondR, atom1.color, bHighlight);
                    }
                }
            }
        });
//        }
//        else if(bHighlight === 2) {
//            this.createBoxRepresentation_P_CA(atoms, 1.2, bHighlight);
//        }
};

// modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
iCn3D.prototype.createLineRepresentation = function (atoms, bHighlight) {
    var me = this;
    var geo = new THREE.Geometry();
    this.createRepresentationSub(atoms, undefined, function (atom0, atom1) {
        if (atom0.color === atom1.color) {
            geo.vertices.push(atom0.coord);
            geo.vertices.push(atom1.coord);
            geo.colors.push(atom0.color);
            geo.colors.push(atom1.color);
        } else {
            var mp = atom0.coord.clone().add(atom1.coord).multiplyScalar(0.5);
            geo.vertices.push(atom0.coord);
            geo.vertices.push(mp);
            geo.vertices.push(atom1.coord);
            geo.vertices.push(mp);
            geo.colors.push(atom0.color);
            geo.colors.push(atom0.color);
            geo.colors.push(atom1.color);
            geo.colors.push(atom1.color);
        }
    });

    if(bHighlight !== 2) {
        var line;
        if(bHighlight === 1) {
            // highlight didn't work for lines
            //line = new THREE.Mesh(geo, this.matShader);
        }
        else {
            //line = new THREE.Line(geo, new THREE.LineBasicMaterial({ linewidth: this.linewidth, vertexColors: true }), THREE.LineSegments);
            line = new THREE.LineSegments(geo, new THREE.LineBasicMaterial({ linewidth: this.linewidth, vertexColors: true }));
            this.mdl.add(line);
        }

        if(bHighlight === 1) {
            this.prevHighlightObjects.push(line);
        }
        else {
            this.objects.push(line);
        }
    }
    else if(bHighlight === 2) {
        this.createBoxRepresentation_P_CA(atoms, 0.8, bHighlight);
    }
};

/*
// modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
// Catmull�Rom subdivision
iCn3D.prototype.subdivide = function (_pnts, _clrs, DIV, bShowArray, bHighlight, prevone, nexttwo, bExtendLastRes) {
    var ret = [];
    var pos = [];
    var color = [];

    var pnts = new Array(); // Smoothing test

    var prevoneLen = (prevone !== undefined) ? prevone.length : 0;
    var nexttwoLenOri = (nexttwo !== undefined) ? nexttwo.length : 0;

    if(prevoneLen > 0) pnts.push(prevone[0]);

    pnts.push(_pnts[0]);
    for (var i = 1, lim = _pnts.length - 1; i < lim; ++i) {
        var p0 = _pnts[i], p1 = _pnts[i + 1];
        pnts.push(p0.smoothen ? p0.clone().add(p1).multiplyScalar(0.5) : p0);
    }
    pnts.push(_pnts[_pnts.length - 1]);

    if(nexttwoLenOri > 0) pnts.push(nexttwo[0]);
    if(nexttwoLenOri > 1) pnts.push(nexttwo[1]);

    var savedPoints = [];
    var savedPos = [];
    var savedColor = [];

    var nexttwoLen = nexttwoLenOri;
    if(bExtendLastRes) {
        nexttwoLen = (nexttwoLenOri > 0) ? nexttwoLenOri - 1 : 0;
    }

    for (var i = -1, size = pnts.length, DIVINV = 1 / DIV; i <= size - 3; ++i) {
        var newI = i - prevoneLen;
        var p0 = pnts[i === -1 ? 0 : i];
        var p1 = pnts[i + 1];
        var p2 = pnts[i + 2];
        var p3 = pnts[i === size - 3 ? size - 1 : i + 3];
        var v0 = p2.clone().sub(p0).multiplyScalar(0.5);
        var v1 = p3.clone().sub(p1).multiplyScalar(0.5);

        //if(i > -1 && bHighlight && bShowArray !== undefined && bShowArray[i + 1]) {
        if(i > -1 && (bShowArray === undefined || bShowArray[newI + 1]) ) {
            // get from previous i for the first half of residue
            if(i >= -1 + prevoneLen && i <= size - 3 - nexttwoLen + 1) {
                ret = ret.concat(savedPoints);
                pos = pos.concat(savedPos);
                color = color.concat(savedColor);
            }
        }

        savedPoints = [];
        savedPos = [];
        savedColor = [];

        for (var j = 0; j < DIV; ++j) {
            var t = DIVINV * j;
            var x = p1.x + t * v0.x
                     + t * t * (-3 * p1.x + 3 * p2.x - 2 * v0.x - v1.x)
                     + t * t * t * (2 * p1.x - 2 * p2.x + v0.x + v1.x);
            var y = p1.y + t * v0.y
                     + t * t * (-3 * p1.y + 3 * p2.y - 2 * v0.y - v1.y)
                     + t * t * t * (2 * p1.y - 2 * p2.y + v0.y + v1.y);
            var z = p1.z + t * v0.z
                     + t * t * (-3 * p1.z + 3 * p2.z - 2 * v0.z - v1.z)
                     + t * t * t * (2 * p1.z - 2 * p2.z + v0.z + v1.z);

            if(!bShowArray) {
                if(i >= -1 + prevoneLen && i <= size - 3 - nexttwoLen) {
                    ret.push(new THREE.Vector3(x, y, z));
                    pos.push(newI + 1);
                    color.push(_clrs[newI+1]);
                }
            }
            else {
                if(i >= -1 + prevoneLen && i <= size - 3 - nexttwoLen) {
                    if(bShowArray[newI + 1]) {
                        if(j <= parseInt((DIV) / 2) ) {
                            ret.push(new THREE.Vector3(x, y, z));
                            pos.push(bShowArray[newI + 1]);
                            color.push(_clrs[newI+1]);
                        }
                    }
                }

                if(i >= -1 + prevoneLen && i <= size - 3 - nexttwoLen + 1) {
                    if(bShowArray[newI + 2]) {
                        if(j > parseInt((DIV) / 2) ) {
                            savedPoints.push(new THREE.Vector3(x, y, z));
                            savedPos.push(bShowArray[newI + 2]);
                            savedColor.push(_clrs[newI+2]);
                        }
                    }
                }
            } // end else

        } // end for (var j = 0;
    } // end for (var i = -1;

    if(!bShowArray || bShowArray[newI + 1]) {
        //if(bHighlight) {
        ret = ret.concat(savedPoints);
        pos = pos.concat(savedPos);
        color = color.concat(savedColor);
        //}

        ret.push(pnts[pnts.length - 1 - nexttwoLen]);
        pos.push(pnts.length - 1 - nexttwoLen);
        color.push(_clrs[pnts.length - 1 - nexttwoLen]);
    }

    savedPoints = [];
    savedPos = [];
    savedColor = [];
    pnts = [];

    var pnts_positions = [];

    pnts_positions.push(ret);
    pnts_positions.push(pos);
    pnts_positions.push(color);

    return pnts_positions;
};
*/

iCn3D.prototype.getKnot = function (alpha, ti, Pi, Pj) {
    var alpha = 1;

    //return Math.pow(Pi.distanceTo(Pj), alpha) + ti;
    return Pi.distanceTo(Pj) + ti;
}

iCn3D.prototype.getValueFromKnot = function (t, t0, t1, t2, t3, y0, y1, y2, y3) {
    var inf = 9999;

    // m(i) = ( t(i+1) - t(i) == 0 ) ? 0 : ( y(i+1) - y(i) ) / ( t(i+1) - t(i) )
    var m0 = (y1 - y0) / (t1 - t0);
    var m1 = (y2 - y1) / (t2 - t1);
    var m2 = (y3 - y2) / (t3 - t2);

    // L(i) = m(i) * (t - t(i)) + y(i)
    //var L0 = m0 * (t - t0) + y0;
    var L1 = m1 * (t - t1) + y1;
    //var L2 = m2 * (t - t2) + y2;

    var denom = (t1 + t2) * (t1 + t2) - 4*(t0*t1 + t2*t3 - t0*t3);
    var d0 = 0;
    var d3 = 0;
    var d1, d2;

    if(denom == 0) {
        d1 = inf;
        d2 = inf;
    }
    else {
        d1 = 6 * (3*m1*t1 + 2*m0*t3 + m2*t1 - 2*m0*t1 - 2*m1*t3 - m1*t2 - m2*t1) / denom;
        d2 = 6 * (3*m1*t2 + 2*m2*t0 + m0*t1 - 2*m1*t0 - 2*m2*t2 - m0*t2 - m1*t1) / denom;
    }

    // a(i) = ( 2*d(i) + d(i+1) ) / 6 / (t(i) - t(i+1))
    // b(i) = ( 2*d(i+1) + d(i) ) / 6 / (t(i+1) - t(i))
    //var a0 = ( 2*d0 + d1 ) / 6 / (t0 - t1);
    var a1 = ( 2*d1 + d2 ) / 6 / (t1 - t2);
    //var a2 = ( 2*d2 + d3 ) / 6 / (t2 - t3);

    //var b0 = ( 2*d1 + d0 ) / 6 / (t1 - t0);
    var b1 = ( 2*d2 + d1 ) / 6 / (t2 - t1);
    //var b2 = ( 2*d3 + d2 ) / 6 / (t3 - t2);

    // C(i) = a(i)*(t - t(i))*(t - t(i+1))*(t - t(i+1)) + b(i)*(t - t(i))*(t - t(i))*(t - t(i+1))
    //var C0 = a0*(t - t0)*(t - t1)*(t - t1) + b0*(t - t0)*(t - t0)*(t - t1);
    var C1 = a1*(t - t1)*(t - t2)*(t - t2) + b1*(t - t1)*(t - t1)*(t - t2);
    //var C2 = a2*(t - t2)*(t - t3)*(t - t3) + b2*(t - t2)*(t - t2)*(t - t3);

    var F1 = L1 + C1;

    return F1;
}

// cubic splines for four points: http://thalestriangles.blogspot.com/2014/02/a-bit-of-ex-spline-ation.html
// https://math.stackexchange.com/questions/577641/how-to-calculate-interpolating-splines-in-3d-space
iCn3D.prototype.subdivide = function (_pnts, _clrs, DIV, bShowArray, bHighlight, prevone, nexttwo, bExtendLastRes) {
    var ret = [];
    var pos = [];
    var color = [];

    var pnts = new Array(); // Smoothing test

    var prevoneLen = (prevone !== undefined) ? prevone.length : 0;
    var nexttwoLenOri = (nexttwo !== undefined) ? nexttwo.length : 0;

    if(prevoneLen > 0) pnts.push(prevone[0]);

    pnts.push(_pnts[0]);
    for (var i = 1, lim = _pnts.length - 1; i < lim; ++i) {
        var p0 = _pnts[i], p1 = _pnts[i + 1];
        pnts.push(p0.smoothen ? p0.clone().add(p1).multiplyScalar(0.5) : p0);
    }
    pnts.push(_pnts[_pnts.length - 1]);

    if(nexttwoLenOri > 0) pnts.push(nexttwo[0]);
    if(nexttwoLenOri > 1) pnts.push(nexttwo[1]);

    var savedPoints = [];
    var savedPos = [];
    var savedColor = [];

    var nexttwoLen = nexttwoLenOri;
    if(bExtendLastRes) {
        nexttwoLen = (nexttwoLenOri > 0) ? nexttwoLenOri - 1 : 0;
    }

    var alpha = 1;

    for (var i = -1, size = pnts.length, DIVINV = 1 / DIV; i <= size - 3; ++i) {
        var newI = i - prevoneLen;
        var p0 = pnts[i === -1 ? 0 : i];
        var p1 = pnts[i + 1];
        var p2 = pnts[i + 2];
        var p3 = pnts[i === size - 3 ? size - 1 : i + 3];

        var t0 = 0;
        var t1 = this.getKnot(alpha, t0, p0, p1);
        var t2 = this.getKnot(alpha, t1, p1, p2);
        var t3 = this.getKnot(alpha, t2, p2, p3);

        if(t1 - t0 < 1e-4) t1 = t0 + 1;
        if(t2 - t1 < 1e-4) t2 = t1 + 1;
        if(t3 - t2 < 1e-4) t3 = t2 + 1;

        //if(i > -1 && bHighlight && bShowArray !== undefined && bShowArray[i + 1]) {
        if(i > -1 && (bShowArray === undefined || bShowArray[newI + 1]) ) {
            // get from previous i for the first half of residue
            if(i >= -1 + prevoneLen && i <= size - 3 - nexttwoLen + 1) {
                ret = ret.concat(savedPoints);
                pos = pos.concat(savedPos);
                color = color.concat(savedColor);
            }
        }

        savedPoints = [];
        savedPos = [];
        savedColor = [];

        var step = (t2 - t1) * DIVINV;
        for (var j = 0; j < DIV; ++j) {
            var t = t1 + step * j;
            var x = this.getValueFromKnot(t, t0, t1, t2, t3, p0.x, p1.x, p2.x, p3.x);
            var y = this.getValueFromKnot(t, t0, t1, t2, t3, p0.y, p1.y, p2.y, p3.y);
            var z = this.getValueFromKnot(t, t0, t1, t2, t3, p0.z, p1.z, p2.z, p3.z);

            if(!bShowArray) {
                if(i >= -1 + prevoneLen && i <= size - 3 - nexttwoLen) {
                    ret.push(new THREE.Vector3(x, y, z));
                    pos.push(newI + 1);
                    color.push(_clrs[newI+1]);
                }
            }
            else {
                if(i >= -1 + prevoneLen && i <= size - 3 - nexttwoLen) {
                    if(bShowArray[newI + 1]) {
                        if(j <= parseInt((DIV) / 2) ) {
                            ret.push(new THREE.Vector3(x, y, z));
                            pos.push(bShowArray[newI + 1]);
                            color.push(_clrs[newI+1]);
                        }
                    }
                }

                if(i >= -1 + prevoneLen && i <= size - 3 - nexttwoLen + 1) {
                    if(bShowArray[newI + 2]) {
                        if(j > parseInt((DIV) / 2) ) {
                            savedPoints.push(new THREE.Vector3(x, y, z));
                            savedPos.push(bShowArray[newI + 2]);
                            savedColor.push(_clrs[newI+2]);
                        }
                    }
                }
            } // end else

        } // end for (var j = 0;
    } // end for (var i = -1;

    if(!bShowArray || bShowArray[newI + 1]) {
        //if(bHighlight) {
        ret = ret.concat(savedPoints);
        pos = pos.concat(savedPos);
        color = color.concat(savedColor);
        //}

        ret.push(pnts[pnts.length - 1 - nexttwoLen]);
        pos.push(pnts.length - 1 - nexttwoLen);
        color.push(_clrs[pnts.length - 1 - nexttwoLen]);
    }

    savedPoints = [];
    savedPos = [];
    savedColor = [];
    pnts = [];

    var pnts_positions = [];

    pnts_positions.push(ret);
    pnts_positions.push(pos);
    pnts_positions.push(color);

    return pnts_positions;
};

iCn3D.prototype.createCurveSubArrow = function (p, width, colors, div, bHighlight, bRibbon, num, positionIndex, pntsCA, prevCOArray, bShowArray, calphaIdArray, bShowArrow, prevone, nexttwo) {
    var divPoints = [], positions = [];

    divPoints.push(p);
    positions.push(positionIndex);

    this.prepareStrand(divPoints, positions, width, colors, div, undefined, bHighlight, bRibbon, num, pntsCA, prevCOArray, false, bShowArray, calphaIdArray, bShowArrow, prevone, nexttwo);

    divPoints = [];
    positions = [];
};

iCn3D.prototype.setCalphaDrawnCoord = function (pnts, div, calphaIdArray) {
    var index = 0;

    if(calphaIdArray !== undefined) {
        for(var i = 0, il = pnts.length; i < il; i += div) { // pnts.length = (calphaIdArray.length - 1) * div + 1
            var serial = calphaIdArray[index];

            if(this.atoms.hasOwnProperty(serial)) {
                this.atoms[serial].coord2 = pnts[i].clone();
            }

            ++index;
        }
    }
};


// modified from iview (http://star.cse.cuhk.edu.hk/iview/)
iCn3D.prototype.createCurveSub = function (_pnts, width, colors, div, bHighlight, bRibbon, bNoSmoothen, bShowArray, calphaIdArray, positions, prevone, nexttwo) {
    if (_pnts.length === 0) return;
    div = div || 5;
    var pnts;
    if(!bNoSmoothen) {
        var bExtendLastRes = true;
        var pnts_clrs = this.subdivide(_pnts, colors, div, bShowArray, bHighlight, prevone, nexttwo, bExtendLastRes);
        pnts = pnts_clrs[0];
        colors = pnts_clrs[2];
    }
    else {
        pnts = _pnts;
    }
    if (pnts.length === 0) return;

    this.setCalphaDrawnCoord(pnts, div, calphaIdArray);

    if(bHighlight === 1) {
        var radius = this.coilWidth / 2;
        //var radiusSegments = 8;
        var radiusSegments = 4; // save memory
        var closed = false;

        if(pnts.length > 1) {
            if(positions !== undefined) {
                var currPos, prevPos;
                var currPoints = [];
                for(var i = 0, il = pnts.length; i < il; ++i) {
                    currPos = positions[i];

                    if( (currPos !== prevPos && currPos !== prevPos + 1 && prevPos !== undefined) || (i === il -1) ) {
                        // first tube
                        var geometry0 = new THREE.TubeGeometry(
                            new THREE.CatmullRomCurve3(currPoints), // path
                            currPoints.length, // segments
                            radius,
                            radiusSegments,
                            closed
                        );

                        mesh = new THREE.Mesh(geometry0, this.matShader);
                        mesh.renderOrder = this.renderOrderPicking;
                        //this.mdlPicking.add(mesh);
                        this.mdl.add(mesh);

                        this.prevHighlightObjects.push(mesh);

                        geometry0 = null;

                        currPoints = [];
                    }

                    currPoints.push(pnts[i]);

                    prevPos = currPos;
                }

                currPoints = [];
            }
            else {
                var geometry0 = new THREE.TubeGeometry(
                    new THREE.CatmullRomCurve3(pnts), // path
                    pnts.length, // segments
                    radius,
                    radiusSegments,
                    closed
                );

                mesh = new THREE.Mesh(geometry0, this.matShader);
                mesh.renderOrder = this.renderOrderPicking;
                //this.mdlPicking.add(mesh);
                this.mdl.add(mesh);

                this.prevHighlightObjects.push(mesh);

                geometry0 = null;
            }
        }
    }
    else {
        var geo = new THREE.Geometry();

        if(bHighlight === 2 && bRibbon) {
            for (var i = 0, divInv = 1 / div; i < pnts.length; ++i) {
                // shift the highlight a little bit to avoid the overlap with ribbon
                pnts[i].addScalar(0.6); // this.ribbonthickness is 0.4
                geo.vertices.push(pnts[i]);
                //geo.colors.push(new THREE.Color(colors[i === 0 ? 0 : Math.round((i - 1) * divInv)]));
                geo.colors.push(new THREE.Color(colors[i]));
            }
        }
        else {
            for (var i = 0, divInv = 1 / div; i < pnts.length; ++i) {
                geo.vertices.push(pnts[i]);
                //geo.colors.push(new THREE.Color(colors[i === 0 ? 0 : Math.round((i - 1) * divInv)]));
                geo.colors.push(new THREE.Color(colors[i]));
            }
        }

        //var line = new THREE.Line(geo, new THREE.LineBasicMaterial({ linewidth: width, vertexColors: true }), THREE.LineStrip);
        var line = new THREE.Line(geo, new THREE.LineBasicMaterial({ linewidth: width, vertexColors: true }));
        this.mdl.add(line);
        if(bHighlight === 2) {
            this.prevHighlightObjects.push(line);
        }
        else {
            this.objects.push(line);
        }
    }

    pnts = null;
};

// modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
iCn3D.prototype.createCylinderCurve = function (atoms, atomNameArray, radius, bLines, bHighlight) {
    var start = null;
    var currentChain, currentResi;
    var i;
    var pnts = [], colors = [], radii = [];

    var maxDistance = 8.0; // max residue-residue (or nucleitide-nucleitide) distance allowed

    for (i in atoms) {
        var atom = atoms[i];
        if (atom.het) continue;

        //if (atom.name !== atomName) continue;
        if(atomNameArray.indexOf(atom.name) == -1) continue;

        if (start !== null && currentChain === atom.chain && currentResi + 1 === atom.resi && Math.abs(start.coord.x - atom.coord.x) < maxDistance && Math.abs(start.coord.y - atom.coord.y) < maxDistance && Math.abs(start.coord.z - atom.coord.z) < maxDistance ) {
//            if (start !== null && currentChain === atom.chain && Math.abs(start.coord.x - atom.coord.x) < maxDistance && Math.abs(start.coord.y - atom.coord.y) < maxDistance && Math.abs(start.coord.z - atom.coord.z) < maxDistance ) {
            var middleCoord = start.coord.clone().add(atom.coord).multiplyScalar(0.5);

            if(!bHighlight) {
                if(bLines) {
                    var line = this.createSingleLine( start.coord, middleCoord, start.color, false);
                    this.mdl.add(line);
                    this.objects.push(line);
                    line = this.createSingleLine( middleCoord, atom.coord, atom.color, false);
                    this.mdl.add(line);
                    this.objects.push(line);
                }
                else {
                    this.createCylinder(start.coord, middleCoord, radius, start.color);
                    this.createCylinder(middleCoord, atom.coord, radius, atom.color);
                    this.createSphere(atom, radius, true, 1, bHighlight);
                }
            }
            else if(bHighlight === 1) {
                this.createCylinder(start.coord, middleCoord, radius, start.color, bHighlight);
                this.createCylinder(middleCoord, atom.coord, radius, atom.color, bHighlight);
                this.createSphere(atom, radius, true, 1, bHighlight);
            }
        }

        start = atom;
        currentChain = atom.chain;
        currentResi = atom.resi;

        if(bHighlight === 2) this.createBox(atom, undefined, undefined, undefined, undefined, bHighlight);
    }
    if (start !== null && currentChain === atom.chain && currentResi + 1 === atom.resi && Math.abs(start.coord.x - atom.coord.x) < maxDistance && Math.abs(start.coord.y - atom.coord.y) < maxDistance && Math.abs(start.coord.z - atom.coord.z) < maxDistance ) {
//        if (start !== null && currentChain === atom.chain && Math.abs(start.coord.x - atom.coord.x) < maxDistance && Math.abs(start.coord.y - atom.coord.y) < maxDistance && Math.abs(start.coord.z - atom.coord.z) < maxDistance ) {
        var middleCoord = start.coord.add(atom.coord).multiplyScalar(0.5);
        if(!bHighlight) {
            if(bLines) {
                var line = this.createSingleLine( start.coord, middleCoord, start.color, false);
                this.mdl.add(line);
                this.objects.push(line);
                line = this.createSingleLine( middleCoord, atom.coord, atom.color, false);
                this.mdl.add(line);
                this.objects.push(line);
            }
            else {
                this.createCylinder(start.coord, middleCoord, radius, start.color);
                this.createCylinder(middleCoord, atom.coord, radius, atom.color);
            }
        }
        else if(bHighlight === 1) {
            this.createCylinder(start.coord, middleCoord, radius, start.color, bHighlight);
            this.createCylinder(middleCoord, atom.coord, radius, atom.color, bHighlight);
            this.createSphere(atom, radius, true, 1, bHighlight);
        }
    }
};

iCn3D.prototype.prepareStrand = function(divPoints, positions, width, colors, div, thickness, bHighlight, bRibbon, num, pntsCA, prevCOArray, bStrip, bShowArray, calphaIdArray, bShowArrow, prevone, nexttwo) {
    if(pntsCA.length === 1) {
        return;
    }

    var colorsLastTwo = [];
    colorsLastTwo.push(colors[colors.length - 2]);
    colorsLastTwo.push(colors[colors.length - 1]);

    div = div || this.axisDIV;
    var numM1Inv2 = 2 / (num - 1);
    var delta, lastCAIndex, lastPrevCOIndex, v;

    var pnts = {}, colorsTmp = [];
    for(var i = 0, il = positions.length; i < il; ++i) pnts[i] = [];

    // smooth C-alpha
    var pnts_clrs = this.subdivide(pntsCA, colors, div, undefined, undefined, prevone, nexttwo);
    var pntsCASmooth = pnts_clrs[0]; // get all smoothen pnts, do not use 'bShowArray'
    //colors = pnts_clrs[2];

    if(pntsCASmooth.length === 1) {
        return;
    }

    // draw the sheet without the last residue
    // use the sheet coord for n-2 residues
    var colorsTmp = [];
    var lastIndex = (bShowArrow === undefined || bShowArrow) ? pntsCA.length - 2 : pntsCA.length;

    for (var i = 0, il = lastIndex; i < il; ++i) {
        for(var index = 0, indexl = positions.length; index < indexl; ++index) {
            pnts[index].push(divPoints[index][i]);
        }
        colorsTmp.push(colors[i]);
    }
    colorsTmp.push(colors[i]);

    if(bShowArrow === undefined || bShowArrow) {
        // assign the sheet coord from C-alpha for the 2nd to the last residue of the sheet
        for(var i = 0, il = positions.length; i < il; ++i) {
            delta = -1 + numM1Inv2 * positions[i];
            lastCAIndex = pntsCASmooth.length - 1 - div;
            lastPrevCOIndex = pntsCA.length - 2;
            v = new THREE.Vector3(pntsCASmooth[lastCAIndex].x + prevCOArray[lastPrevCOIndex].x * delta, pntsCASmooth[lastCAIndex].y + prevCOArray[lastPrevCOIndex].y * delta, pntsCASmooth[lastCAIndex].z + prevCOArray[lastPrevCOIndex].z * delta);
            pnts[i].push(v);
        }
    }

    var posIndex = [];
    var results;
    for(var i = 0, il = positions.length; i < il; ++i) {
        results = this.subdivide(pnts[i], colorsTmp, div, bShowArray, bHighlight);
        pnts[i] = results[0];
        colors = results[2];
        if(i === 0) {
            posIndex = results[1];
        }
    }

    if(bStrip) {
        this.createStrip(pnts[0], pnts[1], colors, div, thickness, bHighlight, true, undefined, calphaIdArray, posIndex, prevone, nexttwo);
    }
    else {
        this.createCurveSub(pnts[0], width, colors, div, bHighlight, bRibbon, true, undefined, calphaIdArray, posIndex, prevone, nexttwo);
    }

    if(bShowArrow === undefined || bShowArrow) {
        // draw the arrow
        colorsTmp = [];

        posIndex = [];
        for(var index = 0, indexl = positions.length; index < indexl; ++index) {
            pnts[index] = [];

            for (var i = div * (pntsCA.length - 2), il = div * (pntsCA.length - 1); bShowArray[parseInt(i/div)] && i < il; i = i + div) {
                var pos = parseInt(i/div);
                for (var j = 0; j < div; ++j) {
                    var delta = -1 + numM1Inv2 * positions[index];
                    var scale = 1.8; // scale of the arrow width
                    delta = delta * scale * (div - j) / div;
                    var oriIndex = parseInt(i/div);

                    var v = new THREE.Vector3(pntsCASmooth[i+j].x + prevCOArray[oriIndex].x * delta, pntsCASmooth[i+j].y + prevCOArray[oriIndex].y * delta, pntsCASmooth[i+j].z + prevCOArray[oriIndex].z * delta);
                    v.smoothen = true;
                    pnts[index].push(v);
                    colorsTmp.push(colorsLastTwo[0]);
                    if(index === 0) posIndex.push(pos);
                }
            }

            // last residue
            // make the arrow end with 0
            var delta = 0;
            var lastCAIndex = pntsCASmooth.length - 1;
            var lastPrevCOIndex = pntsCA.length - 1;

            //if(bShowArray[lastPrevCOIndex]) {
                var v = new THREE.Vector3(pntsCASmooth[lastCAIndex].x + prevCOArray[lastPrevCOIndex].x * delta, pntsCASmooth[lastCAIndex].y + prevCOArray[lastPrevCOIndex].y * delta, pntsCASmooth[lastCAIndex].z + prevCOArray[lastPrevCOIndex].z * delta);
                v.smoothen = true;
                pnts[index].push(v);
                colorsTmp.push(colorsLastTwo[1]);
                if(index === 0) posIndex.push(lastCAIndex);
            //}
        }

        pntsCASmooth = [];

        //colorsTmp.push(colors[colors.length - 2]);
        //colorsTmp.push(colors[colors.length - 1]);

        if(bStrip) {
            this.createStrip(pnts[0], pnts[1], colorsTmp, div, thickness, bHighlight, true, undefined, undefined, posIndex, prevone, nexttwo);
        }
        else {
            this.createCurveSub(pnts[0], width, colorsTmp, div, bHighlight, bRibbon, true, undefined, undefined, posIndex, prevone, nexttwo);
        }
    }

    for(var i in pnts) {
        for(var j = 0, jl = pnts[i].length; j < jl; ++j) {
            pnts[i][j] = null;
        }
        pnts[i] = [];
    }

    pnts = {};
};

iCn3D.prototype.createStripArrow = function (p0, p1, colors, div, thickness, bHighlight, num, start, end, pntsCA, prevCOArray, bShowArray, calphaIdArray, bShowArrow, prevone, nexttwo) {
    var divPoints = [], positions = [];

    divPoints.push(p0);
    divPoints.push(p1);
    positions.push(start);
    positions.push(end);

    this.prepareStrand(divPoints, positions, undefined, colors, div, thickness, bHighlight, undefined, num, pntsCA, prevCOArray, true, bShowArray, calphaIdArray, bShowArrow, prevone, nexttwo);

    divPoints = [];
    positions = [];
};

// modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
iCn3D.prototype.createStrip = function (p0, p1, colors, div, thickness, bHighlight, bNoSmoothen, bShowArray, calphaIdArray, positions, prevone, nexttwo) {
    if (p0.length < 2) return;
    div = div || this.axisDIV;
    if(!bNoSmoothen) {
        var bExtendLastRes = true;
        var pnts_clrs0 = this.subdivide(p0, colors, div, bShowArray, bHighlight, prevone, nexttwo, bExtendLastRes);
        var pnts_clrs1 = this.subdivide(p1, colors, div, bShowArray, bHighlight, prevone, nexttwo, bExtendLastRes);
        p0 = pnts_clrs0[0];
        p1 = pnts_clrs1[0];
        colors = pnts_clrs0[2];
    }
    if (p0.length < 2) return;

    this.setCalphaDrawnCoord(p0, div, calphaIdArray);

    if(bHighlight === 1) {
        //mesh = new THREE.Mesh(geo, this.matShader);

        var radius = this.coilWidth / 2;
        //var radiusSegments = 8;
        var radiusSegments = 4; // save memory
        var closed = false;

        if(positions !== undefined) {
            var currPos, prevPos;
            var currP0 = [], currP1 = [];

            for(var i = 0, il = p0.length; i < il; ++i) {
                currPos = positions[i];

                if((currPos !== prevPos && currPos !== prevPos + 1 && prevPos !== undefined) || (i === il -1) ) {
                    // first tube
                    var geometry0 = new THREE.TubeGeometry(
                        new THREE.CatmullRomCurve3(currP0), // path
                        currP0.length, // segments
                        radius,
                        radiusSegments,
                        closed
                    );

                    mesh = new THREE.Mesh(geometry0, this.matShader);
                    mesh.renderOrder = this.renderOrderPicking;
                    //this.mdlPicking.add(mesh);
                    this.mdl.add(mesh);

                    this.prevHighlightObjects.push(mesh);

                    geometry0 = null;

                    // second tube
                    var geometry1 = new THREE.TubeGeometry(
                        new THREE.CatmullRomCurve3(currP1), // path
                        currP1.length, // segments
                        radius,
                        radiusSegments,
                        closed
                    );

                    mesh = new THREE.Mesh(geometry1, this.matShader);
                    mesh.renderOrder = this.renderOrderPicking;
                    //this.mdlPicking.add(mesh);
                    this.mdl.add(mesh);

                    this.prevHighlightObjects.push(mesh);

                    geometry1 = null;

                    currP0 = [];
                    currP1 = [];
                }

                currP0.push(p0[i]);
                currP1.push(p1[i]);

                prevPos = currPos;
            }

            currP0 = [];
            currP1 = [];
        }
        else {
            // first tube
            var geometry0 = new THREE.TubeGeometry(
                new THREE.CatmullRomCurve3(p0), // path
                p0.length, // segments
                radius,
                radiusSegments,
                closed
            );

            mesh = new THREE.Mesh(geometry0, this.matShader);
            mesh.renderOrder = this.renderOrderPicking;
            //this.mdlPicking.add(mesh);
            this.mdl.add(mesh);

            this.prevHighlightObjects.push(mesh);

            geometry0 = null;

            // second tube
            var geometry1 = new THREE.TubeGeometry(
                new THREE.CatmullRomCurve3(p1), // path
                p1.length, // segments
                radius,
                radiusSegments,
                closed
            );

            mesh = new THREE.Mesh(geometry1, this.matShader);
            mesh.renderOrder = this.renderOrderPicking;
            //this.mdlPicking.add(mesh);
            this.mdl.add(mesh);

            this.prevHighlightObjects.push(mesh);

            geometry1 = null;
        }
    }
    else {
        var geo = new THREE.Geometry();
        var vs = geo.vertices, fs = geo.faces;
        var axis, p0v, p1v, a0v, a1v;
        for (var i = 0, lim = p0.length; i < lim; ++i) {
            vs.push(p0v = p0[i]); // 0
            vs.push(p0v); // 1
            vs.push(p1v = p1[i]); // 2
            vs.push(p1v); // 3
            if (i < lim - 1) {
                axis = p1[i].clone().sub(p0[i]).cross(p0[i + 1].clone().sub(p0[i])).normalize().multiplyScalar(thickness);
            }
            vs.push(a0v = p0[i].clone().add(axis)); // 4
            vs.push(a0v); // 5
            vs.push(a1v = p1[i].clone().add(axis)); // 6
            vs.push(a1v); // 7
        }
        var faces = [[0, 2, -6, -8], [-4, -2, 6, 4], [7, 3, -5, -1], [-3, -7, 1, 5]];

        for (var i = 1, lim = p0.length, divInv = 1 / div; i < lim; ++i) {
            var offset = 8 * i;
            //var color = new THREE.Color(colors[Math.round((i - 1) * divInv)]);
            var color = new THREE.Color(colors[i - 1]);
            for (var j = 0; j < 4; ++j) {
                fs.push(new THREE.Face3(offset + faces[j][0], offset + faces[j][1], offset + faces[j][2], undefined, color));
                fs.push(new THREE.Face3(offset + faces[j][3], offset + faces[j][0], offset + faces[j][2], undefined, color));
            }
        }
        var vsize = vs.length - 8; // Cap
        for (var i = 0; i < 4; ++i) {
            vs.push(vs[i * 2]);
            vs.push(vs[vsize + i * 2]);
        };
        vsize += 8;
        fs.push(new THREE.Face3(vsize, vsize + 2, vsize + 6, undefined, fs[0].color));
        fs.push(new THREE.Face3(vsize + 4, vsize, vsize + 6, undefined, fs[0].color));
        fs.push(new THREE.Face3(vsize + 1, vsize + 5, vsize + 7, undefined, fs[fs.length - 3].color));
        fs.push(new THREE.Face3(vsize + 3, vsize + 1, vsize + 7, undefined, fs[fs.length - 3].color));
        geo.computeFaceNormals();
        geo.computeVertexNormals(false);

        var mesh;

        if(bHighlight === 2) {
          mesh = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({ transparent: true, opacity: 0.5, specular: this.frac, shininess: 30, emissive: 0x000000, vertexColors: THREE.FaceColors, side: THREE.DoubleSide }));

          this.mdl.add(mesh);
          this.prevHighlightObjects.push(mesh);
        }
        else {
          mesh = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({ specular: this.frac, shininess: 30, emissive: 0x000000, vertexColors: THREE.FaceColors, side: THREE.DoubleSide }));

          this.mdl.add(mesh);
          this.objects.push(mesh);
        }
    }

    p0 = null;
    p1 = null;
};

// significantly modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
iCn3D.prototype.createStrand = function (atoms, num, div, fill, coilWidth, helixSheetWidth, doNotSmoothen, thickness, bHighlight) {
    var bRibbon = fill ? true: false;

    // when highlight, the input atoms may only include part of sheet or helix
    // include the whole sheet or helix when highlighting
    var atomsAdjust = {};

    //if( (bHighlight === 1 || bHighlight === 2) && !this.bAllAtoms) {
    if( !this.bAllAtoms) {
        var currChain, currResi, currAtom, prevChain, prevResi, prevAtom;
        var firstAtom, lastAtom;
        var index = 0, length = Object.keys(atoms).length;

        atomsAdjust = this.cloneHash(atoms);
        for(var serial in atoms) {
          currChain = atoms[serial].structure + '_' + atoms[serial].chain;
          currResi = parseInt(atoms[serial].resi);
          currAtom = atoms[serial];

          if(prevChain === undefined) firstAtom = atoms[serial];

          if( (currChain !== prevChain && prevChain !== undefined) || (currResi !== prevResi && currResi !== prevResi + 1 && prevResi !== undefined) || index === length - 1) {
            if( (currChain !== prevChain && prevChain !== undefined) || (currResi !== prevResi && currResi !== prevResi + 1 && prevResi !== undefined) ) {
//              if( (currChain !== prevChain && prevChain !== undefined) || index === length - 1) {
//                if( (currChain !== prevChain && prevChain !== undefined) ) {
                lastAtom = prevAtom;
            }
            else if(index === length - 1) {
                lastAtom = currAtom;
            }

            // fill the beginning
            var beginResi = firstAtom.resi;
            if(firstAtom.ss !== 'coil' && !(firstAtom.ssbegin) ) {
                for(var i = firstAtom.resi - 1; i > 0; --i) {
                    var residueid = firstAtom.structure + '_' + firstAtom.chain + '_' + i;
                    if(!this.residues.hasOwnProperty(residueid)) break;

                    var atom = this.getFirstCalphaAtomObj(this.residues[residueid]);

                    if(atom.ss === firstAtom.ss && atom.ssbegin) {
                        beginResi = atom.resi;
                        break;
                    }
                }

                for(var i = beginResi; i < firstAtom.resi; ++i) {
                    var residueid = firstAtom.structure + '_' + firstAtom.chain + '_' + i;
                    atomsAdjust = this.unionHash(atomsAdjust, this.hash2Atoms(this.residues[residueid]));
                }
            }

            // add one extra residue for coils between strands/helix
            if(this.pk === 3 && bHighlight === 1 && firstAtom.ss === 'coil') {
                    var residueid = firstAtom.structure + '_' + firstAtom.chain + '_' + (firstAtom.resi - 1);
                    if(this.residues.hasOwnProperty(residueid)) {
                        atomsAdjust = this.unionHash(atomsAdjust, this.hash2Atoms(this.residues[residueid]));
                        atoms = this.unionHash(atoms, this.hash2Atoms(this.residues[residueid]));
                    }
            }

            // fill the end
            var endResi = lastAtom.resi;
            // when a coil connects to a sheet and the last residue of coil is highlighted, the first sheet residue is set as atom.notshow. This residue should not be shown.
            if(lastAtom.ss !== 'coil' && !(lastAtom.ssend) && !(lastAtom.notshow)) {
                var endChainResi = this.getLastAtomObj(this.chains[lastAtom.structure + '_' + lastAtom.chain]).resi;
                for(var i = lastAtom.resi + 1; i <= endChainResi; ++i) {
                    var residueid = lastAtom.structure + '_' + lastAtom.chain + '_' + i;
                    if(!this.residues.hasOwnProperty(residueid)) break;

                    var atom = this.getFirstCalphaAtomObj(this.residues[residueid]);

                    if(atom.ss === lastAtom.ss && atom.ssend) {
                        endResi = atom.resi;
                        break;
                    }
                }

                for(var i = lastAtom.resi + 1; i <= endResi; ++i) {
                    var residueid = lastAtom.structure + '_' + lastAtom.chain + '_' + i;
                    atomsAdjust = this.unionHash(atomsAdjust, this.hash2Atoms(this.residues[residueid]));
                }
            }

            // add one extra residue for coils between strands/helix
            if(this.pk === 3 && bHighlight === 1 && lastAtom.ss === 'coil') {
                    var residueid = lastAtom.structure + '_' + lastAtom.chain + '_' + (lastAtom.resi + 1);
                    if(this.residues.hasOwnProperty(residueid)) {
                        atomsAdjust = this.unionHash(atomsAdjust, this.hash2Atoms(this.residues[residueid]));
                        atoms = this.unionHash(atoms, this.hash2Atoms(this.residues[residueid]));
                    }
            }

            // reset notshow
            if(lastAtom.notshow) lastAtom.notshow = undefined;

            firstAtom = currAtom;
          }

          prevChain = currChain;
          prevResi = currResi;
          prevAtom = currAtom;

          ++index;
        }
    }
    else {
        atomsAdjust = atoms;
    }

    if(bHighlight === 2) {
        if(fill) {
            fill = false;
            num = null;
            div = null;
            coilWidth = null;
            helixSheetWidth = null;
            thickness = undefined;
        }
        else {
            fill = true;
            num = 2;
            div = undefined;
            coilWidth = undefined;
            helixSheetWidth = undefined;
            thickness = this.ribbonthickness;
        }
    }

    num = num || this.strandDIV;
    div = div || this.axisDIV;
    coilWidth = coilWidth || this.coilWidth;
    doNotSmoothen = doNotSmoothen || false;
    helixSheetWidth = helixSheetWidth || this.helixSheetWidth;
    var pnts = {}; for (var k = 0; k < num; ++k) pnts[k] = [];
    var pntsCA = [];
    var prevCOArray = [];
    var bShowArray = [];
    var calphaIdArray = []; // used to store one of the final positions drawn in 3D
    var colors = [];
    var currentChain, currentResi, currentCA = null, currentO = null, currentColor = null, prevCoorCA = null, prevCoorO = null, prevColor = null;
    var prevCO = null, ss = null, ssend = false, atomid = null, prevAtomid = null, prevResi = null, calphaid = null, prevCalphaid = null;
    var strandWidth, bSheetSegment = false, bHelixSegment = false;
    var atom, tubeAtoms = {};

    // test the first 30 atoms to see whether only C-alpha is available
    this.bCalphaOnly = this.isCalphaPhosOnly(atomsAdjust); //, 'CA');

    // when highlight, draw whole beta sheet and use bShowArray to show the highlight part
    var residueHash = {};
    for(var i in atomsAdjust) {
        var atom = atomsAdjust[i];

        residueid = atom.structure + '_' + atom.chain + '_' + atom.resi;
        residueHash[residueid] = 1;
    }
    var totalResidueCount = Object.keys(residueHash).length;

    var drawnResidueCount = 0;
    var highlightResiduesCount = 0;

    var bFullAtom = (Object.keys(this.hAtoms).length == Object.keys(this.atoms).length) ? true : false;

    var caArray = []; // record all C-alpha atoms to predict the helix

    for (var i in atomsAdjust) {
        atom = atomsAdjust[i];
        var atomOxygen = undefined;
        if ((atom.name === 'O' || atom.name === 'CA') && !atom.het) {
                // "CA" has to appear before "O"

                if (atom.name === 'CA') {
                    if ( atoms.hasOwnProperty(i) && ((atom.ss !== 'helix' && atom.ss !== 'sheet') || atom.ssend || atom.ssbegin) ) {
                        tubeAtoms[i] = atom;
                    }

                    currentCA = atom.coord;
                    currentColor = atom.color;
                    calphaid = atom.serial;

                    caArray.push(atom.serial);
                }

                if (atom.name === 'O' || (this.bCalphaOnly && atom.name === 'CA')) {
                    if(currentCA === null || currentCA === undefined) {
                        currentCA = atom.coord;
                        currentColor = atom.color;
                        calphaid = atom.serial;
                    }

                    if(atom.name === 'O') {
                        currentO = atom.coord;
                    }
                    // smoothen each coil, helix and sheet separately. The joint residue has to be included both in the previous and next segment
                    var bSameChain = true;
//                    if (currentChain !== atom.chain || currentResi + 1 !== atom.resi) {
                    if (currentChain !== atom.chain) {
                        bSameChain = false;
                    }

                    if(atom.ssend && atom.ss === 'sheet') {
                        bSheetSegment = true;
                    }
                    else if(atom.ssend && atom.ss === 'helix') {
                        bHelixSegment = true;
                    }

                    // assign the previous residue
                    if(prevCoorO) {
                        if(bHighlight === 1 || bHighlight === 2) {
                            colors.push(this.hColor);
                        }
                        else {
                            colors.push(prevColor);
                        }

                        if(ss !== 'coil' && atom.ss === 'coil') {
                            strandWidth = coilWidth;
                        }
                        else if(ssend && atom.ssbegin) { // a transition between two ss
                            strandWidth = coilWidth;
                        }
                        else {
                            strandWidth = (ss === 'coil') ? coilWidth : helixSheetWidth;
                        }

                        var O, oldCA, resSpan = 4;
                        if(atom.name === 'O') {
                            O = prevCoorO.clone();
                            if(prevCoorCA !== null && prevCoorCA !== undefined) {
                                O.sub(prevCoorCA);
                            }
                            else {
                                prevCoorCA = prevCoorO.clone();
                                if(caArray.length > resSpan + 1) { // use the calpha and the previous 4th c-alpha to calculate the helix direction
                                    O = prevCoorCA.clone();
                                    oldCA = this.atoms[caArray[caArray.length - 1 - resSpan - 1]].coord.clone();
                                    O.sub(oldCA);
                                }
                                else {
                                    O = new THREE.Vector3(Math.random(),Math.random(),Math.random());
                                }
                            }
                        }
                        else if(this.bCalphaOnly && atom.name === 'CA') {
                            if(caArray.length > resSpan + 1) { // use the calpha and the previous 4th c-alpha to calculate the helix direction
                                O = prevCoorCA.clone();
                                oldCA = this.atoms[caArray[caArray.length - 1 - resSpan - 1]].coord.clone();
                                O.sub(oldCA);
                            }
                            else {
                                O = new THREE.Vector3(Math.random(),Math.random(),Math.random());
                            }
                        }

                        O.normalize(); // can be omitted for performance
                        O.multiplyScalar(strandWidth);
                        if (prevCO !== null && O.dot(prevCO) < 0) O.negate();
                        prevCO = O;

                        for (var j = 0, numM1Inv2 = 2 / (num - 1); j < num; ++j) {
                            var delta = -1 + numM1Inv2 * j;
                            var v = new THREE.Vector3(prevCoorCA.x + prevCO.x * delta, prevCoorCA.y + prevCO.y * delta, prevCoorCA.z + prevCO.z * delta);
                            if (!doNotSmoothen && ss === 'sheet') v.smoothen = true;
                            pnts[j].push(v);
                        }

                        pntsCA.push(prevCoorCA);
                        prevCOArray.push(prevCO);

                        if(atoms.hasOwnProperty(prevAtomid)) {
                            bShowArray.push(prevResi);
                            calphaIdArray.push(prevCalphaid);

                            ++highlightResiduesCount;
                        }
                        else {
                            bShowArray.push(0);
                            calphaIdArray.push(0);
                        }

                        ++drawnResidueCount;
                    }

                    //var maxDist = 6.0;
                    //var bBrokenSs = (prevCoorCA && Math.abs(currentCA.x - prevCoorCA.x) > maxDist) || (prevCoorCA && Math.abs(currentCA.y - prevCoorCA.y) > maxDist) || (prevCoorCA && Math.abs(currentCA.z - prevCoorCA.z) > maxDist);

                    if ((atom.ssbegin || atom.ssend || (drawnResidueCount === totalResidueCount - 1)) && pnts[0].length > 0 && bSameChain) {
                        var atomName = 'CA';

                        var prevone = [], nexttwo = [];

                        var prevoneResid = this.atoms[prevAtomid].structure + '_' + this.atoms[prevAtomid].chain + '_' + (this.atoms[prevAtomid].resi - 1).toString();
                        var prevoneCoord = this.getAtomCoordFromResi(prevoneResid, atomName);
                        prevone = (prevoneCoord !== undefined) ? [prevoneCoord] : [];

                        var nextoneResid = this.atoms[prevAtomid].structure + '_' + this.atoms[prevAtomid].chain + '_' + (this.atoms[prevAtomid].resi + 1).toString();
                        var nextoneCoord = this.getAtomCoordFromResi(nextoneResid, atomName);
                        if(nextoneCoord !== undefined) {
                            nexttwo.push(nextoneCoord);
                        }

                        var nexttwoResid = this.atoms[prevAtomid].structure + '_' + this.atoms[prevAtomid].chain + '_' + (this.atoms[prevAtomid].resi + 2).toString();
                        var nexttwoCoord = this.getAtomCoordFromResi(nexttwoResid, atomName);
                        if(nexttwoCoord !== undefined) {
                            nexttwo.push(nexttwoCoord);
                        }

                        // assign the current joint residue to the previous segment
                        if(bHighlight === 1 || bHighlight === 2) {
                            colors.push(this.hColor);
                        }
                        else {
                            //colors.push(atom.color);
                            colors.push(prevColor);
                        }

                        if(atom.ssend && atom.ss === 'sheet') { // current residue is the end of ss and is the end of arrow
                            strandWidth = 0; // make the arrow end sharp
                        }
                        else if(ss === 'coil' && atom.ssbegin) {
                            strandWidth = coilWidth;
                        }
                        else if(ssend && atom.ssbegin) { // current residue is the start of ss and  the previous residue is the end of ss, then use coil
                            strandWidth = coilWidth;
                        }
                        else { // use the ss from the previous residue
                            strandWidth = (atom.ss === 'coil') ? coilWidth : helixSheetWidth;
                        }

                        var O, oldCA, resSpan = 4;
                        if(atom.name === 'O') {
                            O = currentO.clone();
                            O.sub(currentCA);
                        }
                        else if(this.bCalphaOnly && atom.name === 'CA') {
                            if(caArray.length > resSpan) { // use the calpha and the previous 4th c-alpha to calculate the helix direction
                                O = currentCA.clone();
                                oldCA = this.atoms[caArray[caArray.length - 1 - resSpan]].coord.clone();
                                O.sub(oldCA);
                            }
                            else {
                                O = new THREE.Vector3(Math.random(),Math.random(),Math.random());
                            }
                        }

                        O.normalize(); // can be omitted for performance
                        O.multiplyScalar(strandWidth);
                        if (prevCO !== null && O.dot(prevCO) < 0) O.negate();
                        prevCO = O;

                        for (var j = 0, numM1Inv2 = 2 / (num - 1); j < num; ++j) {
                            var delta = -1 + numM1Inv2 * j;
                            var v = new THREE.Vector3(currentCA.x + prevCO.x * delta, currentCA.y + prevCO.y * delta, currentCA.z + prevCO.z * delta);
                            if (!doNotSmoothen && ss === 'sheet') v.smoothen = true;
                            pnts[j].push(v);
                        }

                        atomid = atom.serial;

                        pntsCA.push(currentCA);
                        prevCOArray.push(prevCO);

                        // when a coil connects to a sheet and the last residue of coild is highlighted, the first sheet residue is set as atom.highlightStyle. This residue should not be shown.
                        //if(atoms.hasOwnProperty(atomid) && (bHighlight === 1 && !atom.notshow) ) {
                        if(atoms.hasOwnProperty(atomid)) {
                            bShowArray.push(atom.resi);
                            calphaIdArray.push(calphaid);
                        }
                        else {
                            bShowArray.push(0);
                            calphaIdArray.push(0);
                        }

                        // draw the current segment
                        for (var j = 0; !fill && j < num; ++j) {
                            if(bSheetSegment) {
                                this.createCurveSubArrow(pnts[j], 1, colors, div, bHighlight, bRibbon, num, j, pntsCA, prevCOArray, bShowArray, calphaIdArray, true, prevone, nexttwo);
                            }
                            else if(bHelixSegment) {
                                if(bFullAtom) {
                                    this.createCurveSub(pnts[j], 1, colors, div, bHighlight, bRibbon, false, bShowArray, calphaIdArray, undefined, prevone, nexttwo);
                                }
                                else {
                                    this.createCurveSubArrow(pnts[j], 1, colors, div, bHighlight, bRibbon, num, j, pntsCA, prevCOArray, bShowArray, calphaIdArray, false, prevone, nexttwo);
                                }
                            }
                        }
                        if (fill) {
                            if(bSheetSegment) {
                                var start = 0, end = num - 1;
                                this.createStripArrow(pnts[0], pnts[num - 1], colors, div, thickness, bHighlight, num, start, end, pntsCA, prevCOArray, bShowArray, calphaIdArray, true, prevone, nexttwo);
                            }
                            else if(bHelixSegment) {
                                if(bFullAtom) {
                                    this.createStrip(pnts[0], pnts[num - 1], colors, div, thickness, bHighlight, false, bShowArray, calphaIdArray, undefined, prevone, nexttwo);
                                }
                                else {
                                    var start = 0, end = num - 1;
                                    this.createStripArrow(pnts[0], pnts[num - 1], colors, div, thickness, bHighlight, num, start, end, pntsCA, prevCOArray, bShowArray, calphaIdArray, true, prevone, nexttwo);
                                }
                            }
                            else {
                                if(bHighlight === 2) { // draw coils only when highlighted. if not highlighted, coils will be drawn as tubes separately
                                    this.createStrip(pnts[0], pnts[num - 1], colors, div, thickness, bHighlight, false, bShowArray, calphaIdArray, undefined, prevone, nexttwo);
                                }
                            }
                        }
                        for (var k = 0; k < num; ++k) pnts[k] = [];

                        colors = [];
                        pntsCA = [];
                        prevCOArray = [];
                        bShowArray = [];
                        calphaIdArray = [];
                        bSheetSegment = false;
                        bHelixSegment = false;
                    } // end if (atom.ssbegin || atom.ssend)

                    // end of a chain
//                    if ((currentChain !== atom.chain || currentResi + 1 !== atom.resi) && pnts[0].length > 0) {
                    if ((currentChain !== atom.chain) && pnts[0].length > 0) {

                        var atomName = 'CA';

                        var prevoneResid = this.atoms[prevAtomid].structure + '_' + this.atoms[prevAtomid].chain + '_' + (this.atoms[prevAtomid].resi - 1).toString();
                        var prevoneCoord = this.getAtomCoordFromResi(prevoneResid, atomName);
                        var prevone = (prevoneCoord !== undefined) ? [prevoneCoord] : [];

                        var nexttwo = [];

                        for (var j = 0; !fill && j < num; ++j) {
                            if(bSheetSegment) {
                                this.createCurveSubArrow(pnts[j], 1, colors, div, bHighlight, bRibbon, num, j, pntsCA, prevCOArray, bShowArray, calphaIdArray, true, prevone, nexttwo);
                            }
                            else if(bHelixSegment) {
                                if(bFullAtom) {
                                    this.createCurveSub(pnts[j], 1, colors, div, bHighlight, bRibbon, false, bShowArray, calphaIdArray, undefined, prevone, nexttwo);
                                }
                                else {
                                    this.createCurveSubArrow(pnts[j], 1, colors, div, bHighlight, bRibbon, num, j, pntsCA, prevCOArray, bShowArray, calphaIdArray, false, prevone, nexttwo);
                                }
                            }
                        }
                        if (fill) {
                            if(bSheetSegment) {
                                var start = 0, end = num - 1;
                                this.createStripArrow(pnts[0], pnts[num - 1], colors, div, thickness, bHighlight, num, start, end, pntsCA, prevCOArray, bShowArray, calphaIdArray, true, prevone, nexttwo);
                            }
                            else if(bHelixSegment) {
                                if(bFullAtom) {
                                    this.createStrip(pnts[0], pnts[num - 1], colors, div, thickness, bHighlight, false, bShowArray, calphaIdArray, undefined, prevone, nexttwo);
                                }
                                else {
                                    var start = 0, end = num - 1;
                                    this.createStripArrow(pnts[0], pnts[num - 1], colors, div, thickness, bHighlight, num, start, end, pntsCA, prevCOArray, bShowArray, calphaIdArray, false, prevone, nexttwo);
                                }
                            }
                        }

                        for (var k = 0; k < num; ++k) pnts[k] = [];
                        colors = [];
                        pntsCA = [];
                        prevCOArray = [];
                        bShowArray = [];
                        calphaIdArray = [];
                        bSheetSegment = false;
                        bHelixSegment = false;
                    }

                    currentChain = atom.chain;
                    currentResi = atom.resi;
                    ss = atom.ss;
                    ssend = atom.ssend;
                    prevAtomid = atom.serial;
                    prevResi = atom.resi;

                    prevCalphaid = calphaid;

                    // only update when atom.name === 'O'
                    prevCoorCA = currentCA;
                    prevCoorO = atom.coord;
                    prevColor = currentColor;
                } // end if (atom.name === 'O' || (this.bCalphaOnly && atom.name === 'CA') ) {
        } // end if ((atom.name === 'O' || atom.name === 'CA') && !atom.het) {
    } // end for

    caArray = [];

    this.createTube(tubeAtoms, 'CA', coilWidth, bHighlight);

    tubeAtoms = {};
    pnts = {};
};

/*
iCn3D.prototype.createStrandBrick = function (brick, color, thickness, bHighlight) {
    var num = this.strandDIV;
    var div = this.axisDIV;
    var doNotSmoothen = false;
    var helixSheetWidth = this.helixSheetWidth;

    if(bHighlight === 2) {
        thickness *= 1.5;
        helixSheetWidth *= 1.5;
    }

    var pnts = {}; for (var k = 0; k < num; ++k) pnts[k] = [];
    var colors = [];
    var prevCO = null, ss = null;
    for (var i = 0; i < 2; ++i) {
        var currentCA = brick.coords[i];

        colors.push(new THREE.Color(color));

        var O = new THREE.Vector3(brick.coords[2].x, brick.coords[2].y, brick.coords[2].z);
        O.normalize();

        O.multiplyScalar(helixSheetWidth);
        if (prevCO !== null && O.dot(prevCO) < 0) O.negate();
        prevCO = O;
        for (var j = 0, numM1Inv2 = 2 / (num - 1); j < num; ++j) {
            var delta = -1 + numM1Inv2 * j;
            var v = new THREE.Vector3(currentCA.x + prevCO.x * delta, currentCA.y + prevCO.y * delta, currentCA.z + prevCO.z * delta);
            if (!doNotSmoothen) v.smoothen = true;
            pnts[j].push(v);
        }
    }
    this.createStrip(pnts[0], pnts[num - 1], colors, div, thickness, bHighlight);
};
*/

// modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
iCn3D.prototype.createTubeSub = function (_pnts, colors, radii, bHighlight, prevone, nexttwo) {
    if (_pnts.length < 2) return;
    var circleDiv = this.tubeDIV, axisDiv = this.axisDIV;
    var circleDivInv = 1 / circleDiv, axisDivInv = 1 / axisDiv;
    var geo = new THREE.Geometry();
    var pnts_clrs = this.subdivide(_pnts, colors, axisDiv, undefined, undefined, prevone, nexttwo);

    var pnts = pnts_clrs[0];
    colors = pnts_clrs[2];

    var prevAxis1 = new THREE.Vector3(), prevAxis2;
    for (var i = 0, lim = pnts.length; i < lim; ++i) {
        var r, idx = (i - 1) * axisDivInv;
        if (i === 0) r = radii[0];
        else {
            if (idx % 1 === 0) r = radii[idx];
            else {
                var floored = Math.floor(idx);
                var tmp = idx - floored;
                r = radii[floored] * tmp + radii[floored + 1] * (1 - tmp);
            }
        }
        var delta, axis1, axis2;
        if (i < lim - 1) {
            delta = pnts[i].clone().sub(pnts[i + 1]);
            axis1 = new THREE.Vector3(0, -delta.z, delta.y).normalize().multiplyScalar(r);
            axis2 = delta.clone().cross(axis1).normalize().multiplyScalar(r);
            //      var dir = 1, offset = 0;
            if (prevAxis1.dot(axis1) < 0) {
                axis1.negate(); axis2.negate();  //dir = -1;//offset = 2 * Math.PI / axisDiv;
            }
            prevAxis1 = axis1; prevAxis2 = axis2;
        } else {
            axis1 = prevAxis1; axis2 = prevAxis2;
        }
        for (var j = 0; j < circleDiv; ++j) {
            var angle = 2 * Math.PI * circleDivInv * j; //* dir  + offset;
            geo.vertices.push(pnts[i].clone().add(axis1.clone().multiplyScalar(Math.cos(angle))).add(axis2.clone().multiplyScalar(Math.sin(angle))));
        }
    }
    var offset = 0;
    for (var i = 0, lim = pnts.length - 1; i < lim; ++i) {
        //var c = new THREE.Color(colors[Math.round((i - 1) * axisDivInv)]);
        var c = new THREE.Color(colors[i]);

        var reg = 0;
        var r1 = geo.vertices[offset].clone().sub(geo.vertices[offset + circleDiv]).lengthSq();
        var r2 = geo.vertices[offset].clone().sub(geo.vertices[offset + circleDiv + 1]).lengthSq();
        if (r1 > r2) { r1 = r2; reg = 1; };
        for (var j = 0; j < circleDiv; ++j) {
            geo.faces.push(new THREE.Face3(offset + j, offset + (j + reg) % circleDiv + circleDiv, offset + (j + 1) % circleDiv, undefined, c));
            geo.faces.push(new THREE.Face3(offset + (j + 1) % circleDiv, offset + (j + reg) % circleDiv + circleDiv, offset + (j + reg + 1) % circleDiv + circleDiv, undefined, c));
        }
        offset += circleDiv;
    }
    geo.computeFaceNormals();
    geo.computeVertexNormals(false);

    var mesh;
    if(bHighlight === 2) {
      mesh = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({ transparent: true, opacity: 0.5, specular: this.frac, shininess: 30, emissive: 0x000000, vertexColors: THREE.FaceColors, side: THREE.DoubleSide }));
      this.mdl.add(mesh);
    }
    else if(bHighlight === 1) {
      mesh = new THREE.Mesh(geo, this.matShader);
      mesh.renderOrder = this.renderOrderPicking;
      //this.mdlPicking.add(mesh);
      this.mdl.add(mesh);
    }
    else {
      mesh = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({ specular: this.frac, shininess: 30, emissive: 0x000000, vertexColors: THREE.FaceColors, side: THREE.DoubleSide }));
      this.mdl.add(mesh);
    }

    if(bHighlight === 1 || bHighlight === 2) {
        this.prevHighlightObjects.push(mesh);
    }
    else {
        this.objects.push(mesh);
    }
};

iCn3D.prototype.getAtomCoordFromResi = function (resid, atomName) {
    if(this.residues.hasOwnProperty(resid)) {
        for(var i in this.residues[resid]) {
            if(this.atoms[i].name === atomName && !this.atoms[i].het) {
                var coord = (this.atoms[i].coord2 !== undefined) ? this.atoms[i].coord2 : this.atoms[i].coord;

                return coord;
            }
        }
    }

    return undefined;
}

// modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
iCn3D.prototype.createTube = function (atoms, atomName, radius, bHighlight) {
    var pnts = [], colors = [], radii = [], prevone = [], nexttwo = [];
    var currentChain, currentResi;
    var index = 0;
    var prevAtom;
    var maxDist = 6.0;
    var maxDist2 = 3.0; // avoid tube between the residues in 3 residue helix

    var pnts_colors_radii_prevone_nexttwo = [];
    var firstAtom, atom;

    for (var i in atoms) {
        atom = atoms[i];
        if ((atom.name === atomName) && !atom.het) {
            if(index == 0) {
                firstAtom = atom;
            }

            //if (index > 0 && (currentChain !== atom.chain || currentResi + 1 !== atom.resi || Math.abs(atom.coord.x - prevAtom.coord.x) > maxDist || Math.abs(atom.coord.y - prevAtom.coord.y) > maxDist || Math.abs(atom.coord.z - prevAtom.coord.z) > maxDist) ) {
            if (index > 0 && (currentChain !== atom.chain || Math.abs(atom.coord.x - prevAtom.coord.x) > maxDist || Math.abs(atom.coord.y - prevAtom.coord.y) > maxDist || Math.abs(atom.coord.z - prevAtom.coord.z) > maxDist
              || (currentResi + 1 !== atom.resi && (Math.abs(atom.coord.x - prevAtom.coord.x) > maxDist2 || Math.abs(atom.coord.y - prevAtom.coord.y) > maxDist2 || Math.abs(atom.coord.z - prevAtom.coord.z) > maxDist2) )
              ) ) {
                if(bHighlight !== 2) {
                    //this.createTubeSub(pnts, colors, radii, bHighlight);
                    var prevoneResid = firstAtom.structure + '_' + firstAtom.chain + '_' + (firstAtom.resi - 1).toString();
                    var prevoneCoord = this.getAtomCoordFromResi(prevoneResid, atomName);
                    prevone = (prevoneCoord !== undefined) ? [prevoneCoord] : [];

                    var nextoneResid = prevAtom.structure + '_' + prevAtom.chain + '_' + (prevAtom.resi + 1).toString();
                    var nextoneCoord = this.getAtomCoordFromResi(nextoneResid, atomName);
                    if(nextoneCoord !== undefined) {
                        nexttwo.push(nextoneCoord);
                    }

                    var nexttwoResid = prevAtom.structure + '_' + prevAtom.chain + '_' + (prevAtom.resi + 2).toString();
                    var nexttwoCoord = this.getAtomCoordFromResi(nexttwoResid, atomName);
                    if(nexttwoCoord !== undefined) {
                        nexttwo.push(nexttwoCoord);
                    }

                    pnts_colors_radii_prevone_nexttwo.push({'pnts':pnts, 'colors':colors, 'radii':radii, 'prevone':prevone, 'nexttwo':nexttwo});
                }
                pnts = []; colors = []; radii = []; prevone = []; nexttwo = [];
                firstAtom = atom;
                index = 0;
            }
            pnts.push(atom.coord);

            var radiusFinal = radius;
            if(radius) {
                radiusFinal = radius;
            }
            else {
                if(atom.b > 0 && atom.b <= 100) {
                    radiusFinal = atom.b * 0.01;
                }
                else if(atom.b > 100) {
                    radiusFinal = 100 * 0.01;
                }
                else {
                    radiusFinal = this.coilWidth;
                }
            }

            //radii.push(radius || (atom.b > 0 ? atom.b * 0.01 : this.coilWidth));
            radii.push(radiusFinal);

            colors.push(atom.color);
            // the starting residue of a coil uses the color from thenext residue to avoid using the color of the last helix/sheet residue
            if(index === 1) colors[colors.length - 2] = atom.color;

            currentChain = atom.chain;
            currentResi = atom.resi;

            var scale = 1.2;
            if(bHighlight === 2 && !atom.ssbegin) {
                this.createBox(atom, undefined, undefined, scale, undefined, bHighlight);
            }

            ++index;

            prevAtom = atom;
        }
    }
    if(bHighlight !== 2) {
        //this.createTubeSub(pnts, colors, radii, bHighlight);

        prevone = [];
        if(firstAtom !== undefined) {
            var prevoneResid = firstAtom.structure + '_' + firstAtom.chain + '_' + (firstAtom.resi - 1).toString();
            var prevoneCoord = this.getAtomCoordFromResi(prevoneResid, atomName);
            prevone = (prevoneCoord !== undefined) ? [prevoneCoord] : [];
        }

        nexttwo = [];
        if(atom !== undefined) {
            var nextoneResid = atom.structure + '_' + atom.chain + '_' + (atom.resi + 1).toString();
            var nextoneCoord = this.getAtomCoordFromResi(nextoneResid, atomName);
            if(nextoneCoord !== undefined) {
                nexttwo.push(nextoneCoord);
            }

            var nexttwoResid = atom.structure + '_' + atom.chain + '_' + (atom.resi + 2).toString();
            var nexttwoCoord = this.getAtomCoordFromResi(nexttwoResid, atomName);
            if(nexttwoCoord !== undefined) {
                nexttwo.push(nexttwoCoord);
            }
        }

        pnts_colors_radii_prevone_nexttwo.push({'pnts':pnts, 'colors':colors, 'radii':radii, 'prevone':prevone, 'nexttwo':nexttwo});
    }

    for(var i = 0, il = pnts_colors_radii_prevone_nexttwo.length; i < il; ++i) {
        var pnts = pnts_colors_radii_prevone_nexttwo[i].pnts;
        var colors = pnts_colors_radii_prevone_nexttwo[i].colors;
        var radii = pnts_colors_radii_prevone_nexttwo[i].radii;
        var prevone = pnts_colors_radii_prevone_nexttwo[i].prevone;
        var nexttwo = pnts_colors_radii_prevone_nexttwo[i].nexttwo;

        this.createTubeSub(pnts, colors, radii, bHighlight, prevone, nexttwo);
    }

    pnts_colors_radii_prevone_nexttwo = [];
};

// modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
iCn3D.prototype.createCylinderHelix = function (atoms, radius, bHighlight) {
    var start = null;
    var currentChain, currentResi;
    var others = {}, beta = {};
    var i;
    for (i in atoms) {
        var atom = atoms[i];
        if (atom.het) continue;
        if ((atom.ss !== 'helix' && atom.ss !== 'sheet') || atom.ssend || atom.ssbegin) others[atom.serial] = atom;
        if (atom.ss === 'sheet') beta[atom.serial] = atom;
        if (atom.name !== 'CA') continue;
        if (atom.ss === 'helix' && atom.ssend) {
            if (start !== null && currentChain === atom.chain && currentResi < atom.resi) {
                if(bHighlight === 1 || bHighlight === 2) {
                    this.createCylinder(start.coord, atom.coord, radius, this.hColor, bHighlight);
                }
                else {
                    this.createCylinder(start.coord, atom.coord, radius, atom.color);
                }
            }

            start = null;
        }

        if (start === null && atom.ss === 'helix' && atom.ssbegin) {
            start = atom;

            currentChain = atom.chain;
            currentResi = atom.resi;
        }
    }

    if(bHighlight === 1 || bHighlight === 2) {
        if(Object.keys(others).length > 0) this.createTube(others, 'CA', this.coilWidth, bHighlight);
        if(Object.keys(beta).length > 0) this.createStrand(beta, undefined, undefined, true, 0, this.helixSheetWidth, false, this.ribbonthickness * 2, bHighlight);
    }
    else {
        if(Object.keys(others).length > 0) this.createTube(others, 'CA', this.coilWidth);
        if(Object.keys(beta).length > 0) this.createStrand(beta, undefined, undefined, true, 0, this.helixSheetWidth, false, this.ribbonthickness * 2);
    }
};

// modified from GLmol (http://webglmol.osdn.jp/index-en.html)
iCn3D.prototype.drawNucleicAcidStick = function(atomlist, bHighlight) {
   var currentChain, currentResi, start = null, end = null;
   var i;

   for (i in atomlist) {
      var atom = atomlist[i];
      if (atom === undefined || atom.het) continue;

      if (atom.resi !== currentResi || atom.chain !== currentChain) {
         if (start !== null && end !== null) {
            this.createCylinder(new THREE.Vector3(start.coord.x, start.coord.y, start.coord.z),
                              new THREE.Vector3(end.coord.x, end.coord.y, end.coord.z), this.cylinderRadius, start.color, bHighlight);
         }
         start = null; end = null;
      }
      if (atom.name === 'O3\'' || atom.name === 'O3*') start = atom;
      if (atom.resn === '  A' || atom.resn === '  G' || atom.resn === ' DA' || atom.resn === ' DG') {
         if (atom.name === 'N1')  end = atom; //  N1(AG), N3(CTU)
      } else if (atom.name === 'N3') {
         end = atom;
      }
      currentResi = atom.resi; currentChain = atom.chain;
   }
   if (start !== null && end !== null)
      this.createCylinder(new THREE.Vector3(start.coord.x, start.coord.y, start.coord.z),
                        new THREE.Vector3(end.coord.x, end.coord.y, end.coord.z), this.cylinderRadius, start.color, bHighlight);
};

//iCn3D.prototype.isCalphaPhosOnly = function(atomlist, atomname1, atomname2) {
iCn3D.prototype.isCalphaPhosOnly = function(atomlist) {
      var bCalphaPhosOnly = false;

      var index = 0, testLength = 50; //30
      //var bOtherAtoms = false;
      var nOtherAtoms = 0;
      for(var i in atomlist) {
        if(index < testLength) {
          if(atomlist[i].name !== "CA" && atomlist[i].name !== "P" && atomlist[i].name !== "O3'" && atomlist[i].name !== "O3*") {
            //bOtherAtoms = true;
            //break;
            ++nOtherAtoms;
          }
        }
        else {
          break;
        }

        ++index;
      }

      //if(!bOtherAtoms) {
      if(nOtherAtoms < 0.5 * index) {
        bCalphaPhosOnly = true;
      }

      return bCalphaPhosOnly;
};

// modified from GLmol (http://webglmol.osdn.jp/index-en.html)
iCn3D.prototype.drawCartoonNucleicAcid = function(atomlist, div, thickness, bHighlight) {
   this.drawStrandNucleicAcid(atomlist, 2, div, true, undefined, thickness, bHighlight);
};

// modified from GLmol (http://webglmol.osdn.jp/index-en.html)
iCn3D.prototype.drawStrandNucleicAcid = function(atomlist, num, div, fill, nucleicAcidWidth, thickness, bHighlight) {
   if(bHighlight === 2) {
       num = undefined;
       thickness = undefined;
   }

   nucleicAcidWidth = nucleicAcidWidth || this.nucleicAcidWidth;
   div = div || this.axisDIV;
   num = num || this.nucleicAcidStrandDIV;
   var i, j, k;
   var pnts = []; for (k = 0; k < num; k++) pnts[k] = [];
   var colors = [];
   var currentChain, currentResi, currentO3;
   var prevOO = null;

   for (i in atomlist) {
      var atom = atomlist[i];
      if (atom === undefined) continue;

      if ((atom.name === 'O3\'' || atom.name === 'OP2' || atom.name === 'O3*' || atom.name === 'O2P') && !atom.het) {
         if (atom.name === 'O3\'' || atom.name === 'O3*') { // to connect 3' end. FIXME: better way to do?
            if (currentChain !== atom.chain || currentResi + 1 !== atom.resi) {
//            if (currentChain !== atom.chain) {
               if (currentO3 && prevOO) {
                  for (j = 0; j < num; j++) {
                     var delta = -1 + 2 / (num - 1) * j;
                     pnts[j].push(new THREE.Vector3(currentO3.x + prevOO.x * delta,
                      currentO3.y + prevOO.y * delta, currentO3.z + prevOO.z * delta));
                  }
               }
               if (fill) this.createStrip(pnts[0], pnts[1], colors, div, thickness, bHighlight);
               for (j = 0; !thickness && j < num; j++)
                  this.createCurveSub(pnts[j], 1 ,colors, div, bHighlight);
               var pnts = []; for (k = 0; k < num; k++) pnts[k] = [];
               colors = [];
               prevOO = null;
            }
            currentO3 = new THREE.Vector3(atom.coord.x, atom.coord.y, atom.coord.z);
            currentChain = atom.chain;
            currentResi = atom.resi;
            if(bHighlight === 1 || bHighlight === 2) {
                colors.push(this.hColor);
            }
            else {
                colors.push(atom.color);
            }

         }
         else if (atom.name === 'OP2' || atom.name === 'O2P') {
            if (!currentO3) {prevOO = null; continue;} // for 5' phosphate (e.g. 3QX3)
            var O = new THREE.Vector3(atom.coord.x, atom.coord.y, atom.coord.z);
            O.sub(currentO3);
            O.normalize().multiplyScalar(nucleicAcidWidth);  // TODO: refactor
            //if (prevOO !== undefined && O.dot(prevOO) < 0) {
            if (prevOO !== null && O.dot(prevOO) < 0) {
               O.negate();
            }
            prevOO = O;
            for (j = 0; j < num; j++) {
               var delta = -1 + 2 / (num - 1) * j;
               pnts[j].push(new THREE.Vector3(currentO3.x + prevOO.x * delta,
                 currentO3.y + prevOO.y * delta, currentO3.z + prevOO.z * delta));
            }
            currentO3 = null;
         }
      }
   }

   if (currentO3 && prevOO) {
      for (j = 0; j < num; j++) {
         var delta = -1 + 2 / (num - 1) * j;
         pnts[j].push(new THREE.Vector3(currentO3.x + prevOO.x * delta,
           currentO3.y + prevOO.y * delta, currentO3.z + prevOO.z * delta));
      }
   }
   if (fill) this.createStrip(pnts[0], pnts[1], colors, div, thickness, bHighlight);
   for (j = 0; !thickness && j < num; j++)
      this.createCurveSub(pnts[j], 1 ,colors, div, bHighlight);
};

iCn3D.prototype.createSingleLine = function ( src, dst, colorHex, dashed, dashSize ) {
    var geom = new THREE.Geometry();
    var mat;

    if(dashed) {
        mat = new THREE.LineDashedMaterial({ linewidth: 1, color: colorHex, dashSize: dashSize, gapSize: 0.5*dashSize });
    } else {
        mat = new THREE.LineBasicMaterial({ linewidth: 1, color: colorHex });
    }

    geom.vertices.push( src );
    geom.vertices.push( dst );
    if(dashed) geom.computeLineDistances(); // This one is SUPER important, otherwise dashed lines will appear as simple plain lines

    //var axis = new THREE.Line( geom, mat, THREE.LineSegments );
    var axis = new THREE.LineSegments( geom, mat );

    return axis;
};

// used for highlight
iCn3D.prototype.createBox = function (atom, defaultRadius, forceDefault, scale, color, bHighlight) {
    var mesh;

    if(defaultRadius === undefined) defaultRadius = 0.8;
    if(forceDefault === undefined) forceDefault = false;
    if(scale === undefined) scale = 0.8;

    if(bHighlight) {
        if(color === undefined) color = this.hColor;

          mesh = new THREE.Mesh(this.boxGeometry, new THREE.MeshPhongMaterial({ transparent: true, opacity: 0.5, specular: this.frac, shininess: 30, emissive: 0x000000, color: color }));
    }
    else {
        if(color === undefined) color = atom.color;

          mesh = new THREE.Mesh(this.boxGeometry, new THREE.MeshPhongMaterial({ specular: this.frac, shininess: 30, emissive: 0x000000, color: color }));
    }

    mesh.scale.x = mesh.scale.y = mesh.scale.z = forceDefault ? defaultRadius : (this.vdwRadii[atom.elem] || defaultRadius) * (scale ? scale : 1);
    mesh.position.copy(atom.coord);
    this.mdl.add(mesh);

    if(bHighlight) {
        this.prevHighlightObjects.push(mesh);
    }
    else {
        this.objects.push(mesh);
    }
};

// modified from 3Dmol (http://3dmol.csb.pitt.edu/)
// new: http://stackoverflow.com/questions/23514274/three-js-2d-text-sprite-labels
// old: http://stemkoski.github.io/Three.js/Sprite-Text-Labels.html
iCn3D.prototype.makeTextSprite = function ( message, parameters ) {

    if ( parameters === undefined ) parameters = {};
    var fontface = parameters.hasOwnProperty("fontface") ? parameters["fontface"] : "Arial";
    var fontsize = parameters.hasOwnProperty("fontsize") ? parameters["fontsize"] : 18;

    var a = parameters.hasOwnProperty("alpha") ? parameters["alpha"] : 1.0;

    var bBkgd = true;
    var bSchematic = false;
    if(parameters.hasOwnProperty("bSchematic") &&  parameters["bSchematic"]) {
        bSchematic = true;

        fontsize = 40;
    }

    var backgroundColor, borderColor, borderThickness;
    if(parameters.hasOwnProperty("backgroundColor") &&  parameters["backgroundColor"] !== undefined) {
        backgroundColor = this.hexToRgb(parameters["backgroundColor"], a);

        borderColor = parameters.hasOwnProperty("borderColor") ? this.hexToRgb(parameters["borderColor"], a) : { r:0, g:0, b:0, a:1.0 };
        borderThickness = parameters.hasOwnProperty("borderThickness") ? parameters["borderThickness"] : 4;
    }
    else {
        bBkgd = false;
        backgroundColor = undefined;
        borderColor = undefined;
        borderThickness = 0;
    }

    var textAlpha = 1.0;
    var textColor = parameters.hasOwnProperty("textColor") &&  parameters["textColor"] !== undefined ? this.hexToRgb(parameters["textColor"], textAlpha) : { r:255, g:255, b:0, a:1.0 };

    var canvas = document.createElement('canvas');

    var context = canvas.getContext('2d');

    context.font = "Bold " + fontsize + "px " + fontface;

    var metrics = context.measureText( message );

    var textWidth = metrics.width;

    var width = textWidth + 2*borderThickness;
    var height = fontsize + 2*borderThickness;

    if(bSchematic) {
        if(width > height) {
            height = width;
        }
        else {
            width = height;
        }
    }

    //var factor = (bSchematic) ? 3 * this.oriMaxD / 100 : 3 * this.oriMaxD / 100;
    var factor = (bSchematic) ? 3 * this.maxD / 100 : 3 * this.maxD / 100;

    var expandWidthFactor = 0.8 * textWidth / height;

/*
    // define width and height will make long text be squashed, but make the label to appear at the exact location
    if(bSchematic || message.length <= textLengthThreshold) {
        canvas.width = width;
        canvas.height = height;

        factor = 3 * this.oriMaxD / 100;
    }
*/

    canvas.width = width;
    canvas.height = height;

    context.clearRect(0, 0, width, height);

    //var radius = context.measureText( "M" ).width;

    if(bBkgd) {
        // background color
        context.fillStyle   = "rgba(" + backgroundColor.r + "," + backgroundColor.g + "," + backgroundColor.b + "," + backgroundColor.a + ")";
        // border color
        context.strokeStyle = "rgba(" + borderColor.r + "," + borderColor.g + "," + borderColor.b + "," + borderColor.a + ")";

        context.lineWidth = borderThickness;

        if(bSchematic) {
            var r = width * 0.35;
            this.circle(context, 0, 0, width, height, r);
        }
        else {
            //var r = (message.length <= textLengthThreshold) ? height * 0.5 : 0;
            //var r = height * 0.8;
            var r = 0;
            this.roundRect(context, 0, 0, width, height, r);
        }
    }

    // need to redefine again
    context.font = "Bold " + fontsize + "px " + fontface;

    context.textAlign = "center";
    context.textBaseline = "middle";

    context.fillStyle = "rgba("+textColor.r+", "+textColor.g+", "+textColor.b+", 1.0)";
    context.strokeStyle = "rgba("+textColor.r+", "+textColor.g+", "+textColor.b+", 1.0)";

    context.fillText( message, width * 0.5, height * 0.5);

    // canvas contents will be used for a texture
    var texture = new THREE.Texture(canvas)
    texture.needsUpdate = true;

    var frontOfTarget = true;
    //var spriteMaterial = new THREE.SpriteMaterial( { map: texture, useScreenCoordinates: false } );
    var spriteMaterial = new THREE.SpriteMaterial( {
        map: texture,
        //useScreenCoordinates: false,
        depthTest: !frontOfTarget,
        depthWrite: !frontOfTarget
    } );

    //https://stackoverflow.com/questions/29421702/threejs-texture
    spriteMaterial.map.minFilter = THREE.LinearFilter;

    var sprite = new THREE.Sprite( spriteMaterial );

    if(bSchematic) {
        sprite.scale.set(factor, factor, 1.0);
    }
    else {
        sprite.scale.set(expandWidthFactor * factor, factor, 1.0);
    }

    return sprite;
};

// function for drawing rounded rectangles
iCn3D.prototype.roundRect = function (ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.lineTo(x+w-r, y);
    ctx.quadraticCurveTo(x+w, y, x+w, y+r);
    ctx.lineTo(x+w, y+h-r);
    ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
    ctx.lineTo(x+r, y+h);
    ctx.quadraticCurveTo(x, y+h, x, y+h-r);
    ctx.lineTo(x, y+r);
    ctx.quadraticCurveTo(x, y, x+r, y);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
};

iCn3D.prototype.circle = function (ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.arc(x+w/2, y+h/2, r, 0, 2*Math.PI, true);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
};

// modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
iCn3D.prototype.createLabelRepresentation = function (labels) {
    var tmpMaxD = this.maxD;

    for(var name in labels) {
        var labelArray = (labels[name] !== undefined) ? labels[name] : [];

        for (var i = 0, il = labelArray.length; i < il; ++i) {
            var label = labelArray[i];
            // make sure fontsize is a number

            if(label.size == 0) label.size = undefined;
            if(label.color == 0) label.color = undefined;
            if(label.background == 0) label.background = undefined;

            var labelsize = (label.size !== undefined) ? label.size : this.LABELSIZE;
            var labelcolor = (label.color !== undefined) ? label.color : '#ffff00';
            var labelbackground = (label.background !== undefined) ? label.background : '#cccccc';
            var labelalpha = (label.alpha !== undefined) ? label.alpha : 1.0;
            // if label.background is undefined, no background will be drawn
            labelbackground = label.background;

            if(labelcolor !== undefined && labelbackground !== undefined && labelcolor.toLowerCase() === labelbackground.toLowerCase()) {
                labelcolor = "#888888";
            }

            var bChemicalInProteinOrTrace = false;
            var bStick = false;
            if(Object.keys(this.proteins).length + Object.keys(this.nucleotides).length > 0) {
                var firstAtom = this.getFirstAtomObj(this.hAtoms);
                if(firstAtom !== undefined) {
                    if(this.chemicals.hasOwnProperty(firstAtom.serial)
                      || firstAtom.style == 'c alpha trace' || firstAtom.style == 'o3 trace'
                      //|| firstAtom.style == 'schematic'
                      ) {
                        bChemicalInProteinOrTrace = true;
                    }

                    if(firstAtom.style == 'stick' || firstAtom.style == 'ball and stick') {
                        bStick = true;
                    }
                }
            }

            // somehow the transformation is not stable when reset camera
/*
            if(bChemicalInProteinOrTrace) {
                this.maxD = 15; // 50
                this.setCamera();
            }
            else if(bStick) {
                this.maxD = 30; // 50
                this.setCamera();
            }
            else {
                if(Object.keys(this.proteins).length + Object.keys(this.nucleotides).length > 0) {
                    this.maxD = 100;
                    this.setCamera();
                }
                else {
                    this.maxD = 15;
                    this.setCamera();
                }
            }
*/

            var bb;
            if(label.bSchematic !== undefined && label.bSchematic) {

                bb = this.makeTextSprite(label.text, {fontsize: parseInt(labelsize), textColor: labelcolor, borderColor: labelbackground, backgroundColor: labelbackground, alpha: labelalpha, bSchematic: 1});
            }
            else {
                if(label.text.length === 1) {
                    bb = this.makeTextSprite(label.text, {fontsize: parseInt(labelsize), textColor: labelcolor, borderColor: labelbackground, backgroundColor: labelbackground, alpha: labelalpha, bSchematic: 1});
                }
                else {
                    bb = this.makeTextSprite(label.text, {fontsize: parseInt(labelsize), textColor: labelcolor, borderColor: labelbackground, backgroundColor: labelbackground, alpha: labelalpha, bSchematic: 0});
                }
            }

            bb.position.set(label.position.x, label.position.y, label.position.z);
            this.mdl.add(bb);
            // do not add labels to objects for pk
        }
    }

    // somehow the transformation is not stable when reset camera
//    this.maxD = tmpMaxD;
//    this.setCamera();
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3D.prototype.setAtmClr = function(atoms, hex) {
    for (var i in atoms) {
        var atom = this.atoms[i];
        atom.color = new THREE.Color().setHex(hex);

        this.atomPrevColors[i] = atom.color;
    }
};

iCn3D.prototype.updateChainsColor = function (atom) {
    var chainid = atom.structure + '_' + atom.chain;
    if(this.chainsColor[chainid] !== undefined) {  // for mmdbid and align input
        this.chainsColor[chainid] = atom.color;
    }
};

iCn3D.prototype.setMmdbChainColor = function (inAtoms) {
    var atoms = (inAtoms === undefined) ? this.hAtoms : inAtoms;
    this.applyOriginalColor(this.hash2Atoms(atoms));

    // atom color
    var atomHash = this.unionHash(this.chemicals, this.ions);

    for (var i in atomHash) {
        var atom = this.atoms[i];
        atom.color = this.atomColors[atom.elem] || this.defaultAtomColor;

        this.atomPrevColors[i] = atom.color;
    }
};

iCn3D.prototype.setConservationColor = function (atoms, bIdentity) {
/*
    for (var i in atoms) {
        var atom = this.atoms[i];
        atom.color = this.defaultAtomColor;

        this.atomPrevColors[i] = atom.color;
    }
*/
    this.setMmdbChainColor(atoms);

    for(var chainid in this.alnChainsSeq) {
        var resObjectArray = this.alnChainsSeq[chainid];

        for(var i = 0, il = resObjectArray.length; i < il; ++i) {
            var residueid = chainid + '_' + resObjectArray[i].resi;

            for(var j in this.residues[residueid]) {
                if(atoms.hasOwnProperty(j)) {
                    var color = (bIdentity) ? new THREE.Color(resObjectArray[i].color) : new THREE.Color(resObjectArray[i].color2);
                    this.atoms[j].color = color;
                    this.atomPrevColors[j] = color;
                }
            }
        }
    }
};

iCn3D.prototype.setColorByOptions = function (options, atoms, bUseInputColor) {
 if(options !== undefined) {
  if(bUseInputColor !== undefined && bUseInputColor) {
    for (var i in atoms) {
        var atom = this.atoms[i];

        this.atomPrevColors[i] = atom.color;
    }
  }
  else if(options.color.indexOf("#") === 0) {
    for (var i in atoms) {
        var atom = this.atoms[i];
        atom.color = new THREE.Color().setStyle(options.color.toLowerCase());

        this.atomPrevColors[i] = atom.color;
    }
  }
  else {
    switch (options.color.toLowerCase()) {
        case 'spectrum':
            var idx = 0;
            //var lastTerSerialInv = 1 / this.lastTerSerial;
            //var lastTerSerialInv = 1 / this.cnt;
            var cnt = 0;
            for (var i in atoms) {
                var atom = this.atoms[i];
                if(!atom.het) ++cnt;
            }

            var lastTerSerialInv = 1 / cnt;
            for (var i in atoms) {
                var atom = this.atoms[i];
                atom.color = atom.het ? this.atomColors[atom.elem] || this.defaultAtomColor : new THREE.Color().setHSL(2 / 3 * (1 - idx++ * lastTerSerialInv), 1, 0.45);
                //atom.color = this.atomColors[atom.elem] || this.defaultAtomColor;

                this.atomPrevColors[i] = atom.color;
            }
            break;
        case 'chain':
            if(this.chainsColor !== undefined && Object.keys(this.chainsColor).length > 0) { // mmdb input
                this.setMmdbChainColor();
            }
            else {
                var index = -1, prevChain = '', colorLength = this.stdChainColors.length;
                for (var i in atoms) {
                    var atom = this.atoms[i];

                    if(atom.chain != prevChain) {
                        ++index;

                        index = index % colorLength;
                    }

                    atom.color = this.stdChainColors[index];

                    if(Object.keys(this.chainsColor).length > 0) this.updateChainsColor(atom);
                    this.atomPrevColors[i] = atom.color;

                    prevChain = atom.chain;
                }
            }
            break;
        case 'secondary structure':
            this.sheetcolor = 'green';
            for (var i in atoms) {
                var atom = this.atoms[i];
                // secondary color of nucleotide: blue (new THREE.Color(0x0000FF))
                atom.color = atom.het ? this.atomColors[atom.elem] || this.defaultAtomColor : this.ssColors[atom.ss] || new THREE.Color(0xFF00FF);

                this.atomPrevColors[i] = atom.color;
            }

            break;

        case 'secondary structure yellow':
            this.sheetcolor = 'yellow';
            for (var i in atoms) {
                var atom = this.atoms[i];
                // secondary color of nucleotide: blue (new THREE.Color(0x0000FF))
                atom.color = atom.het ? this.atomColors[atom.elem] || this.defaultAtomColor : this.ssColors2[atom.ss] || new THREE.Color(0xFF00FF);

                this.atomPrevColors[i] = atom.color;
            }

            break;

        case 'residue':
            for (var i in atoms) {
                var atom = this.atoms[i];
                atom.color = atom.het ? this.atomColors[atom.elem] || this.defaultAtomColor : this.residueColors[atom.resn] || this.defaultResidueColor;

                this.atomPrevColors[i] = atom.color;
            }
            break;
        case 'charge':
            for (var i in atoms) {
                var atom = this.atoms[i];

                //atom.color = atom.het ? this.atomColors[atom.elem] || this.defaultAtomColor : this.chargeColors[atom.resn] || this.defaultResidueColor;
                atom.color = atom.het ? this.defaultAtomColor : this.chargeColors[atom.resn] || this.defaultResidueColor;

                this.atomPrevColors[i] = atom.color;
            }
            break;
        case 'hydrophobic':
            for (var i in atoms) {
                var atom = this.atoms[i];

                //atom.color = atom.het ? this.atomColors[atom.elem] || this.defaultAtomColor : this.chargeColors[atom.resn] || this.defaultResidueColor;
                atom.color = atom.het ? this.defaultAtomColor : this.hydrophobicColors[atom.resn] || this.defaultResidueColor;

                this.atomPrevColors[i] = atom.color;
            }
            break;
        case 'atom':
            for (var i in atoms) {
                var atom = this.atoms[i];
                atom.color = this.atomColors[atom.elem] || this.defaultAtomColor;

                this.atomPrevColors[i] = atom.color;
            }
            break;

        case 'b factor':
/*
            //http://proteopedia.org/wiki/index.php/Disorder
            // < 30: blue; > 60: red; use 45 as the middle value
            if (!this.middB) {
                var minB = 1000, maxB = -1000;
                for (var i in this.atoms) {
                    var atom = this.atoms[i];
                    if (minB > atom.b) minB = atom.b;
                    if (maxB < atom.b) maxB = atom.b;
                }

                if(minB > 30) minB = 30;
                if(maxB < 60) maxB = 60;

                this.middB = 45; //(maxB + minB) * 0.5;
                this.spanBinv1 = (this.middB > minB) ? 1.0 / (this.middB - minB) : 0;
                this.spanBinv2 = (this.middB < maxB) ? 1.0 / (maxB - this.middB) : 0;
            }
*/

            // http://proteopedia.org/wiki/index.php/Temperature_color_schemes
            // Fixed: Middle (white): 50, red: >= 100, blue: 0
            this.middB = 50;
            this.spanBinv1 = 0.02;
            this.spanBinv2 = 0.02;

            for (var i in atoms) {
                var atom = this.atoms[i];
                if(atom.b === undefined || parseInt(atom.b * 1000) == 0) { // invalid b-factor
                    atom.color =  new THREE.Color().setRGB(0, 1, 0);
                }
                else {
                    var b = atom.b;
                    if(b > 100) b = 100;

                    atom.color = b < this.middB ? new THREE.Color().setRGB(1 - (s = (this.middB - b) * this.spanBinv1), 1 - s, 1) : new THREE.Color().setRGB(1, 1 - (s = (b - this.middB) * this.spanBinv2), 1 - s);
                }

                this.atomPrevColors[i] = atom.color;
            }
            break;

        case 'b factor percentile':
            //http://proteopedia.org/wiki/index.php/Disorder
            // percentile normalize B-factor values from 0 to 1
            var minB = 1000, maxB = -1000;
            if (!this.bfactorArray) {
                this.bfactorArray = [];
                for (var i in this.atoms) {
                    var atom = this.atoms[i];
                    if (minB > atom.b) minB = atom.b;
                    if (maxB < atom.b) maxB = atom.b;

                    this.bfactorArray.push(atom.b);
                }

                this.bfactorArray.sort(function(a, b) { return a - b; });
            }

            var totalCnt = this.bfactorArray.length;
            for (var i in atoms) {
                var atom = this.atoms[i];
                if(atom.b === undefined || parseInt(atom.b * 1000) == 0 || this.bfactorArray.length == 0) { // invalid b-factor
                    atom.color =  new THREE.Color().setRGB(0, 1, 0);
                }
                else {
                    var percentile = this.bfactorArray.indexOf(atom.b) / totalCnt;

                    atom.color = percentile < 0.5 ? new THREE.Color().setRGB(percentile * 2, percentile * 2, 1) : new THREE.Color().setRGB(1, (1 - percentile) * 2, (1 - percentile) * 2);
                }

                this.atomPrevColors[i] = atom.color;
            }

            break;

        case 'identity':
            this.setConservationColor(atoms, true);
            break;

        case 'conserved': // backward-compatible, "conserved" was changed to "identity"
            this.setConservationColor(atoms, true);
            break;

        case 'conservation':
            this.setConservationColor(atoms, false);
            break;

        case 'white':
            this.setAtmClr(atoms, 0xFFFFFF);
            break;

        case 'grey':
            this.setAtmClr(atoms, 0x888888);
            break;

        case 'red':
            this.setAtmClr(atoms, 0xFF0000);
            break;
        case 'green':
            this.setAtmClr(atoms, 0x00FF00);
            break;
        case 'blue':
            this.setAtmClr(atoms, 0x0000FF);
            break;
        case 'magenta':
            this.setAtmClr(atoms, 0xFF00FF);
            break;
        case 'yellow':
            this.setAtmClr(atoms, 0xFFFF00);
            break;
        case 'cyan':
            this.setAtmClr(atoms, 0x00FFFF);
            break;
        case 'custom':
            // do the coloring separately
            break;

        default: // the "#" was missed in order to make sharelink work
            for (var i in atoms) {
                var atom = this.atoms[i];
                atom.color = new THREE.Color().setStyle("#" + options.color.toLowerCase());

                this.atomPrevColors[i] = atom.color;
            }

            break;
    }
  }
 }
};

iCn3D.prototype.applyDisplayOptions = function (options, atoms, bHighlight) { var me = this; // atoms: hash of key -> 1
    if(options === undefined) options = this.opts;

    var residueHash = {};
    var singletonResidueHash = {};
    var atomsObj = {};
    var residueid;

    if(bHighlight === 1 && Object.keys(atoms).length < Object.keys(this.atoms).length) {
        atomsObj = this.hash2Atoms(atoms);

        //for(var i in atomsObj) {
        //    var atom = atomsObj[i];

        //    residueid = atom.structure + '_' + atom.chain + '_' + atom.resi;
        //    residueHash[residueid] = 1;
        //}

        residueHash = me.getResiduesFromAtoms(atoms);

        // find singleton residues
        for(var i in residueHash) {
            residueid = i;

            var last = i.lastIndexOf('_');
            var base = i.substr(0, last + 1);
            var lastResi = parseInt(i.substr(last + 1));

            var prevResidueid = base + (lastResi - 1).toString();
            var nextResidueid = base + (lastResi + 1).toString();

            if(!residueHash.hasOwnProperty(prevResidueid) && !residueHash.hasOwnProperty(prevResidueid)) {
                singletonResidueHash[i] = 1;
            }
        }

        // show the only atom in a transparent box
        if(Object.keys(atomsObj).length === 1 && Object.keys(this.residues[residueid]).length > 1
              && atomsObj[Object.keys(atomsObj)[0]].style !== 'sphere' && atomsObj[Object.keys(atomsObj)[0]].style !== 'dot') {
            if(this.bCid === undefined || !this.bCid) {
                for(var i in atomsObj) {
                    var atom = atomsObj[i];
                    var scale = 1.0;
                    this.createBox(atom, undefined, undefined, scale, undefined, bHighlight);
                }
            }
        }
        else {
            // if only one residue, add the next residue in order to show highlight
            for(var residueid in singletonResidueHash) {
                //var atom = this.getFirstAtomObj(this.residues[residueid]);
                // get calpha
                var calpha = this.getFirstCalphaAtomObj(this.residues[residueid]);
                var atom = calpha;

                var prevResidueid = atom.structure + '_' + atom.chain + '_' + parseInt(atom.resi - 1);
                var nextResidueid = atom.structure + '_' + atom.chain + '_' + parseInt(atom.resi + 1);

                //ribbon, strand, cylinder and plate, nucleotide cartoon, o3 trace, schematic, c alpha trace, b factor tube, lines, stick, ball and stick, sphere, dot

                if(atom.style === 'cylinder and plate' && atom.ss === 'helix') { // no way to highlight part of cylinder
                    for(var i in this.residues[residueid]) {
                        var atom = this.atoms[i];
                        var scale = 1.0;
                        this.createBox(atom, undefined, undefined, scale, undefined, bHighlight);
                    }
                }
                else if( (atom.style === 'ribbon' && atom.ss === 'coil') || (atom.style === 'strand' && atom.ss === 'coil') || atom.style === 'o3 trace' || atom.style === 'schematic' || atom.style === 'c alpha trace' || atom.style === 'b factor tube' || (atom.style === 'cylinder and plate' && atom.ss !== 'helix') ) {
                    // do not add extra residue if the side chain is shown
                    if(calpha !== undefined && calpha.style2 !== undefined && calpha.style2 !== 'nothing') continue;

                    var bAddResidue = false;
                    // add the next residue with same style
                    if(!bAddResidue && this.residues.hasOwnProperty(nextResidueid)) {
                        var index2 = Object.keys(this.residues[nextResidueid])[0];
                        var atom2 = this.hash2Atoms(this.residues[nextResidueid])[index2];
                        if( (atom.style === atom2.style && !atom2.ssbegin) || atom2.ssbegin) {
                            var residueAtoms = this.residues[nextResidueid];
                            atoms = this.unionHash(atoms, residueAtoms);

                            bAddResidue = true;

                            // record the highlight style for the artificial residue
                            if(atom2.ssbegin) {
                                for(var i in residueAtoms) {
                                    this.atoms[i].notshow = true;
                                }
                            }
                        }
                    }

                    // add the previous residue with same style
                    if(!bAddResidue && this.residues.hasOwnProperty(prevResidueid)) {
                        var index2 = Object.keys(this.residues[prevResidueid])[0];
                        var atom2 = this.hash2Atoms(this.residues[prevResidueid])[index2];
                        if(atom.style === atom2.style) {
                            atoms = this.unionHash(atoms, this.residues[prevResidueid]);

                            bAddResidue = true;
                        }
                    }
                }
                else if( (atom.style === 'ribbon' && atom.ss !== 'coil' && atom.ssend) || (atom.style === 'strand' && atom.ss !== 'coil' && atom.ssend)) {
                    // do not add extra residue if the side chain is shown
                    if(calpha !== undefined && calpha.style2 !== undefined && calpha.style2 !== 'nothing') continue;

                    var bAddResidue = false;
                    // add the next residue with same style
                    if(!bAddResidue && this.residues.hasOwnProperty(nextResidueid)) {
                        var index2 = Object.keys(this.residues[nextResidueid])[0];
                        var atom2 = this.hash2Atoms(this.residues[nextResidueid])[index2];
                        //if(atom.style === atom2.style && !atom2.ssbegin) {
                            atoms = this.unionHash(atoms, this.residues[nextResidueid]);

                            bAddResidue = true;
                        //}
                    }
                }
            } // end for
        } // end else {

        atomsObj = {};
    } // end if(bHighlight === 1)

    this.setStyle2Atoms(atoms);

    //this.bAllAtoms = (Object.keys(atoms).length === Object.keys(this.atoms).length);
    this.bAllAtoms = false;
    if(atoms && atoms !== undefined ) {
        this.bAllAtoms = (Object.keys(atoms).length === Object.keys(this.atoms).length);
    }

//        var currentCalphas = {};
//        if(this.opts['sidec'] !== 'nothing') {
//            currentCalphas = this.intHash(this.hAtoms, this.calphas);
//        }

    var chemicalSchematicRadius = this.cylinderRadius * 0.5;

    // remove schematic labels
    //if(this.labels !== undefined) this.labels['schematic'] = undefined;
    if(this.labels !== undefined) delete this.labels['schematic'];

    var bOnlySideChains = false;

    if(bHighlight) {
        var residueHashCalpha = this.getResiduesFromCalphaAtoms(this.hAtoms);

        var proteinAtoms = this.intHash(this.hAtoms, this.proteins);
        var residueHash = this.getResiduesFromAtoms(proteinAtoms);

        if(Object.keys(residueHash) > Object.keys(residueHashCalpha)) { // some residues have only side chains
            bOnlySideChains = true;
        }

/*
        bOnlySideChains = true;

        for(var i in this.hAtoms) {
            if(this.atoms[i].name == 'CA') {
                bOnlySideChains = false;
                break;
            }
        }
*/
    }

    for(var style in this.style2atoms) {
      // 14 styles: ribbon, strand, cylinder and plate, nucleotide cartoon, o3 trace, schematic, c alpha trace, b factor tube, lines, stick, ball and stick, sphere, dot, nothing
      var atomHash = this.style2atoms[style];
      //var bPhosphorusOnly = this.isCalphaPhosOnly(this.hash2Atoms(atomHash), "O3'", "O3*") || this.isCalphaPhosOnly(this.hash2Atoms(atomHash), "P");
      var bPhosphorusOnly = this.isCalphaPhosOnly(this.hash2Atoms(atomHash));

      //if(style === 'ribbon') {
      if(style === 'ribbon' && (!bHighlight || (bHighlight && !bOnlySideChains))) {
          this.createStrand(this.hash2Atoms(atomHash), 2, undefined, true, undefined, undefined, false, this.ribbonthickness, bHighlight);
      }
      //else if(style === 'strand') {
      else if(style === 'strand' && (!bHighlight || (bHighlight && !bOnlySideChains))) {
          this.createStrand(this.hash2Atoms(atomHash), null, null, null, null, null, false, undefined, bHighlight);
      }
      //else if(style === 'cylinder and plate') {
      else if(style === 'cylinder and plate' && (!bHighlight || (bHighlight && !bOnlySideChains))) {
        this.createCylinderHelix(this.hash2Atoms(atomHash), this.cylinderHelixRadius, bHighlight);
      }
      else if(style === 'nucleotide cartoon') {
        if(bPhosphorusOnly) {
            this.createCylinderCurve(this.hash2Atoms(atomHash), ["P"], this.traceRadius, false, bHighlight);
        }
        else {
            this.drawCartoonNucleicAcid(this.hash2Atoms(atomHash), null, this.ribbonthickness, bHighlight);

            if(bHighlight !== 2) this.drawNucleicAcidStick(this.hash2Atoms(atomHash), bHighlight);
        }
      }
      else if(style === 'o3 trace') {
        if(bPhosphorusOnly) {
            this.createCylinderCurve(this.hash2Atoms(atomHash), ["P"], this.traceRadius, false, bHighlight);
        }
        else {
            this.createCylinderCurve(this.hash2Atoms(atomHash), ["O3'", "O3*"], this.traceRadius, false, bHighlight);
        }
      }
      //else if(style === 'phosphorus lines') {
      //  this.createCylinderCurve(this.hash2Atoms(atomHash), ["O3'", "O3*"], 0.2, true, bHighlight);
      //}
      else if(style === 'schematic') {
        // either proteins, nucleotides, or chemicals
        var firstAtom = this.getFirstAtomObj(atomHash);

        //if(firstAtom.het) { // chemicals
        if(this.chemicals.hasOwnProperty(firstAtom.serial)) { // chemicals
            this.addNonCarbonAtomLabels(this.hash2Atoms(atomHash));

            bSchematic = true;
            this.createStickRepresentation(this.hash2Atoms(atomHash), chemicalSchematicRadius, chemicalSchematicRadius, undefined, bHighlight, bSchematic);
        }
        else { // nucleotides or proteins
            this.addResiudeLabels(this.hash2Atoms(atomHash), true);

            if(bPhosphorusOnly) {
                this.createCylinderCurve(this.hash2Atoms(atomHash), ["P"], this.traceRadius, false, bHighlight);
            }
            else {
                this.createCylinderCurve(this.hash2Atoms(atomHash), ["O3'", "O3*"], this.traceRadius, false, bHighlight);
            }
            this.createCylinderCurve(this.hash2Atoms(atomHash), ['CA'], this.traceRadius, false, bHighlight);
        }
      }
      else if(style === 'c alpha trace') {
        this.createCylinderCurve(this.hash2Atoms(atomHash), ['CA'], this.traceRadius, false, bHighlight);
      }
      else if(style === 'b factor tube') {
        this.createTube(this.hash2Atoms(atomHash), 'CA', null, bHighlight);
      }
      else if(style === 'lines') {
        if(bHighlight === 1) {
            this.createStickRepresentation(this.hash2Atoms(atomHash), this.hlLineRadius, this.hlLineRadius, undefined, bHighlight);
        }
        else {
            this.createLineRepresentation(this.hash2Atoms(atomHash), bHighlight);
        }
      }
      else if(style === 'stick') {
        this.createStickRepresentation(this.hash2Atoms(atomHash), this.cylinderRadius, this.cylinderRadius, undefined, bHighlight);
      }
      else if(style === 'ball and stick') {
        this.createStickRepresentation(this.hash2Atoms(atomHash), this.cylinderRadius, this.cylinderRadius * 0.5, this.dotSphereScale, bHighlight);
      }
      else if(style === 'sphere') {
        this.createSphereRepresentation(this.hash2Atoms(atomHash), this.sphereRadius, undefined, undefined, bHighlight);
      }
      else if(style === 'dot') {
        this.createSphereRepresentation(this.hash2Atoms(atomHash), this.sphereRadius, false, this.dotSphereScale, bHighlight);
      }
    } // end for loop

    if(this.cnt > this.maxmaxatomcnt) { // release memory
        this.init_base();
    }

    // hide the previous labels
    if(this.labels !== undefined && Object.keys(this.labels).length > 0) {
        this.hideLabels();

        // labels
        this.createLabelRepresentation(this.labels);
    }
};

iCn3D.prototype.hideLabels = function () { var me = this;
    // remove previous labels
    if(this.mdl !== undefined) {
        for(var i = 0, il = this.mdl.children.length; i < il; ++i) {
             var mesh = this.mdl.children[i];
             if(mesh !== undefined && mesh.type === 'Sprite') {
                 this.mdl.remove(mesh); // somehow didn't work
             }
        }
    }
};

iCn3D.prototype.setStyle2Atoms = function (atoms) {
      this.style2atoms = {};

      for(var i in atoms) {
        // do not show water in assemly
        //if(this.bAssembly && this.water.hasOwnProperty(i)) {
        //    this.atoms[i].style = 'nothing';
        //}

        if(this.style2atoms[this.atoms[i].style] === undefined) this.style2atoms[this.atoms[i].style] = {};

        this.style2atoms[this.atoms[i].style][i] = 1;

        // side chains
        if(this.atoms[i].style2 !== undefined && this.atoms[i].style2 !== 'nothing') {
            if(this.style2atoms[this.atoms[i].style2] === undefined) this.style2atoms[this.atoms[i].style2] = {};

            this.style2atoms[this.atoms[i].style2][i] = 1;
        }
      }

/*
      for(var i in this.atoms) {
          if(atoms.hasOwnProperty(i)) {
            if(this.style2atoms[this.atoms[i].style] === undefined) this.style2atoms[this.atoms[i].style] = {};

            this.style2atoms[this.atoms[i].style][i] = 1;

            // side chains
            if(this.style2atoms[this.atoms[i].style2] === undefined) this.style2atoms[this.atoms[i].style2] = {};

            this.style2atoms[this.atoms[i].style2][i] = 1;
          }
          else if(this.atoms[i].style == 'schematic') { // always display schematic
            if(this.style2atoms[this.atoms[i].style] === undefined) this.style2atoms[this.atoms[i].style] = {};
            this.style2atoms[this.atoms[i].style][i] = 1;
          }
      }
*/
};

// set atom style when loading a structure
iCn3D.prototype.setAtomStyleByOptions = function (options) {
    if(options === undefined) options = this.opts;

    var selectedAtoms;

    if (options.proteins !== undefined) {
        selectedAtoms = this.intHash(this.hAtoms, this.proteins);
        for(var i in selectedAtoms) {
          this.atoms[i].style = options.proteins.toLowerCase();
        }
    }

    // side chain use style2
    if (options.sidec !== undefined && options.sidec !== 'nothing') {
        selectedAtoms = this.intHash(this.hAtoms, this.sidec);
        //var sidec_calpha = this.unionHash(this.calphas, this.sidec);
        //selectedAtoms = this.intHash(this.hAtoms, sidec_calpha);

        for(var i in selectedAtoms) {
          this.atoms[i].style2 = options.sidec.toLowerCase();
        }
    }

    if (options.chemicals !== undefined) {
        selectedAtoms = this.intHash(this.hAtoms, this.chemicals);
        for(var i in selectedAtoms) {
          this.atoms[i].style = options.chemicals.toLowerCase();
        }
    }

    if (options.ions !== undefined) {
        selectedAtoms = this.intHash(this.hAtoms, this.ions);
        for(var i in selectedAtoms) {
          this.atoms[i].style = options.ions.toLowerCase();
        }
    }

    if (options.water !== undefined) {
        selectedAtoms = this.intHash(this.hAtoms, this.water);
        for(var i in selectedAtoms) {
          this.atoms[i].style = options.water.toLowerCase();
        }
    }

    if (options.nucleotides !== undefined) {
        selectedAtoms = this.intHash(this.hAtoms, this.nucleotides);
        for(var i in selectedAtoms) {
          this.atoms[i].style = options.nucleotides.toLowerCase();
        }
    }
};

iCn3D.prototype.rebuildSceneBase = function (options) { var me = this;
    jQuery.extend(me.opts, options);

    this.cam_z = this.maxD * 2;
    //this.cam_z = -this.maxD * 2;

    if(this.scene !== undefined) {
        for(var i = this.scene.children.length - 1; i >= 0; i--) {
             var obj = this.scene.children[i];
             this.scene.remove(obj);
        }
    }
    else {
        this.scene = new THREE.Scene();
    }

    if(this.scene_ghost !== undefined) {
        for(var i = this.scene_ghost.children.length - 1; i >= 0; i--) {
             var obj = this.scene_ghost.children[i];
             this.scene_ghost.remove(obj);
        }
    }
    else {
        this.scene_ghost = new THREE.Scene();
    }

    //this.directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1.2);
    this.directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1.0);

    if(this.cam_z > 0) {
      this.directionalLight.position.set(0, 0, 1);
    }
    else {
      this.directionalLight.position.set(0, 0, -1);
    }

    //var ambientLight = new THREE.AmbientLight(0x202020);
    //var ambientLight = new THREE.AmbientLight(0xdddddd, 0.2);
    var ambientLight = new THREE.AmbientLight(0x404040);

    this.scene.add(this.directionalLight);
    this.scene.add(ambientLight);

    //this.group = new THREE.Object3D();  // regular display

    this.mdl = new THREE.Object3D();  // regular display
    //this.mdlPicking = new THREE.Object3D();  // pk display
    this.mdlImpostor = new THREE.Object3D();  // Impostor display

    //this.scene.add(this.mdlPicking);
    this.scene.add(this.mdl);
    this.scene.add(this.mdlImpostor);

    // highlight on impostors
    this.mdl_ghost = new THREE.Object3D();  // Impostor display
    this.scene_ghost.add(this.mdl_ghost);

    //this.scene_ghost.add(this.directionalLight);
    //this.scene_ghost.add(ambientLight);

    // related to pk
    this.objects = []; // define objects for pk, not all elements are used for pk
    this.objects_ghost = []; // define objects for pk, not all elements are used for pk
    this.raycaster = new THREE.Raycaster();
    this.projector = new THREE.Projector();
    this.mouse = new THREE.Vector2();

    var background = this.backgroundColors[this.opts.background.toLowerCase()];

    if(this.opts.background.toLowerCase() === 'transparent') {
        this.renderer.setClearColor(background, 0);
    }
    else {
        this.renderer.setClearColor(background, 1);
    }

    this.perspectiveCamera = new THREE.PerspectiveCamera(20, this.container.whratio, 0.1, 10000);
    this.perspectiveCamera.position.set(0, 0, this.cam_z);
    this.perspectiveCamera.lookAt(new THREE.Vector3(0, 0, 0));

    this.orthographicCamera = new THREE.OrthographicCamera();
    this.orthographicCamera.position.set(0, 0, this.cam_z);
    this.orthographicCamera.lookAt(new THREE.Vector3(0, 0, 0));

    this.cams = {
        perspective: this.perspectiveCamera,
        orthographic: this.orthographicCamera,
    };
};

iCn3D.prototype.setCamera = function() {
    this.cam = this.cams[this.opts.camera.toLowerCase()];

    if(this.cam === this.perspectiveCamera) {
        var factor = (this.biomtMatrices !== undefined && this.biomtMatrices.length * this.cnt > 10 * this.maxatomcnt) ? 1 : 2;
        if(this.cam_z > 0) {
          this.cam.position.z = this.maxD * factor; // forperspective, the z positionshould be large enough to see the whole molecule
        }
        else {
          this.cam.position.z = -this.maxD * factor; // forperspective, the z positionshould be large enough to see the whole molecule
        }

        if(this.opts['slab'] === 'yes') {
            this.cam.near = this.maxD * 2;
        }
        else {
            this.cam.near = 0.1;
        }
        this.cam.far = 10000;

        this.controls = new THREE.TrackballControls( this.cam, document.getElementById(this.id), this );
    }
    else if (this.cam === this.orthographicCamera){
        if(this.biomtMatrices !== undefined && this.biomtMatrices.length * this.cnt > 10 * this.maxatomcnt) {
            this.cam.right = this.maxD/2 * 1.5;
        }
        else {
            this.cam.right = this.maxD/2 * 2.5;
        }

        this.cam.left = -this.cam.right;
        this.cam.top = this.cam.right /this.container.whratio;
        this.cam.bottom = -this.cam.right /this.container.whratio;

          if(this.opts['slab'] === 'yes') {
              this.cam.near = this.maxD * 2;
          }
          else {
            this.cam.near = 0;
          }

          this.cam.far = 10000;

        this.controls = new THREE.OrthographicTrackballControls( this.cam, document.getElementById(this.id), this );
    }

    this.cam.updateProjectionMatrix();
};

iCn3D.prototype.render = function () {
    this.directionalLight.position.copy(this.cam.position);

    this.renderer.gammaInput = true
    this.renderer.gammaOutput = true

    this.renderer.setPixelRatio( window.devicePixelRatio ); // r71
    this.renderer.render(this.scene, this.cam);
    //this.renderer.render(this.scene_ghost, this.cam);
};

iCn3D.prototype.clearImpostors = function () {
    this.posArray = [];
    this.colorArray = [];
    this.pos2Array = [];
    this.color2Array = [];
    this.radiusArray = [];

    this.posArraySphere = [];
    this.colorArraySphere = [];
    this.radiusArraySphere = [];
};

iCn3D.prototype.applyTransformation = function (_zoomFactor, mouseChange, quaternion) {
    var para = {};
    para.update = false;

    // zoom
    para._zoomFactor = _zoomFactor;

    // translate
    para.mouseChange = new THREE.Vector2();
    para.mouseChange.copy(mouseChange);

    // rotation
    para.quaternion = new THREE.Quaternion();
    para.quaternion.copy(quaternion);

    this.controls.update(para);
};

iCn3D.prototype.applyCenterOptions = function (options) {
    if(options === undefined) options = this.opts;

    switch (options.rotationcenter.toLowerCase()) {
        case 'molecule center':
            // move the molecule to the origin
            if(this.center !== undefined) {
                this.setRotationCenter(this.center);
            }
            break;
        case 'pick center':
            if(this.pAtom !== undefined) {
              this.setRotationCenter(this.pAtom.coord);
            }
            break;
        case 'display center':
            var center = this.centerAtoms(this.dAtoms).center;
            this.setRotationCenter(center);
            break;
        case 'highlight center':
            var center = this.centerAtoms(this.hAtoms).center;
            this.setRotationCenter(center);
            break;
    }
};

iCn3D.prototype.setRotationCenter = function (coord) {
   this.mdl.position.set(0,0,0);
   this.mdlImpostor.position.set(0,0,0);
   this.mdl_ghost.position.set(0,0,0);

    //this.mdlPicking.position.sub(coord);
    this.mdl.position.sub(coord);
    this.mdlImpostor.position.sub(coord);
    this.mdl_ghost.position.sub(coord);
};

iCn3D.prototype.applyOriginalColor = function (atoms) {
    if(atoms === undefined) atoms = this.atoms;

    for (var i in atoms) {
        var atom = atoms[i];
        var chainid = atom.structure + '_' + atom.chain;

        if(this.chainsColor.hasOwnProperty(chainid)) {
            atom.color = this.chainsColor[chainid];
        }
        else {
            atom.color = this.atomColors[atom.elem];
            //break;
        }

        this.atomPrevColors[i] = atom.color;
    }
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3D.prototype.onBeforeRender = function(renderer, scene, camera, geometry, material) {
  var u = material.uniforms;
  var updateList = [];

  if (u.objectId) {
    u.objectId.value = SupportsReadPixelsFloat ? this.id : this.id / 255
    updateList.push('objectId')
  }

  if (u.modelViewMatrixInverse || u.modelViewMatrixInverseTranspose ||
      u.modelViewProjectionMatrix || u.modelViewProjectionMatrixInverse
  ) {
    this.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, this.matrixWorld);
  }

  if (u.modelViewMatrixInverse) {
    u.modelViewMatrixInverse.value.getInverse(this.modelViewMatrix);
    updateList.push('modelViewMatrixInverse');
  }

  if (u.modelViewMatrixInverseTranspose) {
    if (u.modelViewMatrixInverse) {
      u.modelViewMatrixInverseTranspose.value.copy(
        u.modelViewMatrixInverse.value
      ).transpose();
    } else {
      u.modelViewMatrixInverseTranspose.value
        .getInverse(this.modelViewMatrix)
        .transpose();
    }
    updateList.push('modelViewMatrixInverseTranspose');
  }

  if (u.modelViewProjectionMatrix) {
    camera.updateProjectionMatrix();
    u.modelViewProjectionMatrix.value.multiplyMatrices(
      camera.projectionMatrix, this.modelViewMatrix
    );
    updateList.push('modelViewProjectionMatrix');
  }

  if (u.modelViewProjectionMatrixInverse) {
    var tmpMatrix = new THREE.Matrix4();
    if (u.modelViewProjectionMatrix) {
      tmpMatrix.copy(
        u.modelViewProjectionMatrix.value
      );
      u.modelViewProjectionMatrixInverse.value.getInverse(
        tmpMatrix
      );
    } else {
      camera.updateProjectionMatrix();
      tmpMatrix.multiplyMatrices(
        camera.projectionMatrix, this.modelViewMatrix
      );
      u.modelViewProjectionMatrixInverse.value.getInverse(
        tmpMatrix
      );
    }
    updateList.push('modelViewProjectionMatrixInverse');
  }

  if (u.projectionMatrix) {
    camera.updateProjectionMatrix();
    u.projectionMatrix.value.copy( camera.projectionMatrix );
    updateList.push('projectionMatrix');
  }

  if (u.projectionMatrixInverse) {
    camera.updateProjectionMatrix();
    u.projectionMatrixInverse.value.getInverse(camera.projectionMatrix);
    updateList.push('projectionMatrixInverse');
  }

  if (updateList.length) {
    var materialProperties = renderer.properties.get(material);

    if (materialProperties.program) {
      var gl = renderer.getContext();
      var p = materialProperties.program;
      gl.useProgram(p.program);
      var pu = p.getUniforms();

      updateList.forEach(function (name) {
        pu.setValue(gl, name, u[ name ].value)
      });
    }
  }
};

iCn3D.prototype.setParametersForShader = function (opacity) { var me = this;
/*
    var modelViewMatrix = new THREE.Uniform( new THREE.Matrix4() )
            .onUpdate( function( object ){
                this.value.copy( object.modelViewMatrix );
    } );

    var modelViewMatrixInverse = new THREE.Uniform( new THREE.Matrix4() )
            .onUpdate( function( object ){
                this.value.getInverse( object.modelViewMatrix );
    } );

    var modelViewMatrixInverseTranspose = new THREE.Uniform( new THREE.Matrix4() )
            .onUpdate( function( object ){
                this.value.getInverse( object.modelViewMatrix ).transpose();
    } );

    var modelViewProjectionMatrix = new THREE.Uniform( new THREE.Matrix4() )
            .onUpdate( function( object ){
                this.value.multiplyMatrices( me.cam.projectionMatrix, object.modelViewMatrix );
    } );

    var modelViewProjectionMatrixInverse = new THREE.Uniform( new THREE.Matrix4() )
            .onUpdate( function( object ){
                var tmpMatrix = new THREE.Matrix4();
                tmpMatrix.multiplyMatrices(me.cam.projectionMatrix, object.modelViewMatrix);
                this.value.getInverse(tmpMatrix);
    } );

    var projectionMatrix = new THREE.Uniform( new THREE.Matrix4() )
            .onUpdate( function(  ){
                this.value.copy( me.cam.projectionMatrix );
    } );

    var projectionMatrixInverse = new THREE.Uniform( new THREE.Matrix4() )
            .onUpdate( function(  ){
                this.value.getInverse( me.cam.projectionMatrix );
    } );
*/

    var background = this.backgroundColors[this.opts.background.toLowerCase()];
    //var near = 2 * this.maxD;
    var near = 1.5 * this.maxD;
    //var far = 2.5 * this.maxD;
    var far = 3 * this.maxD;

    var opacityValue = (opacity !== undefined) ? opacity : 1.0;

    this.uniforms = THREE.UniformsUtils.merge([
      THREE.UniformsLib.common,
      {
/*
        modelViewMatrix: modelViewMatrix,
        modelViewMatrixInverse: modelViewMatrixInverse,
        modelViewMatrixInverseTranspose: modelViewMatrixInverseTranspose,
        modelViewProjectionMatrix: modelViewProjectionMatrix,
        modelViewProjectionMatrixInverse: modelViewProjectionMatrixInverse,
        projectionMatrix: projectionMatrix,
        projectionMatrixInverse: projectionMatrixInverse,
*/

        modelViewMatrix: { value: new THREE.Matrix4() },
        modelViewMatrixInverse: { value: new THREE.Matrix4() },
        modelViewMatrixInverseTranspose: { value: new THREE.Matrix4() },
        modelViewProjectionMatrix: { value: new THREE.Matrix4() },
        modelViewProjectionMatrixInverse: { value: new THREE.Matrix4() },
        projectionMatrix: { value: new THREE.Matrix4() },
        projectionMatrixInverse: { value: new THREE.Matrix4() },

        //ambientLightColor: { type: "v3", value: [0.25, 0.25, 0.25] },
        diffuse: { type: "v3", value: [1.0, 1.0, 1.0] },
        emissive: { type: "v3", value: [0.0,0.0,0.0] },
        roughness: { type: "f", value: 0.5 }, // 0.4
        metalness: { type: "f", value: 0.3 }, // 0.5
        opacity: { type: "f", value: opacityValue },
        nearClip: { type: "f", value: 0.1 },
        ortho: { type: "f", value: 0.0 },
        shrink: { type: "f", value: 0.13 },
        fogColor: { type: "v3", value: [background.r, background.g, background.b] },
        fogNear: { type: "f", value: near },
        fogFar: { type: "f", value: far },
        fogDensity: { type: "f", value: 2.0 }
      },
        THREE.UniformsLib.ambient,
        THREE.UniformsLib.lights
    ]);

    /*
    //fog_pars_fragment
    #ifdef USE_FOG
        uniform vec3 fogColor;
        #ifdef FOG_EXP2
            uniform float fogDensity;
        #else
            uniform float fogNear;
            uniform float fogFar;
        #endif
    #endif
    */

    this.defines = {
        USE_COLOR: 1,
        //PICKING: 1,
        NEAR_CLIP: 1,
        CAP: 1
    };

    if(this.opts['fog'] === 'yes') {
        this.defines['USE_FOG'] = 1;
        if(this.opts['camera'] === 'orthographic') {
            this.defines['FOG_EXP2'] = 1;
        }
    }

    if(this.bExtFragDepth) {
        this.defines['USE_LOGDEPTHBUF_EXT'] = 1;
    }
};

iCn3D.prototype.drawImpostorShader = function () { var me = this;
    this.setParametersForShader();

    this.createImpostorShaderSphere("SphereImpostor");
    this.createImpostorShaderCylinder("CylinderImpostor");
    //this.createImpostorShaderCylinder("HyperballStickImpostor");
};

iCn3D.prototype.getShader = function (name) { var me = this;
  var shaderText = $NGL_shaderTextHash[name];
  var reInclude = /#include\s+(\S+)/gmi;

  shaderText = shaderText.replace( reInclude, function( match, p1 ){

        var chunk;
        if(THREE.ShaderChunk.hasOwnProperty(p1)) {
            chunk = THREE.ShaderChunk[ p1 ];
        }

        return chunk ? chunk : "";

  } );

  return shaderText;
};

iCn3D.prototype.createImpostorShaderBase = function (shaderName, mapping, mappingIndices, data, attributeData, count, mappingSize, mappingIndicesSize, mappingItemSize) { var me = this;
  var shaderMaterial =
    new THREE.ShaderMaterial({
      defines: me.defines,
      uniforms:  me.uniforms,
      vertexShader:   me.getShader(shaderName + ".vert"),
      fragmentShader: me.getShader(shaderName + ".frag"),
      depthTest: true,
      depthWrite: true,
      needsUpdate: true,
      lights: true
  });

  shaderMaterial.extensions.fragDepth = true;

  if(shaderName == 'CylinderImpostor') {
      this.CylinderImpostorMaterial = shaderMaterial;
  }
  else if(shaderName == 'SphereImpostor') {
      this.SphereImpostorMaterial = shaderMaterial;
  }

    //MappedBuffer
    var attributeSize = count * mappingSize;

    var n = count * mappingIndicesSize;
    var TypedArray = attributeSize > 65535 ? Uint32Array : Uint16Array;
    var index = new TypedArray( n );

        //makeIndex();
    var ix, it;

    for( var v = 0; v < count; v++ ) {
        ix = v * mappingIndicesSize;
        it = v * mappingSize;

        index.set( mappingIndices, ix );

        for( var s = 0; s < mappingIndicesSize; ++s ){
            index[ ix + s ] += it;
        }
    }


    var geometry = new THREE.BufferGeometry();

    // buffer.js
    var dynamic = true;

    if( index ){
        geometry.setIndex(
            new THREE.BufferAttribute( index, 1 )
        );
        geometry.getIndex().setDynamic( dynamic );
    }

    // add attributes from buffer.js
    var itemSize = {
        "f": 1, "v2": 2, "v3": 3, "c": 3
    };

    for( var name in attributeData ){

        var buf;
        var a = attributeData[ name ];

            buf = new Float32Array(
                attributeSize * itemSize[ a.type ]
            );

        geometry.addAttribute(
            name,
            new THREE.BufferAttribute( buf, itemSize[ a.type ] )
                .setDynamic( dynamic )
        );

    }

    // set attributes from mapped-buffer.js
    var attributes = geometry.attributes;

    var a, d, itemSize2, array, i, j;

    for( var name in data ){

        d = data[ name ];
        a = attributes[ name ];
        itemSize2 = a.itemSize;
        array = a.array;

        for( var k = 0; k < count; ++k ) {

            n = k * itemSize2;
            i = n * mappingSize;

            for( var l = 0; l < mappingSize; ++l ) {

                j = i + ( itemSize2 * l );

                for( var m = 0; m < itemSize2; ++m ) {

                    array[ j + m ] = d[ n + m ];

                }

            }

        }

        a.needsUpdate = true;

    }

    // makemapping
    var aMapping = geometry.attributes.mapping.array;

    for( var v = 0; v < count; v++ ) {
        aMapping.set( mapping, v * mappingItemSize * mappingSize );
    }

    var mesh = new THREE.Mesh(geometry, shaderMaterial);

    // important: https://stackoverflow.com/questions/21184061/mesh-suddenly-disappears-in-three-js-clipping
    // You are moving the camera in the CPU. You are moving the vertices of the plane in the GPU
    mesh.frustumCulled = false;

    mesh.scale.x = mesh.scale.y = mesh.scale.z = 1.0;

    if(shaderName == 'CylinderImpostor') {
      mesh.type = 'Cylinder';
    }
    else if(shaderName == 'SphereImpostor') {
      mesh.type = 'Sphere';
    }

    //mesh.onBeforeRender = this.onBeforeRender(this.renderer, this.scene, this.cam, geometry, shaderMaterial);
    mesh.onBeforeRender = this.onBeforeRender;

    this.mdlImpostor.add(mesh);

    //this.objects.push(mesh);
};

iCn3D.prototype.createImpostorShaderCylinder = function (shaderName) { var me = this;
    var positions = new Float32Array( me.posArray );
    var colors = new Float32Array( me.colorArray );
    var positions2 = new Float32Array( me.pos2Array );
    var colors2 = new Float32Array( me.color2Array );
    var radii = new Float32Array( me.radiusArray );

    // cylinder
    var mapping = new Float32Array([
        -1.0,  1.0, -1.0,
        -1.0, -1.0, -1.0,
         1.0,  1.0, -1.0,
         1.0,  1.0,  1.0,
         1.0, -1.0, -1.0,
         1.0, -1.0,  1.0
    ]);

    var mappingIndices = new Uint16Array([
        0, 1, 2,
        1, 4, 2,
        2, 4, 3,
        4, 5, 3
    ]);

    var mappingIndicesSize = 12;
    var mappingType = "v3";
    var mappingSize = 6;
    var mappingItemSize = 3;


    var count = positions.length / 3;

    var data = {
        "position1": positions,
        "color": colors,
        "position2": positions2,
        "color2": colors2,
        "radius": radii
    };

    var attributeData = {
        "position1": { type: "v3", value: null },
        "color": { type: "v3", value: null },
        "position2": { type: "v3", value: null },
        "color2": { type: "v3", value: null },
        "radius": { type: "f", value: null },
        "mapping": { type: mappingType, value: null }
    };

    this.createImpostorShaderBase(shaderName, mapping, mappingIndices, data, attributeData, count, mappingSize, mappingIndicesSize, mappingItemSize);

    data = null;
    positions = null;
    colors = null;
    positions2 = null;
    colors2 = null;
    radii = null;

  me.posArray = null;
  me.colorArray = null;
  me.pos2Array = null;
  me.color2Array = null;
  me.radiusArray = null;
};

iCn3D.prototype.createImpostorShaderSphere = function (shaderName) { var me = this;
    var positions = new Float32Array( me.posArraySphere );
    var colors = new Float32Array( me.colorArraySphere );
    var radii = new Float32Array( me.radiusArraySphere );

    // sphere
    var mapping = new Float32Array([
        -1.0,  1.0,
        -1.0, -1.0,
         1.0,  1.0,
         1.0, -1.0
    ]);

    var mappingIndices = new Uint16Array([
        0, 1, 2,
        1, 3, 2
    ]);

    var mappingIndicesSize = 6;
    var mappingType = "v2";
    var mappingSize = 4;
    var mappingItemSize = 2;

    var count = positions.length / 3;

    var data = {
        "position": positions,
        "color": colors,
        "radius": radii
    };

    var attributeData = {
        "position": { type: "v3", value: null },
        "color": { type: "v3", value: null },
        "radius": { type: "f", value: null },
        "mapping": { type: mappingType, value: null }
    };

    this.createImpostorShaderBase(shaderName, mapping, mappingIndices, data, attributeData, count, mappingSize, mappingIndicesSize, mappingItemSize);

    data = null;
    positions = null;
    colors = null;
    radii = null;

  me.posArraySphere = null;
  me.colorArraySphere = null;
  me.radiusArraySphere = null;
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3D.prototype.positionFromGeometry = function( mesh ){
    var geometry = mesh.geometry;

    var vertices = geometry.vertices;

    var meshPosition = mesh.position;
    var scale = mesh.scale;
    var matrix = mesh.matrix;

    var j, v3;
    var n = vertices.length;
    //var position = new Float32Array( n * 3 );
    var position = [];

    for( var v = 0; v < n; v++ ){

        j = v * 3;

        if(geometry.type == 'SphereGeometry' || geometry.type == 'BoxGeometry') {
            v3 = vertices[v].clone().multiply(scale).add(meshPosition);
        }
        else if(geometry.type == 'CylinderGeometry') {
            v3 = vertices[v].clone().applyMatrix4(matrix);
        }
        else {
            v3 = vertices[v];
        }

        position[ j + 0 ] = v3.x;
        position[ j + 1 ] = v3.y;
        position[ j + 2 ] = v3.z;
    }

    return position;

};


iCn3D.prototype.colorFromGeometry = function( mesh ){
    var geometry = mesh.geometry;

    var meshColor = new THREE.Color(1, 1, 1);
    if(geometry.type == 'SphereGeometry' || geometry.type == 'BoxGeometry' || geometry.type == 'CylinderGeometry') {
         if(mesh.material !== undefined) meshColor = mesh.material.color;
    }

    var faces = geometry.faces;
    var vn = geometry.vertices.length;

    var bSurfaceVertex = (geometry.type == 'Surface') ? true : false;

    var j, f, c1, c2, c3;
    var n = faces.length;
    //var color = new Float32Array( vn * 3 );
    var color = [];

    for( var v = 0; v < n; v++ ){

        f = faces[ v ];

        if(geometry.type == 'Surface') {
            c1 = f.vertexColors[0];
            c2 = f.vertexColors[1];
            c3 = f.vertexColors[2];
        }
        else if(geometry.type == 'SphereGeometry' || geometry.type == 'BoxGeometry' || geometry.type == 'CylinderGeometry') {
            c1 = meshColor;
            c2 = meshColor;
            c3 = meshColor;
        }
        else {
            c1 = f.color;
            c2 = f.color;
            c3 = f.color;
        }

        j = f.a * 3;
        color[ j + 0 ] = c1.r;
        color[ j + 1 ] = c1.g;
        color[ j + 2 ] = c1.b;

        j = f.b * 3;
        color[ j + 0 ] = c2.r;
        color[ j + 1 ] = c2.g;
        color[ j + 2 ] = c2.b;

        j = f.c * 3;
        color[ j + 0 ] = c3.r;
        color[ j + 1 ] = c3.g;
        color[ j + 2 ] = c3.b;

    }

    return color;

};


iCn3D.prototype.indexFromGeometry = function( mesh ){
    var geometry = mesh.geometry;

    var faces = geometry.faces;

    var j, f;
    var n = faces.length;
    //var TypedArray = n * 3 > 65535 ? Uint32Array : Uint16Array;
    //var index = new TypedArray( n * 3 );
    var index = [];

    for( var v = 0; v < n; v++ ){

        j = v * 3;
        f = faces[ v ];

        index[ j + 0 ] = f.a;
        index[ j + 1 ] = f.b;
        index[ j + 2 ] = f.c;

    }

    return index;

};


iCn3D.prototype.normalFromGeometry = function( mesh ){
    var geometry = mesh.geometry;

    var faces = geometry.faces;
    var vn = geometry.vertices.length;

    var j, f, nn, n1, n2, n3;
    var n = faces.length;
    //var normal = new Float32Array( vn * 3 );
    var normal = [];

    for( var v = 0; v < n; v++ ){

        f = faces[ v ];
        nn = f.vertexNormals;
        n1 = nn[ 0 ];
        n2 = nn[ 1 ];
        n3 = nn[ 2 ];

        j = f.a * 3;
        normal[ j + 0 ] = n1.x;
        normal[ j + 1 ] = n1.y;
        normal[ j + 2 ] = n1.z;

        j = f.b * 3;
        normal[ j + 0 ] = n2.x;
        normal[ j + 1 ] = n2.y;
        normal[ j + 2 ] = n2.z;

        j = f.c * 3;
        normal[ j + 0 ] = n3.x;
        normal[ j + 1 ] = n3.y;
        normal[ j + 2 ] = n3.z;

    }

    return normal;

};

iCn3D.prototype.hashvalue2array = function(hash) {
    //return $.map(hash, function(v) { return v; });

    var array = [];
    for(var i in hash) {
        array.push(hash[i]);
    }

    return array;
};

iCn3D.prototype.drawSymmetryMates = function() {
    //if(this.bInstanced) {
    if(this.bInstanced && Object.keys(this.atoms).length * this.biomtMatrices.length > this.maxatomcnt) {
        this.drawSymmetryMatesInstancing();
    }
    else {
        this.drawSymmetryMatesNoInstancing();
    }
}

iCn3D.prototype.drawSymmetryMatesNoInstancing = function() {
   if (this.biomtMatrices === undefined || this.biomtMatrices.length == 0) return;
   var cnt = 1; // itself
   var centerSum = this.center.clone();

   var identity = new THREE.Matrix4();
   identity.identity();

   for (var i = 0; i < this.biomtMatrices.length; i++) {  // skip itself
      var mat = this.biomtMatrices[i];
      if (mat === undefined) continue;

      // skip itself
      if(mat.equals(identity)) continue;

      var symmetryMate = this.mdl.clone();
      symmetryMate.applyMatrix(mat);

      this.mdl.add(symmetryMate);

      symmetryMate = this.mdlImpostor.clone();
      symmetryMate.applyMatrix(mat);

      //symmetryMate.onBeforeRender = this.onBeforeRender;
      for(var j = symmetryMate.children.length - 1; j >= 0; j--) {
           var mesh = symmetryMate.children[j];
           mesh.onBeforeRender = this.onBeforeRender;
      }

      this.mdlImpostor.add(symmetryMate);

      //symmetryMate = this.mdlPicking.clone();
      //symmetryMate.applyMatrix(mat);

      //this.mdlPicking.add(symmetryMate);

      symmetryMate = this.mdl_ghost.clone();
      symmetryMate.applyMatrix(mat);

      this.mdl_ghost.add(symmetryMate);

      var center = this.center.clone();
      center.applyMatrix4(mat);
      centerSum.add(center);

      ++cnt;
   }

   if(this.bSetInstancing === undefined || !this.bSetInstancing) {
       this.maxD *= Math.sqrt(cnt);

       this.center = centerSum.multiplyScalar(1.0 / cnt);

       this.maxDAssembly = this.maxD;

       this.centerAssembly = this.center.clone();

       this.setCenter(this.center);

       // reset cameara
       this.setCamera();
   }
   else {
       this.maxD = this.maxDAssembly;

       this.center = this.centerAssembly.clone();

       this.setCenter(this.center);

       // reset cameara
       this.setCamera();
   }

   this.bSetInstancing = true;
};

iCn3D.prototype.createInstancedGeometry = function(mesh) {
   var baseGeometry = mesh.geometry;

   var geometry = new THREE.InstancedBufferGeometry();

   var positionArray = [];
   var normalArray = [];
   var colorArray = [];
   var indexArray = [];

   var radiusArray = [];
   var mappingArray = [];
   var position2Array = [];
   var color2Array = [];

   if( baseGeometry.vertices && baseGeometry.faces ){
       this.instancedMaterial = this.getInstancedMaterial('Instancing');

       var positionArray2 = this.positionFromGeometry( mesh );
       var normalArray2 = this.normalFromGeometry( mesh );
       var colorArray2 = this.colorFromGeometry( mesh );
       var indexArray2 = this.indexFromGeometry( mesh );

       positionArray = positionArray.concat(positionArray2);
       normalArray = normalArray.concat(normalArray2);
       colorArray = colorArray.concat(colorArray2);
       indexArray = indexArray.concat(indexArray2);

       var bCylinderArray = [];
       var bCylinder = (baseGeometry.type == 'CylinderGeometry') ? 1.0 : 0.0;
       for(var i = 0, il = positionArray.length / 3; i < il; ++i) {
           bCylinderArray.push(bCylinder);
       }

       geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(positionArray), 3));
       geometry.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(normalArray), 3) );
       geometry.addAttribute('color', new THREE.BufferAttribute(new Float32Array(colorArray), 3) );

       geometry.addAttribute('cylinder', new THREE.BufferAttribute(new Float32Array(bCylinderArray), 1) );
       geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indexArray), 1));

       positionArray2 = null;
       normalArray2 = null;
       colorArray2 = null;
       indexArray2 = null;

   }
   else if(this.bImpo && baseGeometry.attributes.color2 !== undefined) { // cylinder
       this.instancedMaterial = this.getInstancedMaterial('CylinderInstancing');

       var positionArray2 = this.hashvalue2array(baseGeometry.attributes.position1.array);
       var colorArray2 = this.hashvalue2array(baseGeometry.attributes.color.array);

       var positionArray2b = this.hashvalue2array(baseGeometry.attributes.position2.array);
       var colorArray2b = this.hashvalue2array(baseGeometry.attributes.color2.array);

       var indexArray2 = this.hashvalue2array(baseGeometry.index.array);
       var radiusArray2 = this.hashvalue2array(baseGeometry.attributes.radius.array);
       var mappingArray2 = this.hashvalue2array(baseGeometry.attributes.mapping.array);

       positionArray = positionArray.concat(positionArray2);
       colorArray = colorArray.concat(colorArray2);

       position2Array = position2Array.concat(positionArray2b);
       color2Array = color2Array.concat(colorArray2b);

       indexArray = indexArray.concat(indexArray2);
       radiusArray = radiusArray.concat(radiusArray2);
       mappingArray = mappingArray.concat(mappingArray2);

       geometry.addAttribute('position1', new THREE.BufferAttribute(new Float32Array(positionArray), 3));
       geometry.addAttribute('color', new THREE.BufferAttribute(new Float32Array(colorArray), 3) );

       geometry.addAttribute('position2', new THREE.BufferAttribute(new Float32Array(position2Array), 3));
       geometry.addAttribute('color2', new THREE.BufferAttribute(new Float32Array(color2Array), 3) );

       geometry.addAttribute('radius', new THREE.BufferAttribute(new Float32Array(radiusArray), 1) );
       geometry.addAttribute('mapping', new THREE.BufferAttribute(new Float32Array(mappingArray), 3) );
       geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indexArray), 1));

       positionArray2 = null;
       colorArray2 = null;
       positionArray2b = null;
       colorArray2b = null;
       indexArray2 = null;
       radiusArray2 = null;
       mappingArray2 = null;
   }
   else if(this.bImpo && baseGeometry.attributes.color !== undefined) { // sphere
       this.instancedMaterial = this.getInstancedMaterial('SphereInstancing');

       var positionArray2 = this.hashvalue2array(baseGeometry.attributes.position.array);
       var colorArray2 = this.hashvalue2array(baseGeometry.attributes.color.array);
       var indexArray2 = this.hashvalue2array(baseGeometry.index.array);
       var radiusArray2 = this.hashvalue2array(baseGeometry.attributes.radius.array);
       var mappingArray2 = this.hashvalue2array(baseGeometry.attributes.mapping.array);

       positionArray = positionArray.concat(positionArray2);
       colorArray = colorArray.concat(colorArray2);
       indexArray = indexArray.concat(indexArray2);
       radiusArray = radiusArray.concat(radiusArray2);
       mappingArray = mappingArray.concat(mappingArray2);

       geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(positionArray), 3));
       geometry.addAttribute('color', new THREE.BufferAttribute(new Float32Array(colorArray), 3) );
       geometry.addAttribute('radius', new THREE.BufferAttribute(new Float32Array(radiusArray), 1) );
       geometry.addAttribute('mapping', new THREE.BufferAttribute(new Float32Array(mappingArray), 2) );
       geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indexArray), 1));

       positionArray2 = null;
       colorArray2 = null;
       indexArray2 = null;
       radiusArray2 = null;
       mappingArray2 = null;
   }

   positionArray = null;
   normalArray = null;
   colorArray = null;
   indexArray = null;

   radiusArray = null;
   mappingArray = null;
   position2Array = null;
   color2Array = null;

   var matricesAttribute1 = new THREE.InstancedBufferAttribute( new Float32Array( this.matricesElements1 ), 4 );
   var matricesAttribute2 = new THREE.InstancedBufferAttribute( new Float32Array( this.matricesElements2 ), 4 );
   var matricesAttribute3 = new THREE.InstancedBufferAttribute( new Float32Array( this.matricesElements3 ), 4 );
   var matricesAttribute4 = new THREE.InstancedBufferAttribute( new Float32Array( this.matricesElements4 ), 4 );

   geometry.addAttribute( 'matrix1', matricesAttribute1 );
   geometry.addAttribute( 'matrix2', matricesAttribute2 );
   geometry.addAttribute( 'matrix3', matricesAttribute3 );
   geometry.addAttribute( 'matrix4', matricesAttribute4 );

   return geometry;
};

iCn3D.prototype.getInstancedMaterial = function(name) {
   //var material = new THREE.RawShaderMaterial({
   var material = new THREE.ShaderMaterial({
      defines: this.defines,
      uniforms:  this.uniforms,
      vertexShader:   this.getShader(name + ".vert"),
      fragmentShader: this.getShader(name + ".frag"),
      depthTest: true,
      depthWrite: true,
      needsUpdate: true,
      lights: true
   });

   material.extensions.fragDepth = true;
   //https://stackoverflow.com/questions/33094496/three-js-shadermaterial-flatshading
   material.extensions.derivatives = '#extension GL_OES_standard_derivatives : enable';

   return material;
}

iCn3D.prototype.drawSymmetryMatesInstancing = function() {
   if (this.biomtMatrices === undefined || this.biomtMatrices.length == 0) return;
   var cnt = 1; // itself
   var centerSum = this.center.clone();

   this.setParametersForShader();

   if(this.bSetInstancing === undefined || !this.bSetInstancing) {
       //this.offsets = [];
       //this.orientations = [];
       this.matricesElements1 = [];
       this.matricesElements2 = [];
       this.matricesElements3 = [];
       this.matricesElements4 = [];

       var identity = new THREE.Matrix4();
       identity.identity();

       for (var i = 0; i < this.biomtMatrices.length; i++) {  // skip itself
          var mat = this.biomtMatrices[i];
          if (mat === undefined) continue;

          var matArray = mat.toArray();

          // skip itself
          if(mat.equals(identity)) continue;

          this.matricesElements1.push(matArray[0], matArray[1], matArray[2], matArray[3]);
          this.matricesElements2.push(matArray[4], matArray[5], matArray[6], matArray[7]);
          this.matricesElements3.push(matArray[8], matArray[9], matArray[10], matArray[11]);
          this.matricesElements4.push(matArray[12], matArray[13], matArray[14], matArray[15]);

          var center = this.center.clone();
          center.applyMatrix4(mat);
          centerSum.add(center);

          ++cnt;
       }
   }

   for(var i = 0, il = this.mdl.children.length; i < il; ++i) {
       var mesh = this.mdl.children[i];

       if(mesh.type === 'Sprite') continue;

       var geometry = this.createInstancedGeometry(mesh);

       var mesh2 = new THREE.Mesh(geometry, this.instancedMaterial);

       mesh2.onBeforeRender = this.onBeforeRender;

       // important: https://stackoverflow.com/questions/21184061/mesh-suddenly-disappears-in-three-js-clipping
       // You are moving the camera in the CPU. You are moving the vertices of the plane in the GPU
       mesh2.frustumCulled = false;

       geometry = undefined;

       this.mdl.add(mesh2);
   }

   for(var i = 0, il = this.mdlImpostor.children.length; i < il; ++i) {
       var mesh = this.mdlImpostor.children[i];

       var geometry = this.createInstancedGeometry(mesh);

/*
       var material;
       if(mesh.type == 'Sphere') {
         material = this.SphereImpostorMaterial;
       }
       else { //if(mesh.type == 'Cylinder') {
         material = this.CylinderImpostorMaterial;
       }
*/
       var mesh2 = new THREE.Mesh(geometry, this.instancedMaterial);
       //var mesh2 = new THREE.Mesh(geometry, material);

       mesh2.onBeforeRender = this.onBeforeRender;

       // important: https://stackoverflow.com/questions/21184061/mesh-suddenly-disappears-in-three-js-clipping
       // You are moving the camera in the CPU. You are moving the vertices of the plane in the GPU
       mesh2.frustumCulled = false;

       geometry = null;

       this.mdlImpostor.add(mesh2);
   }

   if(this.bSetInstancing === undefined || !this.bSetInstancing) {
       this.maxD *= Math.sqrt(cnt);

       this.center = centerSum.multiplyScalar(1.0 / cnt);

       this.maxDAssembly = this.maxD;

       this.centerAssembly = this.center.clone();

       this.setCenter(this.center);

       // reset cameara
       this.setCamera();
   }
   else {
       this.maxD = this.maxDAssembly;

       this.center = this.centerAssembly.clone();

       this.setCenter(this.center);

       // reset cameara
       this.setCamera();
   }

   this.bSetInstancing = true;
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3D.prototype.cloneHash = function(from) {
  var to = {};
  for(var i in from) {
    to[i] = from[i];
  }

  return to;
};

iCn3D.prototype.residueName2Abbr = function(residueName) {
  if(residueName !== undefined && residueName.charAt(0) !== ' ' && residueName.charAt(1) === ' ') {
    //residueName = 'n' + residueName.charAt(0);
    residueName = residueName.charAt(0);
  }

  switch(residueName) {
    case '  A':
      return 'A';
      break;
    case '  C':
      return 'C';
      break;
    case '  G':
      return 'G';
      break;
    case '  T':
      return 'T';
      break;
    case '  U':
      return 'U';
      break;
    case '  I':
      return 'I';
      break;
    case ' DA':
      return 'A';
      break;
    case ' DC':
      return 'C';
      break;
    case ' DG':
      return 'G';
      break;
    case ' DT':
      return 'T';
      break;
    case ' DU':
      return 'U';
      break;
    case ' DI':
      return 'I';
      break;
    case 'ALA':
      return 'A';
      break;
    case 'ARG':
      return 'R';
      break;
    case 'ASN':
      return 'N';
      break;
    case 'ASP':
      return 'D';
      break;
    case 'CYS':
      return 'C';
      break;
    case 'GLU':
      return 'E';
      break;
    case 'GLN':
      return 'Q';
      break;
    case 'GLY':
      return 'G';
      break;
    case 'HIS':
      return 'H';
      break;
    case 'ILE':
      return 'I';
      break;
    case 'LEU':
      return 'L';
      break;
    case 'LYS':
      return 'K';
      break;
    case 'MET':
      return 'M';
      break;
    case 'PHE':
      return 'F';
      break;
    case 'PRO':
      return 'P';
      break;
    case 'SER':
      return 'S';
      break;
    case 'THR':
      return 'T';
      break;
    case 'TRP':
      return 'W';
      break;
    case 'TYR':
      return 'Y';
      break;
    case 'VAL':
      return 'V';
      break;
    case 'SEC':
      return 'U';
      break;
//        case 'PYL':
//          return 'O';
//          break;

    case 'HOH':
      return 'O';
      break;
    case 'WAT':
      return 'O';
      break;

    default:
      return residueName;
  }
};

iCn3D.prototype.intHash = function(atoms1, atoms2) {
    var results = {};

    if(Object.keys(atoms1).length < Object.keys(atoms2).length) {
        for (var i in atoms1) {
            if (atoms2 !== undefined && atoms2[i]) {
                results[i] = atoms1[i];
            }
        }
    }
    else {
        for (var i in atoms2) {
            if (atoms1 !== undefined && atoms1[i]) {
                results[i] = atoms2[i];
            }
        }
    }

    atoms1 = {};
    atoms2 = {};

    return results;
};

// get atoms in allAtoms, but not in "atoms"
iCn3D.prototype.exclHash = function(includeAtoms, excludeAtoms) {
    var results = {};

    for (var i in includeAtoms) {
        if (!(i in excludeAtoms)) {
            results[i] = includeAtoms[i];
        }
    }

    includeAtoms = {};
    excludeAtoms = {};

    return results;
};

iCn3D.prototype.unionHash = function(atoms1, atoms2) {
    // The commented-out version has a problem: atom1 became undefined.
    //jQuery.extend(atoms1, atoms2);

    //return atoms1;

    return this.unionHashNotInPlace(atoms1, atoms2);
};

iCn3D.prototype.unionHashNotInPlace = function(atoms1, atoms2) {
    var results = jQuery.extend({}, atoms1, atoms2);
    atoms1 = {};
    atoms2 = {};

    return results;
};

iCn3D.prototype.intHash2Atoms = function(atoms1, atoms2) {
    return this.hash2Atoms(this.intHash(atoms1, atoms2));
};

// get atoms in allAtoms, but not in "atoms"
iCn3D.prototype.exclHash2Atoms = function(includeAtoms, excludeAtoms) {
    return this.hash2Atoms(this.exclHash(includeAtoms, excludeAtoms));
};

iCn3D.prototype.unionHash2Atoms = function(atoms1, atoms2) {
    return this.hash2Atoms(this.unionHash(atoms1, atoms2));
};

iCn3D.prototype.hash2Atoms = function(hash) {
    var atoms = {};
    for(var i in hash) {
      atoms[i] = this.atoms[i];
    }

    hash = {};

    return atoms;
};

// from iview (http://istar.cse.cuhk.edu.hk/iview/)
iCn3D.prototype.exportCanvas = function () {
    this.render();
    window.open(this.renderer.domElement.toDataURL('image/png'));
};

// zoom
iCn3D.prototype.zoomIn = function (normalizedFactor) { // 0.1
  var para = {};
  para._zoomFactor = 1 - normalizedFactor;
  para.update = true;
  this.controls.update(para);
  this.render();
};

iCn3D.prototype.zoomOut = function (normalizedFactor) { // 0.1
  var para = {};
  para._zoomFactor = 1 + normalizedFactor;
  para.update = true;
  this.controls.update(para);
  this.render();
};

// rotate
iCn3D.prototype.rotateLeft = function (degree) { // 5
  var axis = new THREE.Vector3(0,1,0);
  var angle = -degree / 180.0 * Math.PI;

  axis.applyQuaternion( this.cam.quaternion ).normalize();

  var quaternion = new THREE.Quaternion();
  quaternion.setFromAxisAngle( axis, -angle );

  var para = {};
  para.quaternion = quaternion;
  para.update = true;

  this.controls.update(para);
  this.render();
};

iCn3D.prototype.rotateRight = function (degree) { // 5
  var axis = new THREE.Vector3(0,1,0);
  var angle = degree / 180.0 * Math.PI;

  axis.applyQuaternion( this.cam.quaternion ).normalize();

  var quaternion = new THREE.Quaternion();
  quaternion.setFromAxisAngle( axis, -angle );

  var para = {};
  para.quaternion = quaternion;
  para.update = true;

  this.controls.update(para);
  this.render();
};

iCn3D.prototype.rotateUp = function (degree) { // 5
  var axis = new THREE.Vector3(1,0,0);
  var angle = -degree / 180.0 * Math.PI;

  axis.applyQuaternion( this.cam.quaternion ).normalize();

  var quaternion = new THREE.Quaternion();
  quaternion.setFromAxisAngle( axis, -angle );

  var para = {};
  para.quaternion = quaternion;
  para.update = true;

  this.controls.update(para);
  this.render();
};

iCn3D.prototype.rotateDown = function (degree) { // 5
  var axis = new THREE.Vector3(1,0,0);
  var angle = degree / 180.0 * Math.PI;

  axis.applyQuaternion( this.cam.quaternion ).normalize();

  var quaternion = new THREE.Quaternion();
  quaternion.setFromAxisAngle( axis, -angle );

  var para = {};
  para.quaternion = quaternion;
  para.update = true;

  this.controls.update(para);
  this.render();
};

// translate
iCn3D.prototype.translateLeft = function (percentScreenSize) { // 1
  var mouseChange = new THREE.Vector2(0,0);

  // 1 means the full screen size
  mouseChange.x -= percentScreenSize / 100.0;

  var para = {};
  para.mouseChange = mouseChange;
  para.update = true;

  this.controls.update(para);
  this.render();
};

iCn3D.prototype.translateRight = function (percentScreenSize) { // 1
  var mouseChange = new THREE.Vector2(0,0);

  mouseChange.x += percentScreenSize / 100.0;

  var para = {};
  para.mouseChange = mouseChange;
  para.update = true;

  this.controls.update(para);
  this.render();
};

iCn3D.prototype.translateUp = function (percentScreenSize) { // 1
  var mouseChange = new THREE.Vector2(0,0);

  mouseChange.y -= percentScreenSize / 100.0;

  var para = {};
  para.mouseChange = mouseChange;
  para.update = true;

  this.controls.update(para);
  this.render();
};

iCn3D.prototype.translateDown = function (percentScreenSize) { // 1
  var mouseChange = new THREE.Vector2(0,0);

  mouseChange.y += percentScreenSize / 100.0;

  var para = {};
  para.mouseChange = mouseChange;
  para.update = true;

  this.controls.update(para);
  this.render();
};

iCn3D.prototype.showPickingHilight = function(atom) {
  if(!this.bShift && !this.bCtrl) this.removeHlObjects();

  this.pickedAtomList = {};
  if(this.pk === 1) {
    this.pickedAtomList[atom.serial] = 1;
  }
  else if(this.pk === 2) {
    var residueid = atom.structure + '_' + atom.chain + '_' + atom.resi;
    this.pickedAtomList = this.residues[residueid];
  }
  else if(this.pk === 3) {
    this.pickedAtomList = this.selectStrandHelixFromAtom(atom);
  }
  else if(this.pk === 4) {
    var chainid = atom.structure + '_' + atom.chain;
    this.pickedAtomList = this.chains[chainid];
  }

  if(this.pk === 0) {
      this.bShowHighlight = false;
  }
  else {
      this.bShowHighlight = true;
  }

  var intersectAtoms = (Object.keys(this.hAtoms).length == Object.keys(this.atoms).length) ? {} : this.intHash(this.hAtoms, this.pickedAtomList);
  var intersectAtomsSize = Object.keys(intersectAtoms).length;

  if(!this.bShift && !this.bCtrl) {
      //if(intersectAtomsSize > 0) {
      //    this.hAtoms = this.exclHash(this.hAtoms, this.pickedAtomList);
      //}
      //else {
      //    this.hAtoms = this.cloneHash(this.pickedAtomList);
      //}
      this.hAtoms = this.cloneHash(this.pickedAtomList);
  }
  else if(this.bShift) { // select a range

    if(this.prevPickedAtomList === undefined) {
        this.hAtoms = this.unionHash(this.hAtoms, this.pickedAtomList);
    }
    else {
        var prevAtom = this.getFirstAtomObj(this.prevPickedAtomList);
        var currAtom = this.getFirstAtomObj(this.pickedAtomList);

        var prevChainid = prevAtom.structure + '_' + prevAtom.chain;
        var currChainid = currAtom.structure + '_' + currAtom.chain;

        if(prevChainid != currChainid) {
            this.hAtoms = this.unionHash(this.hAtoms, this.pickedAtomList);
        }
        else { // range in the same chain only
            var combinedAtomList = this.unionHash(this.prevPickedAtomList, this.pickedAtomList);

            var firstAtom = this.getFirstAtomObj(combinedAtomList);
            var lastAtom = this.getLastAtomObj(combinedAtomList);

            for(var i = firstAtom.serial; i <= lastAtom.serial; ++i) {
                this.hAtoms[i] = 1;
            }
        }
    }

    // remember this shift selection
    this.prevPickedAtomList = this.cloneHash(this.pickedAtomList);
  }
  else if(this.bCtrl) {
      if(intersectAtomsSize > 0) {
          this.hAtoms = this.exclHash(this.hAtoms, this.pickedAtomList);
      }
      else {
          this.hAtoms = this.unionHash(this.hAtoms, this.pickedAtomList);
      }
  }

  this.removeHlObjects();
  this.addHlObjects();
};

iCn3D.prototype.showPicking = function(atom, x, y) { var me = this;
    this.showPickingBase(atom, x, y); // including render step
};

iCn3D.prototype.showPickingBase = function(atom, x, y) { var me = this;
  if(x === undefined && y === undefined) { // NOT mouse over
      this.showPickingHilight(atom); // including render step

/*
      //var text = '#' + atom.structure + '.' + atom.chain + ':' + atom.resi + '@' + atom.name;
      var residueText = '.' + atom.chain + ':' + atom.resi;
      var text = residueText + '@' + atom.name;

      var labels = {};
      labels['picking'] = [];

      var label = {};
      label.position = new THREE.Vector3(atom.coord.x + 1, atom.coord.y + 1, atom.coord.z + 1); // shifted by 1

      if(this.pk === 1) {
        label.text = text;
      }
      else if(this.pk === 2) {
        label.text = residueText;
      }
    //  else if(this.pk === 3) {
    //    label.text = residueText;
    //  }

      if(this.pk === 1 || this.pk === 2) {
          labels['picking'].push(label);

          //http://www.johannes-raida.de/tutorials/three.js/tutorial13/tutorial13.htm
          this.createLabelRepresentation(labels);
      }
*/


  }
};

iCn3D.prototype.removeHlObjects = function () {
   // remove prevous highlight
   for(var i in this.prevHighlightObjects) {
       //this.mdlPicking.remove(this.prevHighlightObjects[i]);
       this.mdl.remove(this.prevHighlightObjects[i]);
   }

   this.prevHighlightObjects = [];

   // remove prevous highlight
   for(var i in this.prevHighlightObjects_ghost) {
       //this.mdlPicking.remove(this.prevHighlightObjects_ghost[i]);
       this.mdl.remove(this.prevHighlightObjects_ghost[i]);
   }

   this.prevHighlightObjects_ghost = [];

};

iCn3D.prototype.addHlObjects = function (color, bRender, atomsHash) {
   if(color === undefined) color = this.hColor;
   if(atomsHash === undefined) atomsHash = this.hAtoms;

   this.applyDisplayOptions(this.opts, this.intHash(atomsHash, this.dAtoms), this.bHighlight);

   if(bRender === undefined || bRender) this.render();
};

iCn3D.prototype.resetOrientation = function() {
    var bSet = false;
    if(this.commands.length > 0) {
        var commandTransformation = this.commands[0].split('|||');

        if(commandTransformation.length == 2) {
            var transformation = JSON.parse(commandTransformation[1]);

            this._zoomFactor = transformation.factor;

            this.mouseChange.x = transformation.mouseChange.x;
            this.mouseChange.y = transformation.mouseChange.y;

            this.quaternion._x = transformation.quaternion._x;
            this.quaternion._y = transformation.quaternion._y;
            this.quaternion._z = transformation.quaternion._z;
            this.quaternion._w = transformation.quaternion._w;

            bSet = true;
        }
    }

    if(!bSet) {
        this._zoomFactor = 1.0;
        this.mouseChange = new THREE.Vector2(0,0);
        this.quaternion = new THREE.Quaternion(0,0,0,1);
    }

    //reset this.maxD
    this.maxD = this.oriMaxD;
    this.center = this.oriCenter.clone();

    if(this.ori_chemicalbinding == 'show') {
        this.bSkipChemicalbinding = false;
    }
    else if(this.ori_chemicalbinding == 'hide') {
        this.bSkipChemicalbinding = true;
    }
};

 // from iview (http://istar.cse.cuhk.edu.hk/iview/)
 iCn3D.prototype.getAtomsFromPosition = function(point, threshold) {
    var i, atom;

    if(threshold === undefined || threshold === null) {
      threshold = 1;
    }

    for (i in this.atoms) {
       var atom = this.atoms[i];

       //if(atom.coord.x < point.x - threshold || atom.coord.x > point.x + threshold) continue;
       //if(atom.coord.y < point.y - threshold || atom.coord.y > point.y + threshold) continue;
       //if(atom.coord.z < point.z - threshold || atom.coord.z > point.z + threshold) continue;

       if(this.ions.hasOwnProperty(i) && this.opts['ions'] === 'sphere') {
           var adjust = this.vdwRadii[atom.elem];

           if(Math.abs(atom.coord.x - point.x) - adjust > threshold) continue;
           if(Math.abs(atom.coord.y - point.y) - adjust > threshold) continue;
           if(Math.abs(atom.coord.z - point.z) - adjust > threshold) continue;
       }
       else {
           if(atom.coord.x < point.x - threshold || atom.coord.x > point.x + threshold) continue;
           if(atom.coord.y < point.y - threshold || atom.coord.y > point.y + threshold) continue;
           if(atom.coord.z < point.z - threshold || atom.coord.z > point.z + threshold) continue;
       }

       return atom;
    }

    return null;
 };

iCn3D.prototype.getFirstAtomObj = function(atomsHash) {
    if(atomsHash == undefined) return this.atoms[0];

    var atomKeys = Object.keys(atomsHash);
    var firstIndex = atomKeys[0];

    return this.atoms[firstIndex];
};

iCn3D.prototype.getFirstCalphaAtomObj = function(atomsHash) {
    if(atomsHash == undefined) return this.atoms[0];

    var firstIndex;

    for(var i in atomsHash) {
        if(this.atoms[i].name == 'CA') {
            firstIndex = i;
            break;
        }
    }

    return (firstIndex !== undefined) ? this.atoms[firstIndex] : this.getFirstAtomObj(atomsHash);
};

iCn3D.prototype.getLastAtomObj = function(atomsHash) {
    var atomKeys = Object.keys(atomsHash);
    var lastIndex = atomKeys[atomKeys.length - 1];

    return this.atoms[lastIndex];
};

 // http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
 iCn3D.prototype.hexToRgb = function (hex, a) {
     var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
     return result ? {
         r: parseInt(result[1], 16),
         g: parseInt(result[2], 16),
         b: parseInt(result[3], 16),
         a: a
     } : null;
 };

iCn3D.prototype.selectStrandHelixFromAtom = function(atom) {
    var firstAtom = atom;
    var lastAtom = atom;

    var atomsHash = {};

    // fill the beginning
    var beginResi = firstAtom.resi;
    if(!firstAtom.ssbegin) {
        for(var i = firstAtom.resi - 1; i > 0; --i) {
            var residueid = firstAtom.structure + '_' + firstAtom.chain + '_' + i;
            if(!this.residues.hasOwnProperty(residueid)) break;

            var atom = this.getFirstCalphaAtomObj(this.residues[residueid]);
            beginResi = atom.resi;

            if( (firstAtom.ss !== 'coil' && atom.ss === firstAtom.ss && atom.ssbegin)
              || (firstAtom.ss === 'coil' && atom.ss !== firstAtom.ss) ) {
                if(firstAtom.ss === 'coil' && atom.ss !== firstAtom.ss) {
                    beginResi = atom.resi + 1;
                }
                break;
            }
        }

        for(var i = beginResi; i <= firstAtom.resi; ++i) {
            var residueid = firstAtom.structure + '_' + firstAtom.chain + '_' + i;
            atomsHash = this.unionHash(atomsHash, this.hash2Atoms(this.residues[residueid]));
        }
    }

    // fill the end
    var endResi = lastAtom.resi;
    var endChainResi = this.getLastAtomObj(this.chains[lastAtom.structure + '_' + lastAtom.chain]).resi;
    for(var i = lastAtom.resi + 1; i <= endChainResi; ++i) {
        var residueid = lastAtom.structure + '_' + lastAtom.chain + '_' + i;
        if(!this.residues.hasOwnProperty(residueid)) break;

        var atom = this.getFirstCalphaAtomObj(this.residues[residueid]);
        endResi = atom.resi;

        if( (lastAtom.ss !== 'coil' && atom.ss === lastAtom.ss && atom.ssend) || (lastAtom.ss === 'coil' && atom.ss !== lastAtom.ss) ) {
            if(lastAtom.ss === 'coil' && atom.ss !== lastAtom.ss) {
                endResi = atom.resi - 1;
            }
            break;
        }
    }

    for(var i = lastAtom.resi + 1; i <= endResi; ++i) {
        var residueid = lastAtom.structure + '_' + lastAtom.chain + '_' + i;
        atomsHash = this.unionHash(atomsHash, this.hash2Atoms(this.residues[residueid]));
    }

    return atomsHash;
};

iCn3D.prototype.addNonCarbonAtomLabels = function (atoms) {
    var size = 18;
    var background = "#FFFFFF";

    var atomsHash = this.intHash(this.hAtoms, atoms);

    if(this.labels['schematic'] === undefined) this.labels['schematic'] = [];

    for(var i in atomsHash) {
        var atom = this.atoms[i];

        //if(!atom.het) continue;
        if(!this.residues.hasOwnProperty(atom.structure + '_' + atom.chain + '_' + atom.resi)) continue;
        if(atom.elem === 'C') continue;

        var label = {}; // Each label contains 'position', 'text', 'color', 'background'

        label.position = atom.coord;

        label.bSchematic = 1;

        label.text = atom.elem;
        label.size = size;

        label.color = "#" + atom.color.getHexString();
        label.background = background;

        this.labels['schematic'].push(label);
    }

    this.removeHlObjects();
};

iCn3D.prototype.addResiudeLabels = function (atoms, bSchematic, alpha) {
    var size = 18;
    var background = "#CCCCCC";
    if(alpha === undefined) alpha = 1.0;

    var atomsHash = this.intHash(this.hAtoms, atoms);

    if(bSchematic) {
        if(this.labels['schematic'] === undefined) this.labels['schematic'] = [];
    }
    else {
        if(this.labels['residue'] === undefined) this.labels['residue'] = [];
    }

    var prevReidueID = '';
    for(var i in atomsHash) {
        var atom = this.atoms[i];

        // allow chemicals
        //if(atom.het) continue;

        var label = {}; // Each label contains 'position', 'text', 'color', 'background'

        var currReidueID = atom.structure + '_' + atom.chain + '_' + atom.resi;

        if( (!atom.het && (atom.name === 'CA' || atom.name === "O3'" || atom.name === "O3*") )
          || this.water.hasOwnProperty(atom.serial)
          || this.ions.hasOwnProperty(atom.serial)
          || (this.chemicals.hasOwnProperty(atom.serial) && currReidueID !== prevReidueID) ) {
            label.position = atom.coord;

            label.bSchematic = 0;
            if(bSchematic) label.bSchematic = 1;

            label.text = this.residueName2Abbr(atom.resn);
            label.size = size;

            var atomColorStr = atom.color.getHexString().toUpperCase();
            label.color = (atomColorStr === "CCCCCC" || atomColorStr === "C8C8C8") ? "#888888" : "#" + atomColorStr;
            label.background = background;
            //label.alpha = alpha; // this.hideLabels() didn't work. Remove this line for now

            if(bSchematic) {
                this.labels['schematic'].push(label);
            }
            else {
                this.labels['residue'].push(label);
            }
        }

        prevReidueID = currReidueID;
    }

    this.removeHlObjects();
};

iCn3D.prototype.setCenter = function(center) {
   this.mdl.position.set(0,0,0);
   this.mdlImpostor.position.set(0,0,0);
   this.mdl_ghost.position.set(0,0,0);

   this.mdl.position.sub(center);
   //this.mdlPicking.position.sub(center);
   this.mdlImpostor.position.sub(center);
   this.mdl_ghost.position.sub(center);
};

iCn3D.prototype.getResiduesFromAtoms = function(atomsHash) {
    var residuesHash = {};
    for(var i in atomsHash) {
        var residueid = this.atoms[i].structure + '_' + this.atoms[i].chain + '_' + this.atoms[i].resi;
        residuesHash[residueid] = 1;
    }

    return residuesHash;
};

iCn3D.prototype.getResiduesFromCalphaAtoms = function(atomsHash) {
    var residuesHash = {};
    for(var i in atomsHash) {
        if((this.atoms[i].name == 'CA' && this.proteins.hasOwnProperty(i)) || !this.proteins.hasOwnProperty(i)) {
            var residueid = this.atoms[i].structure + '_' + this.atoms[i].chain + '_' + this.atoms[i].resi;
            residuesHash[residueid] = 1;
        }
    }

    return residuesHash;
};


/*
 * JavaScript Canvas to Blob
 * https://github.com/blueimp/JavaScript-Canvas-to-Blob
 *
 * Copyright 2012, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on stackoverflow user Stoive's code snippet:
 * http://stackoverflow.com/q/4998908
 */

/* global atob, Blob, define */

;(function (window) {
  'use strict'

  var CanvasPrototype =
    window.HTMLCanvasElement && window.HTMLCanvasElement.prototype
  var hasBlobConstructor =
    window.Blob &&
    (function () {
      try {
        return Boolean(new Blob())
      } catch (e) {
        return false
      }
    })()
  var hasArrayBufferViewSupport =
    hasBlobConstructor &&
    window.Uint8Array &&
    (function () {
      try {
        return new Blob([new Uint8Array(100)]).size === 100
      } catch (e) {
        return false
      }
    })()
  var BlobBuilder =
    window.BlobBuilder ||
    window.WebKitBlobBuilder ||
    window.MozBlobBuilder ||
    window.MSBlobBuilder
  var dataURIPattern = /^data:((.*?)(;charset=.*?)?)(;base64)?,/
  var dataURLtoBlob =
    (hasBlobConstructor || BlobBuilder) &&
    window.atob &&
    window.ArrayBuffer &&
    window.Uint8Array &&
    function (dataURI) {
      var matches,
        mediaType,
        isBase64,
        dataString,
        byteString,
        arrayBuffer,
        intArray,
        i,
        bb
      // Parse the dataURI components as per RFC 2397
      matches = dataURI.match(dataURIPattern)
      if (!matches) {
        throw new Error('invalid data URI')
      }
      // Default to text/plain;charset=US-ASCII
      mediaType = matches[2]
        ? matches[1]
        : 'text/plain' + (matches[3] || ';charset=US-ASCII')
      isBase64 = !!matches[4]
      dataString = dataURI.slice(matches[0].length)
      if (isBase64) {
        // Convert base64 to raw binary data held in a string:
        byteString = atob(dataString)
      } else {
        // Convert base64/URLEncoded data component to raw binary:
        byteString = decodeURIComponent(dataString)
      }
      // Write the bytes of the string to an ArrayBuffer:
      arrayBuffer = new ArrayBuffer(byteString.length)
      intArray = new Uint8Array(arrayBuffer)
      for (i = 0; i < byteString.length; i += 1) {
        intArray[i] = byteString.charCodeAt(i)
      }
      // Write the ArrayBuffer (or ArrayBufferView) to a blob:
      if (hasBlobConstructor) {
        return new Blob([hasArrayBufferViewSupport ? intArray : arrayBuffer], {
          type: mediaType
        })
      }
      bb = new BlobBuilder()
      bb.append(arrayBuffer)
      return bb.getBlob(mediaType)
    }
  if (window.HTMLCanvasElement && !CanvasPrototype.toBlob) {
    if (CanvasPrototype.mozGetAsFile) {
      CanvasPrototype.toBlob = function (callback, type, quality) {
        var self = this
        setTimeout(function () {
          if (quality && CanvasPrototype.toDataURL && dataURLtoBlob) {
            callback(dataURLtoBlob(self.toDataURL(type, quality)))
          } else {
            callback(self.mozGetAsFile('blob', type))
          }
        })
      }
    } else if (CanvasPrototype.toDataURL && dataURLtoBlob) {
      CanvasPrototype.toBlob = function (callback, type, quality) {
        var self = this
        setTimeout(function () {
          callback(dataURLtoBlob(self.toDataURL(type, quality)))
        })
      }
    }
  }
  if (typeof define === 'function' && define.amd) {
    define(function () {
      return dataURLtoBlob
    })
  } else if (typeof module === 'object' && module.exports) {
    module.exports = dataURLtoBlob
  } else {
    window.dataURLtoBlob = dataURLtoBlob
  }
})(window)

/* FileSaver.js
 * A saveAs() FileSaver implementation.
 * 1.3.8
 * 2018-03-22 14:03:47
 *
 * By Eli Grey, https://eligrey.com
 * License: MIT
 *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
 */

/*global self */
/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/src/FileSaver.js */

var saveAs = saveAs || (function(view) {
    "use strict";
    // IE <10 is explicitly unsupported
    if (typeof view === "undefined" || typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
        return;
    }
    var
          doc = view.document
          // only get URL when necessary in case Blob.js hasn't overridden it yet
        , get_URL = function() {
            return view.URL || view.webkitURL || view;
        }
        , save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
        , can_use_save_link = "download" in save_link
        , click = function(node) {
            var event = new MouseEvent("click");
            node.dispatchEvent(event);
        }
        , is_safari = /constructor/i.test(view.HTMLElement) || view.safari
        , is_chrome_ios =/CriOS\/[\d]+/.test(navigator.userAgent)
        , setImmediate = view.setImmediate || view.setTimeout
        , throw_outside = function(ex) {
            setImmediate(function() {
                throw ex;
            }, 0);
        }
        , force_saveable_type = "application/octet-stream"
        // the Blob API is fundamentally broken as there is no "downloadfinished" event to subscribe to
        , arbitrary_revoke_timeout = 1000 * 40 // in ms
        , revoke = function(file) {
            var revoker = function() {
                if (typeof file === "string") { // file is an object URL
                    get_URL().revokeObjectURL(file);
                } else { // file is a File
                    file.remove();
                }
            };
            setTimeout(revoker, arbitrary_revoke_timeout);
        }
        , dispatch = function(filesaver, event_types, event) {
            event_types = [].concat(event_types);
            var i = event_types.length;
            while (i--) {
                var listener = filesaver["on" + event_types[i]];
                if (typeof listener === "function") {
                    try {
                        listener.call(filesaver, event || filesaver);
                    } catch (ex) {
                        throw_outside(ex);
                    }
                }
            }
        }
        , auto_bom = function(blob) {
            // prepend BOM for UTF-8 XML and text/* types (including HTML)
            // note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF
            //if (blob && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
            if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
                return new Blob([String.fromCharCode(0xFEFF), blob], {type: blob.type});
            }
            return blob;
        }
        , FileSaver = function(blob, name, no_auto_bom) {
            if (!no_auto_bom) {
                blob = auto_bom(blob);
            }
            // First try a.download, then web filesystem, then object URLs
            var
                  filesaver = this
                , type = (blob) ? blob.type : undefined
                , force = type === force_saveable_type
                , object_url
                , dispatch_all = function() {
                    dispatch(filesaver, "writestart progress write writeend".split(" "));
                }
                // on any filesys errors revert to saving with object URLs
                , fs_error = function() {
                    if ((is_chrome_ios || (force && is_safari)) && view.FileReader) {
                        // Safari doesn't allow downloading of blob urls
                        var reader = new FileReader();
                        reader.onloadend = function() {
                            var url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');
                            var popup = view.open(url, '_blank');
                            if(!popup) view.location.href = url;
                            url=undefined; // release reference before dispatching
                            filesaver.readyState = filesaver.DONE;
                            dispatch_all();
                        };
                        reader.readAsDataURL(blob);
                        filesaver.readyState = filesaver.INIT;
                        return;
                    }
                    // don't create more object URLs than needed
                    if (!object_url) object_url = get_URL().createObjectURL(blob);
                    if (force) {
                        view.location.href = object_url;
                    } else {
                        var opened = view.open(object_url, "_blank");
                        if (!opened) {
                            // Apple does not allow window.open, see https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/WorkingwithWindowsandTabs/WorkingwithWindowsandTabs.html
                            view.location.href = object_url;
                        }
                    }
                    filesaver.readyState = filesaver.DONE;
                    dispatch_all();
                    revoke(object_url);
                }
            ;
            filesaver.readyState = filesaver.INIT;

            if (can_use_save_link) {
                if (!object_url) object_url = get_URL().createObjectURL(blob);
                setImmediate(function() {
                    save_link.href = object_url;
                    save_link.download = name;
                    click(save_link);
                    dispatch_all();
                    revoke(object_url);
                    filesaver.readyState = filesaver.DONE;
                }, 0);
                return;
            }

            fs_error();
        }
        , FS_proto = FileSaver.prototype
        , saveAs = function(blob, name, no_auto_bom) {
            return new FileSaver(blob, name || blob.name || "download", no_auto_bom);
        }
    ;

    // IE 10+ (native saveAs)
    if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
        return function(blob, name, no_auto_bom) {
            name = name || blob.name || "download";

            if (!no_auto_bom) {
                blob = auto_bom(blob);
            }
            return navigator.msSaveOrOpenBlob(blob, name);
        };
    }

    // todo: detect chrome extensions & packaged apps
    //save_link.target = "_blank";

    FS_proto.abort = function(){};
    FS_proto.readyState = FS_proto.INIT = 0;
    FS_proto.WRITING = 1;
    FS_proto.DONE = 2;

    FS_proto.error =
    FS_proto.onwritestart =
    FS_proto.onprogress =
    FS_proto.onwrite =
    FS_proto.onabort =
    FS_proto.onerror =
    FS_proto.onwriteend =
        null;

    return saveAs;
}(
       typeof self !== "undefined" && self
    || typeof window !== "undefined" && window
    || this
));

/*! marchingcube.js
 * @author David Koes  / https://github.com/3dmol/3Dmol.js/tree/master/3Dmol
 * Modified by Jiyao Wang / https://github.com/ncbi/icn3d
 */

var $3Dmol = $3Dmol || {};

//Encapsulate marching cube algorithm for isosurface generation
// (currently used by protein surface rendering and generic volumetric data reading)
$3Dmol.MarchingCubeInitializer = function() {

    //Marching cube algorithm - assume data has been pre-treated so isovalue is 0
    // (i.e. select points greater than 0)
    //origin -  vector of origin of volumetric data (default is (0,0,0))
    // nX, nY, nZ - specifies number of voxels in each dimension
    // scale - cube diagonal unit vector scale (3Dmol vector) (specifying distance between data points); diagonal of cube
    // - default is 1 - assumes unit cube (1,1,1) diag)
    // fulltable - if true, use full marching cubes and tritables - else use trimmed table (e.g. surf render)
    // voxel - if true, draws with a blocky voxel style (default false)
    // verts, faces - vertex and face arrays to fill up

    //to match with protein surface...
    var ISDONE = 2;
    var my = {};

    my.march = function(data, verts, faces, spec) {

        var fulltable = !!(spec.fulltable);
        var origin = (spec.hasOwnProperty('origin') && spec.origin.hasOwnProperty('x')) ? spec.origin : {x:0, y:0, z:0};
        var voxel = !!(spec.voxel);
        var transform = spec.matrix; //if this is set, it overrides origin and unitCube

        var nX = spec.nX || 0;
        var nY = spec.nY || 0;
        var nZ = spec.nZ || 0;

        var scale = spec.scale || 1.0;
        var unitCube = null;
        if(spec.unitCube) {
            unitCube = spec.unitCube;
        } else {
            unitCube = {x:scale,y:scale,z:scale};
        }

        //keep track of calculated vertices to avoid repeats
        var vertnums = new Int32Array(nX*nY*nZ);

        var i, il;

        for (i = 0, il = vertnums.length; i < il; ++i)
            vertnums[i] = -1;

        // create (or retrieve) a vertex at the appropriate point for
        // the edge (p1,p2)

        var getVertex = function(i, j, k, code, p1, p2) {
            var pt = {x:0,y:0,z:0};
            var val1 = !!(code & (1 << p1));
            var val2 = !!(code & (1 << p2));

            // p1 if they are the same or if !val1
            var p = p1;
            if (!val1 && val2)
                p = p2;

            // adjust i,j,k by p
            if (p & 1)
                k++;
            if (p & 2)
                j++;
            if (p & 4)
                i++;

            if(transform) {
                pt = new $3Dmol.Vector3(i,j,k);
                pt = pt.applyMatrix4(transform);
                pt = {x: pt.x, y: pt.y, z: pt.z}; //remove vector gunk
            } else {
                pt.x = origin.x+unitCube.x*i;
                pt.y = origin.y+unitCube.y*j;
                pt.z = origin.z+unitCube.z*k;
            }

            var index = ((nY * i) + j) * nZ + k;

            //Have to add option to do voxels
            if (!voxel) {

                if (vertnums[index] < 0) // not created yet
                {
                    vertnums[index] = verts.length;
                    verts.push( pt );
                }
                return vertnums[index];

            }

            else {
                verts.push(pt);
                return verts.length - 1;
            }

        };

        var intersects = new Int32Array(12);

        var etable = (fulltable) ? edgeTable2 : edgeTable;
        var tritable = (fulltable) ? triTable2 : triTable;

        //Run marching cubes algorithm
        for (i = 0; i < nX-1; ++i) {

            for (var j = 0; j < nY-1; ++j){

                for (var k = 0; k < nZ-1; ++k){

                    var code = 0;

                    for (var p = 0; p < 8; ++p) {
                        var index = ((nY * (i + ((p & 4) >> 2))) + j + ((p & 2) >> 1)) *
                                        nZ + k + (p & 1);

                        //TODO: Need to fix vpBits in protein surface for this to work
                        var val = !!(data[index] & ISDONE);
                        //var val = !!(data[index] > 0);

                        code |= val << p;
                    }

                    if (code === 0 || code === 255)
                        continue;

                    var ecode = etable[code];

                    if (ecode === 0)
                        continue;

                    var ttable = tritable[code];

                    if (ecode & 1)
                        intersects[0] = getVertex(i, j, k, code, 0, 1);
                    if (ecode & 2)
                        intersects[1] = getVertex(i, j, k, code, 1, 3);
                    if (ecode & 4)
                        intersects[2] = getVertex(i, j, k, code, 3, 2);
                    if (ecode & 8)
                        intersects[3] = getVertex(i, j, k, code, 2, 0);
                    if (ecode & 16)
                        intersects[4] = getVertex(i, j, k, code, 4, 5);
                    if (ecode & 32)
                        intersects[5] = getVertex(i, j, k, code, 5, 7);
                    if (ecode & 64)
                        intersects[6] = getVertex(i, j, k, code, 7, 6);
                    if (ecode & 128)
                        intersects[7] = getVertex(i, j, k, code, 6, 4);
                    if (ecode & 256)
                        intersects[8] = getVertex(i, j, k, code, 0, 4);
                    if (ecode & 512)
                        intersects[9] = getVertex(i, j, k, code, 1, 5);
                    if (ecode & 1024)
                        intersects[10] = getVertex(i, j, k, code, 3, 7);
                    if (ecode & 2048)
                        intersects[11] = getVertex(i, j, k, code, 2, 6);

                    for (var t = 0; t < ttable.length; t += 3) {

                        var a = intersects[ttable[t]],
                            b = intersects[ttable[t+1]],
                            c = intersects[ttable[t+2]];

                        if (voxel && t >= 3) {
                            verts.push(verts[a]); a = verts.length - 1;
                            verts.push(verts[b]); b = verts.length - 1;
                            verts.push(verts[c]); c = verts.length - 1;
                        }


                        faces.push(a); faces.push(b); faces.push(c);
                    }

                }

            }

        }


    };

    my.laplacianSmooth = function(numiter, verts, faces) {
            var tps = new Array(verts.length);
            var i, il, j, jl, k, kl;
            for (i = 0, il = verts.length; i < il; i++)
                    tps[i] = {
                        x : 0,
                        y : 0,
                        z : 0
                    };
            var vertdeg = new Array(20);
            var flagvert;
            for (i = 0; i < 20; i++)
                    vertdeg[i] = new Array(verts.length);
            for (i = 0, il = verts.length; i < il; i++)
                    vertdeg[0][i] = 0;
            for (i = 0, il = faces.length / 3; i < il; i++) {
                var aoffset = i*3, boffset = i*3 + 1, coffset = i*3 + 2;
                flagvert = true;
                for (j = 0, jl = vertdeg[0][faces[aoffset]]; j < jl; j++) {
                    if (faces[boffset] == vertdeg[j + 1][faces[aoffset]]) {
                        flagvert = false;
                        break;
                    }
                }
                if (flagvert) {
                    vertdeg[0][faces[aoffset]]++;
                    vertdeg[vertdeg[0][faces[aoffset]]][faces[aoffset]] = faces[boffset];
                }
                flagvert = true;
                for (j = 0, jl = vertdeg[0][faces[aoffset]]; j < jl; j++) {
                    if (faces[coffset] == vertdeg[j + 1][faces[aoffset]]) {
                        flagvert = false;
                        break;
                    }
                }
                if (flagvert) {
                    vertdeg[0][faces[aoffset]]++;
                    vertdeg[vertdeg[0][faces[aoffset]]][faces[aoffset]] = faces[coffset];
                }
                // b
                flagvert = true;
                for (j = 0, jl = vertdeg[0][faces[boffset]]; j < jl; j++) {
                    if (faces[aoffset] == vertdeg[j + 1][faces[boffset]]) {
                        flagvert = false;
                        break;
                    }
                }
                if (flagvert) {
                    vertdeg[0][faces[boffset]]++;
                    vertdeg[vertdeg[0][faces[boffset]]][faces[boffset]] = faces[aoffset];
                }
                flagvert = true;
                for (j = 0, jl = vertdeg[0][faces[boffset]]; j < jl; j++) {
                    if (faces[coffset] == vertdeg[j + 1][faces[boffset]]) {
                        flagvert = false;
                        break;
                    }
                }
                if (flagvert) {
                    vertdeg[0][faces[boffset]]++;
                    vertdeg[vertdeg[0][faces[boffset]]][faces[boffset]] = faces[coffset];
                }
                // c
                flagvert = true;
                for (j = 0; j < vertdeg[0][faces[coffset]]; j++) {
                    if (faces[aoffset] == vertdeg[j + 1][faces[coffset]]) {
                        flagvert = false;
                        break;
                    }
                }
                if (flagvert) {
                    vertdeg[0][faces[coffset]]++;
                    vertdeg[vertdeg[0][faces[coffset]]][faces[coffset]] = faces[aoffset];
                }
                flagvert = true;
                for (j = 0, jl = vertdeg[0][faces[coffset]]; j < jl; j++) {
                    if (faces[boffset] == vertdeg[j + 1][faces[coffset]]) {
                        flagvert = false;
                        break;
                    }
                }
                if (flagvert) {
                    vertdeg[0][faces[coffset]]++;
                    vertdeg[vertdeg[0][faces[coffset]]][faces[coffset]] = faces[boffset];
                }
            }

            var wt = 1.00;
            var wt2 = 0.50;
            var ssign;
            var scaleFactor = 1;
            var outwt = 0.75 / (scaleFactor + 3.5); // area-preserving
            for (k = 0; k < numiter; k++) {
                    for (i = 0, il = verts.length; i < il; i++) {
                            if (vertdeg[0][i] < 3) {
                                    tps[i].x = verts[i].x;
                                    tps[i].y = verts[i].y;
                                    tps[i].z = verts[i].z;
                            } else if (vertdeg[0][i] == 3 || vertdeg[0][i] == 4) {
                                    tps[i].x = 0;
                                    tps[i].y = 0;
                                    tps[i].z = 0;
                                    for (j = 0, jl = vertdeg[0][i]; j < jl; j++) {
                                            tps[i].x += verts[vertdeg[j + 1][i]].x;
                                            tps[i].y += verts[vertdeg[j + 1][i]].y;
                                            tps[i].z += verts[vertdeg[j + 1][i]].z;
                                    }
                                    tps[i].x += wt2 * verts[i].x;
                                    tps[i].y += wt2 * verts[i].y;
                                    tps[i].z += wt2 * verts[i].z;
                                    tps[i].x /= wt2 + vertdeg[0][i];
                                    tps[i].y /= wt2 + vertdeg[0][i];
                                    tps[i].z /= wt2 + vertdeg[0][i];
                            } else {
                                    tps[i].x = 0;
                                    tps[i].y = 0;
                                    tps[i].z = 0;
                                    for (j = 0, jl = vertdeg[0][i]; j < jl; j++) {
                                            tps[i].x += verts[vertdeg[j + 1][i]].x;
                                            tps[i].y += verts[vertdeg[j + 1][i]].y;
                                            tps[i].z += verts[vertdeg[j + 1][i]].z;
                                    }
                                    tps[i].x += wt * verts[i].x;
                                    tps[i].y += wt * verts[i].y;
                                    tps[i].z += wt * verts[i].z;
                                    tps[i].x /= wt + vertdeg[0][i];
                                    tps[i].y /= wt + vertdeg[0][i];
                                    tps[i].z /= wt + vertdeg[0][i];
                            }
                    }
                    for (i = 0, il = verts.length; i < il; i++) {
                            verts[i].x = tps[i].x;
                            verts[i].y = tps[i].y;
                            verts[i].z = tps[i].z;
                    }
                    /*
                     * computenorm(); for (var i = 0; i < vertnumber; i++) { if
                     * (verts[i].inout) ssign = 1; else ssign = -1; verts[i].x += ssign *
                     * outwt * verts[i].pn.x; verts[i].y += ssign * outwt *
                     * verts[i].pn.y; verts[i].z += ssign * outwt * verts[i].pn.z; }
                     */
            }
    };


    /*
     * These tables are based off those by Paul Bourke and Geoffrey Heller:
     * http://paulbourke.net/geometry/polygonise/
     * http://paulbourke.net/geometry/polygonise/table2.txt
     *
     * However, they have been substantially modified to reflect a more
     * sensible corner numbering scheme and the discrete nature of our voxel data
     * (resulting in fewer faces).
     */
    my.edgeTable = [ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0xb00, 0x0, 0x0, 0x0, 0x700, 0x0, 0xd00, 0xe00, 0xf00, 0x0, 0x0, 0x0,
            0x8a, 0x0, 0x15, 0x0, 0x86, 0x0, 0x0, 0x0, 0x28c, 0x0, 0x813, 0xf19,
            0xe10, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x0, 0x0, 0x126, 0x0, 0x0, 0x15, 0x1c,
            0x0, 0xf23, 0x419, 0xd20, 0x0, 0xa8, 0xa2, 0xaa, 0x0, 0x285, 0x9ab,
            0x8a2, 0x0, 0x2af, 0x125, 0xac, 0xfaa, 0xea3, 0xda9, 0xca0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x45, 0x0, 0x384, 0x0, 0x0, 0x0, 0x700, 0x8a, 0x83,
            0x648, 0x780, 0x0, 0x51, 0x0, 0x81a, 0x54, 0x55, 0x54, 0x56, 0x0, 0x51,
            0x0, 0xe5c, 0x14a, 0x451, 0x759, 0x650, 0x0, 0x0, 0x0, 0x2a, 0x0, 0x45,
            0x0, 0x1f6, 0x0, 0x0, 0x15, 0xdfc, 0x8a, 0x7f3, 0x4f9, 0x5f0, 0xb00,
            0x68, 0x921, 0x6a, 0x348, 0x245, 0x16f, 0x66, 0xb00, 0xe6f, 0xd65,
            0xc6c, 0x76a, 0x663, 0x569, 0x460, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0xf46, 0x0, 0x0, 0x45, 0x24c, 0x2a, 0x823, 0x29, 0xb40, 0x0, 0x0, 0x0,
            0x6ba, 0x0, 0x8f5, 0xfff, 0xef6, 0x0, 0xff, 0x2f5, 0x2fc, 0x9ea, 0x8f3,
            0xbf9, 0xaf0, 0x0, 0x0, 0x51, 0x152, 0x0, 0xf55, 0x45f, 0xd56, 0x54,
            0x357, 0x55, 0x154, 0x852, 0xb53, 0x59, 0x950, 0x700, 0x2c8, 0xc2,
            0x48a, 0xfc4, 0xec5, 0xdcf, 0xcc6, 0x2c4, 0x2cf, 0xc5, 0xcc, 0xbca,
            0xac3, 0x9c9, 0x8c0, 0x0, 0x0, 0x0, 0x0, 0xa8, 0x1a4, 0xa8, 0x7a6,
            0xa2, 0xa2, 0x2a4, 0xbac, 0xaa, 0xa3, 0x2a8, 0x3a0, 0xd00, 0xc18,
            0xd00, 0xe3a, 0x34, 0x35, 0x73f, 0x636, 0x924, 0x83f, 0xb35, 0xa3c,
            0x12a, 0x33, 0x339, 0x230, 0xe00, 0xe00, 0xc12, 0xd9a, 0x684, 0x795,
            0x49f, 0x596, 0x92, 0xb9f, 0x815, 0x99c, 0x9a, 0x393, 0x99, 0x190,
            0xf00, 0xe08, 0xd01, 0xc0a, 0x704, 0x605, 0x50f, 0x406, 0xb02, 0xa0f,
            0x905, 0x80c, 0x30a, 0x203, 0x109, 0x0 ];

    var edgeTable = new Uint32Array(my.edgeTable);

    var triTable = my.triTable = [ [], [], [], [], [], [], [], [ 11, 9, 8 ], [], [], [],
            [ 8, 10, 9 ], [], [ 10, 8, 11 ], [ 9, 11, 10 ],
            [ 8, 10, 9, 8, 11, 10 ], [], [], [], [ 1, 7, 3 ], [], [ 4, 2, 0 ], [],
            [ 2, 1, 7 ], [], [], [], [ 2, 7, 3, 2, 9, 7 ], [],
            [ 1, 4, 11, 1, 0, 4 ], [ 3, 8, 0, 11, 9, 4, 11, 10, 9 ],
            [ 4, 11, 9, 11, 10, 9 ], [], [], [], [ 5, 3, 1 ], [], [], [],
            [ 2, 5, 8, 2, 1, 5 ], [], [], [ 2, 4, 0 ], [ 3, 2, 4 ], [],
            [ 0, 9, 1, 8, 10, 5, 8, 11, 10 ], [ 3, 4, 0, 3, 10, 4 ],
            [ 5, 8, 10, 8, 11, 10 ], [], [ 3, 5, 7 ], [ 7, 1, 5 ],
            [ 1, 7, 3, 1, 5, 7 ], [], [ 9, 2, 0, 9, 7, 2 ],
            [ 0, 3, 8, 1, 7, 11, 1, 5, 7 ], [ 11, 1, 7, 1, 5, 7 ], [],
            [ 9, 1, 0, 5, 3, 2, 5, 7, 3 ], [ 8, 2, 5, 8, 0, 2 ],
            [ 2, 5, 3, 5, 7, 3 ], [ 3, 9, 1, 3, 8, 9, 7, 11, 10, 7, 10, 5 ],
            [ 9, 1, 0, 10, 7, 11, 10, 5, 7 ], [ 3, 8, 0, 7, 10, 5, 7, 11, 10 ],
            [ 11, 5, 7, 11, 10, 5 ], [], [], [], [], [], [ 0, 6, 2 ], [],
            [ 7, 2, 9, 7, 9, 8 ], [], [], [], [ 8, 10, 9 ], [ 7, 1, 3 ],
            [ 7, 1, 0 ], [ 6, 9, 3, 6, 10, 9 ], [ 7, 10, 8, 10, 9, 8 ], [],
            [ 6, 0, 4 ], [], [ 11, 1, 4, 11, 3, 1 ], [ 2, 4, 6 ],
            [ 2, 0, 4, 2, 4, 6 ], [ 2, 4, 6 ], [ 1, 4, 2, 4, 6, 2 ], [],
            [ 6, 0, 4 ], [], [ 2, 11, 3, 6, 9, 4, 6, 10, 9 ], [ 8, 6, 1, 8, 1, 3 ],
            [ 10, 0, 6, 0, 4, 6 ], [ 8, 0, 3, 9, 6, 10, 9, 4, 6 ],
            [ 10, 4, 6, 10, 9, 4 ], [], [], [], [ 5, 3, 1 ], [], [ 0, 6, 2 ], [],
            [ 7, 4, 8, 5, 2, 1, 5, 6, 2 ], [], [], [ 2, 4, 0 ],
            [ 7, 4, 8, 2, 11, 3, 10, 5, 6 ], [ 7, 1, 3 ],
            [ 5, 6, 10, 0, 9, 1, 8, 7, 4 ], [ 5, 6, 10, 7, 0, 3, 7, 4, 0 ],
            [ 10, 5, 6, 4, 8, 7 ], [ 9, 11, 8 ], [ 3, 5, 6 ],
            [ 0, 5, 11, 0, 11, 8 ], [ 6, 3, 5, 3, 1, 5 ], [ 3, 9, 6, 3, 8, 9 ],
            [ 9, 6, 0, 6, 2, 0 ], [ 0, 3, 8, 2, 5, 6, 2, 1, 5 ],
            [ 1, 6, 2, 1, 5, 6 ], [ 9, 11, 8 ], [ 1, 0, 9, 6, 10, 5, 11, 3, 2 ],
            [ 6, 10, 5, 2, 8, 0, 2, 11, 8 ], [ 3, 2, 11, 10, 5, 6 ],
            [ 10, 5, 6, 9, 3, 8, 9, 1, 3 ], [ 0, 9, 1, 5, 6, 10 ],
            [ 8, 0, 3, 10, 5, 6 ], [ 10, 5, 6 ], [], [], [], [], [], [], [],
            [ 1, 10, 2, 9, 11, 6, 9, 8, 11 ], [], [], [ 6, 0, 2 ],
            [ 3, 6, 9, 3, 2, 6 ], [ 3, 5, 1 ], [ 0, 5, 1, 0, 11, 5 ], [ 0, 3, 5 ],
            [ 6, 9, 11, 9, 8, 11 ], [], [], [], [ 4, 5, 9, 7, 1, 10, 7, 3, 1 ], [],
            [ 11, 6, 7, 2, 4, 5, 2, 0, 4 ],
            [ 11, 6, 7, 8, 0, 3, 1, 10, 2, 9, 4, 5 ],
            [ 6, 7, 11, 1, 10, 2, 9, 4, 5 ], [],
            [ 4, 1, 0, 4, 5, 1, 6, 7, 3, 6, 3, 2 ], [ 9, 4, 5, 0, 6, 7, 0, 2, 6 ],
            [ 4, 5, 9, 6, 3, 2, 6, 7, 3 ], [ 6, 7, 11, 5, 3, 8, 5, 1, 3 ],
            [ 6, 7, 11, 4, 1, 0, 4, 5, 1 ], [ 4, 5, 9, 3, 8, 0, 11, 6, 7 ],
            [ 9, 4, 5, 7, 11, 6 ], [], [], [ 0, 6, 4 ], [ 8, 6, 4, 8, 1, 6 ], [],
            [ 0, 10, 2, 0, 9, 10, 4, 8, 11, 4, 11, 6 ],
            [ 10, 2, 1, 6, 0, 3, 6, 4, 0 ], [ 10, 2, 1, 11, 4, 8, 11, 6, 4 ],
            [ 4, 2, 6 ], [ 1, 0, 9, 2, 4, 8, 2, 6, 4 ], [ 2, 4, 0, 2, 6, 4 ],
            [ 8, 2, 4, 2, 6, 4 ], [ 11, 4, 1, 11, 6, 4 ],
            [ 0, 9, 1, 4, 11, 6, 4, 8, 11 ], [ 3, 6, 0, 6, 4, 0 ],
            [ 8, 6, 4, 8, 11, 6 ], [ 10, 8, 9 ], [ 6, 3, 9, 6, 7, 3 ], [ 6, 7, 1 ],
            [ 10, 7, 1, 7, 3, 1 ], [ 7, 11, 6, 8, 10, 2, 8, 9, 10 ],
            [ 11, 6, 7, 10, 0, 9, 10, 2, 0 ], [ 2, 1, 10, 7, 11, 6, 8, 0, 3 ],
            [ 1, 10, 2, 6, 7, 11 ], [ 7, 2, 6, 7, 9, 2 ],
            [ 1, 0, 9, 3, 6, 7, 3, 2, 6 ], [ 7, 0, 6, 0, 2, 6 ],
            [ 2, 7, 3, 2, 6, 7 ], [ 7, 11, 6, 3, 9, 1, 3, 8, 9 ],
            [ 9, 1, 0, 11, 6, 7 ], [ 0, 3, 8, 11, 6, 7 ], [ 11, 6, 7 ], [], [], [],
            [], [ 5, 3, 7 ], [ 8, 5, 2, 8, 7, 5 ], [ 5, 3, 7 ],
            [ 1, 10, 2, 5, 8, 7, 5, 9, 8 ], [ 1, 7, 5 ], [ 1, 7, 5 ],
            [ 9, 2, 7, 9, 7, 5 ], [ 11, 3, 2, 8, 5, 9, 8, 7, 5 ],
            [ 1, 3, 7, 1, 7, 5 ], [ 0, 7, 1, 7, 5, 1 ], [ 9, 3, 5, 3, 7, 5 ],
            [ 9, 7, 5, 9, 8, 7 ], [ 8, 10, 11 ], [ 3, 4, 10, 3, 10, 11 ],
            [ 8, 10, 11 ], [ 5, 9, 4, 1, 11, 3, 1, 10, 11 ], [ 2, 4, 5 ],
            [ 5, 2, 4, 2, 0, 4 ], [ 0, 3, 8, 5, 9, 4, 10, 2, 1 ],
            [ 2, 1, 10, 9, 4, 5 ], [ 2, 8, 5, 2, 11, 8 ],
            [ 3, 2, 11, 1, 4, 5, 1, 0, 4 ], [ 9, 4, 5, 8, 2, 11, 8, 0, 2 ],
            [ 11, 3, 2, 9, 4, 5 ], [ 8, 5, 3, 5, 1, 3 ], [ 5, 0, 4, 5, 1, 0 ],
            [ 3, 8, 0, 4, 5, 9 ], [ 9, 4, 5 ], [ 11, 9, 10 ], [ 11, 9, 10 ],
            [ 1, 11, 4, 1, 10, 11 ], [ 8, 7, 4, 11, 1, 10, 11, 3, 1 ],
            [ 2, 7, 9, 2, 9, 10 ], [ 4, 8, 7, 0, 10, 2, 0, 9, 10 ],
            [ 2, 1, 10, 0, 7, 4, 0, 3, 7 ], [ 10, 2, 1, 8, 7, 4 ], [ 1, 7, 4 ],
            [ 3, 2, 11, 4, 8, 7, 9, 1, 0 ], [ 11, 4, 2, 4, 0, 2 ],
            [ 2, 11, 3, 7, 4, 8 ], [ 4, 1, 7, 1, 3, 7 ], [ 1, 0, 9, 8, 7, 4 ],
            [ 3, 4, 0, 3, 7, 4 ], [ 8, 7, 4 ], [ 8, 9, 10, 8, 10, 11 ],
            [ 3, 9, 11, 9, 10, 11 ], [ 0, 10, 8, 10, 11, 8 ],
            [ 10, 3, 1, 10, 11, 3 ], [ 2, 8, 10, 8, 9, 10 ], [ 9, 2, 0, 9, 10, 2 ],
            [ 8, 0, 3, 1, 10, 2 ], [ 10, 2, 1 ], [ 1, 11, 9, 11, 8, 9 ],
            [ 11, 3, 2, 0, 9, 1 ], [ 11, 0, 2, 11, 8, 0 ], [ 11, 3, 2 ],
            [ 8, 1, 3, 8, 9, 1 ], [ 9, 1, 0 ], [ 8, 0, 3 ], [] ];

    var edgeTable2 = [ 0x0, 0x109, 0x203, 0x30a, 0x80c, 0x905, 0xa0f,
            0xb06, 0x406, 0x50f, 0x605, 0x70c, 0xc0a, 0xd03, 0xe09, 0xf00, 0x190,
            0x99, 0x393, 0x29a, 0x99c, 0x895, 0xb9f, 0xa96, 0x596, 0x49f, 0x795,
            0x69c, 0xd9a, 0xc93, 0xf99, 0xe90, 0x230, 0x339, 0x33, 0x13a, 0xa3c,
            0xb35, 0x83f, 0x936, 0x636, 0x73f, 0x435, 0x53c, 0xe3a, 0xf33, 0xc39,
            0xd30, 0x3a0, 0x2a9, 0x1a3, 0xaa, 0xbac, 0xaa5, 0x9af, 0x8a6, 0x7a6,
            0x6af, 0x5a5, 0x4ac, 0xfaa, 0xea3, 0xda9, 0xca0, 0x8c0, 0x9c9, 0xac3,
            0xbca, 0xcc, 0x1c5, 0x2cf, 0x3c6, 0xcc6, 0xdcf, 0xec5, 0xfcc, 0x4ca,
            0x5c3, 0x6c9, 0x7c0, 0x950, 0x859, 0xb53, 0xa5a, 0x15c, 0x55, 0x35f,
            0x256, 0xd56, 0xc5f, 0xf55, 0xe5c, 0x55a, 0x453, 0x759, 0x650, 0xaf0,
            0xbf9, 0x8f3, 0x9fa, 0x2fc, 0x3f5, 0xff, 0x1f6, 0xef6, 0xfff, 0xcf5,
            0xdfc, 0x6fa, 0x7f3, 0x4f9, 0x5f0, 0xb60, 0xa69, 0x963, 0x86a, 0x36c,
            0x265, 0x16f, 0x66, 0xf66, 0xe6f, 0xd65, 0xc6c, 0x76a, 0x663, 0x569,
            0x460, 0x460, 0x569, 0x663, 0x76a, 0xc6c, 0xd65, 0xe6f, 0xf66, 0x66,
            0x16f, 0x265, 0x36c, 0x86a, 0x963, 0xa69, 0xb60, 0x5f0, 0x4f9, 0x7f3,
            0x6fa, 0xdfc, 0xcf5, 0xfff, 0xef6, 0x1f6, 0xff, 0x3f5, 0x2fc, 0x9fa,
            0x8f3, 0xbf9, 0xaf0, 0x650, 0x759, 0x453, 0x55a, 0xe5c, 0xf55, 0xc5f,
            0xd56, 0x256, 0x35f, 0x55, 0x15c, 0xa5a, 0xb53, 0x859, 0x950, 0x7c0,
            0x6c9, 0x5c3, 0x4ca, 0xfcc, 0xec5, 0xdcf, 0xcc6, 0x3c6, 0x2cf, 0x1c5,
            0xcc, 0xbca, 0xac3, 0x9c9, 0x8c0, 0xca0, 0xda9, 0xea3, 0xfaa, 0x4ac,
            0x5a5, 0x6af, 0x7a6, 0x8a6, 0x9af, 0xaa5, 0xbac, 0xaa, 0x1a3, 0x2a9,
            0x3a0, 0xd30, 0xc39, 0xf33, 0xe3a, 0x53c, 0x435, 0x73f, 0x636, 0x936,
            0x83f, 0xb35, 0xa3c, 0x13a, 0x33, 0x339, 0x230, 0xe90, 0xf99, 0xc93,
            0xd9a, 0x69c, 0x795, 0x49f, 0x596, 0xa96, 0xb9f, 0x895, 0x99c, 0x29a,
            0x393, 0x99, 0x190, 0xf00, 0xe09, 0xd03, 0xc0a, 0x70c, 0x605, 0x50f,
            0x406, 0xb06, 0xa0f, 0x905, 0x80c, 0x30a, 0x203, 0x109, 0x0 ];

    var triTable2 = [ [], [ 8, 3, 0 ], [ 9, 0, 1 ], [ 8, 3, 1, 8, 1, 9 ],
            [ 11, 2, 3 ], [ 11, 2, 0, 11, 0, 8 ], [ 11, 2, 3, 0, 1, 9 ],
            [ 2, 1, 11, 1, 9, 11, 11, 9, 8 ], [ 10, 1, 2 ], [ 8, 3, 0, 1, 2, 10 ],
            [ 9, 0, 2, 9, 2, 10 ], [ 3, 2, 8, 2, 10, 8, 8, 10, 9 ],
            [ 10, 1, 3, 10, 3, 11 ], [ 1, 0, 10, 0, 8, 10, 10, 8, 11 ],
            [ 0, 3, 9, 3, 11, 9, 9, 11, 10 ], [ 8, 10, 9, 8, 11, 10 ], [ 8, 4, 7 ],
            [ 3, 0, 4, 3, 4, 7 ], [ 1, 9, 0, 8, 4, 7 ],
            [ 9, 4, 1, 4, 7, 1, 1, 7, 3 ], [ 2, 3, 11, 7, 8, 4 ],
            [ 7, 11, 4, 11, 2, 4, 4, 2, 0 ], [ 3, 11, 2, 4, 7, 8, 9, 0, 1 ],
            [ 2, 7, 11, 2, 1, 7, 1, 4, 7, 1, 9, 4 ], [ 10, 1, 2, 8, 4, 7 ],
            [ 2, 10, 1, 0, 4, 7, 0, 7, 3 ], [ 4, 7, 8, 0, 2, 10, 0, 10, 9 ],
            [ 2, 7, 3, 2, 9, 7, 7, 9, 4, 2, 10, 9 ],
            [ 8, 4, 7, 11, 10, 1, 11, 1, 3 ],
            [ 11, 4, 7, 1, 4, 11, 1, 11, 10, 1, 0, 4 ],
            [ 3, 8, 0, 7, 11, 4, 11, 9, 4, 11, 10, 9 ],
            [ 7, 11, 4, 4, 11, 9, 11, 10, 9 ], [ 9, 5, 4 ], [ 3, 0, 8, 4, 9, 5 ],
            [ 5, 4, 0, 5, 0, 1 ], [ 4, 8, 5, 8, 3, 5, 5, 3, 1 ],
            [ 11, 2, 3, 9, 5, 4 ], [ 9, 5, 4, 8, 11, 2, 8, 2, 0 ],
            [ 3, 11, 2, 1, 5, 4, 1, 4, 0 ],
            [ 8, 5, 4, 2, 5, 8, 2, 8, 11, 2, 1, 5 ], [ 2, 10, 1, 9, 5, 4 ],
            [ 0, 8, 3, 5, 4, 9, 10, 1, 2 ], [ 10, 5, 2, 5, 4, 2, 2, 4, 0 ],
            [ 3, 4, 8, 3, 2, 4, 2, 5, 4, 2, 10, 5 ],
            [ 5, 4, 9, 1, 3, 11, 1, 11, 10 ],
            [ 0, 9, 1, 4, 8, 5, 8, 10, 5, 8, 11, 10 ],
            [ 3, 4, 0, 3, 10, 4, 4, 10, 5, 3, 11, 10 ],
            [ 4, 8, 5, 5, 8, 10, 8, 11, 10 ], [ 9, 5, 7, 9, 7, 8 ],
            [ 0, 9, 3, 9, 5, 3, 3, 5, 7 ], [ 8, 0, 7, 0, 1, 7, 7, 1, 5 ],
            [ 1, 7, 3, 1, 5, 7 ], [ 11, 2, 3, 8, 9, 5, 8, 5, 7 ],
            [ 9, 2, 0, 9, 7, 2, 2, 7, 11, 9, 5, 7 ],
            [ 0, 3, 8, 2, 1, 11, 1, 7, 11, 1, 5, 7 ],
            [ 2, 1, 11, 11, 1, 7, 1, 5, 7 ], [ 1, 2, 10, 5, 7, 8, 5, 8, 9 ],
            [ 9, 1, 0, 10, 5, 2, 5, 3, 2, 5, 7, 3 ],
            [ 5, 2, 10, 8, 2, 5, 8, 5, 7, 8, 0, 2 ],
            [ 10, 5, 2, 2, 5, 3, 5, 7, 3 ],
            [ 3, 9, 1, 3, 8, 9, 7, 11, 10, 7, 10, 5 ],
            [ 9, 1, 0, 10, 7, 11, 10, 5, 7 ], [ 3, 8, 0, 7, 10, 5, 7, 11, 10 ],
            [ 11, 5, 7, 11, 10, 5 ], [ 11, 7, 6 ], [ 0, 8, 3, 11, 7, 6 ],
            [ 9, 0, 1, 11, 7, 6 ], [ 7, 6, 11, 3, 1, 9, 3, 9, 8 ],
            [ 2, 3, 7, 2, 7, 6 ], [ 8, 7, 0, 7, 6, 0, 0, 6, 2 ],
            [ 1, 9, 0, 3, 7, 6, 3, 6, 2 ], [ 7, 6, 2, 7, 2, 9, 2, 1, 9, 7, 9, 8 ],
            [ 1, 2, 10, 6, 11, 7 ], [ 2, 10, 1, 7, 6, 11, 8, 3, 0 ],
            [ 11, 7, 6, 10, 9, 0, 10, 0, 2 ],
            [ 7, 6, 11, 3, 2, 8, 8, 2, 10, 8, 10, 9 ],
            [ 6, 10, 7, 10, 1, 7, 7, 1, 3 ],
            [ 6, 10, 1, 6, 1, 7, 7, 1, 0, 7, 0, 8 ],
            [ 9, 0, 3, 6, 9, 3, 6, 10, 9, 6, 3, 7 ],
            [ 6, 10, 7, 7, 10, 8, 10, 9, 8 ], [ 8, 4, 6, 8, 6, 11 ],
            [ 11, 3, 6, 3, 0, 6, 6, 0, 4 ], [ 0, 1, 9, 4, 6, 11, 4, 11, 8 ],
            [ 1, 9, 4, 11, 1, 4, 11, 3, 1, 11, 4, 6 ],
            [ 3, 8, 2, 8, 4, 2, 2, 4, 6 ], [ 2, 0, 4, 2, 4, 6 ],
            [ 1, 9, 0, 3, 8, 2, 2, 8, 4, 2, 4, 6 ], [ 9, 4, 1, 1, 4, 2, 4, 6, 2 ],
            [ 10, 1, 2, 11, 8, 4, 11, 4, 6 ],
            [ 10, 1, 2, 11, 3, 6, 6, 3, 0, 6, 0, 4 ],
            [ 0, 2, 10, 0, 10, 9, 4, 11, 8, 4, 6, 11 ],
            [ 2, 11, 3, 6, 9, 4, 6, 10, 9 ],
            [ 8, 4, 6, 8, 6, 1, 6, 10, 1, 8, 1, 3 ],
            [ 1, 0, 10, 10, 0, 6, 0, 4, 6 ], [ 8, 0, 3, 9, 6, 10, 9, 4, 6 ],
            [ 10, 4, 6, 10, 9, 4 ], [ 9, 5, 4, 7, 6, 11 ],
            [ 4, 9, 5, 3, 0, 8, 11, 7, 6 ], [ 6, 11, 7, 4, 0, 1, 4, 1, 5 ],
            [ 6, 11, 7, 4, 8, 5, 5, 8, 3, 5, 3, 1 ], [ 4, 9, 5, 6, 2, 3, 6, 3, 7 ],
            [ 9, 5, 4, 8, 7, 0, 0, 7, 6, 0, 6, 2 ],
            [ 4, 0, 1, 4, 1, 5, 6, 3, 7, 6, 2, 3 ], [ 7, 4, 8, 5, 2, 1, 5, 6, 2 ],
            [ 6, 11, 7, 1, 2, 10, 9, 5, 4 ],
            [ 11, 7, 6, 8, 3, 0, 1, 2, 10, 9, 5, 4 ],
            [ 11, 7, 6, 10, 5, 2, 2, 5, 4, 2, 4, 0 ],
            [ 7, 4, 8, 2, 11, 3, 10, 5, 6 ],
            [ 4, 9, 5, 6, 10, 7, 7, 10, 1, 7, 1, 3 ],
            [ 5, 6, 10, 0, 9, 1, 8, 7, 4 ], [ 5, 6, 10, 7, 0, 3, 7, 4, 0 ],
            [ 10, 5, 6, 4, 8, 7 ], [ 5, 6, 9, 6, 11, 9, 9, 11, 8 ],
            [ 0, 9, 5, 0, 5, 3, 3, 5, 6, 3, 6, 11 ],
            [ 0, 1, 5, 0, 5, 11, 5, 6, 11, 0, 11, 8 ],
            [ 11, 3, 6, 6, 3, 5, 3, 1, 5 ], [ 9, 5, 6, 3, 9, 6, 3, 8, 9, 3, 6, 2 ],
            [ 5, 6, 9, 9, 6, 0, 6, 2, 0 ], [ 0, 3, 8, 2, 5, 6, 2, 1, 5 ],
            [ 1, 6, 2, 1, 5, 6 ], [ 1, 2, 10, 5, 6, 9, 9, 6, 11, 9, 11, 8 ],
            [ 1, 0, 9, 6, 10, 5, 11, 3, 2 ], [ 6, 10, 5, 2, 8, 0, 2, 11, 8 ],
            [ 3, 2, 11, 10, 5, 6 ], [ 10, 5, 6, 9, 3, 8, 9, 1, 3 ],
            [ 0, 9, 1, 5, 6, 10 ], [ 8, 0, 3, 10, 5, 6 ], [ 10, 5, 6 ],
            [ 10, 6, 5 ], [ 8, 3, 0, 10, 6, 5 ], [ 0, 1, 9, 5, 10, 6 ],
            [ 10, 6, 5, 9, 8, 3, 9, 3, 1 ], [ 3, 11, 2, 10, 6, 5 ],
            [ 6, 5, 10, 2, 0, 8, 2, 8, 11 ], [ 1, 9, 0, 6, 5, 10, 11, 2, 3 ],
            [ 1, 10, 2, 5, 9, 6, 9, 11, 6, 9, 8, 11 ], [ 1, 2, 6, 1, 6, 5 ],
            [ 0, 8, 3, 2, 6, 5, 2, 5, 1 ], [ 5, 9, 6, 9, 0, 6, 6, 0, 2 ],
            [ 9, 6, 5, 3, 6, 9, 3, 9, 8, 3, 2, 6 ], [ 11, 6, 3, 6, 5, 3, 3, 5, 1 ],
            [ 0, 5, 1, 0, 11, 5, 5, 11, 6, 0, 8, 11 ],
            [ 0, 5, 9, 0, 3, 5, 3, 6, 5, 3, 11, 6 ],
            [ 5, 9, 6, 6, 9, 11, 9, 8, 11 ], [ 10, 6, 5, 4, 7, 8 ],
            [ 5, 10, 6, 7, 3, 0, 7, 0, 4 ], [ 5, 10, 6, 0, 1, 9, 8, 4, 7 ],
            [ 4, 5, 9, 6, 7, 10, 7, 1, 10, 7, 3, 1 ],
            [ 7, 8, 4, 2, 3, 11, 10, 6, 5 ],
            [ 11, 6, 7, 10, 2, 5, 2, 4, 5, 2, 0, 4 ],
            [ 11, 6, 7, 8, 0, 3, 1, 10, 2, 9, 4, 5 ],
            [ 6, 7, 11, 1, 10, 2, 9, 4, 5 ], [ 7, 8, 4, 5, 1, 2, 5, 2, 6 ],
            [ 4, 1, 0, 4, 5, 1, 6, 7, 3, 6, 3, 2 ],
            [ 9, 4, 5, 8, 0, 7, 0, 6, 7, 0, 2, 6 ], [ 4, 5, 9, 6, 3, 2, 6, 7, 3 ],
            [ 6, 7, 11, 4, 5, 8, 5, 3, 8, 5, 1, 3 ],
            [ 6, 7, 11, 4, 1, 0, 4, 5, 1 ], [ 4, 5, 9, 3, 8, 0, 11, 6, 7 ],
            [ 9, 4, 5, 7, 11, 6 ], [ 10, 6, 4, 10, 4, 9 ],
            [ 8, 3, 0, 9, 10, 6, 9, 6, 4 ], [ 1, 10, 0, 10, 6, 0, 0, 6, 4 ],
            [ 8, 6, 4, 8, 1, 6, 6, 1, 10, 8, 3, 1 ],
            [ 2, 3, 11, 6, 4, 9, 6, 9, 10 ],
            [ 0, 10, 2, 0, 9, 10, 4, 8, 11, 4, 11, 6 ],
            [ 10, 2, 1, 11, 6, 3, 6, 0, 3, 6, 4, 0 ],
            [ 10, 2, 1, 11, 4, 8, 11, 6, 4 ], [ 9, 1, 4, 1, 2, 4, 4, 2, 6 ],
            [ 1, 0, 9, 3, 2, 8, 2, 4, 8, 2, 6, 4 ], [ 2, 4, 0, 2, 6, 4 ],
            [ 3, 2, 8, 8, 2, 4, 2, 6, 4 ],
            [ 1, 4, 9, 11, 4, 1, 11, 1, 3, 11, 6, 4 ],
            [ 0, 9, 1, 4, 11, 6, 4, 8, 11 ], [ 11, 6, 3, 3, 6, 0, 6, 4, 0 ],
            [ 8, 6, 4, 8, 11, 6 ], [ 6, 7, 10, 7, 8, 10, 10, 8, 9 ],
            [ 9, 3, 0, 6, 3, 9, 6, 9, 10, 6, 7, 3 ],
            [ 6, 1, 10, 6, 7, 1, 7, 0, 1, 7, 8, 0 ],
            [ 6, 7, 10, 10, 7, 1, 7, 3, 1 ],
            [ 7, 11, 6, 3, 8, 2, 8, 10, 2, 8, 9, 10 ],
            [ 11, 6, 7, 10, 0, 9, 10, 2, 0 ], [ 2, 1, 10, 7, 11, 6, 8, 0, 3 ],
            [ 1, 10, 2, 6, 7, 11 ], [ 7, 2, 6, 7, 9, 2, 2, 9, 1, 7, 8, 9 ],
            [ 1, 0, 9, 3, 6, 7, 3, 2, 6 ], [ 8, 0, 7, 7, 0, 6, 0, 2, 6 ],
            [ 2, 7, 3, 2, 6, 7 ], [ 7, 11, 6, 3, 9, 1, 3, 8, 9 ],
            [ 9, 1, 0, 11, 6, 7 ], [ 0, 3, 8, 11, 6, 7 ], [ 11, 6, 7 ],
            [ 11, 7, 5, 11, 5, 10 ], [ 3, 0, 8, 7, 5, 10, 7, 10, 11 ],
            [ 9, 0, 1, 10, 11, 7, 10, 7, 5 ],
            [ 3, 1, 9, 3, 9, 8, 7, 10, 11, 7, 5, 10 ],
            [ 10, 2, 5, 2, 3, 5, 5, 3, 7 ],
            [ 5, 10, 2, 8, 5, 2, 8, 7, 5, 8, 2, 0 ],
            [ 9, 0, 1, 10, 2, 5, 5, 2, 3, 5, 3, 7 ],
            [ 1, 10, 2, 5, 8, 7, 5, 9, 8 ], [ 2, 11, 1, 11, 7, 1, 1, 7, 5 ],
            [ 0, 8, 3, 2, 11, 1, 1, 11, 7, 1, 7, 5 ],
            [ 9, 0, 2, 9, 2, 7, 2, 11, 7, 9, 7, 5 ],
            [ 11, 3, 2, 8, 5, 9, 8, 7, 5 ], [ 1, 3, 7, 1, 7, 5 ],
            [ 8, 7, 0, 0, 7, 1, 7, 5, 1 ], [ 0, 3, 9, 9, 3, 5, 3, 7, 5 ],
            [ 9, 7, 5, 9, 8, 7 ], [ 4, 5, 8, 5, 10, 8, 8, 10, 11 ],
            [ 3, 0, 4, 3, 4, 10, 4, 5, 10, 3, 10, 11 ],
            [ 0, 1, 9, 4, 5, 8, 8, 5, 10, 8, 10, 11 ],
            [ 5, 9, 4, 1, 11, 3, 1, 10, 11 ],
            [ 3, 8, 4, 3, 4, 2, 2, 4, 5, 2, 5, 10 ],
            [ 10, 2, 5, 5, 2, 4, 2, 0, 4 ], [ 0, 3, 8, 5, 9, 4, 10, 2, 1 ],
            [ 2, 1, 10, 9, 4, 5 ], [ 8, 4, 5, 2, 8, 5, 2, 11, 8, 2, 5, 1 ],
            [ 3, 2, 11, 1, 4, 5, 1, 0, 4 ], [ 9, 4, 5, 8, 2, 11, 8, 0, 2 ],
            [ 11, 3, 2, 9, 4, 5 ], [ 4, 5, 8, 8, 5, 3, 5, 1, 3 ],
            [ 5, 0, 4, 5, 1, 0 ], [ 3, 8, 0, 4, 5, 9 ], [ 9, 4, 5 ],
            [ 7, 4, 11, 4, 9, 11, 11, 9, 10 ],
            [ 3, 0, 8, 7, 4, 11, 11, 4, 9, 11, 9, 10 ],
            [ 11, 7, 4, 1, 11, 4, 1, 10, 11, 1, 4, 0 ],
            [ 8, 7, 4, 11, 1, 10, 11, 3, 1 ],
            [ 2, 3, 7, 2, 7, 9, 7, 4, 9, 2, 9, 10 ],
            [ 4, 8, 7, 0, 10, 2, 0, 9, 10 ], [ 2, 1, 10, 0, 7, 4, 0, 3, 7 ],
            [ 10, 2, 1, 8, 7, 4 ], [ 2, 11, 7, 2, 7, 1, 1, 7, 4, 1, 4, 9 ],
            [ 3, 2, 11, 4, 8, 7, 9, 1, 0 ], [ 7, 4, 11, 11, 4, 2, 4, 0, 2 ],
            [ 2, 11, 3, 7, 4, 8 ], [ 9, 1, 4, 4, 1, 7, 1, 3, 7 ],
            [ 1, 0, 9, 8, 7, 4 ], [ 3, 4, 0, 3, 7, 4 ], [ 8, 7, 4 ],
            [ 8, 9, 10, 8, 10, 11 ], [ 0, 9, 3, 3, 9, 11, 9, 10, 11 ],
            [ 1, 10, 0, 0, 10, 8, 10, 11, 8 ], [ 10, 3, 1, 10, 11, 3 ],
            [ 3, 8, 2, 2, 8, 10, 8, 9, 10 ], [ 9, 2, 0, 9, 10, 2 ],
            [ 8, 0, 3, 1, 10, 2 ], [ 10, 2, 1 ], [ 2, 11, 1, 1, 11, 9, 11, 8, 9 ],
            [ 11, 3, 2, 0, 9, 1 ], [ 11, 0, 2, 11, 8, 0 ], [ 11, 3, 2 ],
            [ 8, 1, 3, 8, 9, 1 ], [ 9, 1, 0 ], [ 8, 0, 3 ], [] ];

            return my;
};

//each webworker needs its own marching cube object
$3Dmol.MarchingCube  = $3Dmol.MarchingCubeInitializer();




/*! ProteinSurface4.js
 * @author David Koes  / https://github.com/3dmol/3Dmol.js/tree/master/3Dmol
 * Modified by Jiyao Wang / https://github.com/ncbi/icn3d
 */

/*  ProteinSurface.js by biochem_fan

Ported and modified for Javascript based on EDTSurf,
  whose license is as follows.

Permission to use, copy, modify, and distribute this program for any
purpose, with or without fee, is hereby granted, provided that this
copyright notice and the reference information appear in all copies or
substantial portions of the Software. It is provided "as is" without
express or implied warranty.

Reference:
http://zhanglab.ccmb.med.umich.edu/EDTSurf/
D. Xu, Y. Zhang (2009) Generating Triangulated Macromolecular Surfaces
by Euclidean Distance Transform. PLoS ONE 4(12): e8140.

=======

TODO: Improved performance on Firefox
      Reduce memory consumption
      Refactor!
 */


// dkoes
// Surface calculations.  This must be safe to use within a web worker.
if (typeof console === 'undefined') {
    // this should only be true inside of a webworker
    console = {
        log : function() {
        }
    };
}

$3Dmol.ProteinSurface = function(threshbox) {

    // constants for vpbits bitmasks
    /** @const */
    var INOUT = 1;
    /** @const */
    var ISDONE = 2;
    /** @const */
    var ISBOUND = 4;

    var ptranx = 0, ptrany = 0, ptranz = 0;
    var probeRadius = 1.4;
    var defaultScaleFactor = 2;
    var scaleFactor = defaultScaleFactor; // 2 is .5A grid; if this is made user configurable,
                            // also have to adjust offset used to find non-shown
                            // atoms
    var pHeight = 0, pWidth = 0, pLength = 0;
    var cutRadius = 0;
    var vpBits = null; // uint8 array of bitmasks
    var vpDistance = null; // floatarray of _squared_ distances
    var vpAtomID = null; // intarray
    var vertnumber = 0, facenumber = 0;
    var pminx = 0, pminy = 0, pminz = 0, pmaxx = 0, pmaxy = 0, pmaxz = 0;

    var vdwRadii = {
            "H" : 1.2,
            "Li" : 1.82,
            "Na" : 2.27,
            "K" : 2.75,
            "C" : 1.7,
            "N" : 1.55,
            "O" : 1.52,
            "F" : 1.47,
            "P" : 1.80,
            "S" : 1.80,
            "CL" : 1.75,
            "BR" : 1.85,
            "SE" : 1.90,
            "ZN" : 1.39,
            "CU" : 1.4,
            "NI" : 1.63,
            "X" : 2
        };

    /** @param {AtomSpec} atom */
    var getVDWIndex = function(atom) {
        if(!atom.elem || typeof(vdwRadii[atom.elem]) == "undefined") {
            return "X";
        }
        return atom.elem;
    };

    var depty = {}, widxz = {};
    var faces, verts;
    var nb = [ new Int32Array([ 1, 0, 0 ]), new Int32Array([ -1, 0, 0 ]),
               new Int32Array([ 0, 1, 0 ]), new Int32Array([ 0, -1, 0 ]),
               new Int32Array([ 0, 0, 1 ]),
               new Int32Array([ 0, 0, -1 ]),
               new Int32Array([ 1, 1, 0 ]),
               new Int32Array([ 1, -1, 0 ]),
               new Int32Array([ -1, 1, 0 ]),
               new Int32Array([ -1, -1, 0 ]),
               new Int32Array([ 1, 0, 1 ]),
               new Int32Array([ 1, 0, -1 ]),
               new Int32Array([ -1, 0, 1 ]),
               new Int32Array([ -1, 0, -1 ]),
               new Int32Array([ 0, 1, 1 ]),
               new Int32Array([ 0, 1, -1 ]),
               new Int32Array([ 0, -1, 1 ]),
               new Int32Array([ 0, -1, -1 ]),
               new Int32Array([ 1, 1, 1 ]),
               new Int32Array([ 1, 1, -1 ]),
               new Int32Array([ 1, -1, 1 ]),
               new Int32Array([ -1, 1, 1 ]),
               new Int32Array([ 1, -1, -1 ]),
               new Int32Array([ -1, -1, 1 ]),
               new Int32Array([ -1, 1, -1 ]),
               new Int32Array([ -1, -1, -1 ]) ];

    var origextent;

    var inOrigExtent = function(x, y, z) {
        if (x < origextent[0][0] || x > origextent[1][0])
            return false;
        if (y < origextent[0][1] || y > origextent[1][1])
            return false;
        if (z < origextent[0][2] || z > origextent[1][2])
            return false;
        return true;
    };

    this.getFacesAndVertices = function(atomlist) {
        var atomsToShow = {};
        var i, il;
        for (i = 0, il = atomlist.length; i < il; i++)
            atomsToShow[atomlist[i]] = 1;
        var vertices = verts;
        for (i = 0, il = vertices.length; i < il; i++) {
            vertices[i].x = vertices[i].x / scaleFactor - ptranx;
            vertices[i].y = vertices[i].y / scaleFactor - ptrany;
            vertices[i].z = vertices[i].z / scaleFactor - ptranz;
        }

        var finalfaces = [];
        for (i = 0, il = faces.length; i < il; i += 3) {
            //var f = faces[i];
            var fa = faces[i], fb = faces[i+1], fc = faces[i+2];
            var a = vertices[fa]['atomid'], b = vertices[fb]['atomid'], c = vertices[fc]['atomid'];

            // must be a unique face for each atom
            var which = a;
            if (b < which)
                which = b;
            if (c < which)
                which = c;
            if (!atomsToShow[which]) {
                continue;
            }
            //var av = vertices[faces[i]];
            //var bv = vertices[faces[i+1]];
            //var cv = vertices[faces[i+2]];

            if (fa !== fb && fb !== fc && fa !== fc){
                //finalfaces.push(fa);
                //finalfaces.push(fb);
                //finalfaces.push(fc);

                // !!! different between 3Dmol and iCn3D
                finalfaces.push({"a":fa, "b":fb, "c":fc});
            }

        }

        //try to help the garbage collector
        vpBits = null; // uint8 array of bitmasks
        vpDistance = null; // floatarray
        vpAtomID = null; // intarray

        return {
            'vertices' : vertices,
            'faces' : finalfaces
        };
    };


    this.initparm = function(extent, btype, volume) {
        // !!! different between 3Dmol and iCn3D
        //if(volume > 1000000) //heuristical decrease resolution to avoid large memory consumption
        //    scaleFactor = defaultScaleFactor/2;

        var margin = (1 / scaleFactor) * 5.5; // need margin to avoid
                                                // boundary/round off effects
        origextent = extent;
        pminx = extent[0][0]; pmaxx = extent[1][0];
        pminy = extent[0][1]; pmaxy = extent[1][1];
        pminz = extent[0][2]; pmaxz = extent[1][2];

        if (!btype) {
            pminx -= margin;
            pminy -= margin;
            pminz -= margin;
            pmaxx += margin;
            pmaxy += margin;
            pmaxz += margin;
        } else {
            pminx -= probeRadius + margin;
            pminy -= probeRadius + margin;
            pminz -= probeRadius + margin;
            pmaxx += probeRadius + margin;
            pmaxy += probeRadius + margin;
            pmaxz += probeRadius + margin;
        }

        pminx = Math.floor(pminx * scaleFactor) / scaleFactor;
        pminy = Math.floor(pminy * scaleFactor) / scaleFactor;
        pminz = Math.floor(pminz * scaleFactor) / scaleFactor;
        pmaxx = Math.ceil(pmaxx * scaleFactor) / scaleFactor;
        pmaxy = Math.ceil(pmaxy * scaleFactor) / scaleFactor;
        pmaxz = Math.ceil(pmaxz * scaleFactor) / scaleFactor;

        ptranx = -pminx;
        ptrany = -pminy;
        ptranz = -pminz;

        // !!! different between 3Dmol and iCn3D
        // copied from surface.js from iview
        var boxLength = 128;
        scaleFactor = pmaxx - pminx;
        if ((pmaxy - pminy) > scaleFactor) scaleFactor = pmaxy - pminy;
        if ((pmaxz - pminz) > scaleFactor) scaleFactor = pmaxz - pminz;
        scaleFactor = (boxLength - 1.0) / scaleFactor;

        boxLength = Math.floor(boxLength * defaultScaleFactor / scaleFactor);
        scaleFactor = defaultScaleFactor;
        //var threshbox = 180; // maximum possible boxsize
        if (boxLength > threshbox) {
            var sfthresh = threshbox / boxLength;
            boxLength = Math.floor(threshbox);
            scaleFactor = scaleFactor * sfthresh;
        }
        // end of surface.js part

        pLength = Math.ceil(scaleFactor * (pmaxx - pminx)) + 1;
        pWidth = Math.ceil(scaleFactor * (pmaxy - pminy)) + 1;
        pHeight = Math.ceil(scaleFactor * (pmaxz - pminz)) + 1;

        this.boundingatom(btype);
        cutRadius = probeRadius * scaleFactor;

        vpBits = new Uint8Array(pLength * pWidth * pHeight);
        vpDistance = new Float64Array(pLength * pWidth * pHeight); // float 32
        // doesn't
        // play
        // nicely
        // with
        // native
        // floats
        vpAtomID = new Int32Array(pLength * pWidth * pHeight);
        //console.log("Box size: ", pLength, pWidth, pHeight, vpBits.length);
    };

    this.boundingatom = function(btype) {
        var tradius = [];
        var txz, tdept, sradius, idx;
        flagradius = btype;

        for ( var i in vdwRadii) {
            if(!vdwRadii.hasOwnProperty(i))
                continue;
            var r = vdwRadii[i];
            if (!btype)
                tradius[i] = r * scaleFactor + 0.5;
            else
                tradius[i] = (r + probeRadius) * scaleFactor + 0.5;

            sradius = tradius[i] * tradius[i];
            widxz[i] = Math.floor(tradius[i]) + 1;
            depty[i] = new Int32Array(widxz[i] * widxz[i]);
            indx = 0;
            for (j = 0; j < widxz[i]; j++) {
                for (k = 0; k < widxz[i]; k++) {
                    txz = j * j + k * k;
                    if (txz > sradius)
                        depty[i][indx] = -1; // outside
                    else {
                        tdept = Math.sqrt(sradius - txz);
                        depty[i][indx] = Math.floor(tdept);
                    }
                    indx++;
                }
            }
        }
    };

    this.fillvoxels = function(atoms, atomlist) { // (int seqinit,int
        // seqterm,bool
        // atomtype,atom*
        // proseq,bool bcolor)
        var i, il;
        for (i = 0, il = vpBits.length; i < il; i++) {
            vpBits[i] = 0;
            vpDistance[i] = -1.0;
            vpAtomID[i] = -1;
        }

        for (i in atomlist) {
            var atom = atoms[atomlist[i]];
            if (atom === undefined)
                continue;
            this.fillAtom(atom, atoms);
        }

        for (i = 0, il = vpBits.length; i < il; i++)
            if (vpBits[i] & INOUT)
                vpBits[i] |= ISDONE;

    };


    this.fillAtom = function(atom, atoms) {
        var cx, cy, cz, ox, oy, oz, mi, mj, mk, i, j, k, si, sj, sk;
        var ii, jj, kk, n;
        //cx = Math.floor(0.5 + scaleFactor * (atom.x + ptranx));
        //cy = Math.floor(0.5 + scaleFactor * (atom.y + ptrany));
        //cz = Math.floor(0.5 + scaleFactor * (atom.z + ptranz));

        // !!! different between 3Dmol and iCn3D
        cx = Math.floor(0.5 + scaleFactor * (atom.coord.x + ptranx));
        cy = Math.floor(0.5 + scaleFactor * (atom.coord.y + ptrany));
        cz = Math.floor(0.5 + scaleFactor * (atom.coord.z + ptranz));

        var at = getVDWIndex(atom);
        var nind = 0;
        var cnt = 0;
        var pWH = pWidth*pHeight;

        for (i = 0, n = widxz[at]; i < n; i++) {
            for (j = 0; j < n; j++) {
                if (depty[at][nind] != -1) {
                    for (ii = -1; ii < 2; ii++) {
                        for (jj = -1; jj < 2; jj++) {
                            for (kk = -1; kk < 2; kk++) {
                                if (ii !== 0 && jj !== 0 && kk !== 0) {
                                    mi = ii * i;
                                    mk = kk * j;
                                    for (k = 0; k <= depty[at][nind]; k++) {
                                        mj = k * jj;
                                        si = cx + mi;
                                        sj = cy + mj;
                                        sk = cz + mk;
                                        if (si < 0 || sj < 0 ||
                                                sk < 0 ||
                                                si >= pLength ||
                                                sj >= pWidth ||
                                                sk >= pHeight)
                                            continue;
                                        var index = si * pWH + sj * pHeight + sk;

                                        if (!(vpBits[index] & INOUT)) {
                                            vpBits[index] |= INOUT;
                                            vpAtomID[index] = atom.serial;
                                        } else {
                                            var atom2 = atoms[vpAtomID[index]];
                                            if(atom2.serial != atom.serial) {
                                                ox = cx + mi - Math.floor(0.5 + scaleFactor *
                                                        (atom2.x + ptranx));
                                                oy = cy + mj - Math.floor(0.5 + scaleFactor *
                                                        (atom2.y + ptrany));
                                                oz = cz + mk - Math.floor(0.5 + scaleFactor *
                                                        (atom2.z + ptranz));
                                                if (mi * mi + mj * mj + mk * mk < ox *
                                                        ox + oy * oy + oz * oz)
                                                    vpAtomID[index] = atom.serial;
                                            }
                                        }

                                    }// k
                                }// if
                            }// kk
                        }// jj
                    }// ii
                }// if
                nind++;
            }// j
        }// i
    };

    this.fillvoxelswaals = function(atoms, atomlist) {
        var i, il;
        for (i = 0, il = vpBits.length; i < il; i++)
            vpBits[i] &= ~ISDONE; // not isdone

        for (i in atomlist) {
            var atom = atoms[atomlist[i]];
            if (atom === undefined)
                continue;

            this.fillAtomWaals(atom, atoms);
        }
    };

    this.fillAtomWaals = function(atom, atoms) {
        var cx, cy, cz, ox, oy, oz, nind = 0;
        var mi, mj, mk, si, sj, sk, i, j, k, ii, jj, kk, n;
        //cx = Math.floor(0.5 + scaleFactor * (atom.x + ptranx));
        //cy = Math.floor(0.5 + scaleFactor * (atom.y + ptrany));
        //cz = Math.floor(0.5 + scaleFactor * (atom.z + ptranz));

        // !!! different between 3Dmol and iCn3D
        cx = Math.floor(0.5 + scaleFactor * (atom.coord.x + ptranx));
        cy = Math.floor(0.5 + scaleFactor * (atom.coord.y + ptrany));
        cz = Math.floor(0.5 + scaleFactor * (atom.coord.z + ptranz));

        var at = getVDWIndex(atom);
        var pWH = pWidth*pHeight;
        for (i = 0, n = widxz[at]; i < n; i++) {
            for (j = 0; j < n; j++) {
                if (depty[at][nind] != -1) {
                    for (ii = -1; ii < 2; ii++) {
                        for (jj = -1; jj < 2; jj++) {
                            for (kk = -1; kk < 2; kk++) {
                                if (ii !== 0 && jj !== 0 && kk !== 0) {
                                    mi = ii * i;
                                    mk = kk * j;
                                    for (k = 0; k <= depty[at][nind]; k++) {
                                        mj = k * jj;
                                        si = cx + mi;
                                        sj = cy + mj;
                                        sk = cz + mk;
                                        if (si < 0 || sj < 0 ||
                                                sk < 0 ||
                                                si >= pLength ||
                                                sj >= pWidth ||
                                                sk >= pHeight)
                                            continue;
                                        var index = si * pWH + sj * pHeight + sk;
                                        if (!(vpBits[index] & ISDONE)) {
                                            vpBits[index] |= ISDONE;
                                            vpAtomID[index] = atom.serial;
                                        }  else {
                                            var atom2 = atoms[vpAtomID[index]];
                                            if(atom2.serial != atom.serial) {
                                                ox = cx + mi - Math.floor(0.5 + scaleFactor *
                                                        (atom2.x + ptranx));
                                                oy = cy + mj - Math.floor(0.5 + scaleFactor *
                                                        (atom2.y + ptrany));
                                                oz = cz + mk - Math.floor(0.5 + scaleFactor *
                                                        (atom2.z + ptranz));
                                                if (mi * mi + mj * mj + mk * mk < ox *
                                                        ox + oy * oy + oz * oz)
                                                    vpAtomID[index] = atom.serial;
                                            }
                                        }
                                    }// k
                                }// if
                            }// kk
                        }// jj
                    }// ii
                }// if
                nind++;
            }// j
        }// i
    };

    this.buildboundary = function() {
        var pWH = pWidth*pHeight;
        for (i = 0; i < pLength; i++) {
            for (j = 0; j < pHeight; j++) {
                for (k = 0; k < pWidth; k++) {
                    var index = i * pWH + k * pHeight + j;
                    if (vpBits[index] & INOUT) {
                        var flagbound = false;
                        var ii = 0;
                        while (ii < 26) {
                            var ti = i + nb[ii][0], tj = j + nb[ii][2], tk = k +
                                    nb[ii][1];
                            if (ti > -1 &&
                                ti < pLength &&
                                tk > -1 &&
                                tk < pWidth &&
                                tj > -1 &&
                                tj < pHeight &&
                                !(vpBits[ti * pWH + tk * pHeight + tj] & INOUT)) {
                                vpBits[index] |= ISBOUND;
                                break;
                            } else
                                ii++;
                        }
                    }
                }
            }
        }
    };

    // a little class for 3d array, should really generalize this and
    // use throughout...
    var PointGrid = function(length, width, height) {
        // the standard says this is zero initialized
        var data = new Int32Array(length * width * height * 3);

        // set position x,y,z to pt, which has ix,iy,and iz
        this.set = function(x, y, z, pt) {
            var index = ((((x * width) + y) * height) + z) * 3;
            data[index] = pt.ix;
            data[index + 1] = pt.iy;
            data[index + 2] = pt.iz;
        };

        // return point at x,y,z
        this.get = function(x, y, z) {
            var index = ((((x * width) + y) * height) + z) * 3;
            return {
                ix : data[index],
                iy : data[index + 1],
                iz : data[index + 2]
            };
        };
    };

    this.fastdistancemap = function() {
        var eliminate = 0;
        var certificate;
        var i, j, k, n;

        var boundPoint = new PointGrid(pLength, pWidth, pHeight);
        var pWH = pWidth*pHeight;
        var cutRSq = cutRadius*cutRadius;

        var inarray = [];
        var outarray = [];

        var index;

        for (i = 0; i < pLength; i++) {
            for (j = 0; j < pWidth; j++) {
                for (k = 0; k < pHeight; k++) {
                    index = i * pWH + j * pHeight + k;
                    vpBits[index] &= ~ISDONE; // isdone = false
                    if (vpBits[index] & INOUT) {
                        if (vpBits[index] & ISBOUND) {
                            var triple = {
                                ix : i,
                                iy : j,
                                iz : k
                            };
                            boundPoint.set(i, j, k, triple);
                            inarray.push(triple);
                            vpDistance[index] = 0;
                            vpBits[index] |= ISDONE;
                            vpBits[index] &= ~ISBOUND;
                        }
                    }
                }
            }
        }

        do {
            outarray = this.fastoneshell(inarray, boundPoint);
            inarray = [];
            for (i = 0, n = outarray.length; i < n; i++) {
                index = pWH * outarray[i].ix + pHeight *
                    outarray[i].iy + outarray[i].iz;
                vpBits[index] &= ~ISBOUND;
                if (vpDistance[index] <= 1.0404 * cutRSq) {
                    inarray.push({
                        ix : outarray[i].ix,
                        iy : outarray[i].iy,
                        iz : outarray[i].iz
                    });
                }
            }
        } while (inarray.length !== 0);

        inarray = [];
        outarray = [];
        boundPoint = null;

        var cutsf = scaleFactor - 0.5;
        if (cutsf < 0)
            cutsf = 0;
        var cutoff = cutRSq - 0.50 / (0.1 + cutsf);
        for (i = 0; i < pLength; i++) {
            for (j = 0; j < pWidth; j++) {
                for (k = 0; k < pHeight; k++) {
                    index = i * pWH + j * pHeight + k;
                    vpBits[index] &= ~ISBOUND;
                    // ses solid
                    if (vpBits[index] & INOUT) {
                        if (!(vpBits[index] & ISDONE) ||
                                ((vpBits[index] & ISDONE) && vpDistance[index] >= cutoff)) {
                            vpBits[index] |= ISBOUND;
                        }
                    }
                }
            }
        }

    };

    this.fastoneshell = function(inarray, boundPoint) { // (int* innum,int
        // *allocout,voxel2
        // ***boundPoint, int*
        // outnum, int *elimi)
        var tx, ty, tz;
        var dx, dy, dz;
        var i, j, n;
        var square;
        var bp, index;
        var outarray = [];
        if (inarray.length === 0)
            return outarray;

        tnv = {
            ix : -1,
            iy : -1,
            iz : -1
        };
        var pWH = pWidth*pHeight;
        for ( i = 0, n = inarray.length; i < n; i++) {
            tx = inarray[i].ix;
            ty = inarray[i].iy;
            tz = inarray[i].iz;
            bp = boundPoint.get(tx, ty, tz);

            for (j = 0; j < 6; j++) {
                tnv.ix = tx + nb[j][0];
                tnv.iy = ty + nb[j][1];
                tnv.iz = tz + nb[j][2];

                if (tnv.ix < pLength && tnv.ix > -1 && tnv.iy < pWidth &&
                        tnv.iy > -1 && tnv.iz < pHeight && tnv.iz > -1) {
                    index = tnv.ix * pWH + pHeight * tnv.iy + tnv.iz;

                    if ((vpBits[index] & INOUT) && !(vpBits[index] & ISDONE)) {

                        boundPoint.set(tnv.ix, tnv.iy, tz + nb[j][2], bp);
                        dx = tnv.ix - bp.ix;
                        dy = tnv.iy - bp.iy;
                        dz = tnv.iz - bp.iz;
                        square = dx * dx + dy * dy + dz * dz;
                        vpDistance[index] = square;
                        vpBits[index] |= ISDONE;
                        vpBits[index] |= ISBOUND;

                        outarray.push({
                            ix : tnv.ix,
                            iy : tnv.iy,
                            iz : tnv.iz
                        });
                    } else if ((vpBits[index] & INOUT) && (vpBits[index] & ISDONE)) {

                        dx = tnv.ix - bp.ix;
                        dy = tnv.iy - bp.iy;
                        dz = tnv.iz - bp.iz;
                        square = dx * dx + dy * dy + dz * dz;
                        if (square < vpDistance[index]) {
                            boundPoint.set(tnv.ix, tnv.iy, tnv.iz, bp);

                            vpDistance[index] = square;
                            if (!(vpBits[index] & ISBOUND)) {
                                vpBits[index] |= ISBOUND;
                                outarray.push({
                                    ix : tnv.ix,
                                    iy : tnv.iy,
                                    iz : tnv.iz
                                });
                            }
                        }
                    }
                }
            }
        }

        // console.log("part1", positout);

        for (i = 0, n = inarray.length; i < n; i++) {
            tx = inarray[i].ix;
            ty = inarray[i].iy;
            tz = inarray[i].iz;
            bp = boundPoint.get(tx, ty, tz);

            for (j = 6; j < 18; j++) {
                tnv.ix = tx + nb[j][0];
                tnv.iy = ty + nb[j][1];
                tnv.iz = tz + nb[j][2];

                if(tnv.ix < pLength && tnv.ix > -1 && tnv.iy < pWidth &&
                        tnv.iy > -1 && tnv.iz < pHeight && tnv.iz > -1) {
                    index = tnv.ix * pWH + pHeight * tnv.iy + tnv.iz;

                    if ((vpBits[index] & INOUT) && !(vpBits[index] & ISDONE)) {
                        boundPoint.set(tnv.ix, tnv.iy, tz + nb[j][2], bp);

                        dx = tnv.ix - bp.ix;
                        dy = tnv.iy - bp.iy;
                        dz = tnv.iz - bp.iz;
                        square = dx * dx + dy * dy + dz * dz;
                        vpDistance[index] = square;
                        vpBits[index] |= ISDONE;
                        vpBits[index] |= ISBOUND;

                        outarray.push({
                            ix : tnv.ix,
                            iy : tnv.iy,
                            iz : tnv.iz
                        });
                    } else if ((vpBits[index] & INOUT) && (vpBits[index] & ISDONE)) {
                        dx = tnv.ix - bp.ix;
                        dy = tnv.iy - bp.iy;
                        dz = tnv.iz - bp.iz;
                        square = dx * dx + dy * dy + dz * dz;
                        if (square < vpDistance[index]) {
                            boundPoint.set(tnv.ix, tnv.iy, tnv.iz, bp);
                            vpDistance[index] = square;
                            if (!(vpBits[index] & ISBOUND)) {
                                vpBits[index] |= ISBOUND;
                                outarray.push({
                                    ix : tnv.ix,
                                    iy : tnv.iy,
                                    iz : tnv.iz
                                });
                            }
                        }
                    }
                }
            }
        }

        // console.log("part2", positout);

        for (i = 0, n = inarray.length; i < n; i++) {
            tx = inarray[i].ix;
            ty = inarray[i].iy;
            tz = inarray[i].iz;
            bp = boundPoint.get(tx, ty, tz);

            for (j = 18; j < 26; j++) {
                tnv.ix = tx + nb[j][0];
                tnv.iy = ty + nb[j][1];
                tnv.iz = tz + nb[j][2];

                if (tnv.ix < pLength && tnv.ix > -1 && tnv.iy < pWidth &&
                        tnv.iy > -1 && tnv.iz < pHeight && tnv.iz > -1) {
                    index = tnv.ix * pWH + pHeight * tnv.iy + tnv.iz;

                    if ((vpBits[index] & INOUT) && !(vpBits[index] & ISDONE)) {
                        boundPoint.set(tnv.ix, tnv.iy, tz + nb[j][2], bp);

                        dx = tnv.ix - bp.ix;
                        dy = tnv.iy - bp.iy;
                        dz = tnv.iz - bp.iz;
                        square = dx * dx + dy * dy + dz * dz;
                        vpDistance[index] = square;
                        vpBits[index] |= ISDONE;
                        vpBits[index] |= ISBOUND;

                        outarray.push({
                            ix : tnv.ix,
                            iy : tnv.iy,
                            iz : tnv.iz
                        });
                    } else if ((vpBits[index] & INOUT)  && (vpBits[index] & ISDONE)) {
                        dx = tnv.ix - bp.ix;
                        dy = tnv.iy - bp.iy;
                        dz = tnv.iz - bp.iz;
                        square = dx * dx + dy * dy + dz * dz;
                        if (square < vpDistance[index]) {
                            boundPoint.set(tnv.ix, tnv.iy, tnv.iz, bp);

                            vpDistance[index] = square;
                            if (!(vpBits[index] & ISBOUND)) {
                                vpBits[index] |= ISBOUND;
                                outarray.push({
                                    ix : tnv.ix,
                                    iy : tnv.iy,
                                    iz : tnv.iz
                                });
                            }
                        }
                    }
                }
            }
        }

        // console.log("part3", positout);
        return outarray;
    };

    this.marchingcubeinit = function(stype) {
        for ( var i = 0, lim = vpBits.length; i < lim; i++) {
            if (stype == 1) {// vdw
                vpBits[i] &= ~ISBOUND;
            } else if (stype == 4) { // ses
                vpBits[i] &= ~ISDONE;
                if (vpBits[i] & ISBOUND)
                    vpBits[i] |= ISDONE;
                vpBits[i] &= ~ISBOUND;
            } else if (stype == 2) {// after vdw
                if ((vpBits[i] & ISBOUND) && (vpBits[i] & ISDONE))
                    vpBits[i] &= ~ISBOUND;
                else if ((vpBits[i] & ISBOUND) && !(vpBits[i] & ISDONE))
                    vpBits[i] |= ISDONE;
            } else if (stype == 3) { // sas
                vpBits[i] &= ~ISBOUND;
            }
        }
    };

    // this code allows me to empirically prune the marching cubes code tables
    // to more efficiently handle discrete data
    var counter = function() {
        var data = Array(256);
        for ( var i = 0; i < 256; i++)
            data[i] = [];

        this.incrementUsed = function(i, j) {
            if (typeof data[i][j] === 'undefined')
                data[i][j] = {
                    used : 0,
                    unused : 0
                };
            data[i][j].used++;
        };

        this.incrementUnused = function(i, j) {
            if (typeof data[i][j] === 'undefined')
                data[i][j] = {
                    used : 0,
                    unused : 0
                };
            data[i][j].unused++;

        };

        var redoTable = function(triTable) {
            var str = "[";
            for ( var i = 0; i < triTable.length; i++) {
                var code = 0;
                var table = triTable[i];
                for ( var j = 0; j < table.length; j++) {
                    code |= (1 << (table[j]));
                }
                str += "0x" + code.toString(16) + ", ";
            }
            str += "]";
            //console.log(str);
        };

        this.print = function() {

            var table = MarchingCube.triTable;
            var str;
            var newtable = [];
            for ( var i = 0; i < table.length; i++) {
                var newarr = [];
                for ( var j = 0; j < table[i].length; j += 3) {
                    var k = j / 3;
                    if (typeof data[i][k] === 'undefined' || !data[i][k].unused) {
                        newarr.push(table[i][j]);
                        newarr.push(table[i][j + 1]);
                        newarr.push(table[i][j + 2]);
                    }
                    if (typeof data[i][k] === 'undefined')
                        console.log("undef " + i + "," + k);
                }
                newtable.push(newarr);
            }
            //console.log(JSON.stringify(newtable));
            redoTable(newtable);
        };
    };

    this.marchingcube = function(stype) {
        this.marchingcubeinit(stype);
        verts = []; faces = [];
        $3Dmol.MarchingCube.march(vpBits, verts, faces, {
            smooth : 1,
            nX : pLength,
            nY : pWidth,
            nZ : pHeight
        });

        var pWH = pWidth*pHeight;
        for (var i = 0, vlen = verts.length; i < vlen; i++) {
            verts[i]['atomid'] = vpAtomID[verts[i].x * pWH + pHeight *
                    verts[i].y + verts[i].z];
        }

        $3Dmol.MarchingCube.laplacianSmooth(1, verts, faces);

    };


};

/*! setupsurface.js from SurfaceWorker.js
 * @author David Koes  / https://github.com/3dmol/3Dmol.js/tree/master/3Dmol
 * Modified by Jiyao Wang / https://github.com/ncbi/icn3d
 */

$3Dmol.SetupSurface = function (data) {
    var me = this;

    //var $3Dmol = $3Dmol || {};

    //var vol = $3Dmol.volume(data.extent);
    var vol = undefined;

    var threshbox = data.threshbox; // maximum possible boxsize, default 180

    var ps = new $3Dmol.ProteinSurface(threshbox);
    ps.initparm(data.extent, (data.type === 1) ? false : true);

    ps.fillvoxels(data.allatoms, data.extendedAtoms);

    ps.buildboundary();

    //if (data.type === 4 || data.type === 2) {
    if (data.type === 2) {
        ps.fastdistancemap();
        ps.boundingatom(false);
        ps.fillvoxelswaals(data.allatoms, data.extendedAtoms);
    }

    //ps.marchingcube(data.type);
    ps.marchingcube();

    ps.vpBits = null; // uint8 array of bitmasks
    ps.vpDistance = null; // floatarray of _squared_ distances
    ps.vpAtomID = null; // intarray

    var result = ps.getFacesAndVertices(data.atomsToShow);

    ps.faces = null;
    ps.verts = null;

    return result;
};


/*! ProteinSurface4.js
 * @author David Koes  / https://github.com/3dmol/3Dmol.js/tree/master/3Dmol
 * Modified by Jiyao Wang / https://github.com/ncbi/icn3d
 */

/*  ProteinSurface.js by biochem_fan

Ported and modified for Javascript based on EDTSurf,
  whose license is as follows.

Permission to use, copy, modify, and distribute this program for any
purpose, with or without fee, is hereby granted, provided that this
copyright notice and the reference information appear in all copies or
substantial portions of the Software. It is provided "as is" without
express or implied warranty.

Reference:
http://zhanglab.ccmb.med.umich.edu/EDTSurf/
D. Xu, Y. Zhang (2009) Generating Triangulated Macromolecular Surfaces
by Euclidean Distance Transform. PLoS ONE 4(12): e8140.

=======

TODO: Improved performance on Firefox
      Reduce memory consumption
      Refactor!
 */


// dkoes
// Surface calculations.  This must be safe to use within a web worker.
if (typeof console === 'undefined') {
    // this should only be true inside of a webworker
    console = {
        log : function() {
        }
    };
}

$3Dmol.ElectronMap = function(threshbox) {

    // constants for vpbits bitmasks
    /** @const */
    var INOUT = 1;
    /** @const */
    var ISDONE = 2;
    /** @const */
    var ISBOUND = 4;

    var isovalue = 1.5;
    var dataArray = {};
    var matrix, center, pmin, pmax, water, header, type;

    var ptranx = 0, ptrany = 0, ptranz = 0;
    var probeRadius = 1.4;
    var defaultScaleFactor = 2;
    var scaleFactor = defaultScaleFactor; // 2 is .5A grid; if this is made user configurable,
                            // also have to adjust offset used to find non-shown
                            // atoms
    var pHeight = 0, pWidth = 0, pLength = 0;
    var cutRadius = 0;
    var vpBits = null; // uint8 array of bitmasks
    var vpDistance = null; // floatarray of _squared_ distances
    var vpAtomID = null; // intarray
    var vertnumber = 0, facenumber = 0;
    var pminx = 0, pminy = 0, pminz = 0, pmaxx = 0, pmaxy = 0, pmaxz = 0;

    var depty = {}, widxz = {};
    var faces, verts;
    var nb = [ new Int32Array([ 1, 0, 0 ]), new Int32Array([ -1, 0, 0 ]),
               new Int32Array([ 0, 1, 0 ]), new Int32Array([ 0, -1, 0 ]),
               new Int32Array([ 0, 0, 1 ]),
               new Int32Array([ 0, 0, -1 ]),
               new Int32Array([ 1, 1, 0 ]),
               new Int32Array([ 1, -1, 0 ]),
               new Int32Array([ -1, 1, 0 ]),
               new Int32Array([ -1, -1, 0 ]),
               new Int32Array([ 1, 0, 1 ]),
               new Int32Array([ 1, 0, -1 ]),
               new Int32Array([ -1, 0, 1 ]),
               new Int32Array([ -1, 0, -1 ]),
               new Int32Array([ 0, 1, 1 ]),
               new Int32Array([ 0, 1, -1 ]),
               new Int32Array([ 0, -1, 1 ]),
               new Int32Array([ 0, -1, -1 ]),
               new Int32Array([ 1, 1, 1 ]),
               new Int32Array([ 1, 1, -1 ]),
               new Int32Array([ 1, -1, 1 ]),
               new Int32Array([ -1, 1, 1 ]),
               new Int32Array([ 1, -1, -1 ]),
               new Int32Array([ -1, -1, 1 ]),
               new Int32Array([ -1, 1, -1 ]),
               new Int32Array([ -1, -1, -1 ]) ];

    this.getFacesAndVertices = function(allatoms, atomlist) {
        var atomsToShow = {};
        var i, il;
        for (i = 0, il = atomlist.length; i < il; i++)
            atomsToShow[atomlist[i]] = 1;
        var vertices = verts;

        for (i = 0, il = vertices.length; i < il; i++) {
/*
            vertices[i].x = vertices[i].x / scaleFactor - ptranx;
            vertices[i].y = vertices[i].y / scaleFactor - ptrany;
            vertices[i].z = vertices[i].z / scaleFactor - ptranz;
*/
            var r = new THREE.Vector3(vertices[i].x, vertices[i].y, vertices[i].z).applyMatrix4(matrix);
            vertices[i].x = r.x / scaleFactor - ptranx;
            vertices[i].y = r.y / scaleFactor - ptrany;
            vertices[i].z = r.z / scaleFactor - ptranz;
        }

        var finalfaces = [];

        for (i = 0, il = faces.length; i < il; i += 3) {
            //var f = faces[i];
            var fa = faces[i], fb = faces[i+1], fc = faces[i+2];

            if (fa !== fb && fb !== fc && fa !== fc){
                finalfaces.push({"a":fa, "b":fb, "c":fc});
            }
        }

        //try to help the garbage collector
        vpBits = null; // uint8 array of bitmasks
        vpDistance = null; // floatarray
        vpAtomID = null; // intarray

        return {
            'vertices' : vertices, //shownVertices,
            'faces' : finalfaces
        };
    };


    this.initparm = function(inHeader, inData, inMatrix, inIsovalue, inCenter, inMaxdist, inPmin, inPmax, inWater, inType) {
        header = inHeader;

        if(header.max !== undefined) { // EM density map from EBI
            isovalue = header.min + (header.max - header.min) * inIsovalue / 100.0;
        }
        else if(header.mean !== undefined) { // density map from EBI
            isovalue = header.mean + header.sigma * inIsovalue; // electron density map from EBI
        }
        else {
            isovalue = inIsovalue;
        }

        dataArray = inData;
        matrix = inMatrix;
        center = inCenter;
        maxdist = inMaxdist;
        pmin = inPmin;
        pmax = inPmax;
        water = inWater;
        type = inType;

        var margin = (1 / scaleFactor) * 5.5; // need margin to avoid
                                                // boundary/round off effects
        //origextent = extent;

        pminx = 0; pmaxx = header.xExtent - 1;
        pminy = 0; pmaxy = header.yExtent - 1;
        pminz = 0; pmaxz = header.zExtent - 1;

        ptranx = -pminx;
        ptrany = -pminy;
        ptranz = -pminz;

        var maxLen = pmaxx - pminx;
        if ((pmaxy - pminy) > maxLen) maxLen = pmaxy - pminy;
        if ((pmaxz - pminz) > maxLen) maxLen = pmaxz - pminz;

        scaleFactor = 1;
        boxLength = maxLen;

        pLength = Math.ceil(scaleFactor * (pmaxx - pminx)) + 1;
        pWidth = Math.ceil(scaleFactor * (pmaxy - pminy)) + 1;
        pHeight = Math.ceil(scaleFactor * (pmaxz - pminz)) + 1;

        //this.boundingatom();
        cutRadius = probeRadius * scaleFactor;

        vpBits = new Uint8Array(pLength * pWidth * pHeight);
        //vpDistance = new Float64Array(pLength * pWidth * pHeight); // float 32
        //vpAtomID = new Int32Array(pLength * pWidth * pHeight);
        vpAtomID = new Uint8Array(pLength * pWidth * pHeight);
        //console.log("Box size: ", pLength, pWidth, pHeight, vpBits.length);
    };

    this.fillvoxels = function(atoms, atomlist) { // (int seqinit,int
        // seqterm,bool
        // atomtype,atom*
        // proseq,bool bcolor)
        var i, j, k, il;
        for (i = 0, il = vpBits.length; i < il; i++) {
            vpBits[i] = 0;
            //vpDistance[i] = -1.0;
            vpAtomID[i] = 0;
        }

        var inverseMatrix = new THREE.Matrix4().getInverse(matrix);

        var indexArray = [];
        maxdist = parseInt(maxdist); // has to be integer
        var widthHeight = pWidth * pHeight;
        var lengthWidth = pLength * pWidth;

        for (var serial in atomlist) {
            var atom = atoms[atomlist[serial]];
            var r = new THREE.Vector3(atom.coord.x, atom.coord.y, atom.coord.z).applyMatrix4(inverseMatrix);

            for(i = Math.floor(r.x) - maxdist, il = Math.ceil(r.x) + maxdist; i <= il; ++i) {
                if(i < 0 || i > header.xExtent - 1) continue;
                for(j = Math.floor(r.y) - maxdist, jl = Math.ceil(r.y) + maxdist; j<= jl; ++j) {
                    if(j < 0 || j > header.yExtent - 1) continue;
                    for(k = Math.floor(r.z) - maxdist, kl = Math.ceil(r.z) + maxdist; k<= kl; ++k) {
                        if(k < 0 || k > header.zExtent - 1) continue;

                        var index = i * widthHeight + j * pHeight + k;
                        indexArray.push(index);
                    }
                }
            }
        }

        for(i = 0, il = indexArray.length; i < il; ++i) {
            var index = indexArray[i];
            if(type == '2fofc') {
                vpBits[index] = (dataArray[index] >= isovalue) ? 1 : 0;
                //vpAtomID[index] = (dataArray[index] >= 0) ? 1 : 0; // determine whether it's positive
            }
            else if(type == 'fofc') {
                vpBits[index] = (dataArray[index] >= isovalue || dataArray[index] <= -isovalue) ? 1 : 0;
                vpAtomID[index] = (dataArray[index] >= 0) ? 1 : 0; // determine whether it's positive
            }
            else if(type == 'em') {
                vpBits[index] = (dataArray[index] >= isovalue) ? 1 : 0;
                //vpAtomID[index] = (dataArray[index] >= 0) ? 1 : 0; // determine whether it's positive
            }
        }

/*
        var index = 0;
        for(i = 0; i < pLength; ++i) {
            for(j = 0; j < pWidth; ++j) {
                for(k = 0; k < pHeight; ++k) {
                    vpBits[index] = (dataArray[index] >= isovalue || dataArray[index] <= -isovalue) ? 1 : 0;
                    vpAtomID[index] = (dataArray[index] >= 0) ? 1 : 0;
                    ++index;
                }
            }
        }
*/

        for (i = 0, il = vpBits.length; i < il; i++)
            if (vpBits[i] & INOUT)
                vpBits[i] |= ISDONE;

    };

    this.buildboundary = function() {
        var pWH = pWidth*pHeight;
        for (i = 0; i < pLength; i++) {
            for (j = 0; j < pHeight; j++) {
                for (k = 0; k < pWidth; k++) {
                    var index = i * pWH + k * pHeight + j;
                    if (vpBits[index] & INOUT) {
                        var flagbound = false;
                        var ii = 0;
                        while (ii < 26) {
                            var ti = i + nb[ii][0], tj = j + nb[ii][2], tk = k +
                                    nb[ii][1];
                            if (ti > -1 &&
                                ti < pLength &&
                                tk > -1 &&
                                tk < pWidth &&
                                tj > -1 &&
                                tj < pHeight &&
                                !(vpBits[ti * pWH + tk * pHeight + tj] & INOUT)) {
                                vpBits[index] |= ISBOUND;
                                break;
                            } else
                                ii++;
                        }
                    }
                }
            }
        }
    };

    this.marchingcubeinit = function(stype) {
        for ( var i = 0, lim = vpBits.length; i < lim; i++) {
            if (stype == 1) {// vdw
                vpBits[i] &= ~ISBOUND;
            } else if (stype == 4) { // ses
                vpBits[i] &= ~ISDONE;
                if (vpBits[i] & ISBOUND)
                    vpBits[i] |= ISDONE;
                vpBits[i] &= ~ISBOUND;
            } else if (stype == 2) {// after vdw
                if ((vpBits[i] & ISBOUND) && (vpBits[i] & ISDONE))
                    vpBits[i] &= ~ISBOUND;
                else if ((vpBits[i] & ISBOUND) && !(vpBits[i] & ISDONE))
                    vpBits[i] |= ISDONE;
            } else if (stype == 3) { // sas
                vpBits[i] &= ~ISBOUND;
            }
            else {
                vpBits[i] &= ~ISBOUND;
            }
        }
    };

    // this code allows me to empirically prune the marching cubes code tables
    // to more efficiently handle discrete data
    var counter = function() {
        var data = Array(256);
        for ( var i = 0; i < 256; i++)
            data[i] = [];

        this.incrementUsed = function(i, j) {
            if (typeof data[i][j] === 'undefined')
                data[i][j] = {
                    used : 0,
                    unused : 0
                };
            data[i][j].used++;
        };

        this.incrementUnused = function(i, j) {
            if (typeof data[i][j] === 'undefined')
                data[i][j] = {
                    used : 0,
                    unused : 0
                };
            data[i][j].unused++;

        };

        var redoTable = function(triTable) {
            var str = "[";
            for ( var i = 0; i < triTable.length; i++) {
                var code = 0;
                var table = triTable[i];
                for ( var j = 0; j < table.length; j++) {
                    code |= (1 << (table[j]));
                }
                str += "0x" + code.toString(16) + ", ";
            }
            str += "]";
            //console.log(str);
        };

        this.print = function() {

            var table = MarchingCube.triTable;
            var str;
            var newtable = [];
            for ( var i = 0; i < table.length; i++) {
                var newarr = [];
                for ( var j = 0; j < table[i].length; j += 3) {
                    var k = j / 3;
                    if (typeof data[i][k] === 'undefined' || !data[i][k].unused) {
                        newarr.push(table[i][j]);
                        newarr.push(table[i][j + 1]);
                        newarr.push(table[i][j + 2]);
                    }
                    if (typeof data[i][k] === 'undefined')
                        console.log("undef " + i + "," + k);
                }
                newtable.push(newarr);
            }
            //console.log(JSON.stringify(newtable));
            redoTable(newtable);
        };
    };

    this.marchingcube = function(stype) {
        this.marchingcubeinit(stype);
        verts = []; faces = [];

        $3Dmol.MarchingCube.march(vpBits, verts, faces, {
            smooth : 1,
            nX : pLength,
            nY : pWidth,
            nZ : pHeight
        });

        var pWH = pWidth*pHeight;
        for (var i = 0, vlen = verts.length; i < vlen; i++) {
            // positive values
            verts[i]['atomid'] = vpAtomID[verts[i].x * pWH + pHeight *
                    verts[i].y + verts[i].z];
        }

        $3Dmol.MarchingCube.laplacianSmooth(1, verts, faces);

    };
};

/*! setupsurface.js from SurfaceWorker.js
 * @author David Koes  / https://github.com/3dmol/3Dmol.js/tree/master/3Dmol
 * Modified by Jiyao Wang / https://github.com/ncbi/icn3d
 */

$3Dmol.SetupMap = function (data) {
    var ps = new $3Dmol.ElectronMap();
    ps.initparm(data.header, data.data, data.matrix, data.isovalue, data.center, data.maxdist, data.pmin, data.pmax, data.water, data.type);

    ps.fillvoxels(data.allatoms, data.extendedAtoms);

    ps.buildboundary();

    ps.marchingcube();

    ps.vpBits = null; // uint8 array of bitmasks
    //ps.vpDistance = null; // floatarray of _squared_ distances
    ps.vpAtomID = null; // intarray

    var result = ps.getFacesAndVertices(data.allatoms, data.atomsToShow);

    ps.faces = null;
    ps.verts = null;

    return result;
};


/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

// modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
iCn3D.prototype.createSurfaceRepresentation = function (atoms, type, wireframe, opacity) { var me = this;
    if(Object.keys(atoms).length == 0) return;

    if(opacity == undefined) opacity = 1.0;

    this.opacity = opacity;

    var geo;

    var extent = this.getExtent(atoms);

    // surface from 3Dmol
    var distance = 5; // consider atom 5 angstrom from the selected atoms

    var extendedAtoms = [];

    if(this.bConsiderNeighbors) {
        extendedAtoms = Object.keys(this.unionHash(atoms, this.getAtomsWithinAtom(this.atoms, atoms, distance)));
    }
    else {
        extendedAtoms = Object.keys(atoms);
    }

    //var sigma2fofc = 1.5;
    //var sigmafofc = 3.0;
    var maxdist = 1; // maximum distance to show electron density map, set it between 1 AND 2

    var bTransparent = (parseInt(10*opacity) != 10 && !wireframe && !(this.bInstanced && Object.keys(this.atoms).length * this.biomtMatrices.length > this.maxatomcnt) ) ? true : false;

    var ps;
    if(type == 11) { // 2fofc
        //maxdist = (me.mapData.sigma2 < 1.5) ? 2 : 1;

        ps = $3Dmol.SetupMap({
            //extent: extent,
            allatoms: this.atoms,
            atomsToShow: Object.keys(atoms),
            extendedAtoms: extendedAtoms,
            water: this.water,
            //type: type,
            //threshbox: this.threshbox,
            header: me.mapData.header2,
            data: me.mapData.data2,
            matrix: me.mapData.matrix2,
            isovalue: me.mapData.sigma2,
            center: this.center,
            maxdist: maxdist,
            pmin: this.pmin,
            pmax: this.pmax,
            type: '2fofc'
        });
    }
    else if(type == 12) { // fofc
        //maxdist = (me.mapData.sigma < 3) ? 2 : 1;
        ps = $3Dmol.SetupMap({
            //extent: extent,
            allatoms: this.atoms,
            atomsToShow: Object.keys(atoms),
            extendedAtoms: extendedAtoms,
            water: this.water,
            //type: type,
            //threshbox: this.threshbox,
            header: me.mapData.header,
            data: me.mapData.data,
            matrix: me.mapData.matrix,
            isovalue: me.mapData.sigma,
            center: this.center,
            maxdist: maxdist,
            pmin: this.pmin,
            pmax: this.pmax,
            type: 'fofc'
        });
    }
    else if(type == 13) { // em
        maxdist = 3; // EM map has no unit cell. It could include more gird space.

        ps = $3Dmol.SetupMap({
            //extent: extent,
            allatoms: this.atoms,
            atomsToShow: Object.keys(atoms),
            extendedAtoms: extendedAtoms,
            water: this.water,
            //type: type,
            //threshbox: this.threshbox,
            header: me.mapData.headerEm,
            data: me.mapData.dataEm,
            matrix: me.mapData.matrixEm,
            isovalue: me.mapData.sigmaEm,
            center: this.center,
            maxdist: maxdist,
            pmin: this.pmin,
            pmax: this.pmax,
            type: 'em'
        });
    }
    else {
        ps = $3Dmol.SetupSurface({
            extent: extent,
            allatoms: this.atoms,
            atomsToShow: Object.keys(atoms),
            extendedAtoms: extendedAtoms,
            type: type,
            threshbox: (bTransparent) ? 60 : this.threshbox
        });
    }

    var verts = ps.vertices;
    var faces = ps.faces;

    var colorFor2fofc = new THREE.Color('#00FFFF');
    var colorForfofcPos = new THREE.Color('#00FF00');
    //var colorForfofcNeg = new THREE.Color('#ff3300');
    var colorForfofcNeg = new THREE.Color('#ff0000');
    var colorForEm = new THREE.Color('#00FFFF');

    geo = new THREE.Geometry();
    geo.vertices = verts.map(function (v) {
        var r = new THREE.Vector3(v.x, v.y, v.z);

        r.atomid = v.atomid;
        return r;
    });

    geo.faces = faces.map(function (f) {
        //return new THREE.Face3(f.a, f.b, f.c);
        var vertexColors = ['a', 'b', 'c' ].map(function (d) {
            if(type == 11) { // 2fofc
                return colorFor2fofc;
            }
            else if(type == 12) { // fofc
                return (geo.vertices[f[d]].atomid) ? colorForfofcPos : colorForfofcNeg;
            }
            else if(type == 13) { // em
                return colorForEm;
            }
            else {
                var atomid = geo.vertices[f[d]].atomid;
                return me.atoms[atomid].color;
            }
        });

        return new THREE.Face3(f.a, f.b, f.c, undefined, vertexColors);
    });


    //http://analyticphysics.com/Coding%20Methods/Special%20Topics%20in%20Three.js.htm
    //var c = geo.center();

    //geo.computeFaceNormals();
    //geo.computeVertexNormals(false);
    geo.computeVertexNormals(true);

    geo.colorsNeedUpdate = true;
    geo.normalsNeedUpdate = true;

    geo.type = 'Surface'; // to be recognized in vrml.js for 3D printing

    //var normalArray = geo.data.normals;
    var normalArray = JSON.parse(JSON.stringify(geo)).data.normals;

    if(bTransparent) { // WebGL has someordering problem when dealing with transparency
      // the following method minimize the number of objects by a factor of 3
      var va2faces = {};

      for(var i = 0, il = faces.length; i < il; ++i) {
        var va = faces[i].a;
        var vb = faces[i].b;
        var vc = faces[i].c;

        // It produces less objects using va as the key
        if(va2faces[va] === undefined) va2faces[va] = [];
        //va2faces[va].push(va);
        va2faces[va].push(vb);
        va2faces[va].push(vc);
      }

      for(var va in va2faces) {
        var geometry = new THREE.Geometry();
        geometry.vertices = [];
        geometry.faces = [];

        var faceVertices = va2faces[va];
        for(var i = 0, il = faceVertices.length; i < il; i += 2) {
            var vb = faceVertices[i];
            var vc = faceVertices[i + 1];

            geometry.vertices.push(new THREE.Vector3(verts[va].x, verts[va].y, verts[va].z));
            geometry.vertices.push(new THREE.Vector3(verts[vb].x, verts[vb].y, verts[vb].z));
            geometry.vertices.push(new THREE.Vector3(verts[vc].x, verts[vc].y, verts[vc].z));

            var vertexColors = [];
            vertexColors.push(me.atoms[verts[va].atomid].color);
            vertexColors.push(me.atoms[verts[vb].atomid].color);
            vertexColors.push(me.atoms[verts[vc].atomid].color);

            var normals = [];
            normals.push(normalArray[va]);
            normals.push(normalArray[vb]);
            normals.push(normalArray[vc]);

            var initPos = i / 2 * 3;
            geometry.faces.push(new THREE.Face3(initPos, initPos + 1, initPos + 2, normals, vertexColors));
        }

        //geometry.computeVertexNormals(false);

        geometry.colorsNeedUpdate = true;
        //geometry.normalsNeedUpdate = true;

        geometry.type = 'Surface'; // to be recognized in vrml.js for 3D printing

        var mesh = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({
            specular: this.frac,
            shininess: 10, //30,
            emissive: 0x000000,
            vertexColors: THREE.VertexColors,
            wireframe: wireframe,
            opacity: opacity,
            transparent: true,
            side: THREE.DoubleSide
        }));

        //http://www.html5gamedevs.com/topic/7288-threejs-transparency-bug-or-limitation-or-what/
        //mesh.renderOrder = 0; // default 0
        var sum = new THREE.Vector3(0,0,0);
        for(var i = 0, il = mesh.geometry.vertices.length; i < il; ++i) {
            sum = sum.add(mesh.geometry.vertices[i]);
        }

        var realPos = sum.multiplyScalar(1.0 / mesh.geometry.vertices.length).sub(me.oriCenter).applyMatrix4(me.cam.matrixWorldInverse);
        mesh.renderOrder = (me.cam_z > 0) ? -parseInt(realPos.z) : parseInt(realPos.z);

        mesh.onBeforeRender = function(renderer, scene, camera, geometry, material, group) {
            //https://juejin.im/post/5a0872d4f265da43062a4156
            var sum = new THREE.Vector3(0,0,0);
            for(var i = 0, il = this.geometry.vertices.length; i < il; ++i) {
                sum = sum.add(this.geometry.vertices[i]);
            }

            var realPos = sum.multiplyScalar(1.0 / this.geometry.vertices.length).sub(me.oriCenter).applyMatrix4(me.cam.matrixWorldInverse);
            this.renderOrder = (me.cam_z > 0) ? -parseInt(realPos.z) : parseInt(realPos.z);
        };

        me.mdl.add(mesh);

        if(type == 11 || type == 12) {
            this.prevMaps.push(mesh);
        }
        else if(type == 13) {
            this.prevEmmaps.push(mesh);
        }
        else {
            this.prevSurfaces.push(mesh);
        }
      } // for(var va
    }
    else {
        var mesh = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({
            specular: this.frac,
            shininess: 10, //30,
            emissive: 0x000000,
            vertexColors: THREE.VertexColors,
            wireframe: wireframe,
            opacity: opacity,
            transparent: true,
            side: THREE.DoubleSide
        }));

        //http://www.html5gamedevs.com/topic/7288-threejs-transparency-bug-or-limitation-or-what/
        mesh.renderOrder = 0; // default 0

        me.mdl.add(mesh);

        if(type == 11 || type == 12) {
            this.prevMaps.push(mesh);
        }
        else if(type == 13) {
            this.prevEmmaps.push(mesh);
        }
        else {
            this.prevSurfaces.push(mesh);
        }
    }

    // remove the reference
    ps = null;
    verts = null;
    faces = null;

    // remove the reference
    geo = null;

    // do not add surface to raycasting objects for pk
};

// http://soledadpenades.com/articles/three-js-tutorials/drawing-the-coordinate-axes/
iCn3D.prototype.buildAxes = function (radius) {
    var axes = new THREE.Object3D();

    axes.add( this.createSingleLine( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0 + radius, 0, 0 ), 0xFF0000, false, 0.5 ) ); // +X
    axes.add( this.createSingleLine( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0 - radius, 0, 0 ), 0x800000, true, 0.5) ); // -X

    axes.add( this.createSingleLine( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0 + radius, 0 ), 0x00FF00, false, 0.5 ) ); // +Y
    axes.add( this.createSingleLine( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0 - radius, 0 ), 0x008000, true, 0.5 ) ); // -Y

    axes.add( this.createSingleLine( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, 0 + radius ), 0x0000FF, false, 0.5 ) ); // +Z
    axes.add( this.createSingleLine( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, 0 - radius ), 0x000080, true, 0.5 ) ); // -Z

    this.scene.add( axes );
};

iCn3D.prototype.createLines = function(lines) { // show extra lines, not used for pk, so no this.objects
   if(lines !== undefined) {
     for(var name in lines) {
         var lineArray = lines[name];

         for(var i = 0, il = lineArray.length; i < il; ++i) {
           var line = lineArray[i];

           var p1 = line.position1;
           var p2 = line.position2;

           var dashed = (line.dashed) ? line.dashed : false;
           var dashSize = 0.3;

           //this.mdl.add(this.createSingleLine( p1, p2, colorHex, dashed, dashSize ));

           var radius = this.lineRadius;

           var colorStr = '#' + line.color.replace(/\#/g, '');

           var color = new THREE.Color(colorStr);

           if(!dashed) {
                if(name == 'stabilizer') {
                    this.createBrick(p1, p2, radius, color);
                }
                else {
                    this.createCylinder(p1, p2, radius, color);
                }
           }
           else {
             var distance = p1.distanceTo(p2);

             var nsteps = parseInt(distance / dashSize);
             var step = p2.clone().sub(p1).multiplyScalar(dashSize/distance);

             var start, end;
             for(var j = 0; j < nsteps; ++j) {
                 if(j % 2 == 1) {
                      start = p1.clone().add(step.clone().multiplyScalar(j));
                      end = p1.clone().add(step.clone().multiplyScalar(j + 1));

                      if(name == 'stabilizer') {
                        this.createBrick(start, end, radius, color);
                      }
                      else {
                        this.createCylinder(start, end, radius, color);
                      }
                  }
             }
           }
         }
     }
   }

   // do not add the artificial lines to raycasting objects
};

iCn3D.prototype.createBrick = function (p0, p1, radius, color) {
    var cylinderGeometry = new THREE.CylinderGeometry(1, 1, 1, 4, 1);

    var mesh = new THREE.Mesh(cylinderGeometry, new THREE.MeshPhongMaterial({ specular: this.frac, shininess: 30, emissive: 0x000000, color: color }));

    mesh.position.copy(p0).add(p1).multiplyScalar(0.5);
    mesh.matrixAutoUpdate = false;
    mesh.lookAt(p1.clone().sub(p0));
    mesh.updateMatrix();

    mesh.matrix.multiply(new THREE.Matrix4().makeScale(radius, radius, p0.distanceTo(p1))).multiply(new THREE.Matrix4().makeRotationX(Math.PI * 0.5));

    this.mdl.add(mesh);
};


/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3D.prototype.applyPrevColor = function () {
    for (var i in this.atoms) {
        var atom = this.atoms[i];
        atom.color = this.atomPrevColors[i];
    }
};

iCn3D.prototype.applyChemicalbindingOptions = function (options) {
    if(options === undefined) options = this.opts;

    // display mode
    if (options.chemicalbinding === 'show') {
        var startAtoms;
        if(this.chemicals !== undefined && Object.keys(this.chemicals).length > 0) { // show chemical-protein interaction
            startAtoms = this.hash2Atoms(this.chemicals);
        }

        // find atoms in chainid1, which interact with chainid2
        var radius = 4;

        if(startAtoms !== undefined) {
            var targetAtoms = this.getAtomsWithinAtom(this.atoms, startAtoms, radius);

/*
            var residueHash = {};

            // draw sidec for these residues
            for(var i in targetAtoms) {
              if(startAtoms.hasOwnProperty(i)) continue;
              residueHash[this.atoms[i].structure + '_' + this.atoms[i].chain + '_' + this.atoms[i].resi] = 1;
            }

            var residueArray = Object.keys(residueHash);

            for(var i = 0, il = residueArray.length; i < il; ++i) {
                for(var j in this.residues[residueArray[i]]) {
                    // all atoms should be shown for hbonds
                    //this.atoms[j].style2 = 'stick';
                    this.atoms[j].style2 = 'lines';
                }
            }
*/
            // show hydrogens
            var threshold = 3.5;
            this.opts["hbonds"] = "yes";
            //this.opts["water"] = "dot";

            if(Object.keys(targetAtoms).length > 0) {
                this.calculateChemicalHbonds(startAtoms, targetAtoms, parseFloat(threshold) );
            }

            // zoom in on the atoms
            this.zoominSelection( this.unionHash(startAtoms, targetAtoms) );

            //this.opts['fog'] = 'yes';
        }
    }
    else if (options.chemicalbinding === 'hide') {
        // truen off hdonds
        this.hideHbonds();

        // center on the atoms
        this.zoominSelection(this.atoms);

        //this.opts['fog'] = 'no';
    }
};

iCn3D.prototype.hideHbonds = function () {
        this.opts["hbonds"] = "no";
        if(this.lines === undefined) this.lines = {};
        this.lines['hbond'] = [];
        this.hbondpnts = [];

        for(var i in this.atoms) {
            this.atoms[i].style2 = 'nothing';
        }

        for(var i in this.sidec) {
            this.atoms[i].style2 = this.opts["sidec"];
        }

        for(var i in this.water) {
            this.atoms[i].style = this.opts["water"];
        }
};

iCn3D.prototype.applySsbondsOptions = function (options) {
    if(options === undefined) options = this.opts;

    if (options.ssbonds.toLowerCase() === 'yes' && this.ssbondpnts !== undefined) {
      var color = '#FFFF00';
      var colorObj = new THREE.Color(0xFFFF00);

      var structureArray = Object.keys(this.structures);
      var start, end;

      if(this.bAlternate) {
          start = this.ALTERNATE_STRUCTURE;
          end = this.ALTERNATE_STRUCTURE + 1;
      }
      else {
          start = 0;
          end = structureArray.length;
      }

      this.lines['ssbond'] = [];

      for(var s = start, sl = end; s < sl; ++s) {
          var structure = structureArray[s];

          if(this.ssbondpnts[structure] === undefined) continue;

          //for(var i = 0, lim = Math.floor(this.ssbondpnts[structure].length / 2); i < lim; i++) {
          for(var i = Math.floor(this.ssbondpnts[structure].length / 2) - 1; i >= 0; i--) {
            var res1 = this.ssbondpnts[structure][2 * i], res2 = this.ssbondpnts[structure][2 * i + 1];
            var serial1, serial2;

            var line = {};
            line.color = color;
            line.dashed = true;

            var bFound = false;
            for(var j in this.residues[res1]) {
                if(this.atoms[j].name === 'SG') {
                    serial1 = this.atoms[j].serial;
                    line.position1 = this.atoms[j].coord;
                    line.serial1 = this.atoms[j].serial;
                    bFound = true;
                    break;
                }
            }

            if(!bFound) {
                for(var j in this.residues[res1]) {
                    if(this.atoms[j].name === 'CA') {
                        line.position1 = this.atoms[j].coord;
                        line.serial1 = this.atoms[j].serial;
                        bFound = true;
                        break;
                    }
                }
            }

            bFound = false;
            for(var j in this.residues[res2]) {
                if(this.atoms[j].name === 'SG') {
                    serial2 = this.atoms[j].serial;
                    line.position2 = this.atoms[j].coord;
                    line.serial2 = this.atoms[j].serial;
                    bFound = true;
                    break;
                }
            }

            if(!bFound) {
                for(var j in this.residues[res2]) {
                    if(this.atoms[j].name === 'CA') {
                        line.position2 = this.atoms[j].coord;
                        line.serial2 = this.atoms[j].serial;
                        bFound = true;
                        break;
                    }
                }
            }

            // only draw bonds connected with currently displayed atoms
            if(line.serial1 !== undefined && line.serial2 !== undefined && !this.dAtoms.hasOwnProperty(line.serial1) && !this.dAtoms.hasOwnProperty(line.serial2)) continue;

            // determine whether it's true disulfide bonds
            // disulfide bond is about 2.05 angstrom
            var distMax = 3;
            if(line.position1 === undefined || line.position2 === undefined || line.position1.distanceTo(line.position2) > distMax) {
                this.ssbondpnts[structure].splice(2 * i, 2);
                continue;
            }

            //if(this.atoms[serial1].ids !== undefined) { // mmdb id as input
                // remove the original disulfide bonds
                var pos = this.atoms[serial1].bonds.indexOf(serial2);
                var array1, array2;
                if(pos != -1) {
                    array1 = this.atoms[serial1].bonds.slice(0, pos);
                    array2 = this.atoms[serial1].bonds.slice(pos + 1);

                    this.atoms[serial1].bonds = array1.concat(array2);
                }

                pos = this.atoms[serial2].bonds.indexOf(serial1);
                if(pos != -1) {
                    array1 = this.atoms[serial2].bonds.slice(0, pos);
                    array2 = this.atoms[serial2].bonds.slice(pos + 1);

                    this.atoms[serial2].bonds = array1.concat(array2);
                }
            //}

            //if(this.lines['ssbond'] === undefined) this.lines['ssbond'] = [];
            this.lines['ssbond'].push(line);

            // create bonds for disulfide bonds
            //this.createCylinder(line.position1, line.position2, this.cylinderRadius * 0.5, colorObj);
            this.createCylinder(line.position1, line.position2, this.cylinderRadius, colorObj);

            // show ball and stick for these two residues
            var residueAtoms = this.unionHash(this.residues[res1], this.residues[res2]);

            // show side chains for the selected atoms
            var atoms = this.intHash(residueAtoms, this.sidec);
            var calpha_atoms = this.intHash(residueAtoms, this.calphas);
            // include calphas
            atoms = this.unionHash(atoms, calpha_atoms);

            // draw sidec separatedly
            for(var j in atoms) {
              this.atoms[j].style2 = 'stick';
            }
          } // for(var i = 0,
      } // for(var s = 0,
    } // if (options.ssbonds.toLowerCase() === 'yes'
};

iCn3D.prototype.applyMapOptions = function (options) {
    if(options === undefined) options = this.opts;

    switch (options.mapwireframe) {
        case 'yes':
            options.mapwireframe = true;
            break;
        case 'no':
            options.mapwireframe = false;
            break;
    }

    var atoms, currAtoms;

    // only show the surface for atoms which are displaying
    atoms = this.intHash(this.dAtoms, this.hAtoms);

    currAtoms = this.hash2Atoms(atoms);

    switch (options.map.toLowerCase()) {
        case '2fofc':
            this.createSurfaceRepresentation(currAtoms, 11, options.mapwireframe);
            break;
        case 'fofc':
            this.createSurfaceRepresentation(currAtoms, 12, options.mapwireframe);
            break;
        case 'nothing':
            // remove surfaces
            this.removeMaps();
            break;
    }
};

iCn3D.prototype.applyEmmapOptions = function (options) {
    if(options === undefined) options = this.opts;

    switch (options.emmapwireframe) {
        case 'yes':
            options.emmapwireframe = true;
            break;
        case 'no':
            options.emmapwireframe = false;
            break;
    }

    var atoms, currAtoms;

    // only show the surface for atoms which are displaying
    atoms = this.intHash(this.dAtoms, this.hAtoms);

    currAtoms = this.hash2Atoms(atoms);

    switch (options.emmap.toLowerCase()) {
        case 'em':
            this.createSurfaceRepresentation(currAtoms, 13, options.emmapwireframe);
            break;
        case 'nothing':
            // remove surfaces
            this.removeEmmaps();
            break;
    }
};

iCn3D.prototype.setFog = function() {
    var background = this.backgroundColors[this.opts.background.toLowerCase()];

    // apply fog
    if(this.opts['fog'] === 'yes') {
        if(this.opts['camera'] === 'perspective') {        //perspective, orthographic
            //this.scene.fog = new THREE.Fog(background, this.cam_z, this.cam_z + 0.5 * this.maxD);
            //this.scene.fog = new THREE.Fog(background, 2 * this.maxD, 2.5 * this.maxD);
            this.scene.fog = new THREE.Fog(background, 1.5 * this.maxD, 3 * this.maxD);
        }
        else if(this.opts['camera'] === 'orthographic') {
            //this.scene.fog = new THREE.FogExp2(background, 2);
            //this.scene.fog.near = 1.5 * this.maxD;
            //this.scene.fog.far = 3 * this.maxD;

            this.scene.fog = undefined;
        }
    }
    else {
        this.scene.fog = undefined;
    }
};

// change the display atom when alternating
iCn3D.prototype.alternateStructures = function () {
    var hAtomsCount = Object.keys(this.hAtoms).length;
    var allAtomsCount = Object.keys(this.atoms).length;

    this.dAtoms = {};

    var moleculeArray = Object.keys(this.structures);
    for(var i = 0, il = moleculeArray.length; i < il; ++i) {
        var structure = moleculeArray[i];
        if(i > this.ALTERNATE_STRUCTURE || (this.ALTERNATE_STRUCTURE === il - 1 && i === 0) ) {
            for(var k in this.structures[structure]) {
                var chain = this.structures[structure][k];
                this.dAtoms = this.unionHash(this.dAtoms, this.chains[chain]);
            }

            this.ALTERNATE_STRUCTURE = i;
            break;
        }
    }

    if(hAtomsCount < allAtomsCount) {
        this.dAtoms = this.intHash(this.dAtoms, this.hAtoms);

        this.bShowHighlight = false;
        this.opts['rotationcenter'] = 'highlight center';
    }

    // also alternating the surfaces
    this.removeSurfaces();
    this.applySurfaceOptions();

    this.removeMaps();
    this.applyMapOptions();

    this.removeEmmaps();
    this.applyEmmapOptions();

    this.draw();

    this.bShowHighlight = true;
    this.opts['rotationcenter'] = 'molecule center';
};

iCn3D.prototype.updateStabilizer = function () {
    this.stabilizerpnts = [];

    if(this.pairArray !== undefined) {
        for(var i = 0, il = this.pairArray.length; i < il; i += 2) {
            var coordI = this.getResidueRepPos(this.pairArray[i]);
            var coordJ = this.getResidueRepPos(this.pairArray[i + 1]);

            this.stabilizerpnts.push(coordI);
            this.stabilizerpnts.push(coordJ);
        }
    }
};

iCn3D.prototype.getResidueRepPos = function (serial) { var me = this;
    var atomIn = this.atoms[serial];
    var residueid = atomIn.structure + "_" + atomIn.chain + "_" + atomIn.resi;

    var pos;
    if(!this.proteins.hasOwnProperty(serial) && !this.nucleotides.hasOwnProperty(serial)) { // chemicals or ions
        pos = atomIn.coord;
    }
    else {
        for(var i in this.residues[residueid]) {
            var atom = this.atoms[i];
            if(atom.name === 'N3') { // nucleotide: N3
                pos = this.atoms[i].coord;
                break;
            }
            else if(atom.name === 'CA' && atom.ss == 'coil') { // protein coil: CA
                pos = this.atoms[i].coord;
                break;
            }
            else if(atom.name === 'CA' && (atom.ss == 'helix' || atom.ss == 'sheet')) { // protein secondary: CA
                pos = (this.atoms[i].coord2 !== undefined) ? this.atoms[i].coord2 : this.atoms[i].coord;
                break;
            }
        }
    }

    if(pos === undefined) pos = atomIn.coord;

    return pos;
};

iCn3D.prototype.applySurfaceOptions = function (options) {
    if(options === undefined) options = this.opts;

    //switch (options.wireframe.toLowerCase()) {
    switch (options.wireframe) {
        case 'yes':
            options.wireframe = true;
            break;
        case 'no':
            options.wireframe = false;
            break;
    }

    options.opacity = parseFloat(options.opacity);

    var atoms, currAtoms;

    // only show the surface for atoms which are displaying
    atoms = this.intHash(this.dAtoms, this.hAtoms);
    // exclude water molecules
    if(options['water'] === 'nothing') atoms = this.exclHash(atoms, this.water);

    currAtoms = this.hash2Atoms(atoms);

    switch (options.surface.toLowerCase()) {
        case 'van der waals surface':
            this.createSurfaceRepresentation(currAtoms, 1, options.wireframe, options.opacity);
            break;
//            case 'solvent excluded surface':
//                this.createSurfaceRepresentation(currAtoms, 2, options.wireframe, options.opacity);
//                break;
        case 'solvent accessible surface':
            this.createSurfaceRepresentation(currAtoms, 3, options.wireframe, options.opacity);
            break;
        case 'molecular surface':
            this.createSurfaceRepresentation(currAtoms, 2, options.wireframe, options.opacity);
            break;
        case 'van der waals surface with context':
            this.createSurfaceRepresentation(currAtoms, 1, options.wireframe, options.opacity);
            break;
        case 'solvent accessible surface with context':
            this.createSurfaceRepresentation(currAtoms, 3, options.wireframe, options.opacity);
            break;
        case 'molecular surface with context':
            this.createSurfaceRepresentation(currAtoms, 2, options.wireframe, options.opacity);
            break;
        case 'nothing':
            // remove surfaces
            this.removeSurfaces();
            break;
    }
};

iCn3D.prototype.applyOtherOptions = function (options) {
    if(options === undefined) options = this.opts;

    this.lines['hbond'] = [];

    //common part options

    // lines
    //if (options.hbonds.toLowerCase() === 'yes' || options.ncbonds.toLowerCase() === 'yes') {
    if (options.hbonds.toLowerCase() === 'yes') {
        var color = '#00FF00';
        var pnts = this.hbondpnts;

         for (var i = 0, lim = Math.floor(pnts.length / 2); i < lim; i++) {
            var line = {};
            line.position1 = pnts[2 * i].coord;
            line.serial1 = pnts[2 * i].serial;
            line.position2 = pnts[2 * i + 1].coord;
            line.serial2 = pnts[2 * i + 1].serial;
            line.color = color;
            line.dashed = true;

            // only draw bonds connected with currently displayed atoms
            if(line.serial1 !== undefined && line.serial2 !== undefined && !this.dAtoms.hasOwnProperty(line.serial1) && !this.dAtoms.hasOwnProperty(line.serial2)) continue;

            if(this.lines['hbond'] === undefined) this.lines['hbond'] = [];
            this.lines['hbond'].push(line);
         }

        //this.createLines(this.lines);
    }

    if (this.pairArray !== undefined && this.pairArray.length > 0) {
        this.updateStabilizer(); // to update this.stabilizerpnts

        var color = '#FFFFFF';
        var pnts = this.stabilizerpnts;
        this.lines['stabilizer'] = []; // reset
        for (var i = 0, lim = Math.floor(pnts.length / 2); i < lim; i++) {
            var line = {};
            line.position1 = pnts[2 * i];
            line.position2 = pnts[2 * i + 1];
            line.color = color;
            line.dashed = false; // if true, there will be too many cylinders in the dashed lines

            this.lines['stabilizer'].push(line);
        }
    }

    this.createLines(this.lines);

    // maps
    if(this.prevMaps !== undefined) {
        for(var i = 0, il = this.prevMaps.length; i < il; ++i) {
            this.mdl.add(this.prevMaps[i]);
        }
    }

    // EM map
    if(this.prevEmmaps !== undefined) {
        for(var i = 0, il = this.prevEmmaps.length; i < il; ++i) {
            this.mdl.add(this.prevEmmaps[i]);
        }
    }

    // surfaces
    if(this.prevSurfaces !== undefined) {
        for(var i = 0, il = this.prevSurfaces.length; i < il; ++i) {
            this.mdl.add(this.prevSurfaces[i]);
        }
    }

    this.applyCenterOptions(options);

    switch (options.axis.toLowerCase()) {
        case 'yes':
            this.axis = true;

            this.buildAxes(this.maxD/2);

            break;
        case 'no':
            this.axis = false;
            break;
    }
    switch (options.pk.toLowerCase()) {
        case 'atom':
            this.pk = 1;
            break;
        case 'no':
            this.pk = 0;
            break;
        case 'residue':
            this.pk = 2;
            break;
        case 'strand':
            this.pk = 3;
            break;
    }
};

iCn3D.prototype.rebuildScene = function (options) { var me = this;
    this.rebuildSceneBase(options);

    if(this.bSkipChemicalbinding === undefined || !this.bSkipChemicalbinding) this.applyChemicalbindingOptions();
    this.bSkipChemicalbinding = true;

    // show disulfide bonds, set side chains
    this.applySsbondsOptions();

    this.applyDisplayOptions(this.opts, this.dAtoms);

    this.applyOtherOptions();

    this.setFog();

    this.setCamera();

    //https://stackoverflow.com/questions/15726560/three-js-raycaster-intersection-empty-when-objects-not-part-of-scene
    me.scene_ghost.updateMatrixWorld(true);
};

iCn3D.prototype.draw = function () { var me = this;
    this.rebuildScene();

    // Impostor display using the saved arrays
    if(this.bImpo) {
        this.drawImpostorShader();
    }

    this.applyPrevColor();

//    if(Object.keys(me.mapData).length > 0) me.applyMapOptions();

    //if(this.bSSOnly) this.drawHelixBrick(this.molid2ss, this.molid2color);

    if(this.biomtMatrices !== undefined && this.biomtMatrices.length > 1) {
        if(this.bAssembly) {
            this.drawSymmetryMates();
        }
        else {
            this.centerSelection();
        }
    }

    // show the hAtoms
    var hAtomsLen = (this.hAtoms !== undefined) ? Object.keys(this.hAtoms).length : 0;

    //if(hAtomsLen > 0 && hAtomsLen < Object.keys(this.atoms).length) {
    if(hAtomsLen > 0 && hAtomsLen < Object.keys(this.dAtoms).length) {
        this.removeHlObjects();
        if(this.bShowHighlight === undefined || this.bShowHighlight) this.addHlObjects();
    }

    if(this.bRender === true) {
      this.applyTransformation(this._zoomFactor, this.mouseChange, this.quaternion);
      this.render();

      // reset to hide the side chain
      //this.opts['sidec'] = 'nothing';
    }

    this.clearImpostors();
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

// get hbonds between "molecule" and "chemical"
iCn3D.prototype.calculateChemicalHbonds = function (startAtoms, targetAtoms, threshold) {
    if(Object.keys(startAtoms).length === 0 || Object.keys(targetAtoms).length === 0) return;

    var atomHbond = {};
    var chain_resi, chain_resi_atom;

    var maxlengthSq = threshold * threshold;

    for (var i in startAtoms) {
      var atom = startAtoms[i];

      if(atom.elem === "N" || atom.elem === "O" || atom.elem === "F") { // calculate hydrogen bond
        chain_resi_atom = atom.structure + "_" + atom.chain + "_" + atom.resi + "_" + atom.name;

        atomHbond[chain_resi_atom] = atom;
      }
    } // end of for (var i in startAtoms) {

    var hbondsAtoms = {};
    var residueHash = {};

    for (var i in targetAtoms) {
      var atom = targetAtoms[i];

      if(atom.elem === "N" || atom.elem === "O" || atom.elem === "F") { // calculate hydrogen bond
        chain_resi = atom.structure + "_" + atom.chain + "_" + atom.resi;
        chain_resi_atom = chain_resi + "_" + atom.name;

        for (var j in atomHbond) {
          var xdiff = Math.abs(atom.coord.x - atomHbond[j].coord.x);
          if(xdiff > threshold) continue;

          var ydiff = Math.abs(atom.coord.y - atomHbond[j].coord.y);
          if(ydiff > threshold) continue;

          var zdiff = Math.abs(atom.coord.z - atomHbond[j].coord.z);
          if(zdiff > threshold) continue;

          var dist = xdiff * xdiff + ydiff * ydiff + zdiff * zdiff;
          if(dist > maxlengthSq) continue;

          // output hydrogen bonds
          this.hbondpnts.push({'serial': atom.serial, 'coord': atom.coord});
          this.hbondpnts.push({'serial': atomHbond[j].serial, 'coord': atomHbond[j].coord});

          hbondsAtoms = this.unionHash(hbondsAtoms, this.residues[atom.structure + "_" + atom.chain + "_" + atom.resi]);
          hbondsAtoms = this.unionHash(hbondsAtoms, this.residues[atomHbond[j].structure + "_" + atomHbond[j].chain + "_" + atomHbond[j].resi]);

          residueHash[chain_resi] = 1;
        } // end of for (var j in atomHbond) {
      }
    } // end of for (var i in targetAtoms) {

    var residueArray = Object.keys(residueHash);

    // draw sidec for these residues
    for(var i = 0, il = residueArray.length; i < il; ++i) {
        for(var j in this.residues[residueArray[i]]) {
            // all atoms should be shown for hbonds
            this.atoms[j].style2 = 'stick';
            //this.atoms[j].style2 = 'lines';
        }
    }

    return hbondsAtoms;
};

iCn3D.prototype.getChainsFromAtoms = function(atomsHash) {
    var chainsHash = {};
    for(var i in atomsHash) {
       var atom = this.atoms[i];
       var chainid = atom.structure + "_" + atom.chain;

       chainsHash[chainid] = 1;
    }

    return chainsHash;
};


 iCn3D.prototype.getNeighboringAtoms = function(atomlist, atomlistTarget, distance) {
    var me = this;

    var extent = this.getExtent(atomlistTarget);

    var targetRadiusSq1 = (extent[2][0] - extent[0][0]) * (extent[2][0] - extent[0][0]) + (extent[2][1] - extent[0][1]) * (extent[2][1] - extent[0][1]) + (extent[2][2] - extent[0][2]) * (extent[2][2] - extent[0][2]);
    var targetRadiusSq2 = (extent[2][0] - extent[1][0]) * (extent[2][0] - extent[1][0]) + (extent[2][1] - extent[1][1]) * (extent[2][1] - extent[1][1]) + (extent[2][2] - extent[1][2]) * (extent[2][2] - extent[1][2]);
    var targetRadiusSq = (targetRadiusSq1 > targetRadiusSq2) ? targetRadiusSq1 : targetRadiusSq2;
    var targetRadius = Math.sqrt(targetRadiusSq);

    var maxDistSq = (targetRadius + distance) * (targetRadius + distance);

    var neighbors = {};
    for (var i in atomlist) {
       //var atom = atomlist[i];
       var atom = me.atoms[i];

       // exclude the target atoms
       if(atom.serial in atomlistTarget) continue;

       if (atom.coord.x < extent[0][0] - distance || atom.coord.x > extent[1][0] + distance) continue;
       if (atom.coord.y < extent[0][1] - distance || atom.coord.y > extent[1][1] + distance) continue;
       if (atom.coord.z < extent[0][2] - distance || atom.coord.z > extent[1][2] + distance) continue;

       // only show protein or DNA/RNA
       //if(atom.serial in this.proteins || atom.serial in this.nucleotides) {
           var atomDistSq = (atom.coord.x - extent[2][0]) * (atom.coord.x - extent[2][0]) + (atom.coord.y - extent[2][1]) * (atom.coord.y - extent[2][1]) + (atom.coord.z - extent[2][2]) * (atom.coord.z - extent[2][2]);

           if(atomDistSq < maxDistSq) {
               neighbors[atom.serial] = atom;
           }
       //}
    }

    return neighbors;
 };

 // modified from iview (http://istar.cse.cuhk.edu.hk/iview/)
 iCn3D.prototype.getAtomsWithinAtom = function(atomlist, atomlistTarget, distance) {
    var me = this;

    var neighbors = this.getNeighboringAtoms(atomlist, atomlistTarget, distance);

    var ret = {};
    for(var i in atomlistTarget) {
        //var oriAtom = atomlistTarget[i];
        var oriAtom = me.atoms[i];
        var radius = this.vdwRadii[oriAtom.elem] || this.defaultRadius;

        for (var j in neighbors) {
           var atom = neighbors[j];

           // exclude the target atoms
           if(atom.serial in atomlistTarget) continue;

           var atomDistSq = (atom.coord.x - oriAtom.coord.x) * (atom.coord.x - oriAtom.coord.x) + (atom.coord.y - oriAtom.coord.y) * (atom.coord.y - oriAtom.coord.y) + (atom.coord.z - oriAtom.coord.z) * (atom.coord.z - oriAtom.coord.z);

           var maxDistSq = (radius + distance) * (radius + distance);

           if(atomDistSq < maxDistSq) {
               ret[atom.serial] = atom;
           }
       }
    }

    return ret;
 };

 // from iview (http://istar.cse.cuhk.edu.hk/iview/)
 iCn3D.prototype.getExtent = function(atomlist) {
    var me = this;

    var xmin = ymin = zmin = 9999;
    var xmax = ymax = zmax = -9999;
    var xsum = ysum = zsum = cnt = 0;
    var i;
    for (i in atomlist) {
       //var atom = atomlist[i];
       var atom = me.atoms[i];
       cnt++;
       xsum += atom.coord.x; ysum += atom.coord.y; zsum += atom.coord.z;


       xmin = (xmin < atom.coord.x) ? xmin : atom.coord.x;

       ymin = (ymin < atom.coord.y) ? ymin : atom.coord.y;
       zmin = (zmin < atom.coord.z) ? zmin : atom.coord.z;
       xmax = (xmax > atom.coord.x) ? xmax : atom.coord.x;
       ymax = (ymax > atom.coord.y) ? ymax : atom.coord.y;
       zmax = (zmax > atom.coord.z) ? zmax : atom.coord.z;
    }

    return [[xmin, ymin, zmin], [xmax, ymax, zmax], [xsum / cnt, ysum / cnt, zsum / cnt]];
 };

iCn3D.prototype.centerAtoms = function(atoms) {
    var pmin = new THREE.Vector3( 9999, 9999, 9999);
    var pmax = new THREE.Vector3(-9999,-9999,-9999);
    var psum = new THREE.Vector3();
    var cnt = 0;

    for (var i in atoms) {
        var atom = this.atoms[i];
        var coord = atom.coord;
        psum.add(coord);
        pmin.min(coord);
        pmax.max(coord);
        ++cnt;
    }

    var maxD = pmax.distanceTo(pmin);

    return {"center": psum.multiplyScalar(1.0 / cnt), "maxD": maxD};
};

iCn3D.prototype.removeSurfaces = function () {
   // remove prevous highlight
   for(var i = 0, il = this.prevSurfaces.length; i < il; ++i) {
       this.mdl.remove(this.prevSurfaces[i]);
   }

   this.prevSurfaces = [];
};

iCn3D.prototype.removeLastSurface = function () {
   // remove prevous highlight
   if(this.prevSurfaces.length > 0) {
       this.mdl.remove(this.prevSurfaces[this.prevSurfaces.length - 1]);
       this.prevSurfaces.slice(this.prevSurfaces.length - 1, 1);
   }
};

iCn3D.prototype.removeMaps = function () {
   // remove prevous highlight
   for(var i = 0, il = this.prevMaps.length; i < il; ++i) {
       this.mdl.remove(this.prevMaps[i]);
   }

   this.prevMaps = [];
};

iCn3D.prototype.removeEmmaps = function () {
   // remove prevous highlight
   for(var i = 0, il = this.prevEmmaps.length; i < il; ++i) {
       this.mdl.remove(this.prevEmmaps[i]);
   }

   this.prevEmmaps = [];
};

iCn3D.prototype.removeLastMap = function () {
   // remove prevous highlight
   if(this.prevMaps.length > 0) {
       this.mdl.remove(this.prevMaps[this.prevMaps.length - 1]);
       this.prevMaps.slice(this.prevMaps.length - 1, 1);
   }
};

iCn3D.prototype.removeLastEmmap = function () {
   // remove prevous highlight
   if(this.prevEmmaps.length > 0) {
       this.mdl.remove(this.prevEmmaps[this.prevEmmaps.length - 1]);
       this.prevEmmaps.slice(this.prevEmmaps.length - 1, 1);
   }
};

iCn3D.prototype.zoominSelection = function(atoms) {
   if(atoms === undefined) {
       atoms = this.hash2Atoms(this.hAtoms);
   }

   // center on the hAtoms if more than one residue is selected
   if(Object.keys(atoms).length > 1) {
           var centerAtomsResults = this.centerAtoms(atoms);
           this.maxD = centerAtomsResults.maxD;
           if (this.maxD < 5) this.maxD = 5;

           this.mdl.position.set(0,0,0);
           this.mdlImpostor.position.set(0,0,0);
           this.mdl_ghost.position.set(0,0,0);

           this.mdl.position.sub(centerAtomsResults.center);
           //this.mdlPicking.position.sub(centerAtomsResults.center);
           this.mdlImpostor.position.sub(centerAtomsResults.center);
           this.mdl_ghost.position.sub(centerAtomsResults.center);

           this.center = centerAtomsResults.center;

           // reset cameara
           this.setCamera();
   }
};

iCn3D.prototype.centerSelection = function(atoms) {
   this.resetOrientation();

   if(atoms === undefined) {
       atoms = this.hash2Atoms(this.hAtoms);
   }

   // center on the hAtoms if more than one residue is selected
   if(Object.keys(atoms).length > 1) {
           var centerAtomsResults = this.centerAtoms(atoms);

           this.center = centerAtomsResults.center;
           this.setCenter(this.center);

           // reset cameara
           this.setCamera();
   }
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

// make dialog movable outside of the window
// http://stackoverflow.com/questions/6696461/jquery-ui-dialog-drag-question
// if (!$.ui.dialog.prototype._makeDraggableBase) {
//     $.ui.dialog.prototype._makeDraggableBase = $.ui.dialog.prototype._makeDraggable;
//     $.ui.dialog.prototype._makeDraggable = function() {
//         this._makeDraggableBase();
//         this.uiDialog.draggable("option", "containment", false);
//     };
// }

var iCn3DUI = function(cfg) {
    var me = this;

    this.REVISION = '2.7.4';

    me.bFullUi = true;

    me.cfg = cfg;
    me.divid = me.cfg.divid;
    me.pre = me.divid + "_";

    me.inputid = '';

    me.setOperation = 'or'; // by default the set operation is 'or'

    me.WIDTH = 400; // total width of view area
    me.HEIGHT = 400; // total height of view area

    me.RESIDUE_WIDTH = 10;  // sequences
    me.MENU_HEIGHT = 40;

    // used to set the position for the log/command textarea
    //me.MENU_WIDTH = 690;
    me.MENU_WIDTH = 750;

    me.LESSWIDTH = 20;
    me.LESSWIDTH_RESIZE = 20;
    me.LESSHEIGHT = 20;

    me.ROT_DIR = 'right';
    me.bHideSelection = true;

    me.CMD_HEIGHT = 0.8*me.MENU_HEIGHT;

    //me.EXTRAHEIGHT = 2*me.MENU_HEIGHT + me.CMD_HEIGHT;
    me.EXTRAHEIGHT = me.MENU_HEIGHT + me.CMD_HEIGHT;
    if(me.cfg.showmenu != undefined && me.cfg.showmenu == false) {
        //me.EXTRAHEIGHT -= 2*me.MENU_HEIGHT;
        me.EXTRAHEIGHT -= me.MENU_HEIGHT;
    }
    if(me.cfg.showcommand != undefined && me.cfg.showcommand == false) {
        me.EXTRAHEIGHT -= me.CMD_HEIGHT;
    }

    me.GREY8 = "#888888"; // style protein grey
    me.GREYB = "#BBBBBB";
    me.GREYC = "#CCCCCC"; // grey background
    me.GREYD = "#DDDDDD";
    me.ORANGE = "#FFA500";

    // https://www.ncbi.nlm.nih.gov/Class/FieldGuide/BLOSUM62.txt, range from -4 to 11
    me.b62ResArray = ['A', 'R', 'N', 'D', 'C', 'Q', 'E', 'G', 'H', 'I', 'L', 'K', 'M', 'F', 'P', 'S', 'T', 'W', 'Y', 'V', 'B', 'Z', 'X', '*']; // length: 24

    me.b62Matrix = [
            [4, -1, -2, -2, 0, -1, -1, 0, -2, -1, -1, -1, -1, -2, -1, 1, 0, -3, -2, 0, -2, -1, 0, -4],
            [-1, 5, 0, -2, -3, 1, 0, -2, 0, -3, -2, 2, -1, -3, -2, -1, -1, -3, -2, -3, -1, 0, -1, -4],
            [-2, 0, 6, 1, -3, 0, 0, 0, 1, -3, -3, 0, -2, -3, -2, 1, 0, -4, -2, -3, 3, 0, -1, -4],
            [-2, -2, 1, 6, -3, 0, 2, -1, -1, -3, -4, -1, -3, -3, -1, 0, -1, -4, -3, -3, 4, 1, -1, -4],
            [0, -3, -3, -3, 9, -3, -4, -3, -3, -1, -1, -3, -1, -2, -3, -1, -1, -2, -2, -1, -3, -3, -2, -4],
            [-1, 1, 0, 0, -3, 5, 2, -2, 0, -3, -2, 1, 0, -3, -1, 0, -1, -2, -1, -2, 0, 3, -1, -4],
            [-1, 0, 0, 2, -4, 2, 5, -2, 0, -3, -3, 1, -2, -3, -1, 0, -1, -3, -2, -2, 1, 4, -1, -4],
            [0, -2, 0, -1, -3, -2, -2, 6, -2, -4, -4, -2, -3, -3, -2, 0, -2, -2, -3, -3, -1, -2, -1, -4],
            [-2, 0, 1, -1, -3, 0, 0, -2, 8, -3, -3, -1, -2, -1, -2, -1, -2, -2, 2, -3, 0, 0, -1, -4],
            [-1, -3, -3, -3, -1, -3, -3, -4, -3, 4, 2, -3, 1, 0, -3, -2, -1, -3, -1, 3, -3, -3, -1, -4],
            [-1, -2, -3, -4, -1, -2, -3, -4, -3, 2, 4, -2, 2, 0, -3, -2, -1, -2, -1, 1, -4, -3, -1, -4],
            [-1, 2, 0, -1, -3, 1, 1, -2, -1, -3, -2, 5, -1, -3, -1, 0, -1, -3, -2, -2, 0, 1, -1, -4],
            [-1, -1, -2, -3, -1, 0, -2, -3, -2, 1, 2, -1, 5, 0, -2, -1, -1, -1, -1, 1, -3, -1, -1, -4],
            [-2, -3, -3, -3, -2, -3, -3, -3, -1, 0, 0, -3, 0, 6, -4, -2, -2, 1, 3, -1, -3, -3, -1, -4],
            [-1, -2, -2, -1, -3, -1, -1, -2, -2, -3, -3, -1, -2, -4, 7, -1, -1, -4, -3, -2, -2, -1, -2, -4],
            [1, -1, 1, 0, -1, 0, 0, 0, -1, -2, -2, 0, -1, -2, -1, 4, 1, -3, -2, -2, 0, 0, 0, -4],
            [0, -1, 0, -1, -1, -1, -1, -2, -2, -1, -1, -1, -1, -2, -1, 1, 5, -2, -2, 0, -1, -1, 0, -4],
            [-3, -3, -4, -4, -2, -2, -3, -2, -2, -3, -2, -3, -1, 1, -4, -3, -2, 11, 2, -3, -4, -3, -2, -4],
            [-2, -2, -2, -3, -2, -1, -2, -3, 2, -1, -1, -2, -1, 3, -3, -2, -2, 2, 7, -1, -3, -2, -1, -4],
            [0, -3, -3, -3, -1, -2, -2, -3, -3, 3, 1, -2, 1, -1, -2, -2, 0, -3, -1, 4, -3, -2, -1, -4],
            [-2, -1, 3, 4, -3, 0, 1, -1, 0, -3, -4, 0, -3, -3, -2, 0, -1, -4, -3, -3, 4, 1, -1, -4],
            [-1, 0, 0, 1, -3, 3, 4, -2, 0, -3, -3, 1, -1, -3, -1, 0, -1, -3, -2, -2, 1, 4, -1, -4],
            [0, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, 0, 0, -2, -1, -1, -1, -1, -1, -4],
            [-4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, 1],
        ];

    me.opts = {};
    me.opts['camera']             = 'perspective';        //perspective, orthographic
    me.opts['background']         = 'transparent';        //transparent, black, grey, white
    me.opts['color']              = 'chain';              //spectrum, secondary structure, charge, hydrophobic, conserved, chain, residue, atom, b factor, red, green, blue, magenta, yellow, cyan, white, grey, custom
    me.opts['proteins']           = 'ribbon';             //ribbon, strand, cylinder and plate, schematic, c alpha trace, b factor tube, lines, stick, ball and stick, sphere, nothing
    me.opts['sidec']              = 'nothing';            //lines, stick, ball and stick, sphere, nothing
    me.opts['nucleotides']        = 'nucleotide cartoon'; //nucleotide cartoon, o3 trace, schematic, lines, stick,
                                                              // nucleotides ball and stick, sphere, nothing
    me.opts['surface']            = 'nothing';            //Van der Waals surface, molecular surface, solvent accessible surface, nothing
    me.opts['opacity']            = '1.0';                //1.0, 0.9, 0.8, 0.7, 0.6, 0.5
    me.opts['wireframe']          = 'no';                 //yes, no
    me.opts['map']                = 'nothing';            //2fofc, fofc, nothing
    me.opts['mapwireframe']       = 'yes';                //yes, no
    me.opts['emmap']              = 'nothing';            //em, nothing
    me.opts['emmapwireframe']     = 'yes';                //yes, no
    me.opts['chemicals']          = 'stick';              //lines, stick, ball and stick, schematic, sphere, nothing
    me.opts['water']              = 'nothing';            //sphere, dot, nothing
    me.opts['ions']               = 'sphere';             //sphere, dot, nothing
    me.opts['hbonds']             = 'no';                 //yes, no
    //me.opts['stabilizer']           = 'no';                 //yes, no
    me.opts['ssbonds']            = 'yes';                 //yes, no
    me.opts['rotationcenter']     = 'molecule center';    //molecule center, pick center, display center
    me.opts['axis']               = 'no';                 //yes, no
    me.opts['fog']                = 'no';                 //yes, no
    me.opts['slab']               = 'no';                 //yes, no
    me.opts['pk']                 = 'residue';            //no, atom, residue, strand, chain
    me.opts['chemicalbinding']      = 'hide';               //show, hide

    if(me.cfg.align !== undefined) me.opts['color'] = 'identity';
    if(me.cfg.blast_rep_id !== undefined) me.opts['color'] = 'conservation';
    if(me.cfg.cid !== undefined) me.opts['color'] = 'atom';

    if(me.cfg.options !== undefined) jQuery.extend(me.opts, me.cfg.options);

    me.init();

    me.modifyIcn3d();


};

iCn3DUI.prototype = {

    constructor: iCn3DUI,

    init: function () { var me = this;
        me.bSelectResidue = false;
        me.bSelectAlignResidue = false;
        me.selectedResidues = {};

        me.bAnnoShown = false;
        me.bSetChainsAdvancedMenu = false;
        me.b2DShown = false;

        me.bCrashed = false;
        me.prevCommands = "";

        me.bAddCommands = true;
        me.bAddLogs = true;

        me.bNotLoadStructure = false;

        me.bInitial = true;

        //me.bInputfile = false;

        $("#" + me.pre + "dl_annotations").html('');
        $("#" + me.pre + "dl_2ddgm").html('');
    },

    // modify iCn3D function
    modifyIcn3d: function() {var me = this;
        me.modifyIcn3dshowPicking();
    },

    switchHighlightLevelUp: function() { var me = this;
          if(!me.icn3d.bShift && !me.icn3d.bCtrl) me.icn3d.removeHlObjects();

          if(me.icn3d.highlightlevel === 1) { // atom -> residue
              me.icn3d.highlightlevel = 2;

              var firstAtom = me.icn3d.getFirstAtomObj(me.icn3d.pickedAtomList);

              if(!me.icn3d.bShift && !me.icn3d.bCtrl) {
                  me.icn3d.hAtoms = me.icn3d.cloneHash(me.icn3d.residues[firstAtom.structure + '_' + firstAtom.chain + '_' + firstAtom.resi]);
            }
            else {
                me.icn3d.hAtoms = me.icn3d.unionHash(me.icn3d.hAtoms, me.icn3d.residues[firstAtom.structure + '_' + firstAtom.chain + '_' + firstAtom.resi]);
            }
          }
          else if(me.icn3d.highlightlevel === 2) { // residue -> strand
              me.icn3d.highlightlevel = 3;

              var firstAtom = me.icn3d.getFirstAtomObj(me.icn3d.pickedAtomList);
              if(!me.icn3d.bShift && !me.icn3d.bCtrl) {
                  me.icn3d.hAtoms = me.icn3d.cloneHash(me.icn3d.selectStrandHelixFromAtom(firstAtom));
            }
            else {
                me.icn3d.hAtoms = me.icn3d.unionHash(me.icn3d.hAtoms, me.icn3d.selectStrandHelixFromAtom(firstAtom));
            }
          }
          else if(me.icn3d.highlightlevel === 3) { // strand -> chain
              me.icn3d.highlightlevel = 4;

              var firstAtom = me.icn3d.getFirstAtomObj(me.icn3d.pickedAtomList);
              if(!me.icn3d.bShift && !me.icn3d.bCtrl) {
                  me.icn3d.hAtoms = me.icn3d.cloneHash(me.icn3d.chains[firstAtom.structure + '_' + firstAtom.chain]);
            }
            else {
                me.icn3d.hAtoms = me.icn3d.unionHash(me.icn3d.hAtoms, me.icn3d.chains[firstAtom.structure + '_' + firstAtom.chain]);
            }
          }
          else if(me.icn3d.highlightlevel === 4 || me.icn3d.highlightlevel === 5) { // chain -> structure
              me.icn3d.highlightlevel = 5;

              var firstAtom = me.icn3d.getFirstAtomObj(me.icn3d.pickedAtomList);

              if(!me.icn3d.bShift && !me.icn3d.bCtrl) me.icn3d.hAtoms = {};
              var chainArray = me.icn3d.structures[firstAtom.structure];
              for(var i = 0, il = chainArray.length; i < il; ++i) {
                  me.icn3d.hAtoms = me.icn3d.unionHash(me.icn3d.hAtoms, me.icn3d.chains[chainArray[i]]);
            }
          }

          me.icn3d.addHlObjects();
          me.updateHlAll();
    },

    switchHighlightLevelDown: function() { var me = this;
          me.icn3d.removeHlObjects();

          if( (me.icn3d.highlightlevel === 2 || me.icn3d.highlightlevel === 1) && Object.keys(me.icn3d.pickedAtomList).length === 1) { // residue -> atom
              me.icn3d.highlightlevel = 1;

              me.icn3d.hAtoms = me.icn3d.cloneHash(me.icn3d.pickedAtomList);
              if(!me.icn3d.bShift && !me.icn3d.bCtrl) {
                  me.icn3d.hAtoms = me.icn3d.cloneHash(me.icn3d.pickedAtomList);
            }
            else {
                me.icn3d.hAtoms = me.icn3d.unionHash(me.icn3d.hAtoms, me.icn3d.pickedAtomList);
            }
          }
          else if(me.icn3d.highlightlevel === 3) { // strand -> residue
            var residueHash = {};

            for(var i in me.icn3d.pickedAtomList) {
                residueid = me.icn3d.atoms[i].structure + '_' + me.icn3d.atoms[i].chain + '_' + me.icn3d.atoms[i].resi;
                residueHash[residueid] = 1;
            }

            if(Object.keys(residueHash).length === 1) {
                me.icn3d.highlightlevel = 2;

                var firstAtom = me.icn3d.getFirstAtomObj(me.icn3d.pickedAtomList);
                if(!me.icn3d.bShift && !me.icn3d.bCtrl) {
                    me.icn3d.hAtoms = me.icn3d.cloneHash(me.icn3d.residues[firstAtom.structure + '_' + firstAtom.chain + '_' + firstAtom.resi]);
                }
                else {
                    me.icn3d.hAtoms = me.icn3d.unionHash(me.icn3d.hAtoms, me.icn3d.residues[firstAtom.structure + '_' + firstAtom.chain + '_' + firstAtom.resi]);
                }
            }
          }
          else if(me.icn3d.highlightlevel === 4) { // chain -> strand
              me.icn3d.highlightlevel = 3;

              var firstAtom = me.icn3d.getFirstAtomObj(me.icn3d.pickedAtomList);
              if(!me.icn3d.bShift && !me.icn3d.bCtrl) {
                  me.icn3d.hAtoms = me.icn3d.cloneHash(me.icn3d.selectStrandHelixFromAtom(firstAtom));
              }
              else {
                  me.icn3d.hAtoms = me.icn3d.unionHash(me.icn3d.hAtoms, me.icn3d.selectStrandHelixFromAtom(firstAtom));
              }
          }
          else if(me.icn3d.highlightlevel === 5) { // structure -> chain
              me.icn3d.highlightlevel = 4;

              var firstAtom = me.icn3d.getFirstAtomObj(me.icn3d.pickedAtomList);
              if(!me.icn3d.bShift && !me.icn3d.bCtrl) {
                  me.icn3d.hAtoms = me.icn3d.cloneHash(me.icn3d.chains[firstAtom.structure + '_' + firstAtom.chain]);
            }
            else {
                me.icn3d.hAtoms = me.icn3d.unionHash(me.icn3d.hAtoms, me.icn3d.chains[firstAtom.structure + '_' + firstAtom.chain]);
            }
          }

          me.icn3d.addHlObjects();
          me.updateHlAll();
    },

    switchHighlightLevel: function() { var me = this;
      $(document).bind('keydown', function (e) {
        if(e.keyCode === 38) { // arrow up, select upper level of atoms
          e.preventDefault();

          if(Object.keys(me.icn3d.pickedAtomList).length == 0 || !me.icn3d.hAtoms.hasOwnProperty(me.icn3d.getFirstAtomObj(me.icn3d.pickedAtomList).serial)) {
              me.icn3d.pickedAtomList = me.icn3d.cloneHash(me.icn3d.hAtoms);
              //me.icn3d.pk = 2;
          }

          me.switchHighlightLevelUp();
          me.setLogCmd("highlight level up", true);
        }
        else if(e.keyCode === 40) { // arrow down, select down level of atoms
          e.preventDefault();

          if(Object.keys(me.icn3d.pickedAtomList).length == 0 || !me.icn3d.hAtoms.hasOwnProperty(me.icn3d.getFirstAtomObj(me.icn3d.pickedAtomList).serial)) {
              me.icn3d.pickedAtomList = me.icn3d.cloneHash(me.icn3d.hAtoms);
              //me.icn3d.pk = 2;
          }

          me.switchHighlightLevelDown();
          me.setLogCmd("highlight level down", true);
        }
      });
    },

    allCustomEvents: function() { var me = this;
      // add custom events here
    },

    setCustomDialogs: function() { var me = this;
        var html = "";

        return html;
    },

    modifyIcn3dshowPicking: function() {var me = this;
        iCn3D.prototype.showPicking = function(atom, x, y) {
          if(me.cfg.cid !== undefined) {
              this.pk = 1; // atom
          }
          else {
              // do not change the picking option
          }

          me.icn3d.highlightlevel = me.icn3d.pk;

          this.showPickingBase(atom, x, y);

          if(x !== undefined && y !== undefined) { // mouse over
            if(me.cfg.showmenu != undefined && me.cfg.showmenu == true) {
                y += me.MENU_HEIGHT;
            }

            var text = (this.pk == 1) ? atom.resn + atom.resi + '@' + atom.name : atom.resn + atom.resi;
            //if(me.cfg.align !== undefined) {
            if(Object.keys(me.icn3d.structures).length > 1) {
                text = atom.structure + ' ' + text;
                $("#" + me.pre + "popup").css("width", "100px");
            }
            else {
                $("#" + me.pre + "popup").css("width", "80px");
            }

            $("#" + me.pre + "popup").html(text);
            $("#" + me.pre + "popup").css("top", y).css("left", x+20).show();
          }
          else {
              // highlight the sequence background
              var idArray = this.id.split('_'); // id: div0_canvas
              me.pre = idArray[0] + "_";

              me.updateHlAll();

              var transformation = {};
              transformation.factor = this._zoomFactor;
              transformation.mouseChange = this.mouseChange;
              //transformation.quaternion = this.quaternion;
              transformation.quaternion = {};
              transformation.quaternion._x = parseFloat(this.quaternion._x).toPrecision(5);
              transformation.quaternion._y = parseFloat(this.quaternion._y).toPrecision(5);
              transformation.quaternion._z = parseFloat(this.quaternion._z).toPrecision(5);
              transformation.quaternion._w = parseFloat(this.quaternion._w).toPrecision(5);

              if(me.bAddCommands) {
                  this.commands.push('pickatom ' + atom.serial + '|||' + me.getTransformationStr(transformation));
                  this.optsHistory.push(this.cloneHash(this.opts));
                  this.optsHistory[this.optsHistory.length - 1].hlatomcount = Object.keys(this.hAtoms).length;

                  if(me.isSessionStorageSupported()) me.saveCommandsToSession();

                  me.STATENUMBER = this.commands.length;
              }

              this.logs.push('pickatom ' + atom.serial + ' (chain: ' + atom.structure + '_' + atom.chain + ', residue: ' + atom.resn + ', number: ' + atom.resi + ', atom: ' + atom.name + ')');
              if ( $( "#" + me.pre + "logtext" ).length )  {
                $("#" + me.pre + "logtext").val("> " + this.logs.join("\n> ") + "\n> ").scrollTop($("#" + me.pre + "logtext")[0].scrollHeight);
              }
          }
/*
          // add label
          var residueText = atom.resn + atom.resi;

          var text;
          if(me.cfg.cid !== undefined) {
              text = atom.name;
              this.pk = 1; // atom
          }
          else {
              text = residueText + '@' + atom.name;
              // do not change the picking option
              //this.pk = 2; // residue
          }

          var labels = {};
          labels['picking'] = [];

          var label = {};
          label.position = new THREE.Vector3(atom.coord.x + 1, atom.coord.y + 1, atom.coord.z + 1); // shifted by 1

          if(this.pk === 1) {
            label.text = text;
          }
          else if(this.pk === 2) {
            label.text = residueText;
          }

          label.background = "#CCCCCC";

          if(this.pk === 1 || this.pk === 2) {
              labels['picking'].push(label);

              //http://www.johannes-raida.de/tutorials/three.js/tutorial13/tutorial13.htm
              if(me.bMeasureDistance === undefined || !me.bMeasureDistance) this.createLabelRepresentation(labels);
          }
*/
        };
    },

    // ======= functions start==============
    // show3DStructure is the main function to show 3D structure
    show3DStructure: function() { var me = this;
      me.deferred = $.Deferred(function() {
        if(me.isSessionStorageSupported()) me.getCommandsBeforeCrash();

        me.setViewerWidthHeight();

        var width, height;

        if(me.cfg.width.toString().indexOf('%') !== -1) {
          width = me.WIDTH * me.cfg.width.substr(0, me.cfg.width.toString().indexOf('%')) / 100.0 - me.LESSWIDTH;
        }
        else {
          width = me.cfg.width;
        }

        if(me.cfg.height.toString().indexOf('%') !== -1) {
          height = me.HEIGHT * me.cfg.height.substr(0, me.cfg.height.toString().indexOf('%')) / 100.0 - me.EXTRAHEIGHT - me.LESSHEIGHT;
        }
        else {
          height = me.cfg.height;
        }

        me.realWidth = width;
        me.realHeight = height;

        me.setTopMenusHtml(me.divid);

        me.allEventFunctions();

        me.allCustomEvents();

        var extraHeight = 0;
        if(me.cfg.showmenu == undefined || me.cfg.showmenu) {
            //extraHeight += 2*me.MENU_HEIGHT;
            extraHeight += me.MENU_HEIGHT;
        }
        if(me.cfg.showcommand == undefined || me.cfg.showcommand) {
            extraHeight += me.CMD_HEIGHT;
        }

        if(me.cfg.showmenu != undefined && me.cfg.showmenu == false) {
          me.hideMenu();
        }
        else {
          me.showMenu();
        }

        if(me.cfg.showtitle != undefined && me.cfg.showtitle == false) {
          $("#" + me.pre + "title").hide();
        }
        else {
          $("#" + me.pre + "title").show();
        }

        $("#" + me.pre + "viewer").width(width).height(parseInt(height) + extraHeight);
        $("#" + me.pre + "canvas").width(width).height(parseInt(height));
        //$("#" + me.pre + "canvas").resizable(); // resizing behavor not good for canvas.

        me.icn3d = new iCn3D(me.pre + 'canvas');
        if(!me.isMobile()) me.icn3d.scaleFactor = 2.0;

        me.handleContextLost();

        me.icn3d.setWidthHeight(width, height);

        me.icn3d.ori_chemicalbinding = me.opts['chemicalbinding'];


        if(me.cfg.bCalphaOnly !== undefined) me.icn3d.bCalphaOnly = me.cfg.bCalphaOnly;

        //me.deferred = undefined; // sequential calls

        me.icn3d.opts = me.icn3d.cloneHash(me.opts);

        me.STATENUMBER = me.icn3d.commands.length;

        // If previously crashed, recover it
        if(me.isSessionStorageSupported() && me.bCrashed) {
            me.bCrashed = false;

            var loadCommand = me.commandsBeforeCrash.split('|||')[0];
            var id = loadCommand.substr(loadCommand.lastIndexOf(' ') + 1);

            // reload only if viewing the same structure
            if(id === me.cfg.mmtfid || id === me.cfg.pdbid || id === me.cfg.mmdbid || id === me.cfg.gi  || id === me.cfg.blast_rep_id || id === me.cfg.cid || id === me.cfg.mmcifid || id === me.cfg.align) {
                me.loadScript(me.commandsBeforeCrash, true);

                return;
            }
        }

        me.icn3d.molTitle = '';

        if(me.cfg.url !== undefined) {
            var type_url = me.cfg.url.split('|');
            var type = type_url[0];
            var url = type_url[1];

            me.icn3d.molTitle = "";
            me.inputid = undefined;

            me.setLogCmd('load url ' + url + ' | type ' + type, true);

            me.downloadUrl(url, type);
        }
        else if(me.cfg.mmtfid !== undefined) {
           me.inputid = me.cfg.mmtfid;

           me.setLogCmd('load mmtf ' + me.cfg.mmtfid, true);

           me.downloadMmtf(me.cfg.mmtfid);
        }
        else if(me.cfg.pdbid !== undefined) {
           me.inputid = me.cfg.pdbid;

           me.setLogCmd('load pdb ' + me.cfg.pdbid, true);

           me.downloadPdb(me.cfg.pdbid);
        }
        else if(me.cfg.mmdbid !== undefined) {
           me.inputid = me.cfg.mmdbid;

           me.setLogCmd('load mmdb ' + me.cfg.mmdbid + ' | parameters ' + me.cfg.inpara, true);

           me.downloadMmdb(me.cfg.mmdbid);
        }
        else if(me.cfg.gi !== undefined) {
           me.setLogCmd('load gi ' + me.cfg.gi, true);

           me.downloadGi(me.cfg.gi);
        }
        else if(me.cfg.blast_rep_id !== undefined) {
           me.setLogCmd('load seq_struct_ids ' + me.cfg.query_id + ',' + me.cfg.blast_rep_id, true);

           me.downloadBlast_rep_id(me.cfg.query_id + ',' + me.cfg.blast_rep_id);
        }
        else if(me.cfg.cid !== undefined) {
           me.inputid = me.cfg.cid;

           var url = "https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/" + me.inputid + "/description/jsonp";
           $.ajax({
              url: url,
              dataType: 'jsonp',
              tryCount : 0,
              retryLimit : 1,
              success: function(data) {
                  if(data.InformationList !== undefined && data.InformationList.Information !== undefined) me.icn3d.molTitle = data.InformationList.Information[0].Title;
              },
              error : function(xhr, textStatus, errorThrown ) {
                this.tryCount++;
                if (this.tryCount <= this.retryLimit) {
                    //try again
                    $.ajax(this);
                    return;
                }
                return;
              }
           });

            me.setLogCmd('load cid ' + me.cfg.cid, true);

            me.downloadCid(me.cfg.cid);
        }
        else if(me.cfg.mmcifid !== undefined) {
            me.inputid = me.cfg.mmcifid;

            me.setLogCmd('load mmcif ' + me.cfg.mmcifid, true);

            me.downloadMmcif(me.cfg.mmcifid);
        }
        else if(me.cfg.align !== undefined) {
            var alignArray = me.cfg.align.split(','); // e.g., 6 IDs: 103701,1,4,68563,1,167 [mmdbid1,biounit,molecule,mmdbid2,biounit,molecule], or 2IDs: 103701,68563 [mmdbid1,mmdbid2]

            if(alignArray.length === 6) {
                me.inputid = alignArray[0] + "_" + alignArray[3];
            }
            else if(alignArray.length === 2) {
                me.inputid = alignArray[0] + "_" + alignArray[1];
            }

            me.setLogCmd('load alignment ' + me.cfg.align + ' | parameters ' + me.cfg.inpara, true);

            me.downloadAlignment(me.cfg.align);
        }
        else if(me.cfg.command !== undefined && me.cfg.command !== '') {
            me.loadScript(me.cfg.command);
        }
        else {
            alert("Please use the \"File\" menu to retrieve a structure of interest or to display a local file.");
        }
      });

      return me.deferred.promise();
    },

    hideMenu: function() { var me = this;
      if($("#" + me.pre + "mnlist")[0] !== undefined) $("#" + me.pre + "mnlist")[0].style.display = "none";
      if($("#" + me.pre + "mnLogSection")[0] !== undefined) $("#" + me.pre + "mnLogSection")[0].style.display = "none";
      if($("#" + me.pre + "cmdlog")[0] !== undefined) $("#" + me.pre + "cmdlog")[0].style.display = "none";

      $("#" + me.pre + "title")[0].style.margin = "10px 0 0 10px";
    },

    showMenu: function() { var me = this;
      if($("#" + me.pre + "mnlist")[0] !== undefined) $("#" + me.pre + "mnlist")[0].style.display = "block";
      if($("#" + me.pre + "mnLogSection")[0] !== undefined) $("#" + me.pre + "mnLogSection")[0].style.display = "block";
      if($("#" + me.pre + "cmdlog")[0] !== undefined) $("#" + me.pre + "cmdlog")[0].style.display = "block";

      //if($("#" + me.pre + "title")[0] !== undefined) $("#" + me.pre + "title")[0].style.display = "block";
    },

    saveSelectionIfSelected: function (id, value) { var me = this;
      if(me.bSelectResidue || me.bSelectAlignResidue) {
          var name = $("#" + me.pre + "seq_command_name2").val().replace(/\s+/g, '_');
          //var description = $("#" + me.pre + "seq_command_desc2").val();

          if(name === "") {
            name = $("#" + me.pre + "alignseq_command_name").val().replace(/\s+/g, '_');
            //description = $("#" + me.pre + "alignseq_command_desc").val();
          }

          if(name !== "") me.saveSelection(name, name);

          me.bSelectResidue = false;
          me.bSelectAlignResidue = false;
      }
    },

    setOption: function (id, value) { var me = this;
      //var options2 = {};
      //options2[id] = value;

      // remember the options
      me.icn3d.opts[id] = value;

      me.saveSelectionIfSelected();

      if(id === 'color') {
          me.icn3d.setColorByOptions(me.icn3d.opts, me.icn3d.hAtoms);

          me.icn3d.draw();

          var residueHash = me.icn3d.getResiduesFromCalphaAtoms(me.icn3d.hAtoms);
          me.changeSeqColor(Object.keys(residueHash));
      }
      else if(id === 'surface' || id === 'opacity' || id === 'wireframe') {
          if(id === 'opacity' || id === 'wireframe') {
              me.icn3d.removeLastSurface();
          }
          me.icn3d.applySurfaceOptions();
          //me.icn3d.render();
          me.icn3d.draw(); // to make surface work in assembly
      }
      else if(id === 'map' || id === 'mapwireframe') {
          if(id === 'mapwireframe') {
              me.icn3d.removeLastMap();
          }

          me.icn3d.applyMapOptions();

          //me.icn3d.render();
          me.icn3d.draw(); // to make surface work in assembly
      }
      else if(id === 'emmap' || id === 'emmapwireframe') {
          if(id === 'emmapwireframe') {
              me.icn3d.removeLastEmmap();
          }

          me.icn3d.applyEmmapOptions();

          //me.icn3d.render();
          me.icn3d.draw(); // to make surface work in assembly
      }
      else if(id === 'chemicalbinding') {
          me.icn3d.bSkipChemicalbinding = false;
          me.icn3d.draw();
      }
      else {
          me.icn3d.draw();
      }
    },

    setStyle: function (selectionType, style) { var me = this;
      var atoms = {};
      switch (selectionType) {
          case 'proteins':
              atoms = me.icn3d.intHash(me.icn3d.hAtoms, me.icn3d.proteins);
              break;
          case 'sidec':
              atoms = me.icn3d.intHash(me.icn3d.hAtoms, me.icn3d.sidec);
              calpha_atoms = me.icn3d.intHash(me.icn3d.hAtoms, me.icn3d.calphas);
              // include calphas
              atoms = me.icn3d.unionHash(atoms, calpha_atoms);
              break;
          case 'nucleotides':
              atoms = me.icn3d.intHash(me.icn3d.hAtoms, me.icn3d.nucleotides);
              break;
          case 'chemicals':
              atoms = me.icn3d.intHash(me.icn3d.hAtoms, me.icn3d.chemicals);
              break;
          case 'ions':
              atoms = me.icn3d.intHash(me.icn3d.hAtoms, me.icn3d.ions);
              break;
          case 'water':
              atoms = me.icn3d.intHash(me.icn3d.hAtoms, me.icn3d.water);
              break;
      }

      // draw sidec separatedly
      if(selectionType === 'sidec') {
          for(var i in atoms) {
            me.icn3d.atoms[i].style2 = style;
          }
      }
      else {
          for(var i in atoms) {
            me.icn3d.atoms[i].style = style;
          }
      }

      me.icn3d.opts[selectionType] = style;

      me.saveSelectionIfSelected();

      me.icn3d.draw();
    },

    setLogCmd: function (str, bSetCommand, bAddLogs) { var me = this;
      if(str.trim() === '') return false;

      var pos = str.indexOf('|||');
      if(pos !== -1) str = str.substr(0, pos);

      var transformation = {};
      transformation.factor = me.icn3d._zoomFactor;
      transformation.mouseChange = me.icn3d.mouseChange;

      transformation.quaternion = {};
      transformation.quaternion._x = parseFloat(me.icn3d.quaternion._x).toPrecision(5);
      transformation.quaternion._y = parseFloat(me.icn3d.quaternion._y).toPrecision(5);
      transformation.quaternion._z = parseFloat(me.icn3d.quaternion._z).toPrecision(5);
      transformation.quaternion._w = parseFloat(me.icn3d.quaternion._w).toPrecision(5);

      if(bSetCommand) {
          // save the command only when it's not a history command, i.e., not in the process of going back and forth
          if(me.bAddCommands) {
              // If a new command was called, remove the forward commands and push to the command array
              if(me.STATENUMBER < me.icn3d.commands.length) {
                  var oldCommand = me.icn3d.commands[me.STATENUMBER - 1];
                  var pos = oldCommand.indexOf('|||');
                  if(str !== oldCommand.substr(0, pos)) {
                    me.icn3d.commands = me.icn3d.commands.slice(0, me.STATENUMBER);

                    me.icn3d.commands.push(str + '|||' + me.getTransformationStr(transformation));
                    me.icn3d.optsHistory.push(me.icn3d.cloneHash(me.icn3d.opts));
                    me.icn3d.optsHistory[me.icn3d.optsHistory.length - 1].hlatomcount = Object.keys(me.icn3d.hAtoms).length;

                    if(me.isSessionStorageSupported()) me.saveCommandsToSession();

                    me.STATENUMBER = me.icn3d.commands.length;
                  }
              }
              else {
                me.icn3d.commands.push(str + '|||' + me.getTransformationStr(transformation));

                me.icn3d.optsHistory.push(me.icn3d.cloneHash(me.icn3d.opts));
                if(me.icn3d.hAtoms !== undefined) me.icn3d.optsHistory[me.icn3d.optsHistory.length - 1].hlatomcount = Object.keys(me.icn3d.hAtoms).length;

                if(me.isSessionStorageSupported()) me.saveCommandsToSession();

                me.STATENUMBER = me.icn3d.commands.length;
              }
          }
      }

      if(me.bAddLogs && me.cfg.showcommand) {
          me.icn3d.logs.push(str);

          // move cursor to the end, and scroll to the end
          $("#" + me.pre + "logtext").val("> " + me.icn3d.logs.join("\n> ") + "\n> ").scrollTop($("#" + me.pre + "logtext")[0].scrollHeight);
      }

      me.adjustIcon();
    },

    renderStructure: function () {  var me = this;
      if(me.bInitial) {
          if(me.cfg.command !== undefined && me.cfg.command !== '') {
              me.icn3d.bRender = false;

              jQuery.extend(me.icn3d.opts, me.opts);
              me.icn3d.draw();
          }
          else {
              jQuery.extend(me.icn3d.opts, me.opts);
              me.icn3d.draw();
          }

          if(Object.keys(me.icn3d.structures).length > 1) {
              $("#" + me.pre + "alternate").show();
          }
          else {
              $("#" + me.pre + "alternate").hide();
          }
      }
      else {
          me.saveSelectionIfSelected();

          me.icn3d.draw();
      }

      if(me.bInitial && me.cfg.command !== undefined && me.cfg.command !== '') {
              me.icn3d.bRender = true;
              me.loadScript(me.cfg.command);
      }

      // display the structure right away. load the mns and sequences later
      setTimeout(function(){
          if(me.bInitial) {
              if(me.cfg.showsets !== undefined && me.cfg.showsets) {
                   me.showSets();
              }

              if(me.cfg.align !== undefined) {
                  var bShowHighlight = false;
                  seqObj = me.getAlignSequencesAnnotations(Object.keys(me.icn3d.alnChains), undefined, undefined, bShowHighlight);

                  $("#" + me.pre + "dl_sequence2").html(seqObj.sequencesHtml);
                  $("#" + me.pre + "dl_sequence2").width(me.RESIDUE_WIDTH * seqObj.maxSeqCnt + 200);
              }

              //me.setProtNuclLigInMenu();

              if(me.cfg.showanno !== undefined && me.cfg.showanno) {
                   var cmd = "view annotations";
                   me.setLogCmd(cmd, true);

                   me.showAnnotations();
/*
                   if(Object.keys(me.icn3d.proteins).length > 0) {
                      $.when(me.applyCommandAnnotationsAndCddSite(cmd)).then(function() {
                          // do something afterward
                      });
                   }
                   else {
                      me.applyCommandAnnotationsAndCddSiteBase(cmd);
                   }
*/
              }
          }
          else {
              me.updateHlAll();
          }

          me.bInitial = false;
      }, 0);
    },

    exportCustomAtoms: function () { var me = this;
       var html = "";

       var nameArray = (me.icn3d.defNames2Residues !== undefined) ? Object.keys(me.icn3d.defNames2Residues).sort() : [];

       for(var i = 0, il = nameArray.length; i < il; ++i) {
         var name = nameArray[i];
         var residueArray = me.icn3d.defNames2Residues[name];
         var description = me.icn3d.defNames2Descr[name];
         var command = me.icn3d.defNames2Command[name];
         command = command.replace(/,/g, ', ');

         html += name + "\tselect ";

         html += me.residueids2spec(residueArray);

         html += "\n";
       } // outer for

       nameArray = (me.icn3d.defNames2Atoms !== undefined) ? Object.keys(me.icn3d.defNames2Atoms).sort() : [];

       for(var i = 0, il = nameArray.length; i < il; ++i) {
         var name = nameArray[i];
         var atomArray = me.icn3d.defNames2Atoms[name];
         var description = me.icn3d.defNames2Descr[name];
         var command = me.icn3d.defNames2Command[name];
         command = command.replace(/,/g, ', ');

         var residueArray = me.atoms2residues(atomArray);

         if(residueArray.length > 0) {
             html += name + "\tselect ";
             html += me.residueids2spec(residueArray);

             html += "\n";
         }
       } // outer for

       return html;
    },

    atoms2residues: function(atomArray) { var me = this;
         var atoms = {};
         for(var j = 0, jl = atomArray.length; j < jl; ++j) {
             atoms[atomArray[j]] = 1;
         }

         var residueHash = me.icn3d.getResiduesFromCalphaAtoms(atoms);

         return Object.keys(residueHash);
    },

    residueids2spec: function(residueArray) { var me = this;
         var spec = "";

         if(residueArray !== undefined){
             var residueArraySorted = residueArray.sort(function(a, b) {
                        if(a !== '' && !isNaN(a)) {
                            return parseInt(a) - parseInt(b);
                        }
                        else {
                            var lastPosA = a.lastIndexOf('_');
                            var lastPosB = b.lastIndexOf('_');
                            if(a.substr(0, lastPosA) < b.substr(0, lastPosB)) return -1;
                            else if(a.substr(0, lastPosA) > b.substr(0, lastPosB)) return 1;
                            else if(a.substr(0, lastPosA) == b.substr(0, lastPosB)) {
                                if(parseInt(a.substr(lastPosA + 1)) < parseInt(b.substr(lastPosB + 1)) ) return -1;
                                else if(parseInt(a.substr(lastPosA + 1)) > parseInt(b.substr(lastPosB + 1)) ) return 1;
                                else if(parseInt(a.substr(lastPosA + 1)) == parseInt(b.substr(lastPosB + 1)) ) return 0;
                            }
                        }
                    });

             var prevChain = '', chain, prevResi = 0, resi, lastDashPos, firstDashPos, struturePart, chainPart;
             var startResi;
             var bMultipleStructures = (Object.keys(me.icn3d.structures).length == 1) ? false : true;
             for(var j = 0, jl = residueArraySorted.length; j < jl; ++j) {
                 var residueid = residueArraySorted[j];

                 lastDashPos = residueid.lastIndexOf('_');
                 chain = residueid.substr(0, lastDashPos);
                 resi = parseInt(residueid.substr(lastDashPos+1));

                 firstDashPos = prevChain.indexOf('_');
                 struturePart = prevChain.substr(0, firstDashPos);
                 chainPart = prevChain.substr(firstDashPos + 1);

                 if(prevChain !== chain) {
                     if(j > 0) {
                         if(prevResi === startResi) {
                             if(bMultipleStructures) {
                                 spec += '$' + struturePart + '.' + chainPart + ':' + startResi + ' or ';
                             }
                             else {
                                 spec += '.' + chainPart + ':' + startResi + ' or ';
                             }
                         }
                         else {
                             if(bMultipleStructures) {
                                 spec += '$' + struturePart + '.' + chainPart + ':' + startResi + '-' + prevResi + ' or ';
                             }
                             else {
                                 spec += '.' + chainPart + ':' + startResi + '-' + prevResi + ' or ';
                             }
                         }
                     }

                     startResi = resi;
                 }
                 else if(prevChain === chain) {
                     if(resi !== prevResi + 1) {
                         if(prevResi === startResi) {
                             if(bMultipleStructures) {
                                 spec += '$' + struturePart + '.' + chainPart + ':' + startResi + ' or ';
                             }
                             else {
                                 spec += '.' + chainPart + ':' + startResi + ' or ';
                             }
                         }
                         else {
                             if(bMultipleStructures) {
                                 spec += '$' + struturePart + '.' + chainPart + ':' + startResi + '-' + prevResi + ' or ';
                             }
                             else {
                                 spec += '.' + chainPart + ':' + startResi + '-' + prevResi + ' or ';
                             }
                         }

                         startResi = resi;
                     }
                 }

                 prevChain = chain;
                 prevResi = resi;
             }

             // last residue
             firstDashPos = prevChain.indexOf('_');
             struturePart = prevChain.substr(0, firstDashPos);
             chainPart = prevChain.substr(firstDashPos + 1);

             if(prevResi === startResi) {
                 if(bMultipleStructures) {
                     spec += '$' + struturePart + '.' + chainPart + ':' + startResi;
                 }
                 else {
                     spec += '.' + chainPart + ':' + startResi;
                 }
             }
             else {
                 if(bMultipleStructures) {
                     spec += '$' + struturePart + '.' + chainPart + ':' + startResi + '-' + prevResi;
                 }
                 else {
                     spec += '.' + chainPart + ':' + startResi + '-' + prevResi;
                 }
             }
         }

         return spec;
    },

    pickCustomSphere: function (radius) {   var me = this; // me.icn3d.pAtom is set already
//        me.removeHlMenus();

        var select = "select zone cutoff " + radius;

        var atomlistTarget = {};

        for(var i in me.icn3d.hAtoms) {
          atomlistTarget[i] = me.icn3d.atoms[i];
        }

        // select all atom, not just displayed atoms
        var atoms = me.icn3d.getAtomsWithinAtom(me.icn3d.atoms, atomlistTarget, parseFloat(radius));

        var residues = {}, atomArray = undefined;

        for (var i in atoms) {
            var atom = atoms[i];
            var residueid = atom.structure + '_' + atom.chain + '_' + atom.resi;
            residues[residueid] = 1;

            //atomArray.push(i);
        }

        var residueArray = Object.keys(residues);

        me.icn3d.hAtoms = {};
        for(var index = 0, indexl = residueArray.length; index < indexl; ++index) {
          var residueid = residueArray[index];
          for(var i in me.icn3d.residues[residueid]) {
            //var atom = me.icn3d.atoms[i];
            //atom.color = new THREE.Color(0xFF0000);

            //me.icn3d.atomPrevColors[i] = atom.color;

            me.icn3d.hAtoms[i] = 1;
          }
        }

        me.icn3d.dAtoms = me.icn3d.cloneHash(me.icn3d.atoms);

        var commandname, commanddesc;
          var firstAtom = me.icn3d.getFirstAtomObj(atomlistTarget);
          commandname = "sphere." + firstAtom.chain + ":" + me.icn3d.residueName2Abbr(firstAtom.resn.substr(0, 3)) + firstAtom.resi + "-" + $("#" + me.pre + "radius_aroundsphere").val() + "A";
          commanddesc = "select a sphere around currently selected " + Object.keys(me.icn3d.hAtoms).length + " atoms with a radius of " + radius + " angstrom";

        me.addCustomSelection(residueArray, commandname, commanddesc, select, true);

        var nameArray = [commandname];

        //me.changeCustomResidues(nameArray);

        me.saveSelectionIfSelected();

        me.icn3d.draw(); // show all neighbors, even not displayed before
    },

    // between the highlighted and the rest atoms
    showHbonds: function (threshold) { var me = this;
        me.icn3d.opts["hbonds"] = "yes";
        me.icn3d.opts["water"] = "dot";

        var select = 'hbonds ' + threshold;

       var complement = {};

       for(var i in me.icn3d.atoms) {
           if(!me.icn3d.hAtoms.hasOwnProperty(i) && me.icn3d.dAtoms.hasOwnProperty(i)) {
               complement[i] = me.icn3d.atoms[i];
           }
       }

        var firstAtom = me.icn3d.getFirstAtomObj(me.icn3d.hAtoms);

        if(Object.keys(complement).length > 0 && Object.keys(me.icn3d.hAtoms).length > 0) {
            var selectedAtoms = me.icn3d.calculateChemicalHbonds(complement, me.icn3d.intHash2Atoms(me.icn3d.dAtoms, me.icn3d.hAtoms), parseFloat(threshold) );

            var residues = {}, atomArray = undefined;

            for (var i in selectedAtoms) {
                var residueid = me.icn3d.atoms[i].structure + '_' + me.icn3d.atoms[i].chain + '_' + me.icn3d.atoms[i].resi;
                residues[residueid] = 1;

                //atomArray.push(i);

                //me.icn3d.atoms[i].style2 = 'stick';
            }

            me.icn3d.hAtoms = {};
            for(var resid in residues) {
                for(var i in me.icn3d.residues[resid]) {
                    me.icn3d.hAtoms[i] = 1;
                    me.icn3d.atoms[i].style2 = 'stick';
                    //me.icn3d.atoms[i].style2 = 'lines';
                }
            }

            var commandname = 'hbonds_' + firstAtom.serial;
            var commanddesc = 'all atoms that are hydrogen-bonded with the selected atoms';
            me.addCustomSelection(Object.keys(residues), commandname, commanddesc, select, true);

            var nameArray = [commandname];

            //me.changeCustomResidues(nameArray);

            me.saveSelectionIfSelected();

            //me.setStyle('sidec', 'ball and stick');

            me.icn3d.draw();
        }
    },

    // show all disulfide bonds
    showSsbonds: function () { var me = this;
         me.icn3d.opts["ssbonds"] = "yes";

         var select = 'disulfide bonds';

//         me.removeHlMenus();

         var residues = {}, atomArray = undefined;

         var structureArray = Object.keys(me.icn3d.structures);

         for(var s = 0, sl = structureArray.length; s < sl; ++s) {
             var structure = structureArray[s];

             if(me.icn3d.ssbondpnts[structure] === undefined) continue;

             for (var i = 0, lim = Math.floor(me.icn3d.ssbondpnts[structure].length / 2); i < lim; i++) {
                var res1 = me.icn3d.ssbondpnts[structure][2 * i], res2 = me.icn3d.ssbondpnts[structure][2 * i + 1];

                residues[res1] = 1;
                residues[res2] = 1;

                me.icn3d.hAtoms = me.icn3d.unionHash(me.icn3d.hAtoms, me.icn3d.residues[res1]);
                me.icn3d.hAtoms = me.icn3d.unionHash(me.icn3d.hAtoms, me.icn3d.residues[res2]);

            }
        }

        if(Object.keys(residues).length > 0) {
            var commandname = 'ssbonds';
            var commanddesc = 'all atoms that have disulfide bonds';
            me.addCustomSelection(Object.keys(residues), commandname, commanddesc, select, true);

            var nameArray = [commandname];

            //me.changeCustomResidues(nameArray);

            me.saveSelectionIfSelected();

            // show side chains for the selected atoms
            //me.setStyle('sidec', 'stick');

            me.icn3d.draw();
        }
    },

    addLine: function (x1, y1, z1, x2, y2, z2, color, dashed, type) { var me = this;
        var line = {}; // Each line contains 'position1', 'position2', 'color', and a boolean of 'dashed'
        line.position1 = new THREE.Vector3(x1, y1, z1);
        line.position2 = new THREE.Vector3(x2, y2, z2);
        line.color = color;
        line.dashed = dashed;

        if(me.icn3d.lines[type] === undefined) me.icn3d.lines[type] = [];

        if(type !== undefined) {
            me.icn3d.lines[type].push(line);
        }
        else {
            me.icn3d.lines['custom'].push(line);
        }

        me.icn3d.removeHlObjects();

        //me.icn3d.draw();
    },

    back: function () { var me = this;
      me.backForward = true;

      me.STATENUMBER--;

      // do not add to the array me.icn3d.commands
      me.bAddCommands = false;
      me.bAddLogs = false; // turn off log

      me.bNotLoadStructure = true;

      if(me.STATENUMBER < 1) {
        me.STATENUMBER = 1;
      }
      else {
        me.execCommands(0, me.STATENUMBER-1, me.STATENUMBER);
      }

      me.adjustIcon();

      me.bAddCommands = true;
      me.bAddLogs = true;
    },

    forward: function () { var me = this;
      me.backForward = true;

      me.STATENUMBER++;

      // do not add to the array me.icn3d.commands
      me.bAddCommands = false;
      me.bAddLogs = false; // turn off log

      me.bNotLoadStructure = true;

      if(me.STATENUMBER > me.icn3d.commands.length) {
        me.STATENUMBER = me.icn3d.commands.length;
      }
      else {
        me.execCommands(0, me.STATENUMBER-1, me.STATENUMBER);
      }

      me.adjustIcon();

      me.bAddCommands = true;
      me.bAddLogs = true;
    },

    toggleSelection: function () { var me = this;
        if(me.bHideSelection) {
            for(var i in me.icn3d.dAtoms) {
                if(me.icn3d.hAtoms.hasOwnProperty(i)) delete me.icn3d.dAtoms[i];
            }

              me.bHideSelection = false;
        }
        else {
            me.icn3d.dAtoms = me.icn3d.unionHash(me.icn3d.dAtoms, me.icn3d.hAtoms);

              me.bHideSelection = true;
        }

        me.icn3d.draw();
    },

    adjustIcon: function () { var me = this;
      if(me.STATENUMBER === 1) {
        if($("#" + me.pre + "back").hasClass('icn3d-middleIcon')) {
          $("#" + me.pre + "back").toggleClass('icn3d-middleIcon');
          $("#" + me.pre + "back").toggleClass('icn3d-endIcon');
        }
      }
      else {
        if($("#" + me.pre + "back").hasClass('icn3d-endIcon')) {
          $("#" + me.pre + "back").toggleClass('icn3d-middleIcon');
          $("#" + me.pre + "back").toggleClass('icn3d-endIcon');
        }
      }

      if(me.STATENUMBER === me.icn3d.commands.length) {
        if($("#" + me.pre + "forward").hasClass('icn3d-middleIcon')) {
          $("#" + me.pre + "forward").toggleClass('icn3d-middleIcon');
          $("#" + me.pre + "forward").toggleClass('icn3d-endIcon');
        }
      }
      else {
        if($("#" + me.pre + "forward").hasClass('icn3d-endIcon')) {
          $("#" + me.pre + "forward").toggleClass('icn3d-middleIcon');
          $("#" + me.pre + "forward").toggleClass('icn3d-endIcon');
        }
      }
    },

    toggle: function (id1, id2, id3, id4) { var me = this;
      $("#" + id1).toggleClass('ui-icon-plus');
      $("#" + id1).toggleClass('ui-icon-minus');

      $("#" + id2).toggleClass('ui-icon-plus');
      $("#" + id2).toggleClass('ui-icon-minus');

      $("#" + id1).toggleClass('icn3d-shown');
      $("#" + id1).toggleClass('icn3d-hidden');

      $("#" + id2).toggleClass('icn3d-shown');
      $("#" + id2).toggleClass('icn3d-hidden');

      $("#" + id3).toggleClass('icn3d-shown');
      $("#" + id3).toggleClass('icn3d-hidden');

      $("#" + id4).toggleClass('icn3d-shown');
      $("#" + id4).toggleClass('icn3d-hidden');
    },

    selectComplement: function() { var me = this;
           var complement = {};
           //var residueHash = {}, chainHash = {};
           //var residueid, chainid;

           for(var i in me.icn3d.atoms) {
               if(!me.icn3d.hAtoms.hasOwnProperty(i)) {
                   complement[i] = 1;
                   //chainid = me.icn3d.atoms[i].structure + '_' + me.icn3d.atoms[i].chain;
                   //residueid = chainid + '_' + me.icn3d.atoms[i].resi;
                   //chainHash[chainid] =1;
                   //residueHash[residueid] = 1;
               }
           }

           me.icn3d.hAtoms = me.icn3d.cloneHash(complement);

           //me.highlightResidues(Object.keys(residueHash), Object.keys(chainHash));
           me.updateHlAll();
    },

    saveCommandsToSession: function() { var me = this;
        var dataStr = me.icn3d.commands.join('\n');
        var data = decodeURIComponent(dataStr);

        sessionStorage.setItem('commands', data);
    },

    addChainLabels: function (atoms) { var me = this;
        var size = 18;
        var background = "#CCCCCC";

        var atomsHash = me.icn3d.intHash(me.icn3d.hAtoms, atoms);

        if(me.icn3d.labels['chain'] === undefined) me.icn3d.labels['chain'] = [];

        var chainHash = me.icn3d.getChainsFromAtoms(atomsHash);

        for(var chainid in chainHash) {
            var label = {};

            label.position = me.icn3d.centerAtoms(me.icn3d.chains[chainid]).center;

            var pos = chainid.indexOf('_');
            var chainName = chainid.substr(pos + 1);
            var proteinName = me.getProteinName(chainid);
            if(proteinName.length > 20) proteinName = proteinName.substr(0, 20) + '...';

            label.text = 'Chain ' + chainName + ': ' + proteinName;
            label.size = size;

            var atomColorStr = me.icn3d.getFirstCalphaAtomObj(me.icn3d.chains[chainid]).color.getHexString().toUpperCase();
            label.color = (atomColorStr === "CCCCCC" || atomColorStr === "C8C8C8") ? "#888888" : "#" + atomColorStr;
            label.background = background;

            me.icn3d.labels['chain'].push(label);
        }

        me.icn3d.removeHlObjects();
    },

    addTerminiLabels: function (atoms) { var me = this;
        var size = 18;
        var background = "#CCCCCC";

        var protNucl = me.icn3d.unionHash(me.icn3d.proteins, me.icn3d.nucleotides);
        var hlProtNucl = me.icn3d.intHash(me.icn3d.dAtoms, protNucl);
        var atomsHash = me.icn3d.intHash(hlProtNucl, atoms);

        if(me.icn3d.labels['chain'] === undefined) me.icn3d.labels['chain'] = [];

        var chainHash = me.icn3d.getChainsFromAtoms(atomsHash);

        for(var chainid in chainHash) {
            var chainAtomsHash = me.icn3d.intHash(hlProtNucl, me.icn3d.chains[chainid]);
            var serialArray = Object.keys(chainAtomsHash);
            var firstAtom = me.icn3d.atoms[serialArray[0]];
            var lastAtom = me.icn3d.atoms[serialArray[serialArray.length - 1]];

            var labelN = {}, labelC = {};

            labelN.position = firstAtom.coord;
            labelC.position = lastAtom.coord;

            labelN.text = 'N-';
            labelC.text = 'C-';

            if(me.icn3d.nucleotides.hasOwnProperty(firstAtom.serial)) {
                labelN.text = "5'";
                labelC.text = "3'";
            }

            labelN.size = size;
            labelC.size = size;

            var atomNColorStr = firstAtom.color.getHexString().toUpperCase();
            var atomCColorStr = lastAtom.color.getHexString().toUpperCase();

            labelN.color = (atomNColorStr === "CCCCCC" || atomNColorStr === "C8C8C8") ? "#888888" : "#" + atomNColorStr;
            labelC.color = (atomCColorStr === "CCCCCC" || atomCColorStr === "C8C8C8") ? "#888888" : "#" + atomCColorStr;

            labelN.background = background;
            labelC.background = background;

            me.icn3d.labels['chain'].push(labelN);
            me.icn3d.labels['chain'].push(labelC);
        }

        me.icn3d.removeHlObjects();
    },

    //http://jasonjl.me/blog/2015/06/21/taking-action-on-browser-crashes/
    getCommandsBeforeCrash: function() { var me = this;
       window.addEventListener('load', function () {
          sessionStorage.setItem('good_exit', 'pending');
       });

       window.addEventListener('beforeunload', function () {
          sessionStorage.setItem('good_exit', 'true');
       });

       if(sessionStorage.getItem('good_exit') && sessionStorage.getItem('good_exit') === 'pending') {
          if(!me.isMac()) me.bCrashed = true;  // this doesn't work in mac
          me.commandsBeforeCrash = sessionStorage.getItem('commands');
          if(!me.commandsBeforeCrash) me.commandsBeforeCrash = '';
       }
    },

    addLineFromPicking: function(type) { var me = this;
             var size = 0, color, background = 0;
             var color = $("#" + me.pre + type + "color" ).val();

             var x = (me.icn3d.pAtom.coord.x + me.icn3d.pAtom2.coord.x) / 2;
             var y = (me.icn3d.pAtom.coord.y + me.icn3d.pAtom2.coord.y) / 2;
             var z = (me.icn3d.pAtom.coord.z + me.icn3d.pAtom2.coord.z) / 2;

             var dashed = (type == 'stabilizer') ? false : true;

             me.setLogCmd('add line | x1 ' + me.icn3d.pAtom.coord.x.toPrecision(4)  + ' y1 ' + me.icn3d.pAtom.coord.y.toPrecision(4) + ' z1 ' + me.icn3d.pAtom.coord.z.toPrecision(4) + ' | x2 ' + me.icn3d.pAtom2.coord.x.toPrecision(4)  + ' y2 ' + me.icn3d.pAtom2.coord.y.toPrecision(4) + ' z2 ' + me.icn3d.pAtom2.coord.z.toPrecision(4) + ' | color ' + color + ' | dashed ' + dashed + ' | type ' + type, true);

             me.addLine(me.icn3d.pAtom.coord.x, me.icn3d.pAtom.coord.y, me.icn3d.pAtom.coord.z, me.icn3d.pAtom2.coord.x, me.icn3d.pAtom2.coord.y, me.icn3d.pAtom2.coord.z, color, dashed, type);

             me.icn3d.pickpair = false;
    },

    setEntrezLinks: function(db) { var me = this;
      var structArray = Object.keys(me.icn3d.structures);

      var url;

      if(structArray.length === 1) {
          url = "https://www.ncbi.nlm.nih.gov/" + db + "/?term=" + structArray[0];
          me.setLogCmd("Entrez " + db + " about PDB " + structArray[0] + ": " + url, false);

          window.open(url, '_blank');
      }
      else if(structArray.length === 2) {
          url = "https://www.ncbi.nlm.nih.gov/" + db + "/?term=" + structArray[0] + " OR " + structArray[1];
          me.setLogCmd("Entrez " + db + " about PDB " + structArray[0] + " OR " + structArray[1] + ": " + url, false);

          window.open(url, '_blank');
      }
    },

    shareLink: function() { var me = this;
           var url = me.shareLinkUrl();

           if(me.bInputfile) {
               alert("Share Link does NOT work when the data is from custom files. Please save 'iCn3D PNG Image' in the File menu and open it in iCn3D.");
               return;
           }

            if(url.length > 4000) {
               alert("The url is more than 4000 characters and may not work. Please save 'iCn3D PNG Image' or 'State File' and open them in iCn3D.");
               return;
           }


           me.setLogCmd("share link: " + url, false);

           //window.open(url, '_blank');

/*
           //https://gist.github.com/hayageek/4584508
           var request = gapi.client.urlshortener.url.insert({
                'resource': {
                  'longUrl': url
                }
           });
           request.execute(function(response) {
                var shorturl = 'Problem in getting shortened URL';
                if(response.id !== undefined) {
                    shorturl = response.id;
                }

                $("#" + me.pre + "ori_url").val(url);
                $("#" + me.pre + "short_url").val(shorturl);

                me.openDialog(me.pre + 'dl_copyurl', 'Copy a Share Link URL');
           });
*/

           //https://firebase.google.com/docs/dynamic-links/rest
           //Web API Key: AIzaSyBxl9CgM0dY5lagHL4UOhEpLWE1fuwdnvc
           var fdlUrl = "https://firebasedynamiclinks.googleapis.com/v1/shortLinks?key=AIzaSyBxl9CgM0dY5lagHL4UOhEpLWE1fuwdnvc";
           $.ajax({
              url: fdlUrl,
              type: 'POST',
              //data : {'longDynamicLink': 'https://d55qc.app.goo.gl/?link=' + url, "suffix": {"option": "SHORT"}},
              //data : {'longDynamicLink': 'https://d55qc.app.goo.gl/?link=' + encodeURIComponent(url)},
              data : {'longDynamicLink': 'https://icn3d.page.link/?link=' + encodeURIComponent(url)},
              dataType: 'json',
              success: function(data) {
                var shorturl = 'Problem in getting shortened URL';
                if(data.shortLink !== undefined) {
                    shorturl = data.shortLink;
                }

                $("#" + me.pre + "ori_url").val(url);
                $("#" + me.pre + "short_url").val(shorturl);

                me.openDialog(me.pre + 'dl_copyurl', 'Copy a Share Link URL');
              },
              error : function(xhr, textStatus, errorThrown ) {
                var shorturl = 'Problem in getting shortened URL';

                $("#" + me.pre + "ori_url").val(url);
                $("#" + me.pre + "short_url").val(shorturl);

                me.openDialog(me.pre + 'dl_copyurl', 'Copy a Share Link URL');
              }
           });
    },

    exportInteractions: function() { var me = this;
       var text = '<html><body><b>Interacting residues</b>:<br/><table border=1 cellpadding=0 cellspacing=0><tr><th>Base Chain: Residues</th><th>Interacting Chain</th></tr>';

       //me.chainids2resids[fisrtChainid][secondChainid].push(resid);
/*
       for(var fisrtChainid in me.chainids2resids) {
           for(var secondChainid in me.chainids2resids[fisrtChainid]) {
               text += '<tr><td>' + fisrtChainid + ': ';
               text += me.residueids2spec(me.chainids2resids[fisrtChainid][secondChainid]);
               text += '</td><td>' + secondChainid + '</td></tr>';
           }
       }
*/

       for(var fisrtChainid in me.chainname2residues) {
           for(var name in me.chainname2residues[fisrtChainid]) {
               var secondChainid = fisrtChainid.substr(0, fisrtChainid.indexOf('_')) + '_' + name.substr(0, name.indexOf(' '));
               text += '<tr><td>' + fisrtChainid + ': ';
               text += me.residueids2spec(me.chainname2residues[fisrtChainid][name]);
               text += '</td><td>' + secondChainid + '</td></tr>';
           }
       }

       text += '</table><br/></body></html>';

       var file_pref = (me.inputid) ? me.inputid : "custom";
       me.saveFile(file_pref + '_interactions.html', 'html', text);
    },

    saveColor: function() { var me = this;
       for(var i in me.icn3d.atoms) {
           var atom = me.icn3d.atoms[i];
           atom.colorSave = atom.color.clone();
       }
    },

    applySavedColor: function() { var me = this;
       for(var i in me.icn3d.atoms) {
           var atom = me.icn3d.atoms[i];
           if(atom.colorSave !== undefined) {
               atom.color = atom.colorSave.clone();
           }
       }

       me.icn3d.draw();

       me.changeSeqColor(Object.keys(me.icn3d.residues));
    },

    saveStyle: function() { var me = this;
       for(var i in me.icn3d.atoms) {
           var atom = me.icn3d.atoms[i];
           atom.styleSave = atom.style;
           if(atom.style2 !== undefined) atom.style2Save = atom.style2;
       }
    },

    applySavedStyle: function() { var me = this;
       for(var i in me.icn3d.atoms) {
           var atom = me.icn3d.atoms[i];
           if(atom.styleSave !== undefined) {
               atom.style = atom.styleSave;
           }
           if(atom.style2Save !== undefined) {
               atom.style2 = atom.style2Save;
           }
       }

       me.icn3d.draw();
    },

    // ====== functions end ===============

    // ====== events start ===============
    // back and forward arrows
    clickBack: function() { var me = this;
        $("#" + me.pre + "back").add("#" + me.pre + "mn6_back").click(function(e) {
           e.preventDefault();

           me.setLogCmd("back", false);
           me.back();
        });
    },

    clickForward: function() { var me = this;
        $("#" + me.pre + "forward").add("#" + me.pre + "mn6_forward").click(function(e) {
           e.preventDefault();

           me.setLogCmd("forward", false);
           me.forward();
        });
    },

    clickToggle: function() { var me = this;
        $("#" + me.pre + "toggle").add("#" + me.pre + "mn2_toggle").click(function(e) {
           //me.setLogCmd("toggle selection", true);
           me.toggleSelection();
           me.setLogCmd("toggle selection", true);
        });
    },

    clickHlColorYellow: function() { var me = this;
        $("#" + me.pre + "mn2_hl_clrYellow").click(function(e) {
           me.setLogCmd("set highlight color yellow", true);
           me.icn3d.hColor = new THREE.Color(0xFFFF00);
           me.icn3d.matShader = me.icn3d.setOutlineColor('yellow');
           me.icn3d.draw(); // required to make it work properly
        });
    },

    clickHlColorGreen: function() { var me = this;
        $("#" + me.pre + "mn2_hl_clrGreen").click(function(e) {
           me.setLogCmd("set highlight color green", true);
           me.icn3d.hColor = new THREE.Color(0x00FF00);
           me.icn3d.matShader = me.icn3d.setOutlineColor('green');
           me.icn3d.draw(); // required to make it work properly
        });
    },

    clickHlColorRed: function() { var me = this;
        $("#" + me.pre + "mn2_hl_clrRed").click(function(e) {
           me.setLogCmd("set highlight color red", true);
           me.icn3d.hColor = new THREE.Color(0xFF0000);
           me.icn3d.matShader = me.icn3d.setOutlineColor('red');
           me.icn3d.draw(); // required to make it work properly
        });
    },

    clickHlStyleOutline: function() { var me = this;
        $("#" + me.pre + "mn2_hl_styleOutline").click(function(e) {
           me.setLogCmd("set highlight style outline", true);
           me.icn3d.bHighlight = 1;

           me.showHighlight();

           //me.icn3d.draw();
        });
    },

    clickHlStyleObject: function() { var me = this;
        $("#" + me.pre + "mn2_hl_styleObject").click(function(e) {
           me.setLogCmd("set highlight style 3d", true);
           me.icn3d.bHighlight = 2;

           me.showHighlight();

           //me.icn3d.draw();
        });
    },

    clickHlStyleNone: function() { var me = this;
        $("#" + me.pre + "mn2_hl_styleNone").click(function (e) {
            e.stopImmediatePropagation();

            me.clearHighlight();

            me.setLogCmd("clear selection", true);
        });
    },

    clickAlternate: function() { var me = this;
        $("#" + me.pre + "alternate").add("#" + me.pre + "mn2_alternate").click(function(e) {
           //me.setLogCmd("alternate structures", false);
           me.icn3d.bAlternate = true;

           me.icn3d.alternateStructures();

           me.icn3d.bAlternate = false;
           me.setLogCmd("alternate structures", false);
        });
    },

    //mn 1
    clkMn1_mmtfid: function() { var me = this;
        $("#" + me.pre + "mn1_mmtfid").click(function(e) {
           me.openDialog(me.pre + 'dl_mmtfid', 'Please input MMTF ID');
        });
    },

    clkMn1_pdbid: function() { var me = this;
        $("#" + me.pre + "mn1_pdbid").click(function(e) {
           me.openDialog(me.pre + 'dl_pdbid', 'Please input PDB ID');
        });
    },

    clkMn1_align: function() { var me = this;
        $("#" + me.pre + "mn1_align").click(function(e) {
           me.openDialog(me.pre + 'dl_align', 'Align two 3D structures');
        });
    },

    clkMn1_pdbfile: function() { var me = this;
        $("#" + me.pre + "mn1_pdbfile").click(function(e) {
           me.openDialog(me.pre + 'dl_pdbfile', 'Please input PDB File');
        });
    },

    clkMn1_mol2file: function() { var me = this;
        $("#" + me.pre + "mn1_mol2file").click(function(e) {
           me.openDialog(me.pre + 'dl_mol2file', 'Please input Mol2 File');
        });
    },
    clkMn1_sdffile: function() { var me = this;
        $("#" + me.pre + "mn1_sdffile").click(function(e) {
           me.openDialog(me.pre + 'dl_sdffile', 'Please input SDF File');
        });
    },
    clkMn1_xyzfile: function() { var me = this;
        $("#" + me.pre + "mn1_xyzfile").click(function(e) {
           me.openDialog(me.pre + 'dl_xyzfile', 'Please input XYZ File');
        });
    },
    clkMn1_urlfile: function() { var me = this;
        $("#" + me.pre + "mn1_urlfile").click(function(e) {
           me.openDialog(me.pre + 'dl_urlfile', 'Load data by URL');
        });
    },

    clkMn1_mmciffile: function() { var me = this;
        $("#" + me.pre + "mn1_mmciffile").click(function(e) {
           me.openDialog(me.pre + 'dl_mmciffile', 'Please input mmCIF File');
        });
    },

    clkMn1_mmcifid: function() { var me = this;
        $("#" + me.pre + "mn1_mmcifid").click(function(e) {
           me.openDialog(me.pre + 'dl_mmcifid', 'Please input mmCIF ID');
        });
    },

    clkMn1_mmdbid: function() { var me = this;
        $("#" + me.pre + "mn1_mmdbid").click(function(e) {
           me.openDialog(me.pre + 'dl_mmdbid', 'Please input MMDB ID');
        });
    },

    clkMn1_blast_rep_id: function() { var me = this;
        $("#" + me.pre + "mn1_blast_rep_id").click(function(e) {
           me.openDialog(me.pre + 'dl_blast_rep_id', 'Align sequence to structure');
        });
    },

    clkMn1_gi: function() { var me = this;
        $("#" + me.pre + "mn1_gi").click(function(e) {
           me.openDialog(me.pre + 'dl_gi', 'Please input protein gi');
        });
    },

    clkMn1_cid: function() { var me = this;
        $("#" + me.pre + "mn1_cid").click(function(e) {
           me.openDialog(me.pre + 'dl_cid', 'Please input PubChem CID');
        });
    },

    clkMn1_pngimage: function() { var me = this;
        $("#" + me.pre + "mn1_pngimage").click(function(e) {
           me.openDialog(me.pre + 'dl_pngimage', 'Please input the PNG image');
        });
    },

    clkMn1_state: function() { var me = this;
        $("#" + me.pre + "mn1_state").click(function(e) {
           me.openDialog(me.pre + 'dl_state', 'Please input the state file');
        });
    },

    clkMn1_selection: function() { var me = this;
        $("#" + me.pre + "mn1_selection").click(function(e) {
           me.openDialog(me.pre + 'dl_selection', 'Please input the selection file');
        });
    },

    clkMn1_exportState: function() { var me = this;
        $("#" + me.pre + "mn1_exportState").click(function (e) {
           me.setLogCmd("export state file", false);

           var file_pref = (me.inputid) ? me.inputid : "custom";
           me.saveFile(file_pref + '_statefile.txt', 'command');
        });
    },

    exportStlFile: function(postfix) { var me = this;
       // assemblies
       if(me.icn3d.biomtMatrices !== undefined && me.icn3d.biomtMatrices.length > 1 && me.icn3d.bAssembly) {
            // use a smaller grid to build the surface for assembly
            me.icn3d.threshbox = 180 / Math.pow(me.icn3d.biomtMatrices.length, 0.33);

            me.icn3d.removeSurfaces();
            me.icn3d.applySurfaceOptions();

            me.icn3d.removeMaps();
            me.icn3d.applyMapOptions();

            me.icn3d.removeEmmaps();
            me.icn3d.applyEmmapOptions();
       }

       var text = me.saveStlFile();
       var file_pref = (me.inputid) ? me.inputid : "custom";
       me.saveFile(file_pref + postfix + '.stl', 'binary', text);

       // assemblies
       if(me.icn3d.biomtMatrices !== undefined && me.icn3d.biomtMatrices.length > 1 && me.icn3d.bAssembly
         && Object.keys(me.icn3d.dAtoms).length * me.icn3d.biomtMatrices.length > me.icn3d.maxAtoms3DMultiFile ) {
            alert(me.icn3d.biomtMatrices.length + " files will be generated for this assembly. Please merge these files using some software and 3D print the merged file.");

            var identity = new THREE.Matrix4();
            identity.identity();

            var index = 1;
            for (var i = 0; i < me.icn3d.biomtMatrices.length; i++) {  // skip itself
              var mat = me.icn3d.biomtMatrices[i];
              if (mat === undefined) continue;

              // skip itself
              if(mat.equals(identity)) continue;

              var time = (i + 1) * 100;

              //https://stackoverflow.com/questions/1190642/how-can-i-pass-a-parameter-to-a-settimeout-callback
              setTimeout(function(mat, index){
                  text = me.saveStlFile(mat);
                  me.saveFile(file_pref + postfix + index + '.stl', 'binary', text);
                  text = '';
              }.bind(this, mat, index), time);

              ++index;
            }

            // reset grid to build the surface for assembly
            me.icn3d.threshbox = 180;
       }
    },

    exportVrmlFile: function(postfix) { var me = this;
       // assemblies
       if(me.icn3d.biomtMatrices !== undefined && me.icn3d.biomtMatrices.length > 1 && me.icn3d.bAssembly) {
            // use a smaller grid to build the surface for assembly
            me.icn3d.threshbox = 180 / Math.pow(me.icn3d.biomtMatrices.length, 0.33);

            me.icn3d.removeSurfaces();
            me.icn3d.applySurfaceOptions();

            me.icn3d.removeMaps();
            me.icn3d.applyMapOptions();

            me.icn3d.removeEmmaps();
            me.icn3d.applyEmmapOptions();
       }

       var text = me.saveVrmlFile();
       var file_pref = (me.inputid) ? me.inputid : "custom";
       //me.saveFile(file_pref + postfix + '.wrl', 'text', text);
       me.saveFile(file_pref + postfix + '.vrml', 'text', text);

       // assemblies
       if(me.icn3d.biomtMatrices !== undefined && me.icn3d.biomtMatrices.length > 1 && me.icn3d.bAssembly
         && Object.keys(me.icn3d.dAtoms).length * me.icn3d.biomtMatrices.length > me.icn3d.maxAtoms3DMultiFile ) {
            alert(me.icn3d.biomtMatrices.length + " files will be generated for this assembly. Please merge these files using some software and 3D print the merged file.");

            var identity = new THREE.Matrix4();
            identity.identity();

            var index = 1;
            for (var i = 0; i < me.icn3d.biomtMatrices.length; i++) {  // skip itself
              var mat = me.icn3d.biomtMatrices[i];
              if (mat === undefined) continue;

              // skip itself
              if(mat.equals(identity)) continue;

              var time = (i + 1) * 100;

              //https://stackoverflow.com/questions/1190642/how-can-i-pass-a-parameter-to-a-settimeout-callback
              setTimeout(function(mat, index){
                  text = me.saveVrmlFile(mat);
                  //me.saveFile(me.inputid + postfix + index + '.wrl', 'text', text);
                  me.saveFile(file_pref + postfix + index + '.vrml', 'text', text);
                  text = '';
              }.bind(this, mat, index), time);

              ++index;
            }

            // reset grid to build the surface for assembly
            me.icn3d.threshbox = 180;
       }
    },

    clkMn1_exportStl: function() { var me = this;
        $("#" + me.pre + "mn1_exportStl").click(function (e) {
           me.setLogCmd("export stl file", false);

           //me.hideStabilizer();

           me.exportStlFile('');
        });
    },

    clkMn1_exportVrml: function() { var me = this;
        $("#" + me.pre + "mn1_exportVrml").click(function (e) {
           me.setLogCmd("export vrml file", false);

           //me.hideStabilizer();

           me.exportVrmlFile('');
        });
    },

    clkMn1_exportStlStab: function() { var me = this;
        $("#" + me.pre + "mn1_exportStlStab").click(function (e) {
           me.setLogCmd("export stl stabilizer file", false);

           //me.icn3d.bRender = false;

           me.hideStabilizer();
           me.resetAfter3Dprint();
           me.addStabilizer();

           me.exportStlFile('_stab');
        });
    },

    clkMn1_exportVrmlStab: function() { var me = this;
        $("#" + me.pre + "mn1_exportVrmlStab").click(function (e) {
           me.setLogCmd("export vrml stabilizer file", false);

           //me.icn3d.bRender = false;

           me.hideStabilizer();
           me.resetAfter3Dprint();
           me.addStabilizer();

           me.exportVrmlFile('_stab');
        });
    },

    clkMn6_exportInteraction: function() { var me = this;
        $("#" + me.pre + "mn6_exportInteraction").click(function (e) {
           me.setLogCmd("export interactions", false);

           me.exportInteractions();
        });
    },

    clkMn1_exportCanvas: function() { var me = this;
        $("#" + me.pre + "mn1_exportCanvas").add("#" + me.pre + "saveimage").click(function (e) {
           me.setLogCmd("export canvas", false);

           var file_pref = (me.inputid) ? me.inputid : "custom";
           me.saveFile(file_pref + '_image_icn3d_loadable.png', 'png');
        });
    },

    clkMn1_exportCounts: function() { var me = this;
        $("#" + me.pre + "mn1_exportCounts").click(function (e) {
           me.setLogCmd("export counts", false);

           var text = '<html><body><b>Total Count for atoms with coordinates</b>:<br/><table border=1><tr><th>Structure Count</th><th>Chain Count</th><th>Residue Count</th><th>Atom Count</th></tr>';

           text += '<tr><td>' + Object.keys(me.icn3d.structures).length + '</td><td>' + Object.keys(me.icn3d.chains).length + '</td><td>' + Object.keys(me.icn3d.residues).length + '</td><td>' + Object.keys(me.icn3d.atoms).length + '</td></tr>';

           text += '</table><br/>';

           text += '<b>Counts by Chain for atoms with coordinates</b>:<br/><table border=1><tr><th>Structure</th><th>Chain</th><th>Residue Count</th><th>Atom Count</th></tr>';

           var chainArray = Object.keys(me.icn3d.chains);
           for(var i = 0, il = chainArray.length; i < il; ++i) {
               var chainid = chainArray[i];
               var pos = chainid.indexOf('_');
               var structure = chainid.substr(0, pos);
               var chain = chainid.substr(pos + 1);

               var residueHash = {};
               var atoms = me.icn3d.chains[chainid];
               for(var j in atoms) {
                   residueHash[me.icn3d.atoms[j].resi] = 1;
               }

               text += '<tr><td>' + structure + '</td><td>' + chain + '</td><td>' + Object.keys(residueHash).length + '</td><td>' + Object.keys(me.icn3d.chains[chainid]).length + '</td></tr>';
           }

           text += '</table><br/></body></html>';

           var file_pref = (me.inputid) ? me.inputid : "custom";
           me.saveFile(file_pref + '_counts.html', 'html', text);
        });
    },

    clkMn1_exportSelections: function() { var me = this;
        $("#" + me.pre + "mn1_exportSelections").click(function (e) {
           me.setLogCmd("export all selections", false);

           var text = me.exportCustomAtoms();

           var file_pref = (me.inputid) ? me.inputid : "custom";
           me.saveFile(file_pref + '_selections.txt', 'text', [text]);
        });
    },

    clkMn1_sharelink: function() { var me = this;
        $("#" + me.pre + "mn1_sharelink").click(function (e) {
            me.shareLink();
        });
    },

    clkMn1_link_structure: function() { var me = this;
        $("#" + me.pre + "mn1_link_structure").click(function (e) {
           var url = me.getLinkToStructureSummary(true);

           window.open(url, '_blank');
        });
    },

    clkMn1_link_bind: function() { var me = this;
        $("#" + me.pre + "mn1_link_bind").click(function (e) {
           url = "https://www.ncbi.nlm.nih.gov/pccompound?LinkName=pccompound_structure&from_uid=" + me.inputid;
           me.setLogCmd("link to 3D protein structures bound to CID " + me.inputid + ": " + url, false);

           window.open(url, '_blank');
        });
    },

    clkMn1_link_vast: function() { var me = this;
        $("#" + me.pre + "mn1_link_vast").click(function (e) {
           if(me.inputid === undefined) {
                   url = "https://www.ncbi.nlm.nih.gov/pccompound?term=" + me.icn3d.molTitle;
                   me.setLogCmd("link to compounds " + me.icn3d.molTitle + ": " + url, false);
           }
           else {
               if(me.cfg.cid !== undefined) {
                       url = "https://www.ncbi.nlm.nih.gov/pccompound?LinkName=pccompound_pccompound_3d&from_uid=" + me.inputid;
                       me.setLogCmd("link to compounds with structure similar to CID " + me.inputid + ": " + url, false);
               }
               else {
                   var idArray = me.inputid.split('_');

                   var url;
                   if(idArray.length === 1) {
                       url = "https://www.ncbi.nlm.nih.gov/Structure/vastplus/vastplus.cgi?uid=" + me.inputid;
                       me.setLogCmd("link to structures similar to " + me.inputid + ": " + url, false);
                   }
                   else if(idArray.length === 2) {
                       url = "https://www.ncbi.nlm.nih.gov/Structure/vastplus/vastplus.cgi?uid=" + idArray[0];
                       me.setLogCmd("link to structures similar to " + idArray[0] + ": " + url, false);
                   }
               }

               window.open(url, '_blank');
           }
        });
    },

    clkMn1_link_pubmed: function() { var me = this;
        $("#" + me.pre + "mn1_link_pubmed").click(function (e) {
           var url;
           if(me.inputid === undefined) {
               var url;
               url = "https://www.ncbi.nlm.nih.gov/pubmed/?term=" + me.icn3d.molTitle;
               me.setLogCmd("link to literature about " + me.icn3d.molTitle + ": " + url, false);

               window.open(url, '_blank');
           }
           else if(me.pmid !== undefined) {
               var idArray = me.pmid.toString().split('_');

               var url;
               if(idArray.length === 1) {
                   url = "https://www.ncbi.nlm.nih.gov/pubmed/" + me.pmid;
                   me.setLogCmd("link to PubMed ID " + me.pmid + ": " + url, false);
               }
               else if(idArray.length === 2) {
                   url = "https://www.ncbi.nlm.nih.gov/pubmed/?term=" + idArray[0] + " OR " + idArray[1];
                   me.setLogCmd("link to PubMed IDs " + idArray[0] + ", " + idArray[1] + ": " + url, false);
               }

               window.open(url, '_blank');
           }
           else if(isNaN(me.inputid)) {
               var idArray = me.inputid.toString().split('_');

               var url;
               if(idArray.length === 1) {
                   url = "https://www.ncbi.nlm.nih.gov/pubmed/?term=" + me.inputid;
                   me.setLogCmd("link to literature about PDB " + me.inputid + ": " + url, false);
               }
               else if(idArray.length === 2) {
                   url = "https://www.ncbi.nlm.nih.gov/pubmed/?term=" + idArray[0] + " OR " + idArray[1];
                   me.setLogCmd("link to literature about PDB " + idArray[0] + " OR " + idArray[1] + ": " + url, false);
               }

               window.open(url, '_blank');
           }
           else {
               if(me.cfg.cid !== undefined) {
                   alert("No literature information is available for this compound in the SDF file.");
               }
               else {
                   alert("No literature information is available for this structure.");
               }
           }
        });
    },

    clkMn1_link_protein: function() { var me = this;
        $("#" + me.pre + "mn1_link_protein").click(function (e) {
          //me.setEntrezLinks('protein');
          var structArray = Object.keys(me.icn3d.structures);

          var chainArray = Object.keys(me.icn3d.chains);
          var text = '';
          for(var i = 0, il = chainArray.length; i < il; ++i) {
              var firstAtom = me.icn3d.getFirstCalphaAtomObj(me.icn3d.chains[chainArray[i]]);

              if(me.icn3d.proteins.hasOwnProperty(firstAtom.serial) && chainArray[i].length == 6) {
                  text += chainArray[i] + '[accession] OR ';
              }
          }
          if(text.length > 0) text = text.substr(0, text.length - 4);

          var url = "https://www.ncbi.nlm.nih.gov/protein/?term=" + text;
          me.setLogCmd("link to Entrez protein about PDB " + structArray + ": " + url, false);

          window.open(url, '_blank');
        });
    },

    // mn 2
    clkMn2_selectannotations: function() { var me = this;
        $("#" + me.pre + "mn6_selectannotations").click(function (e) {
           me.showAnnotations();
           me.setLogCmd("view annotations", true);
        });
    },

    clkMn2_selectall: function() { var me = this;
        $("#" + me.pre + "mn2_selectall").click(function (e) {
           me.setLogCmd("select all", true);

           me.selectAll();

           me.removeHlAll();

           me.icn3d.draw();

        });

        $("#" + me.pre + "clearall").click(function (e) {
           me.setLogCmd("clear all", true);

           me.bSelectResidue = false;

           me.selectAll();

           me.removeHlAll();

           me.icn3d.draw();

        });

    },

    clkMn2_selectcomplement: function() { var me = this;
        $("#" + me.pre + "mn2_selectcomplement").click(function (e) {
           if(Object.keys(me.icn3d.hAtoms).length < Object.keys(me.icn3d.atoms).length) {
               me.setLogCmd("select complement", true);

               me.selectComplement();
           }
        });
    },

    clkMn2_selectsidechains: function() { var me = this;
        $("#" + me.pre + "mn2_selectsidechains").click(function (e) {
           me.setLogCmd("select side chains", true);

           me.selectSideChains();
        });
    },

    clkMn2_alignment: function() { var me = this;
        $("#" + me.pre + "mn2_alignment").click(function (e) {
           me.openDialog(me.pre + 'dl_alignment', 'Select residues in aligned sequences');
        });
    },

    clkMn2_command: function() { var me = this;
        $("#" + me.pre + "mn2_command").click(function (e) {
           me.openDialog(me.pre + 'dl_advanced2', 'Select by specification');
           //$("#" + me.pre + "dl_setsmenu").hide();
           //$("#" + me.pre + "dl_setoperations").hide();
           //$("#" + me.pre + "dl_command").show();
        });
    },

    clkMn2_definedsets: function() { var me = this;
        $("#" + me.pre + "mn2_definedsets").add("#" + me.pre + "definedsets").click(function (e) {
           me.showSets();

           me.setLogCmd('defined sets', true);
        });

        $("#" + me.pre + "setOr").click(function (e) {
           me.setOperation = 'or';
        });
        $("#" + me.pre + "setAnd").click(function (e) {
           me.setOperation = 'and';
        });
        $("#" + me.pre + "setNot").click(function (e) {
           me.setOperation = 'not';
        });
    },

    clkMn2_pkNo: function() { var me = this;
        $("#" + me.pre + "mn2_pkNo").click(function (e) {
           me.icn3d.pk = 0;
           me.icn3d.opts['pk'] = 'no';
           me.setLogCmd('set pk off', true);

           me.icn3d.draw();
           me.icn3d.removeHlObjects();
        });
    },

    clkMn2_pkYes: function() { var me = this;
        $("#" + me.pre + "mn2_pkYes").click(function (e) {
           me.icn3d.pk = 1;
           me.icn3d.opts['pk'] = 'atom';
           me.setLogCmd('set pk atom', true);
        });
    },

    clkMn2_pkResidue: function() { var me = this;
        $("#" + me.pre + "mn2_pkResidue").click(function (e) {
           me.icn3d.pk = 2;
           me.icn3d.opts['pk'] = 'residue';
           me.setLogCmd('set pk residue', true);
        });
    },

    clkMn2_pkStrand: function() { var me = this;
        $("#" + me.pre + "mn2_pkStrand").click(function (e) {
           me.icn3d.pk = 3;
           me.icn3d.opts['pk'] = 'strand';
           me.setLogCmd('set pk strand', true);
        });
    },

    clkMn2_pkChain: function() { var me = this;
        $("#" + me.pre + "mn2_pkChain").click(function (e) {
           me.icn3d.pk = 4;
           me.icn3d.opts['pk'] = 'chain';
           me.setLogCmd('set pk chain', true);
        });
    },

    clkMn2_aroundsphere: function() { var me = this;
        $("#" + me.pre + "mn2_aroundsphere").click(function (e) {
           me.openDialog(me.pre + 'dl_aroundsphere', 'Select a sphere around current selection');
        });
    },

    clkMn2_select_chain: function() { var me = this;
        $("#" + me.pre + "mn2_select_chain").add("#" + me.pre + "definedSets").click(function (e) {
           me.openDialog(me.pre + 'dl_select_chain', 'Select Structure/Chain/Custom Selection');
        });
    },

    // mn 3
    clkMn3_proteinsRibbon: function() { var me = this;
        $("#" + me.pre + "mn3_proteinsRibbon").click(function (e) {
           me.setStyle('proteins', 'ribbon');
           me.setLogCmd('style proteins ribbon', true);
        });
    },

    clkMn3_proteinsStrand: function() { var me = this;
        $("#" + me.pre + "mn3_proteinsStrand").click(function (e) {
           me.setStyle('proteins', 'strand');

           me.setLogCmd('style proteins strand', true);
        });
    },

    clkMn3_proteinsCylinder: function() { var me = this;
        $("#" + me.pre + "mn3_proteinsCylinder").click(function (e) {
           me.setStyle('proteins', 'cylinder and plate');
           me.setLogCmd('style proteins cylinder and plate', true);
        });
    },

    clkMn3_proteinsSchematic: function() { var me = this;
        $("#" + me.pre + "mn3_proteinsSchematic").click(function (e) {
           me.setStyle('proteins', 'schematic');
           me.setLogCmd('style proteins schematic', true);
        });
    },

    clkMn3_proteinsCalpha: function() { var me = this;
        $("#" + me.pre + "mn3_proteinsCalpha").click(function (e) {
           me.setStyle('proteins', 'c alpha trace');
           me.setLogCmd('style proteins c alpha trace', true);
        });
    },

    clkMn3_proteinsBfactor: function() { var me = this;
        $("#" + me.pre + "mn3_proteinsBfactor").click(function (e) {
           me.setStyle('proteins', 'b factor tube');
           me.setLogCmd('style proteins b factor tube', true);
        });
    },

    clkMn3_proteinsLines: function() { var me = this;
        $("#" + me.pre + "mn3_proteinsLines").click(function (e) {
           me.setStyle('proteins', 'lines');
           me.setLogCmd('style proteins lines', true);
        });
    },

    clkMn3_proteinsStick: function() { var me = this;
        $("#" + me.pre + "mn3_proteinsStick").click(function (e) {
           me.setStyle('proteins', 'stick');
           me.setLogCmd('style proteins stick', true);
        });
    },

    clkMn3_proteinsBallstick: function() { var me = this;
        $("#" + me.pre + "mn3_proteinsBallstick").click(function (e) {
           me.setStyle('proteins', 'ball and stick');
           me.setLogCmd('style proteins ball and stick', true);
        });
    },

    clkMn3_proteinsSphere: function() { var me = this;
        $("#" + me.pre + "mn3_proteinsSphere").click(function (e) {
           me.setStyle('proteins', 'sphere');
           me.setLogCmd('style proteins sphere', true);
        });
    },

    clkMn3_proteinsNo: function() { var me = this;
        $("#" + me.pre + "mn3_proteinsNo").click(function (e) {
           me.setStyle('proteins', 'nothing');
           me.setLogCmd('style proteins nothing', true);
        });
    },

    clkMn3_sidecLines: function() { var me = this;
        $("#" + me.pre + "mn3_sidecLines").click(function (e) {
           me.setStyle('sidec', 'lines');
           me.setLogCmd('style sidec lines', true);
        });
    },

    clkMn3_sidecStick: function() { var me = this;
        $("#" + me.pre + "mn3_sidecStick").click(function (e) {
           me.setStyle('sidec', 'stick');
           me.setLogCmd('style sidec stick', true);
        });
    },

    clkMn3_sidecBallstick: function() { var me = this;
        $("#" + me.pre + "mn3_sidecBallstick").click(function (e) {
           me.setStyle('sidec', 'ball and stick');
           me.setLogCmd('style sidec ball and stick', true);
        });
    },

    clkMn3_sidecSphere: function() { var me = this;
        $("#" + me.pre + "mn3_sidecSphere").click(function (e) {
           me.setStyle('sidec', 'sphere');
           me.setLogCmd('style sidec sphere', true);
        });
    },

    clkMn3_sidecNo: function() { var me = this;
        $("#" + me.pre + "mn3_sidecNo").click(function (e) {
           me.setStyle('sidec', 'nothing');
           me.setLogCmd('style sidec nothing', true);
        });
    },


    clkMn3_nuclCartoon: function() { var me = this;
        $("#" + me.pre + "mn3_nuclCartoon").click(function (e) {
           me.setStyle('nucleotides', 'nucleotide cartoon');
           me.setLogCmd('style nucleotides nucleotide cartoon', true);
        });
    },

    clkMn3_nuclSchematic: function() { var me = this;
        $("#" + me.pre + "mn3_nuclSchematic").click(function (e) {
           me.setStyle('nucleotides', 'schematic');
           me.setLogCmd('style nucleotides schematic', true);
        });
    },

    clkMn3_nuclPhos: function() { var me = this;
        $("#" + me.pre + "mn3_nuclPhos").click(function (e) {
           me.setStyle('nucleotides', 'o3 trace');
           me.setLogCmd('style nucleotides o3 trace', true);
        });
    },

    clkMn3_nuclLines: function() { var me = this;
        $("#" + me.pre + "mn3_nuclLines").click(function (e) {
           me.setStyle('nucleotides', 'lines');
           me.setLogCmd('style nucleotides lines', true);
        });
    },

    clkMn3_nuclStick: function() { var me = this;
        $("#" + me.pre + "mn3_nuclStick").click(function (e) {
           me.setStyle('nucleotides', 'stick');
           me.setLogCmd('style nucleotides stick', true);
        });
    },

    clkMn3_nuclBallstick: function() { var me = this;
        $("#" + me.pre + "mn3_nuclBallstick").click(function (e) {
           me.setStyle('nucleotides', 'ball and stick');
           me.setLogCmd('style nucleotides ball and stick', true);
        });
    },

    clkMn3_nuclSphere: function() { var me = this;
        $("#" + me.pre + "mn3_nuclSphere").click(function (e) {
           me.setStyle('nucleotides', 'sphere');
           me.setLogCmd('style nucleotides sphere', true);
        });
    },

    clkMn3_nuclNo: function() { var me = this;
        $("#" + me.pre + "mn3_nuclNo").click(function (e) {
           me.setStyle('nucleotides', 'nothing');
           me.setLogCmd('style nucleotides nothing', true);
        });
    },

    clkMn3_ligLines: function() { var me = this;
        $("#" + me.pre + "mn3_ligLines").click(function (e) {
           me.setStyle('chemicals', 'lines');
           me.setLogCmd('style chemicals lines', true);
        });
    },

    clkMn3_ligStick: function() { var me = this;
        $("#" + me.pre + "mn3_ligStick").click(function (e) {
           me.setStyle('chemicals', 'stick');
           me.setLogCmd('style chemicals stick', true);
        });
    },

    clkMn3_ligBallstick: function() { var me = this;
        $("#" + me.pre + "mn3_ligBallstick").click(function (e) {
           me.setStyle('chemicals', 'ball and stick');
           me.setLogCmd('style chemicals ball and stick', true);
        });
    },

    clkMn3_ligSchematic: function() { var me = this;
        $("#" + me.pre + "mn3_ligSchematic").click(function (e) {
           me.setStyle('chemicals', 'schematic');
           me.setLogCmd('style chemicals schematic', true);
        });
    },

    clkMn3_ligSphere: function() { var me = this;
        $("#" + me.pre + "mn3_ligSphere").click(function (e) {
           me.setStyle('chemicals', 'sphere');
           me.setLogCmd('style chemicals sphere', true);
        });
    },

    clkMn3_ligNo: function() { var me = this;
        $("#" + me.pre + "mn3_ligNo").click(function (e) {
           me.setStyle('chemicals', 'nothing');
           me.setLogCmd('style chemicals nothing', true);
        });
    },

    clkMn3_ionsSphere: function() { var me = this;
        $("#" + me.pre + "mn3_ionsSphere").click(function (e) {
           me.setStyle('ions', 'sphere');
           me.setLogCmd('style ions sphere', true);
        });
    },

    clkMn3_ionsDot: function() { var me = this;
        $("#" + me.pre + "mn3_ionsDot").click(function (e) {
           me.setStyle('ions', 'dot');
           me.setLogCmd('style ions dot', true);
        });
    },

    clkMn3_ionsNo: function() { var me = this;
        $("#" + me.pre + "mn3_ionsNo").click(function (e) {
           me.setStyle('ions', 'nothing');
           me.setLogCmd('style ions nothing', true);
        });
    },

    clkMn3_waterSphere: function() { var me = this;
        $("#" + me.pre + "mn3_waterSphere").click(function (e) {
           me.setStyle('water', 'sphere');
           me.setLogCmd('style water sphere', true);
        });
    },

    clkMn3_waterDot: function() { var me = this;
        $("#" + me.pre + "mn3_waterDot").click(function (e) {
           me.setStyle('water', 'dot');
           me.setLogCmd('style water dot', true);
        });
    },

    clkMn3_waterNo: function() { var me = this;
        $("#" + me.pre + "mn3_waterNo").click(function (e) {
           me.setStyle('water', 'nothing');
           me.setLogCmd('style water nothing', true);
        });
    },

    // mn 4
    clkMn4_clrSpectrum: function() { var me = this;
        $("#" + me.pre + "mn4_clrSpectrum").click(function (e) {
           me.setOption('color', 'spectrum');
           me.setLogCmd('color spectrum', true);
        });
    },

    clkMn4_clrChain: function() { var me = this;
        $("#" + me.pre + "mn4_clrChain").click(function (e) {
           me.setOption('color', 'chain');
           me.setLogCmd('color chain', true);
        });
    },

    clkMn4_clrSSGreen: function() { var me = this;
        $("#" + me.pre + "mn4_clrSSGreen").click(function (e) {
           me.icn3d.sheetcolor = 'green';

           me.setOption('color', 'secondary structure');
           me.setLogCmd('color secondary structure', true);
        });
    },

    clkMn4_clrSSYellow: function() { var me = this;
        $("#" + me.pre + "mn4_clrSSYellow").click(function (e) {
           me.icn3d.sheetcolor = 'yellow';

           me.setOption('color', 'secondary structure yellow');
           me.setLogCmd('color secondary structure yellow', true);
        });
    },

    clkMn4_clrResidue: function() { var me = this;
        $("#" + me.pre + "mn4_clrResidue").click(function (e) {
           me.setOption('color', 'residue');
           me.setLogCmd('color residue', true);
        });
    },

    clkMn4_clrCharge: function() { var me = this;
        $("#" + me.pre + "mn4_clrCharge").click(function (e) {
           me.setOption('color', 'charge');
           me.setLogCmd('color charge', true);
        });
    },

    clkMn4_clrHydrophobic: function() { var me = this;
        $("#" + me.pre + "mn4_clrHydrophobic").click(function (e) {
           me.setOption('color', 'hydrophobic');
           me.setLogCmd('color hydrophobic', true);
        });
    },

    clkMn4_clrAtom: function() { var me = this;
        $("#" + me.pre + "mn4_clrAtom").click(function (e) {
           me.setOption('color', 'atom');
           me.setLogCmd('color atom', true);
        });
    },

    clkMn4_clrBfactor: function() { var me = this;
        $("#" + me.pre + "mn4_clrBfactor").click(function (e) {
           me.setOption('color', 'b factor');
           me.setLogCmd('color b factor', true);
        });
    },

    clkMn4_clrBfactorNorm: function() { var me = this;
        $("#" + me.pre + "mn4_clrBfactorNorm").click(function (e) {
           me.setOption('color', 'b factor percentile');
           me.setLogCmd('color b factor percentile', true);
        });
    },

    clkMn4_clrIdentity: function() { var me = this;
        $("#" + me.pre + "mn4_clrIdentity").click(function (e) {
           me.setOption('color', 'identity');
           me.setLogCmd('color identity', true);
        });
    },

    clkMn4_clrConserved: function() { var me = this;
        $("#" + me.pre + "mn4_clrConserved").click(function (e) {
           me.setOption('color', 'conservation');
           me.setLogCmd('color conservation', true);
        });
    },

    clkMn4_clrRed: function() { var me = this;
        $("#" + me.pre + "mn4_clrRed").click(function (e) {
           me.setOption('color', 'red');
           me.setLogCmd('color red', true);
        });
    },

    clkMn4_clrGreen: function() { var me = this;
        $("#" + me.pre + "mn4_clrGreen").click(function (e) {
           me.setOption('color', 'green');
           me.setLogCmd('color green', true);
        });
    },

    clkMn4_clrBlue: function() { var me = this;
        $("#" + me.pre + "mn4_clrBlue").click(function (e) {
           me.setOption('color', 'blue');
           me.setLogCmd('color blue', true);
        });
    },

    clkMn4_clrMagenta: function() { var me = this;
        $("#" + me.pre + "mn4_clrMagenta").click(function (e) {
           me.setOption('color', 'magenta');
           me.setLogCmd('color magenta', true);
        });
    },

    clkMn4_clrYellow: function() { var me = this;
        $("#" + me.pre + "mn4_clrYellow").click(function (e) {
           me.setOption('color', 'yellow');
           me.setLogCmd('color yellow', true);
        });
    },

    clkMn4_clrCyan: function() { var me = this;
        $("#" + me.pre + "mn4_clrCyan").click(function (e) {
           me.setOption('color', 'cyan');
           me.setLogCmd('color cyan', true);
        });
    },

    clkMn4_clrWhite: function() { var me = this;
        $("#" + me.pre + "mn4_clrWhite").click(function (e) {
           me.setOption('color', 'white');
           me.setLogCmd('color white', true);
        });
    },

    clkMn4_clrGrey: function() { var me = this;
        $("#" + me.pre + "mn4_clrGrey").click(function (e) {
           me.setOption('color', 'grey');
           me.setLogCmd('color grey', true);
        });
    },

    clkMn4_clrCustom: function() { var me = this;
        $("#" + me.pre + "mn4_clrCustom").click(function (e) {
           me.openDialog(me.pre + 'dl_clr', 'Color picker');
        });
    },

    clkMn4_clrSave: function() { var me = this;
        $("#" + me.pre + "mn4_clrSave").click(function (e) {
           me.saveColor();

           me.setLogCmd('save color', true);
        });
    },

    clkMn4_clrApplySave: function() { var me = this;
        $("#" + me.pre + "mn4_clrApplySave").click(function (e) {
           me.applySavedColor();

           me.setLogCmd('apply saved color', true);
        });
    },

    clkMn3_styleSave: function() { var me = this;
        $("#" + me.pre + "mn3_styleSave").click(function (e) {
           me.saveStyle();
           me.setLogCmd('save style', true);
        });
    },

    clkMn3_styleApplySave: function() { var me = this;
        $("#" + me.pre + "mn3_styleApplySave").click(function (e) {
           me.applySavedStyle();
           me.setLogCmd('apply saved style', true);
        });
    },

    // mn 5
    clkMn5_neighborsYes: function() { var me = this;
        $("#" + me.pre + "mn5_neighborsYes").click(function (e) {
           me.icn3d.bConsiderNeighbors = true;

           me.icn3d.removeLastSurface();
           me.icn3d.applySurfaceOptions();
           me.icn3d.render();

           me.setLogCmd('set surface neighbors on', true);
        });
    },

    clkMn5_neighborsNo: function() { var me = this;
        $("#" + me.pre + "mn5_neighborsNo").click(function (e) {
           me.icn3d.bConsiderNeighbors = false;

           me.icn3d.removeLastSurface();
           me.icn3d.applySurfaceOptions();
           me.icn3d.render();

           me.setLogCmd('set surface neighbors off', true);
        });
    },

    clkMn5_surfaceVDW: function() { var me = this;
        $("#" + me.pre + "mn5_surfaceVDW").click(function (e) {
           me.icn3d.bConsiderNeighbors = false;
           me.setOption('surface', 'Van der Waals surface');
           me.setLogCmd('set surface Van der Waals surface', true);
        });
    },

    clkMn5_surfaceSAS: function() { var me = this;
        $("#" + me.pre + "mn5_surfaceSAS").click(function (e) {
           me.icn3d.bConsiderNeighbors = false;
           me.setOption('surface', 'solvent accessible surface');
           me.setLogCmd('set surface solvent accessible surface', true);
        });
    },

    clkMn5_surfaceMolecular: function() { var me = this;
        $("#" + me.pre + "mn5_surfaceMolecular").click(function (e) {
           me.icn3d.bConsiderNeighbors = false;
           me.setOption('surface', 'molecular surface');
           me.setLogCmd('set surface molecular surface', true);
        });
    },

    clkMn5_surfaceVDWContext: function() { var me = this;
        $("#" + me.pre + "mn5_surfaceVDWContext").click(function (e) {
           me.icn3d.bConsiderNeighbors = true;
           me.setOption('surface', 'Van der Waals surface with context');
           me.setLogCmd('set surface Van der Waals surface with context', true);
        });
    },

    clkMn5_surfaceSASContext: function() { var me = this;
        $("#" + me.pre + "mn5_surfaceSASContext").click(function (e) {
           me.icn3d.bConsiderNeighbors = true;
           me.setOption('surface', 'solvent accessible surface with context');
           me.setLogCmd('set surface solvent accessible surface with context', true);
        });
    },

    clkMn5_surfaceMolecularContext: function() { var me = this;
        $("#" + me.pre + "mn5_surfaceMolecularContext").click(function (e) {
           me.icn3d.bConsiderNeighbors = true;
           me.setOption('surface', 'molecular surface with context');
           me.setLogCmd('set surface molecular surface with context', true);
        });
    },

    clkMn5_surfaceNo: function() { var me = this;
        $("#" + me.pre + "mn5_surfaceNo").click(function (e) {
           me.setOption('surface', 'nothing');
           me.setLogCmd('set surface nothing', true);
        });
    },

    clkMn5_opacity10: function() { var me = this;
        $("#" + me.pre + "mn5_opacity10").click(function (e) {
           me.setOption('opacity', '1.0');
           me.setLogCmd('set surface opacity 1.0', true);
        });
    },

    clkMn5_opacity09: function() { var me = this;
        $("#" + me.pre + "mn5_opacity09").click(function (e) {
           me.setOption('opacity', '0.9');
           me.setLogCmd('set surface opacity 0.9', true);
        });
    },

    clkMn5_opacity08: function() { var me = this;
        $("#" + me.pre + "mn5_opacity08").click(function (e) {
           me.setOption('opacity', '0.8');
           me.setLogCmd('set surface opacity 0.8', true);
        });
    },

    clkMn5_opacity07: function() { var me = this;
        $("#" + me.pre + "mn5_opacity07").click(function (e) {
           me.setOption('opacity', '0.7');
           me.setLogCmd('set surface opacity 0.7', true);
        });
    },

    clkMn5_opacity06: function() { var me = this;
        $("#" + me.pre + "mn5_opacity06").click(function (e) {
           me.setOption('opacity', '0.6');
           me.setLogCmd('set surface opacity 0.6', true);
        });
    },

    clkMn5_opacity05: function() { var me = this;
        $("#" + me.pre + "mn5_opacity05").click(function (e) {
           me.setOption('opacity', '0.5');
           me.setLogCmd('set surface opacity 0.5', true);
        });
    },

    clkMn5_opacity04: function() { var me = this;
        $("#" + me.pre + "mn5_opacity04").click(function (e) {
           me.setOption('opacity', '0.4');
           me.setLogCmd('set surface opacity 0.4', true);
        });
    },

    clkMn5_opacity03: function() { var me = this;
        $("#" + me.pre + "mn5_opacity03").click(function (e) {
           me.setOption('opacity', '0.3');
           me.setLogCmd('set surface opacity 0.3', true);
        });
    },

    clkMn5_opacity02: function() { var me = this;
        $("#" + me.pre + "mn5_opacity02").click(function (e) {
           me.setOption('opacity', '0.2');
           me.setLogCmd('set surface opacity 0.2', true);
        });
    },

    clkMn5_opacity01: function() { var me = this;
        $("#" + me.pre + "mn5_opacity01").click(function (e) {
           me.setOption('opacity', '0.1');
           me.setLogCmd('set surface opacity 0.1', true);
        });
    },

    clkMn5_wireframeYes: function() { var me = this;
        $("#" + me.pre + "mn5_wireframeYes").click(function (e) {
           me.setOption('wireframe', 'yes');
           me.setLogCmd('set surface wireframe on', true);
        });
    },

    clkMn5_wireframeNo: function() { var me = this;
        $("#" + me.pre + "mn5_wireframeNo").click(function (e) {
           me.setOption('wireframe', 'no');
           me.setLogCmd('set surface wireframe off', true);
        });
    },

    clkMn5_elecmap2fofc: function() { var me = this;
        $("#" + me.pre + "mn5_elecmap2fofc").click(function (e) {
           me.openDialog(me.pre + 'dl_elecmap2fofc', '2Fo-Fc Electron Density Map');
        });
    },

    clkMn5_elecmapfofc: function() { var me = this;
        $("#" + me.pre + "mn5_elecmapfofc").click(function (e) {
           me.openDialog(me.pre + 'dl_elecmapfofc', 'Fo-Fc Electron Density Map');
        });
    },

    clkMn5_elecmapNo: function() { var me = this;
        $("#" + me.pre + "mn5_elecmapNo").add("#" + me.pre + "elecmapNo2").add("#" + me.pre + "elecmapNo3").click(function (e) {
           me.setOption('map', 'nothing');
           me.setLogCmd('set map nothing', true);
        });
    },

    clickApplymap2fofc: function() { var me = this;
        $("#" + me.pre + "applymap2fofc").click(function(e) {
           e.preventDefault();
           //dialog.dialog( "close" );

           var sigma2fofc = parseFloat($("#" + me.pre + "sigma2fofc" ).val());

           var type = '2fofc';
           me.Dsn6Parser(me.inputid, type, sigma2fofc);

           //me.setOption('map', '2fofc');
           me.setLogCmd('set map 2fofc sigma ' + sigma2fofc + ';', true);
        });
    },

    clickApplymapfofc: function() { var me = this;
        $("#" + me.pre + "applymapfofc").click(function(e) {
           e.preventDefault();
           //dialog.dialog( "close" );

           var sigmafofc = parseFloat($("#" + me.pre + "sigmafofc" ).val());

           var type = 'fofc';
           me.Dsn6Parser(me.inputid, type, sigmafofc);

           //me.setOption('map', 'fofc');
           me.setLogCmd('set map fofc sigma ' + sigmafofc + ';', true);
        });
    },

    clkMn5_mapwireframeYes: function() { var me = this;
        $("#" + me.pre + "mn5_mapwireframeYes").click(function (e) {
           //me.Dsn6Parser(me.inputid);

           me.setOption('mapwireframe', 'yes');
           me.setLogCmd('set map wireframe on', true);
        });
    },

    clkMn5_mapwireframeNo: function() { var me = this;
        $("#" + me.pre + "mn5_mapwireframeNo").click(function (e) {
           me.setOption('mapwireframe', 'no');
           me.setLogCmd('set map wireframe off', true);
        });
    },

    clkMn5_emmap: function() { var me = this;
        $("#" + me.pre + "mn5_emmap").click(function (e) {
           me.openDialog(me.pre + 'dl_emmap', 'EM Density Map');
        });
    },

    clkMn5_emmapNo: function() { var me = this;
        $("#" + me.pre + "mn5_emmapNo").add("#" + me.pre + "emmapNo2").click(function (e) {
           me.setOption('emmap', 'nothing');
           me.setLogCmd('set emmap nothing', true);
        });
    },

    clickApplyemmap: function() { var me = this;
        $("#" + me.pre + "applyemmap").click(function(e) {
           e.preventDefault();
           //dialog.dialog( "close" );

           var empercentage = parseFloat($("#" + me.pre + "empercentage" ).val());

           var type = 'em';
           //me.emd = 'emd-3906';
           me.DensityCifParser(me.inputid, type, empercentage, me.icn3d.emd);

           me.setLogCmd('set emmap percentage ' + empercentage + ';', true);
        });
    },

    clkMn5_emmapwireframeYes: function() { var me = this;
        $("#" + me.pre + "mn5_emmapwireframeYes").click(function (e) {
           //me.Dsn6Parser(me.inputid);

           me.setOption('emmapwireframe', 'yes');
           me.setLogCmd('set emmap wireframe on', true);
        });
    },

    clkMn5_emmapwireframeNo: function() { var me = this;
        $("#" + me.pre + "mn5_emmapwireframeNo").click(function (e) {
           me.setOption('emmapwireframe', 'no');
           me.setLogCmd('set emmap wireframe off', true);
        });
    },

    // mn 6
    clkMn6_assemblyYes: function() { var me = this;
        $("#" + me.pre + "mn6_assemblyYes").click(function (e) {
           me.icn3d.bAssembly = true;
           me.setLogCmd('set assembly on', true);
           me.icn3d.draw();
        });
    },

    clkMn6_assemblyNo: function() { var me = this;
        $("#" + me.pre + "mn6_assemblyNo").click(function (e) {
           me.icn3d.bAssembly = false;
           me.setLogCmd('set assembly off', true);
           me.icn3d.draw();
        });
    },

    clkMn6_addlabelResidues: function() { var me = this;
        $("#" + me.pre + "mn6_addlabelResidues").click(function (e) {
           //me.setLogCmd('add residue labels', true);

           me.icn3d.addResiudeLabels(me.icn3d.hAtoms);

           me.saveSelectionIfSelected();
           me.setLogCmd('add residue labels', true);
           me.icn3d.draw();
        });
    },

    clkMn6_addlabelChains: function() { var me = this;
        $("#" + me.pre + "mn6_addlabelChains").click(function (e) {
           me.addChainLabels(me.icn3d.hAtoms);

           me.saveSelectionIfSelected();
           me.setLogCmd('add chain labels', true);
           me.icn3d.draw();
        });
    },

    clkMn6_addlabelTermini: function() { var me = this;
        $("#" + me.pre + "mn6_addlabelTermini").click(function (e) {
           me.addTerminiLabels(me.icn3d.hAtoms);

           me.saveSelectionIfSelected();
           me.setLogCmd('add terminal labels', true);
           me.icn3d.draw();
        });
    },

    clkMn6_addlabelYes: function() { var me = this;
        $("#" + me.pre + "mn6_addlabelYes").click(function (e) {
           me.openDialog(me.pre + 'dl_addlabel', 'Add custom labels by selection');
           me.icn3d.pk = 1;
           me.icn3d.opts['pk'] = 'atom';
           me.icn3d.pickpair = true;
           me.icn3d.pAtomNum = 0;
        });
    },

    clkMn6_addlabelSelection: function() { var me = this;
        $("#" + me.pre + "mn6_addlabelSelection").click(function (e) {
           me.openDialog(me.pre + 'dl_addlabelselection', 'Add custom labels by the current selection');
        });
    },

    clkMn2_saveselection: function() { var me = this;
        $("#" + me.pre + "mn2_saveselection").click(function (e) {
           me.openDialog(me.pre + 'dl_saveselection', 'Save the current selection');
        });
    },

    clkMn6_addlabelNo: function() { var me = this;
        $("#" + me.pre + "mn6_addlabelNo").add("#" + me.pre + "removeLabels").click(function (e) {
           me.icn3d.pickpair = false;

           //me.icn3d.labels['residue'] = [];
           //me.icn3d.labels['custom'] = [];

           var select = "set labels off";
           me.setLogCmd(select, true);

           for(var name in me.icn3d.labels) {
               //if(name === 'residue' || name === 'custom') {
                   me.icn3d.labels[name] = [];
               //}
           }

           me.icn3d.draw();
        });
    },

    clkMn6_distanceYes: function() { var me = this;
        $("#" + me.pre + "mn6_distanceYes").click(function (e) {
           me.openDialog(me.pre + 'dl_distance', 'Measure the distance of atoms');
           me.icn3d.pk = 1;
           me.icn3d.opts['pk'] = 'atom';
           me.icn3d.pickpair = true;
           me.icn3d.pAtomNum = 0;

           me.bMeasureDistance = true;
        });
    },

    clkMn6_distanceNo: function() { var me = this;
        $("#" + me.pre + "mn6_distanceNo").click(function (e) {
           me.icn3d.pickpair = false;

           var select = "set lines off";
           me.setLogCmd(select, true);

           me.icn3d.labels['distance'] = [];
           me.icn3d.lines['distance'] = [];

           me.icn3d.pk = 2;

           me.icn3d.draw();
        });
    },

    clkMn2_selectedcenter: function() { var me = this;
        $("#" + me.pre + "mn2_selectedcenter").add("#" + me.pre + "zoomin_selection").click(function (e) {
           //me.setLogCmd('zoom selection', true);

           me.icn3d.zoominSelection();
           me.icn3d.draw();
           me.setLogCmd('zoom selection', true);
        });
    },

    clkMn6_center: function() { var me = this;
        $("#" + me.pre + "mn6_center").click(function (e) {
           //me.setLogCmd('center selection', true);

           me.icn3d.centerSelection();
           me.icn3d.draw();
           me.setLogCmd('center selection', true);
        });
    },

    clkMn6_resetOrientation: function() { var me = this;
        $("#" + me.pre + "mn6_resetOrientation").add("#" + me.pre + "resetOrientation").click(function (e) {
           //me.setLogCmd('reset orientation', true);

           me.icn3d.resetOrientation();

           me.icn3d.applyOriginalColor();

           me.icn3d.draw();
           me.setLogCmd('reset orientation', true);
        });
    },

    clkMn6_chemicalbindingshow: function() { var me = this;
        $("#" + me.pre + "mn6_chemicalbindingshow").add("#" + me.pre + "chemicalbindingshow").click(function (e) {
           me.setOption('chemicalbinding', 'show');
           me.setLogCmd('set chemicalbinding show', true);
        });
    },

    clkMn6_chemicalbindinghide: function() { var me = this;
        $("#" + me.pre + "mn6_chemicalbindinghide").add("#" + me.pre + "chemicalbindinghide").click(function (e) {
           me.setOption('chemicalbinding', 'hide');
           me.setLogCmd('set chemicalbinding hide', true);
        });
    },

    clkMn6_rotateleft: function() { var me = this;
        $("#" + me.pre + "mn6_rotateleft").click(function (e) {
           me.setLogCmd('rotate left', true);

           me.icn3d.bStopRotate = false;
           me.icn3d.rotateCount = 0;
           me.icn3d.rotateCountMax = 6000;
           me.ROT_DIR = 'left';

           me.rotStruc('left');
        });
    },

    clkMn6_rotateright: function() { var me = this;
        $("#" + me.pre + "mn6_rotateright").click(function (e) {
           me.setLogCmd('rotate right', true);

           me.icn3d.bStopRotate = false;
           me.icn3d.rotateCount = 0;
           me.icn3d.rotateCountMax = 6000;
           me.ROT_DIR = 'right';

           me.rotStruc('right');
        });
    },

    clkMn6_rotateup: function() { var me = this;
        $("#" + me.pre + "mn6_rotateup").click(function (e) {
           me.setLogCmd('rotate up', true);

           me.icn3d.bStopRotate = false;
           me.icn3d.rotateCount = 0;
           me.icn3d.rotateCountMax = 6000;
           me.ROT_DIR = 'up';

           me.rotStruc('up');
        });
    },

    clkMn6_rotatedown: function() { var me = this;
        $("#" + me.pre + "mn6_rotatedown").click(function (e) {
           me.setLogCmd('rotate down', true);

           me.icn3d.bStopRotate = false;
           me.icn3d.rotateCount = 0;
           me.icn3d.rotateCountMax = 6000;
           me.ROT_DIR = 'down';

           me.rotStruc('down');
        });
    },

    clkMn6_cameraPers: function() { var me = this;
        $("#" + me.pre + "mn6_cameraPers").click(function (e) {
           me.setOption('camera', 'perspective');
           me.setLogCmd('set camera perspective', true);
        });
    },

    clkMn6_cameraOrth: function() { var me = this;
        $("#" + me.pre + "mn6_cameraOrth").click(function (e) {
           me.setOption('camera', 'orthographic');
           me.setLogCmd('set camera orthographic', true);
        });
    },

    clkMn6_bkgdBlack: function() { var me = this;
        $("#" + me.pre + "mn6_bkgdBlack").click(function (e) {
           me.setOption('background', 'black');
           me.setLogCmd('set background black', true);
        });
    },

    clkMn6_bkgdGrey: function() { var me = this;
        $("#" + me.pre + "mn6_bkgdGrey").click(function (e) {
           me.setOption('background', 'grey');
           me.setLogCmd('set background grey', true);
        });
    },

    clkMn6_bkgdWhite: function() { var me = this;
        $("#" + me.pre + "mn6_bkgdWhite").click(function (e) {
           me.setOption('background', 'white');
           me.setLogCmd('set background white', true);
        });
    },

    clkMn6_bkgdTransparent: function() { var me = this;
        $("#" + me.pre + "mn6_bkgdTransparent").click(function (e) {
           me.setOption('background', 'transparent');
           me.setLogCmd('set background transparent', true);
        });
    },

    clkMn6_showfogYes: function() { var me = this;
        $("#" + me.pre + "mn6_showfogYes").click(function (e) {
           me.setOption('fog', 'yes');
           me.setLogCmd('set fog on', true);
        });
    },

    clkMn6_showfogNo: function() { var me = this;
        $("#" + me.pre + "mn6_showfogNo").click(function (e) {
           me.setOption('fog', 'no');
           me.setLogCmd('set fog off', true);
        });
    },

    clkMn6_showslabYes: function() { var me = this;
        $("#" + me.pre + "mn6_showslabYes").click(function (e) {
           me.setOption('slab', 'yes');
           me.setLogCmd('set slab on', true);
        });
    },

    clkMn6_showslabNo: function() { var me = this;
        $("#" + me.pre + "mn6_showslabNo").click(function (e) {
           me.setOption('slab', 'no');
           me.setLogCmd('set slab off', true);
        });
    },

    clkMn6_showaxisYes: function() { var me = this;
        $("#" + me.pre + "mn6_showaxisYes").click(function (e) {
           me.setOption('axis', 'yes');
           me.setLogCmd('set axis on', true);
        });
    },

    clkMn6_showaxisNo: function() { var me = this;
        $("#" + me.pre + "mn6_showaxisNo").click(function (e) {
           me.setOption('axis', 'no');
           me.setLogCmd('set axis off', true);
        });
    },

    clkMn6_hbondsYes: function() { var me = this;
        $("#" + me.pre + "mn6_hbondsYes").click(function (e) {
           me.openDialog(me.pre + 'dl_hbonds', 'Hydrogen bonds to selection');
        });
    },

    clkMn6_hbondsNo: function() { var me = this;
        $("#" + me.pre + "mn6_hbondsNo").click(function (e) {
           var select = "set hbonds off";
           me.setLogCmd(select, true);

           me.icn3d.hideHbonds();
           me.icn3d.draw();
        });
    },

    clkmn1_stabilizerYes: function() { var me = this;
        $("#" + me.pre + "mn1_stabilizerYes").click(function (e) {
           //me.openDialog(me.pre + 'dl_stabilizer', 'Hydrogen bonds inside selection');

           var select = "stabilizer";

           me.addStabilizer();
           me.prepareFor3Dprint();
           //me.icn3d.draw();

           me.setLogCmd(select, true);
        });
    },

    clkmn1_stabilizerNo: function() { var me = this;
        $("#" + me.pre + "mn1_stabilizerNo").click(function (e) {
           var select = "set stabilizer off";
           me.setLogCmd(select, true);

           me.hideStabilizer();

           me.icn3d.draw();
        });
    },

    clkmn1_stabilizerOne: function() { var me = this;
        $("#" + me.pre + "mn1_stabilizerOne").click(function (e) {
           me.openDialog(me.pre + 'dl_stabilizer', 'Add One Stabilizer');
           me.icn3d.pk = 1;
           me.icn3d.opts['pk'] = 'atom';
           me.icn3d.pickpair = true;
           me.icn3d.pAtomNum = 0;
        });
    },

    clkmn1_stabilizerRmOne: function() { var me = this;
        $("#" + me.pre + "mn1_stabilizerRmOne").click(function (e) {
           me.openDialog(me.pre + 'dl_stabilizer_rm', 'Remove One Stabilizer');
           me.icn3d.pk = 1;
           me.icn3d.opts['pk'] = 'atom';
           me.icn3d.pickpair = true;
           me.icn3d.pAtomNum = 0;
        });
    },

    clkmn1_thicknessSet: function() { var me = this;
        $("#" + me.pre + "mn1_thicknessSet").click(function (e) {
           me.openDialog(me.pre + 'dl_thickness', 'Set Thickness for 3D Printing');
        });
    },

    clkmn5_setThickness: function() { var me = this;
        $("#" + me.pre + "mn3_setThickness").click(function (e) {
           me.openDialog(me.pre + 'dl_thickness2', 'Set Thickness');
        });
    },

    clkmn1_thicknessReset: function() { var me = this;
        $("#" + me.pre + "mn1_thicknessReset").click(function (e) {
           var select = "reset thickness";
           me.setLogCmd(select, true);

           me.bSetThickness = false;

           me.resetAfter3Dprint();
           me.icn3d.draw();
        });
    },

    clkMn6_ssbondsYes: function() { var me = this;
        $("#" + me.pre + "mn6_ssbondsYes").click(function (e) {
           var select = "disulfide bonds";
           me.setLogCmd(select, true);

           me.showSsbonds();
        });
    },

    clkMn6_ssbondsNo: function() { var me = this;
        $("#" + me.pre + "mn6_ssbondsNo").click(function (e) {
           me.icn3d.opts["ssbonds"] = "no";

           var select = "set disulfide bonds off";
           me.setLogCmd(select, true);

           me.icn3d.lines['ssbond'] = [];

           me.setStyle('sidec', 'nothing');
        });
    },

    clkMn6_clbondsYes: function() { var me = this;
        $("#" + me.pre + "mn6_clbondsYes").click(function (e) {
           var select = "cross linkage";
           me.setLogCmd(select, true);

           me.icn3d.bShowCrossResidueBond = true;

           me.setStyle('proteins', 'lines')
           //me.icn3d.draw();
        });
    },

    clkMn6_clbondsNo: function() { var me = this;
        $("#" + me.pre + "mn6_clbondsNo").click(function (e) {
           me.icn3d.opts["clbonds"] = "no";

           var select = "set cross linkage off";
           me.setLogCmd(select, true);

           me.icn3d.bShowCrossResidueBond = false;
           //me.opts['proteins'] = 'ribbon';

           //me.icn3d.draw();
           me.setStyle('proteins', 'ribbon')
        });
    },

    // other
    clickViewswitch: function() { var me = this;
/*
        $("#" + me.pre + "viewswitch").click(function (e) {
            if($("#" + me.pre + "viewswitch")[0].checked) { // mode: Detailed View
                me.setAnnoViewAndDisplay('overview');
                me.setLogCmd("set view overview", true);
            }
            else { // mode: all
                me.setAnnoViewAndDisplay('detailed view');
                me.setLogCmd("set view detailed view", true);
            }
        });
*/
        $("#" + me.pre + "anno_summary").click(function (e) {
            e.preventDefault();

            me.setAnnoViewAndDisplay('overview');
            me.setLogCmd("set view overview", true);
        });

        $("#" + me.pre + "anno_details").click(function (e) {
            e.preventDefault();

            me.setAnnoViewAndDisplay('detailed view');
            me.setLogCmd("set view detailed view", true);
        });
    },

    clickShow_annotations: function() { var me = this;
        $("#" + me.pre + "show_annotations").click(function(e) {
             me.showAnnotations();
             me.setLogCmd("view annotations", true);
        });
    },

    clickShowallchains: function() { var me = this;
        $("#" + me.pre + "showallchains").click(function(e) {
             me.showAnnoAllChains();
             me.setLogCmd("show annotations all chains", true);
        });
    },

    clickShow_alignsequences: function() { var me = this;
        $("#" + me.pre + "show_alignsequences").click(function(e) {
             me.openDialog(me.pre + 'dl_alignment', 'Select residues in aligned sequences');
        });
    },

    clickShow_2ddgm: function() { var me = this;
        $("#" + me.pre + "show_2ddgm").add("#" + me.pre + "mn2_2ddgm").click(function(e) {
             me.openDialog(me.pre + 'dl_2ddgm', 'Interactions');
             if(!me.b2DShown) {
                 if(me.cfg.align !== undefined) {
                     var structureArray = Object.keys(me.icn3d.structures);
                     me.set2DDiagramsForAlign(structureArray[0].toUpperCase(), structureArray[1].toUpperCase());
                 }
                 else {
                     me.download2Ddgm(me.inputid.toUpperCase());
                 }
             }

             me.setLogCmd("view interactions", true);
        });
    },

    clickSearchSeq: function() { var me = this;
        $(document).on("click", "#" + me.pre + "search_seq_button", function(e) {
           e.stopImmediatePropagation();

           var select = $("#" + me.pre + "search_seq").val();
           if(isNaN(select) && select.indexOf('$') == -1 && select.indexOf('.') == -1 && select.indexOf(':') == -1 && select.indexOf('@') == -1) {
               select = ':' + select;
           }

           var commandname = select;
           //var commanddesc = "search with the one-letter sequence " + select;
           var commanddesc = select;

           me.selectByCommand(select, commandname, commanddesc);
           //me.setLogCmd('select ' + select + ' | name ' + commandname + ' | description ' + commanddesc, true);
           me.setLogCmd('select ' + select + ' | name ' + commandname, true);
        });
    },

    clickReload_mmtf: function() { var me = this;
        $("#" + me.pre + "reload_mmtf").click(function(e) {
           e.preventDefault();

           dialog.dialog( "close" );

           me.setLogCmd("load mmtf " + $("#" + me.pre + "mmtfid").val(), false);

           window.open('https://www.ncbi.nlm.nih.gov/Structure/icn3d/full.html?mmtfid=' + $("#" + me.pre + "mmtfid").val(), '_blank');
        });
    },

    clickReload_pdb: function() { var me = this;
        $("#" + me.pre + "reload_pdb").click(function(e) {
           e.preventDefault();

           dialog.dialog( "close" );

           me.setLogCmd("load pdb " + $("#" + me.pre + "pdbid").val(), false);

           window.open('https://www.ncbi.nlm.nih.gov/Structure/icn3d/full.html?pdbid=' + $("#" + me.pre + "pdbid").val(), '_blank');
        });
    },

    clickReload_align_refined: function() { var me = this;
        $("#" + me.pre + "reload_align_refined").click(function(e) {
           e.preventDefault();

           dialog.dialog( "close" );

           var alignment = $("#" + me.pre + "alignid1").val() + "," + $("#" + me.pre + "alignid2").val();

           me.setLogCmd("load alignment " + alignment + ' | parameters &atype=1', false);

           window.open('https://www.ncbi.nlm.nih.gov/Structure/icn3d/full.html?align=' + alignment + '&showalignseq=1&atype=1', '_blank');
        });
    },

    clickReload_align_ori: function() { var me = this;
        $("#" + me.pre + "reload_align_ori").click(function(e) {
           e.preventDefault();

           dialog.dialog( "close" );

           var alignment = $("#" + me.pre + "alignid1").val() + "," + $("#" + me.pre + "alignid2").val();

           me.setLogCmd("load alignment " + alignment + ' | parameters &atype=0', false);

           window.open('https://www.ncbi.nlm.nih.gov/Structure/icn3d/full.html?align=' + alignment + '&showalignseq=1&atype=0', '_blank');
        });
    },

    clickReload_mmcif: function() { var me = this;
        $("#" + me.pre + "reload_mmcif").click(function(e) {
           e.preventDefault();

           dialog.dialog( "close" );

           me.setLogCmd("load mmcif " + $("#" + me.pre + "mmcifid").val(), false);

           window.open('https://www.ncbi.nlm.nih.gov/Structure/icn3d/full.html?mmcifid=' + $("#" + me.pre + "mmcifid").val(), '_blank');
        });
    },

    clickReload_mmdb: function() { var me = this;
        $("#" + me.pre + "reload_mmdb").click(function(e) {
           e.preventDefault();

           dialog.dialog( "close" );

           me.setLogCmd("load mmdb " + $("#" + me.pre + "mmdbid").val(), false);

           //me.downloadMmdb($("#" + me.pre + "mmdbid").val());
           window.open('https://www.ncbi.nlm.nih.gov/Structure/icn3d/full.html?mmdbid=' + $("#" + me.pre + "mmdbid").val(), '_blank');
        });
    },

    clickReload_blast_rep_id: function() { var me = this;
        $("#" + me.pre + "reload_blast_rep_id").click(function(e) {
           e.preventDefault();

           dialog.dialog( "close" );

           //var query_id = $("#" + me.pre + "query_id").val().toUpperCase();
           var query_id = $("#" + me.pre + "query_id").val();
           var query_fasta = encodeURIComponent($("#" + me.pre + "query_fasta").val());
           //var blast_rep_id = $("#" + me.pre + "blast_rep_id").val().toUpperCase();
           var blast_rep_id = $("#" + me.pre + "blast_rep_id").val();

           me.setLogCmd("load seq_struc_ids " + query_id + "," + blast_rep_id, false);

           query_id = (query_id !== '' && query_id !== undefined) ? query_id : query_fasta;

//           if(query_id !== '' && query_id !== undefined) {
               window.open('https://www.ncbi.nlm.nih.gov/Structure/icn3d/full.html?from=icn3d&blast_rep_id=' + blast_rep_id + '&query_id=' + query_id, '_blank');
/*
           }
           else if(query_fasta !== '' && query_fasta !== undefined) {
               var form = document.createElement("form");
               form.setAttribute("method", "post");
               form.setAttribute("action", "https://www.ncbi.nlm.nih.gov/Structure/icn3d/full.html");

               form.setAttribute("target", "_blank");

               var hiddenField = document.createElement("input");
               hiddenField.setAttribute('command', 'view+annotations;+set+annotation+cdd;+set+view+detailed+view;+select+chain+' + blast_rep_id + ';+show+selection');
               hiddenField.setAttribute('query_id', query_fasta);
               hiddenField.setAttribute('blast_rep_id', blast_rep_id);
               form.appendChild(hiddenField);
               document.body.appendChild(form);

               var newWin = window.open('', '_blank');

               if (newWin) {
                   form.submit();
               } else {
                   alert('You must allow popups for this to work.');
               }
           }
*/
        });
    },

    clickReload_gi: function() { var me = this;
        $("#" + me.pre + "reload_gi").click(function(e) {
           e.preventDefault();

           dialog.dialog( "close" );

           me.setLogCmd("load gi " + $("#" + me.pre + "gi").val(), false);

           window.open('https://www.ncbi.nlm.nih.gov/Structure/icn3d/full.html?gi=' + $("#" + me.pre + "gi").val(), '_blank');
        });
    },

    clickReload_cid: function() { var me = this;
        $("#" + me.pre + "reload_cid").click(function(e) {
           e.preventDefault();

           dialog.dialog( "close" );

           me.setLogCmd("load cid " + $("#" + me.pre + "cid").val(), false);

           window.open('https://www.ncbi.nlm.nih.gov/Structure/icn3d/full.html?cid=' + $("#" + me.pre + "cid").val(), '_blank');
        });
    },

    clickReload_pngimage: function() { var me = this;
        $("#" + me.pre + "reload_pngimage").click(function(e) {
           e.preventDefault();

           dialog.dialog( "close" );
           //close all dialog
           $(".ui-dialog-content").dialog("close");

           // initialize icn3dui
           me.init();
           me.icn3d.init();

           var file = $("#" + me.pre + "pngimage")[0].files[0];

           if(!file) {
             alert("Please select a file before clicking 'Load'");
           }
           else {
             if (!window.File || !window.FileReader || !window.FileList || !window.Blob) {
                alert('The File APIs are not fully supported in this browser.');
             }

             var reader = new FileReader();
             reader.onload = function (e) {
               var imageStr = e.target.result; // or = reader.result;

               var matchedStr = 'Share Link: ';
               var pos = imageStr.indexOf(matchedStr);

               var matchedStrData = "Start of data file======\n";
               var posData = imageStr.indexOf(matchedStrData);

               if(pos == -1 && posData == -1) {
                   alert('Please load a PNG image saved by clicking "Save Datas > PNG Image" in the Data menu...');
               }
               else if(pos != -1) {
                   var url = imageStr.substr(pos + matchedStr.length);

                   me.setLogCmd('load iCn3D PNG image ' + $("#" + me.pre + "pngimage").val(), false);

                   window.open(url);
               }
               else if(posData != -1) {
                   me.bInputfile = true;

                   var posDataEnd = imageStr.indexOf("End of data file======\n");
                   var data = imageStr.substr(posData + matchedStrData.length, posDataEnd - posData - matchedStrData.length);

                   var matchedStrState = "Start of state file======\n";
                   var posState = imageStr.indexOf(matchedStrState);

                   var posStateEnd = imageStr.indexOf("End of state file======\n");
                   var statefile = imageStr.substr(posState + matchedStrState.length, posStateEnd - posState- matchedStrState.length);

                   var matchedStrType = "Start of type file======\n";
                   var posType = imageStr.indexOf(matchedStrType);

                   var posTypeEnd = imageStr.indexOf("End of type file======\n");
                   var type = imageStr.substr(posType + matchedStrType.length, posTypeEnd - posType - matchedStrType.length - 1); // remove the new line char

                    if(type === 'pdb') {
                        $.when( me.loadPdbData(data))
                         .then(function() {
                             me.icn3d.commands = [];
                             me.icn3d.optsHistory = [];

                             me.loadScript(statefile, true);
                         });
                    }
                    else {
                        if(type === 'mol2') {
                            me.loadMol2Data(data);
                        }
                        else if(type === 'sdf') {
                            me.loadSdfData(data);
                        }
                        else if(type === 'xyz') {
                            me.loadXyzData(data);
                        }
                        else if(type === 'mmcif') {
                            me.loadMmcifData(data);
                        }

                       me.icn3d.commands = [];
                       me.icn3d.optsHistory = [];

                       me.loadScript(statefile, true);
                   }

                   me.setLogCmd('load iCn3D PNG image ' + $("#" + me.pre + "pngimage").val(), false);
               }
             };

             reader.readAsText(file);
           }

        });
    },

    clickReload_state: function() { var me = this;
        $("#" + me.pre + "reload_state").click(function(e) {
           e.preventDefault();

           dialog.dialog( "close" );
           //close all dialog
           $(".ui-dialog-content").dialog("close");

           // initialize icn3dui
           //Do NOT clear data if iCn3D loads a pdb or other data file and then load a state file
           if(!me.bInputfile) {
               me.init();
               me.icn3d.init();
           }

           var file = $("#" + me.pre + "state")[0].files[0];

           if(!file) {
             alert("Please select a file before clicking 'Load'");
           }
           else {
             if (!window.File || !window.FileReader || !window.FileList || !window.Blob) {
                alert('The File APIs are not fully supported in this browser.');
             }

             var reader = new FileReader();
             reader.onload = function (e) {
               var dataStr = e.target.result; // or = reader.result;

               me.setLogCmd('load state file ' + $("#" + me.pre + "state").val(), false);

               me.icn3d.commands = [];
               me.icn3d.optsHistory = [];

               me.loadScript(dataStr, true);
             };

             reader.readAsText(file);
           }

        });
    },

    clickReload_selectionfile: function() { var me = this;
        $("#" + me.pre + "reload_selectionfile").click(function(e) {
           e.preventDefault();

           dialog.dialog( "close" );

           var file = $("#" + me.pre + "selectionfile")[0].files[0];

           if(!file) {
             alert("Please select a file before clicking 'Load'");
           }
           else {
             if (!window.File || !window.FileReader || !window.FileList || !window.Blob) {
                alert('The File APIs are not fully supported in this browser.');
             }

             var reader = new FileReader();
             reader.onload = function (e) {
               var dataStr = e.target.result; // or = reader.result;

               //me.setLogCmd('load selection file ' + $("#" + me.pre + "selectionfile").val(), false);

               me.loadSelection(dataStr);
               me.setLogCmd('load selection file ' + $("#" + me.pre + "selectionfile").val(), false);
             };

             reader.readAsText(file);
           }

        });
    },

    clickReload_pdbfile: function() { var me = this;
        $("#" + me.pre + "reload_pdbfile").click(function(e) {
           e.preventDefault();

           me.bInitial = true;

           dialog.dialog( "close" );
           //close all dialog
           $(".ui-dialog-content").dialog("close");

           var file = $("#" + me.pre + "pdbfile")[0].files[0];

           if(!file) {
             alert("Please select a file before clicking 'Load'");
           }
           else {
             if (!window.File || !window.FileReader || !window.FileList || !window.Blob) {
                alert('The File APIs are not fully supported in this browser.');
             }

             var reader = new FileReader();
             reader.onload = function (e) {
               var dataStr = e.target.result; // or = reader.result;

               me.setLogCmd('load pdb file ' + $("#" + me.pre + "pdbfile").val(), false);

               me.icn3d.molTitle = "";

               me.init();
               me.icn3d.init();

               me.bInputfile = true;
               me.InputfileData = dataStr;
               me.InputfileType = 'pdb';

               me.loadPdbData(dataStr);
             };

             reader.readAsText(file);
           }

        });
    },

    clickReload_mol2file: function() { var me = this;
        $("#" + me.pre + "reload_mol2file").click(function(e) {
           e.preventDefault();

           me.bInitial = true;

           dialog.dialog( "close" );
           //close all dialog
           $(".ui-dialog-content").dialog("close");

           var file = $("#" + me.pre + "mol2file")[0].files[0];

           if(!file) {
             alert("Please select a file before clicking 'Load'");
           }
           else {
             if (!window.File || !window.FileReader || !window.FileList || !window.Blob) {
                alert('The File APIs are not fully supported in this browser.');
             }

             var reader = new FileReader();
             reader.onload = function (e) {
               var dataStr = e.target.result; // or = reader.result;

               me.setLogCmd('load mol2 file ' + $("#" + me.pre + "mol2file").val(), false);

               me.icn3d.molTitle = "";

               me.inputid = undefined;

               me.init();
               me.icn3d.init();

               me.bInputfile = true;
               me.InputfileData = dataStr;
               me.InputfileType = 'mol2';

               me.loadMol2Data(dataStr);
             };

             reader.readAsText(file);
           }

        });
    },

    clickReload_sdffile: function() { var me = this;
        $("#" + me.pre + "reload_sdffile").click(function(e) {
           e.preventDefault();

           me.bInitial = true;

           dialog.dialog( "close" );
           //close all dialog
           $(".ui-dialog-content").dialog("close");

           var file = $("#" + me.pre + "sdffile")[0].files[0];

           if(!file) {
             alert("Please select a file before clicking 'Load'");
           }
           else {
             if (!window.File || !window.FileReader || !window.FileList || !window.Blob) {
                alert('The File APIs are not fully supported in this browser.');
             }

             var reader = new FileReader();
             reader.onload = function (e) {
               var dataStr = e.target.result; // or = reader.result;

               me.setLogCmd('load sdf file ' + $("#" + me.pre + "sdffile").val(), false);

               me.icn3d.molTitle = "";
               me.inputid = undefined;

               me.init();
               me.icn3d.init();

               me.bInputfile = true;
               me.InputfileData = dataStr;
               me.InputfileType = 'sdf';

               me.loadSdfData(dataStr);
             };

             reader.readAsText(file);
           }

        });
    },

    clickReload_xyzfile: function() { var me = this;
        $("#" + me.pre + "reload_xyzfile").click(function(e) {
           e.preventDefault();

           me.bInitial = true;

           dialog.dialog( "close" );
           //close all dialog
           $(".ui-dialog-content").dialog("close");

           var file = $("#" + me.pre + "xyzfile")[0].files[0];

           if(!file) {
             alert("Please select a file before clicking 'Load'");
           }
           else {
             if (!window.File || !window.FileReader || !window.FileList || !window.Blob) {
                alert('The File APIs are not fully supported in this browser.');
             }

             var reader = new FileReader();
             reader.onload = function (e) {
               var dataStr = e.target.result; // or = reader.result;

               me.setLogCmd('load xyz file ' + $("#" + me.pre + "xyzfile").val(), false);

               me.icn3d.molTitle = "";
               me.inputid = undefined;

               me.init();
               me.icn3d.init();

               me.bInputfile = true;
               me.InputfileData = dataStr;
               me.InputfileType = 'xyz';

               me.loadXyzData(dataStr);
             };

             reader.readAsText(file);
           }

        });
    },

    clickReload_urlfile: function() { var me = this;
        $("#" + me.pre + "reload_urlfile").click(function(e) {
           e.preventDefault();

           me.bInitial = true;

           dialog.dialog( "close" );
           //close all dialog
           $(".ui-dialog-content").dialog("close");

           var type = $("#" + me.pre + "filetype").val();
           var url = $("#" + me.pre + "urlfile").val();

           me.init();
           me.icn3d.init();

           me.bInputfile = true;

           me.downloadUrl(url, type);
        });
    },

    clickReload_mmciffile: function() { var me = this;
        $("#" + me.pre + "reload_mmciffile").click(function(e) {
           e.preventDefault();

           me.bInitial = true;

           dialog.dialog( "close" );
           //close all dialog
           $(".ui-dialog-content").dialog("close");

           var file = $("#" + me.pre + "mmciffile")[0].files[0];

           if(!file) {
             alert("Please select a file before clicking 'Load'");
           }
           else {
             if (!window.File || !window.FileReader || !window.FileList || !window.Blob) {
                alert('The File APIs are not fully supported in this browser.');
             }

             var reader = new FileReader();
             reader.onload = function (e) {
               var dataStr = e.target.result; // or = reader.result;

               me.setLogCmd('load mmcif file ' + $("#" + me.pre + "mmciffile").val(), false);

               me.icn3d.molTitle = "";

                var url = "//www.ncbi.nlm.nih.gov/Structure/mmcifparser/mmcifparser.cgi";

                me.icn3d.bCid = undefined;

               $.ajax({
                  url: url,
                  type: 'POST',
                  data : {'mmciffile': dataStr},
                  dataType: 'jsonp',
                  cache: true,
                  tryCount : 0,
                  retryLimit : 1,
                  beforeSend: function() {
                      if($("#" + me.pre + "wait")) $("#" + me.pre + "wait").show();
                      if($("#" + me.pre + "canvas")) $("#" + me.pre + "canvas").hide();
                      if($("#" + me.pre + "cmdlog")) $("#" + me.pre + "cmdlog").hide();
                  },
                  complete: function() {
                      if($("#" + me.pre + "wait")) $("#" + me.pre + "wait").hide();
                      if($("#" + me.pre + "canvas")) $("#" + me.pre + "canvas").show();
                      if($("#" + me.pre + "cmdlog")) $("#" + me.pre + "cmdlog").show();
                  },
                  success: function(data) {
                      me.init();
                      me.icn3d.init();

                      me.bInputfile = true;
                      me.InputfileData = data;
                      me.InputfileType = 'mmcif';

                      me.loadMmcifData(data);
                  },
                  error : function(xhr, textStatus, errorThrown ) {
                    this.tryCount++;
                    if (this.tryCount <= this.retryLimit) {
                        //try again
                        $.ajax(this);
                        return;
                    }
                    return;
                  }
                });
             };

             reader.readAsText(file);
           }

        });
    },

    clickApplycustomcolor: function() { var me = this;
        $("#" + me.pre + "applycustomcolor").click(function(e) {
           e.preventDefault();
           dialog.dialog( "close" );

           me.setOption("color", $("#" + me.pre + "colorcustom").val());
           me.setLogCmd("color " + $("#" + me.pre + "colorcustom").val(), true);
        });
    },

    clickApplypick_aroundsphere: function() { var me = this;
        $("#" + me.pre + "applypick_aroundsphere").click(function(e) {
            e.preventDefault();

            dialog.dialog( "close" );
            var radius = parseFloat($("#" + me.pre + "radius_aroundsphere").val());

               var select = "select zone cutoff " + radius;
               //me.setLogCmd(select, true);

               me.pickCustomSphere(radius);

               me.updateHlAll();

               me.setLogCmd(select, true);
        });
    },

    clickApplyhbonds: function() { var me = this;
        $("#" + me.pre + "applyhbonds").click(function(e) {
           e.preventDefault();
           dialog.dialog( "close" );

           var threshold = parseFloat($("#" + me.pre + "hbondthreshold" ).val());

           var select = "hbonds " + threshold;
           //me.setLogCmd(select, true);

           me.showHbonds(threshold);
           me.setLogCmd(select, true);
        });
    },

    clickApplypick_labels: function() { var me = this;
        $("#" + me.pre + "applypick_labels").click(function(e) {
           e.preventDefault();
           dialog.dialog( "close" );

           var text = $("#" + me.pre + "labeltext" ).val();
           var size = $("#" + me.pre + "labelsize" ).val();
           var color = $("#" + me.pre + "labelcolor" ).val();
           var background = $("#" + me.pre + "labelbkgd" ).val();
           if(size === '0' || size === '' || size === 'undefined') size = 0;
           if(color === '0' || color === '' || color === 'undefined') color = 0;
           if(background === '0' || background === '' || background === 'undefined') background = 0;

           if(me.icn3d.pAtom === undefined || me.icn3d.pAtom2 === undefined) {
             alert("Please pick another atom");
           }
           else {
             var x = (me.icn3d.pAtom.coord.x + me.icn3d.pAtom2.coord.x) / 2;
             var y = (me.icn3d.pAtom.coord.y + me.icn3d.pAtom2.coord.y) / 2;
             var z = (me.icn3d.pAtom.coord.z + me.icn3d.pAtom2.coord.z) / 2;

             //me.setLogCmd('add label ' + text + ' | x ' + x  + ' y ' + y + ' z ' + z + ' | size ' + size + ' | color ' + color + ' | background ' + background + ' | type custom', true);

             me.addLabel(text, x, y, z, size, color, background, 'custom');

             me.icn3d.pickpair = false;

             var sizeStr = '', colorStr = '', backgroundStr = '';
             if(size != 0) sizeStr = ' | size ' + size;
             if(color != 0) colorStr = ' | color ' + color;
             if(background != 0) backgroundStr = ' | background ' + background;

             me.setLogCmd('add label ' + text + ' | x ' + x.toPrecision(4)  + ' y ' + y.toPrecision(4) + ' z ' + z.toPrecision(4) + sizeStr + colorStr + backgroundStr + ' | type custom', true);
             me.icn3d.draw();
           }
        });
    },

    clickApplyselection_labels: function() { var me = this;
        $("#" + me.pre + "applyselection_labels").click(function(e) {
           e.preventDefault();
           dialog.dialog( "close" );

           var text = $("#" + me.pre + "labeltext2" ).val();
           var size = $("#" + me.pre + "labelsize2" ).val();
           var color = $("#" + me.pre + "labelcolor2" ).val();
           var background = $("#" + me.pre + "labelbkgd2" ).val();
           if(size === '0' || size === '' || size === 'undefined') size = 0;
           if(color === '0' || color === '' || color === 'undefined') color = 0;
           if(background === '0' || background === '' || background === 'undefined') background = 0;

             var position = me.icn3d.centerAtoms(me.icn3d.hash2Atoms(me.icn3d.hAtoms));
             var x = position.center.x;
             var y = position.center.y;
             var z = position.center.z;

             //me.setLogCmd('add label ' + text + ' | size ' + size + ' | color ' + color + ' | background ' + background + ' | type custom', true);

             me.addLabel(text, x, y, z, size, color, background, 'custom');

             var sizeStr = '', colorStr = '', backgroundStr = '';
             if(size != 0) sizeStr = ' | size ' + size;
             if(color != 0) colorStr = ' | color ' + color;
             if(background != 0) backgroundStr = ' | background ' + background;

             me.setLogCmd('add label ' + text + ' | x ' + x.toPrecision(4)  + ' y ' + y.toPrecision(4) + ' z ' + z.toPrecision(4) + sizeStr + colorStr + backgroundStr + ' | type custom', true);

             me.icn3d.draw();
        });
    },

    clickApplypick_stabilizer: function() { var me = this;
        $("#" + me.pre + "applypick_stabilizer").click(function(e) {
           e.preventDefault();
           dialog.dialog( "close" );

           if(me.icn3d.pAtom === undefined || me.icn3d.pAtom2 === undefined) {
             alert("Please pick another atom");
           }
           else {
             me.icn3d.pickpair = false;

             me.setLogCmd('add one stabilizer | ' + me.icn3d.pAtom.serial + ' ' + me.icn3d.pAtom2.serial, true);

             if(me.icn3d.pairArray === undefined) me.icn3d.pairArray = [];
             me.icn3d.pairArray.push(me.icn3d.pAtom.serial);
             me.icn3d.pairArray.push(me.icn3d.pAtom2.serial);

             //me.updateStabilizer();
             me.setThichknessFor3Dprint();

             me.icn3d.draw();
           }
        });
    },

    // https://github.com/tovic/color-picker
    // https://tovic.github.io/color-picker/color-picker.value-update.html
    pickColor: function() { var me = this;
        var picker = new CP(document.querySelector("#" + me.pre + "colorcustom"));

        picker.on("change", function(color) {
            this.target.value = color;
        });

        $("#" + me.pre + "colorcustom").on("input keyup paste cut", function() {
            var color = $("#" + me.pre + "colorcustom").val();
            picker.set('#' + color).enter();
        });
    },

    clickApplypick_stabilizer_rm: function() { var me = this;
        $("#" + me.pre + "applypick_stabilizer_rm").click(function(e) {
           e.preventDefault();
           dialog.dialog( "close" );

           if(me.icn3d.pAtom === undefined || me.icn3d.pAtom2 === undefined) {
             alert("Please pick another atom");
           }
           else {
             me.icn3d.pickpair = false;

             me.setLogCmd('remove one stabilizer | ' + me.icn3d.pAtom.serial + ' ' + me.icn3d.pAtom2.serial, true);

             var rmLineArray = [];
             rmLineArray.push(me.icn3d.pAtom.serial);
             rmLineArray.push(me.icn3d.pAtom2.serial);

             me.removeOneStabilizer(rmLineArray);

             //me.updateStabilizer();

             me.icn3d.draw();
           }
        });
    },

    clickApplypick_measuredistance: function() { var me = this;
        $("#" + me.pre + "applypick_measuredistance").click(function(e) {
           e.preventDefault();
           dialog.dialog( "close" );
           me.bMeasureDistance = false;

           if(me.icn3d.pAtom === undefined || me.icn3d.pAtom2 === undefined) {
             alert("Please pick another atom");
           }
           else {
             var size = 0, color, background = 0;
             var color = $("#" + me.pre + "linecolor" ).val();

             var x = (me.icn3d.pAtom.coord.x + me.icn3d.pAtom2.coord.x) / 2;
             var y = (me.icn3d.pAtom.coord.y + me.icn3d.pAtom2.coord.y) / 2;
             var z = (me.icn3d.pAtom.coord.z + me.icn3d.pAtom2.coord.z) / 2;

             me.addLineFromPicking('distance');

             var distance = parseInt(me.icn3d.pAtom.coord.distanceTo(me.icn3d.pAtom2.coord) * 10) / 10;

             var text = distance.toString() + " A";

             me.addLabel(text, x, y, z, size, color, background, 'distance');

             var sizeStr = '', colorStr = '', backgroundStr = '';
             if(size != 0) sizeStr = ' | size ' + size;
             if(color != 0) colorStr = ' | color ' + color;
             if(background != 0) backgroundStr = ' | background ' + background;

             me.setLogCmd('add label ' + text + ' | x ' + x.toPrecision(4)  + ' y ' + y.toPrecision(4) + ' z ' + z.toPrecision(4) + sizeStr + colorStr + backgroundStr + ' | type distance', true);

             me.icn3d.draw();

             me.icn3d.pk = 2;
           }
        });
    },

    clickApply_thickness: function() { var me = this;
        $("#" + me.pre + "apply_thickness_3dprint").click(function(e) {
            e.preventDefault();
            //dialog.dialog( "close" );

            me.bSetThickness = true;

            me.icn3d.lineRadius = parseFloat($("#" + me.pre + "linerad_3dprint" ).val()); //0.1; // hbonds, distance lines
            me.icn3d.coilWidth = parseFloat($("#" + me.pre + "coilrad_3dprint" ).val()); //0.4; // style cartoon-coil
            me.icn3d.cylinderRadius = parseFloat($("#" + me.pre + "stickrad_3dprint" ).val()); //0.4; // style stick
            me.icn3d.traceRadius = parseFloat($("#" + me.pre + "stickrad_3dprint" ).val()); //0.2; // style c alpha trace, nucleotide stick
            me.icn3d.dotSphereScale = parseFloat($("#" + me.pre + "ballscale_3dprint" ).val()); //0.3; // style ball and stick, dot

            me.icn3d.ribbonthickness = parseFloat($("#" + me.pre + "ribbonthick_3dprint" ).val()); //0.4; // style ribbon, nucleotide cartoon, stand thickness
            me.icn3d.helixSheetWidth = parseFloat($("#" + me.pre + "prtribbonwidth_3dprint" ).val()); //1.3; // style ribbon, stand thickness
            me.icn3d.nucleicAcidWidth = parseFloat($("#" + me.pre + "nucleotideribbonwidth_3dprint" ).val()); //0.8; // nucleotide cartoon

            me.setLogCmd('set thickness | linerad ' + me.icn3d.lineRadius + ' | coilrad ' + me.icn3d.coilWidth + ' | stickrad ' + me.icn3d.cylinderRadius + ' | tracerad ' + me.icn3d.traceRadius + ' | ribbonthick ' + me.icn3d.ribbonthickness + ' | proteinwidth ' + me.icn3d.helixSheetWidth + ' | nucleotidewidth ' + me.icn3d.nucleicAcidWidth  + ' | ballscale ' + me.icn3d.dotSphereScale, true);

            me.icn3d.draw();
        });

        $("#" + me.pre + "apply_thickness_style").click(function(e) {
            e.preventDefault();
            //dialog.dialog( "close" );

            me.bSetThickness = true;

            me.icn3d.lineRadius = parseFloat($("#" + me.pre + "linerad_style" ).val()); //0.1; // hbonds, distance lines
            me.icn3d.coilWidth = parseFloat($("#" + me.pre + "coilrad_style" ).val()); //0.4; // style cartoon-coil
            me.icn3d.cylinderRadius = parseFloat($("#" + me.pre + "stickrad_style" ).val()); //0.4; // style stick
            me.icn3d.traceRadius = parseFloat($("#" + me.pre + "stickrad_style" ).val()); //0.2; // style c alpha trace, nucleotide stick
            me.icn3d.dotSphereScale = parseFloat($("#" + me.pre + "ballscale_style" ).val()); //0.3; // style ball and stick, dot

            me.icn3d.ribbonthickness = parseFloat($("#" + me.pre + "ribbonthick_style" ).val()); //0.4; // style ribbon, nucleotide cartoon, stand thickness
            me.icn3d.helixSheetWidth = parseFloat($("#" + me.pre + "prtribbonwidth_style" ).val()); //1.3; // style ribbon, stand thickness
            me.icn3d.nucleicAcidWidth = parseFloat($("#" + me.pre + "nucleotideribbonwidth_style" ).val()); //0.8; // nucleotide cartoon

            me.setLogCmd('set thickness | linerad ' + me.icn3d.lineRadius + ' | coilrad ' + me.icn3d.coilWidth + ' | stickrad ' + me.icn3d.cylinderRadius + ' | tracerad ' + me.icn3d.traceRadius + ' | ribbonthick ' + me.icn3d.ribbonthickness + ' | proteinwidth ' + me.icn3d.helixSheetWidth + ' | nucleotidewidth ' + me.icn3d.nucleicAcidWidth  + ' | ballscale ' + me.icn3d.dotSphereScale, true);

            me.icn3d.draw();
        });
    },

    clickReset: function() { var me = this;
        $("#" + me.pre + "reset").click(function (e) {
            //me.setLogCmd("reset", true);

            //reset me.icn3d.maxD
            me.icn3d.maxD = me.icn3d.oriMaxD;
            me.icn3d.center = me.icn3d.oriCenter.clone();

            me.icn3d.reinitAfterLoad();

            me.renderFinalStep(1);
            me.setMode('all');

            me.setLogCmd("reset", true);

            me.removeSeqChainBkgd();
            me.removeSeqResidueBkgd();

            me.removeHl2D();
            me.removeHlMenus();
        });
    },

    clickToggleHighlight: function() { var me = this;
        $("#" + me.pre + "toggleHighlight").add("#" + me.pre + "toggleHighlight2").click(function (e) {
            e.stopImmediatePropagation();
            me.toggleHighlight();
        });

        $(document).on("click", "#" + me.pre + "seq_clearselection", function(e) {
            e.stopImmediatePropagation();
            dialog.dialog( "close" );

            me.clearHighlight();
        });

        $(document).on("click", "#" + me.pre + "seq_clearselection2", function(e) {
            e.stopImmediatePropagation();

            e.preventDefault();

            me.clearHighlight();
            me.setLogCmd("clear selection", true);
        });

        $(document).on("click", "#" + me.pre + "alignseq_clearselection", function(e) {
            e.stopImmediatePropagation();
            me.clearHighlight();
            me.setLogCmd("clear selection", true);
        });
    },

    pressCommandtext: function() { var me = this;
        $("#" + me.pre + "logtext").keypress(function(e){
           me.bAddLogs = false; // turn off log

           var code = (e.keyCode ? e.keyCode : e.which);

           if(code == 13) { //Enter keycode
              e.preventDefault();

              var dataStr = $(this).val();

              me.icn3d.bRender = true;

              var commandArray = dataStr.split('\n');
              var lastCommand = commandArray[commandArray.length - 1].substr(2).trim(); // skip "> "
              me.icn3d.logs.push(lastCommand);
              $("#" + me.pre + "logtext").val("> " + me.icn3d.logs.join("\n> ") + "\n> ").scrollTop($("#" + me.pre + "logtext")[0].scrollHeight);

              if(lastCommand !== '') {
                var transformation = {};
                transformation.factor = me.icn3d._zoomFactor;
                transformation.mouseChange = me.icn3d.mouseChange;
                transformation.quaternion = me.icn3d.quaternion;

                me.icn3d.commands.push(lastCommand + '|||' + me.getTransformationStr(transformation));
                me.icn3d.optsHistory.push(me.icn3d.cloneHash(me.icn3d.opts));
                me.icn3d.optsHistory[me.icn3d.optsHistory.length - 1].hlatomcount = Object.keys(me.icn3d.hAtoms).length;

                if(me.isSessionStorageSupported()) me.saveCommandsToSession();

                me.STATENUMBER = me.icn3d.commands.length;

                if(lastCommand.indexOf('load') !== -1) {
                    me.applyCommandLoad(lastCommand);
                }
                else if(lastCommand.indexOf('set map') !== -1 && lastCommand.indexOf('set map wireframe') === -1) {
                    me.applyCommandMap(lastCommand);
                }
                else if(lastCommand.indexOf('view annotations') == 0
                  //|| lastCommand.indexOf('set annotation cdd') == 0
                  //|| lastCommand.indexOf('set annotation site') == 0
                  ) {
                    me.applyCommandAnnotationsAndCddSite(lastCommand);
                }
                else if(lastCommand.indexOf('set annotation clinvar') == 0
                  || lastCommand.indexOf('set annotation snp') == 0) {
                    me.applyCommandSnpClinvar(lastCommand);
                }
                else if(lastCommand.indexOf('set annotation 3ddomain') == 0) {
                    me.applyCommand3ddomain(lastCommand);
                }
                else if(lastCommand.indexOf('set annotation all') == 0) {
                    //$.when(me.applyCommandAnnotationsAndCddSite(lastCommand))
                    //    .then(me.applyCommandSnpClinvar(lastCommand))
                    $.when(me.applyCommandSnpClinvar(lastCommand))
                        .then(me.applyCommandSnpClinvar(lastCommand));

                    me.setAnnoTabAll();
                }
                else {
                    me.applyCommand(lastCommand + '|||' + me.getTransformationStr(transformation));
                }

                me.saveSelectionIfSelected();
                me.icn3d.draw();
              }
           }

           me.bAddLogs = true;
        });
    },

    clickSeqSaveSelection: function() { var me = this;
        $(document).on("click", "#" + me.pre + "seq_saveselection", function(e) {
           e.stopImmediatePropagation();
           dialog.dialog( "close" );

           if(!$('#' + me.pre + 'dl_definedsets').hasClass('ui-dialog-content') || !$('#' + me.pre + 'dl_definedsets').dialog( 'isOpen' )) {
             me.openDialog(me.pre + 'dl_definedsets', 'Select sets');
           }

           me.bSelectResidue = false;

           var name = $("#" + me.pre + "seq_command_name").val().replace(/\s+/g, '_');
           //var description = $("#" + me.pre + "seq_command_desc").val();

           me.saveSelection(name, name);
        });

        $(document).on("click", "#" + me.pre + "seq_saveselection2", function(e) {
           e.stopImmediatePropagation();

           if(!$('#' + me.pre + 'dl_definedsets').hasClass('ui-dialog-content') || !$('#' + me.pre + 'dl_definedsets').dialog( 'isOpen' )) {
             me.openDialog(me.pre + 'dl_definedsets', 'Select sets');
           }

           me.bSelectResidue = false;

           var name = $("#" + me.pre + "seq_command_name2").val().replace(/\s+/g, '_');
           //var description = $("#" + me.pre + "seq_command_desc2").val();

           me.saveSelection(name, name);
        });
    },

    clickAlignSeqSaveSelection: function() { var me = this;
        $(document).on("click", "#" + me.pre + "alignseq_saveselection", function(e) {
            e.stopImmediatePropagation();

           if(!$('#' + me.pre + 'dl_definedsets').hasClass('ui-dialog-content') || !$('#' + me.pre + 'dl_definedsets').dialog( 'isOpen' )) {
             me.openDialog(me.pre + 'dl_definedsets', 'Select sets');
           }

            me.bSelectAlignResidue = false;

            var name = $("#" + me.pre + "alignseq_command_name").val().replace(/\s+/g, '_');
            //var description = $("#" + me.pre + "alignseq_command_desc").val();

            me.saveSelection(name, name);
        });
    },

    clickOutputSelection: function() { var me = this;
        $(document).on("click", "." + me.pre + "outputselection", function(e) {
              e.stopImmediatePropagation();
            me.bSelectResidue = false;
            me.bSelectAlignResidue = false;
            me.setLogCmd('output selection', true);
            me.outputSelection();
        });
    },

    bindMouseup: function() { var me = this;
        $("accordion").bind('mouseup touchend', function (e) {
          if(me.icn3d.controls) {
            me.icn3d.controls.noRotate = false;
            me.icn3d.controls.noZoom = false;
            me.icn3d.controls.noPan = false;
          }
        });
    },

    bindMousedown: function() { var me = this;
        $("accordion").bind('mousedown touchstart', function (e) {
          if(me.icn3d.controls) {
            me.icn3d.controls.noRotate = true;
            me.icn3d.controls.noZoom = true;
            me.icn3d.controls.noPan = true;
          }
        });
    },

    expandShrink: function() { var me = this;
        //$("[id$=_cddseq_expand]").on('click', '.ui-icon-plus', function(e) {
        $(document).on("click", ".icn3d-expand", function(e) {
            e.stopImmediatePropagation();

            var oriId = $(this).attr('id');
            var pos = oriId.lastIndexOf('_');
            var id = oriId.substr(0, pos);

            $("#" + id).show();
            $("#" + id + "_expand").hide();
            $("#" + id + "_shrink").show();
        });

        //$("[id$=_cddseq_shrink]").on('click', '.ui-icon-minus', function(e) {
        $(document).on("click", ".icn3d-shrink", function(e) {
            e.stopImmediatePropagation();

            var oriId = $(this).attr('id');
            var pos = oriId.lastIndexOf('_');
            var id = oriId.substr(0, pos);

            $("#" + id).hide();
            $("#" + id + "_expand").show();
            $("#" + id + "_shrink").hide();
        });
    },

    scrollAnno: function() { var me = this;
        window.onscroll = function (e) {
            if(me.view == 'detailed view' && $(window).scrollTop() == 0 && $(window).scrollTop() == 0 && $("#" + me.pre + "dl_selectannotations").scrollTop() == 0) {
                // show fixed titles
                me.showFixedTitle();
            }
            else {
                // remove fixed titles
                me.hideFixedTitle();
            }
        } ;

        $( "#" + me.pre + "dl_selectannotations" ).scroll(function() {
            if(me.view == 'detailed view' && $(window).scrollTop() == 0 && $(window).scrollTop() == 0 && $("#" + me.pre + "dl_selectannotations").scrollTop() == 0) {
                // show fixed titles
                me.showFixedTitle();
            }
            else {
                // remove fixed titles
                me.hideFixedTitle();
            }
        });
    },

    // ===== events end
    allEventFunctions: function() { var me = this;
        me.clickModeswitch();
        me.clickViewswitch();

        if(! me.isMobile()) {
            me.selectSequenceNonMobile();
        }
        else {
            me.selectSequenceMobile();
            me.selectChainMobile();
        }

        me.clickBack();
        me.clickForward();
        me.clickToggle();

        me.clickHlColorYellow();
        me.clickHlColorGreen();
        me.clickHlColorRed();
        me.clickHlStyleOutline();
        me.clickHlStyleObject();
        me.clickHlStyleNone();

        me.clickAlternate();
        me.clkMn1_mmtfid();
        me.clkMn1_pdbid();
        me.clkMn1_align();
        me.clkMn1_pdbfile();
        me.clkMn1_mol2file();
        me.clkMn1_sdffile();
        me.clkMn1_xyzfile();
        me.clkMn1_urlfile();
        me.clkMn1_mmciffile();
        me.clkMn1_mmcifid();
        me.clkMn1_mmdbid();
        me.clkMn1_blast_rep_id();
        me.clkMn1_gi();
        me.clkMn1_cid();
        me.clkMn1_pngimage();
        me.clkMn1_state();
        me.clkMn1_selection();
        me.clkMn1_exportState();
        me.clkMn1_exportStl();
        me.clkMn1_exportVrml();
        me.clkMn1_exportStlStab();
        me.clkMn1_exportVrmlStab();
        me.clkMn6_exportInteraction();
        me.clkMn1_exportCanvas();
        me.clkMn1_exportCounts();
        me.clkMn1_exportSelections();
        me.clkMn1_sharelink();
        me.clkMn1_link_structure();
        me.clkMn1_link_bind();
        me.clkMn1_link_vast();
        me.clkMn1_link_pubmed();
        me.clkMn1_link_protein();
//        me.clkMn1_link_gene();
//        me.clkMn1_link_chemicals();
        me.clkMn2_selectannotations();
//        me.clkMn2_selectresidues();
        me.clkMn2_selectcomplement();
        me.clkMn2_selectsidechains();
        me.clkMn2_selectall();
        me.clkMn2_alignment();
        me.clkMn2_command();
        me.clkMn2_definedsets();
        me.clkMn2_pkYes();
        me.clkMn2_pkNo();
        me.clkMn2_pkResidue();
        me.clkMn2_pkStrand();
        me.clkMn2_pkChain();
        me.clkMn2_aroundsphere();
        me.clkMn2_select_chain();
        me.clkMn3_proteinsRibbon();
        me.clkMn3_proteinsStrand();
        me.clkMn3_proteinsCylinder();
        me.clkMn3_proteinsSchematic();
        me.clkMn3_proteinsCalpha();
        me.clkMn3_proteinsBfactor();
        me.clkMn3_proteinsLines();
        me.clkMn3_proteinsStick();
        me.clkMn3_proteinsBallstick();
        me.clkMn3_proteinsSphere();
        me.clkMn3_proteinsNo();
        me.clkMn3_sidecLines();
        me.clkMn3_sidecStick();
        me.clkMn3_sidecBallstick();
        me.clkMn3_sidecSphere();
        me.clkMn3_sidecNo();
        me.clkMn3_nuclCartoon();
        me.clkMn3_nuclSchematic();
        me.clkMn3_nuclPhos();
        me.clkMn3_nuclLines();
        me.clkMn3_nuclStick();
        me.clkMn3_nuclBallstick();
        me.clkMn3_nuclSphere();
        me.clkMn3_nuclNo();
        me.clkMn3_ligLines();
        me.clkMn3_ligStick();
        me.clkMn3_ligBallstick();
        me.clkMn3_ligSchematic();
        me.clkMn3_ligSphere();
        me.clkMn3_ligNo();
        me.clkMn3_ionsSphere();
        me.clkMn3_ionsDot();
        me.clkMn3_ionsNo();
        me.clkMn3_waterSphere();
        me.clkMn3_waterDot();
        me.clkMn3_waterNo();
        me.clkMn4_clrSpectrum();
        me.clkMn4_clrChain();
        me.clkMn4_clrSSGreen();
        me.clkMn4_clrSSYellow();
        me.clkMn4_clrResidue();
        me.clkMn4_clrCharge();
        me.clkMn4_clrHydrophobic();
        me.clkMn4_clrAtom();
        me.clkMn4_clrBfactor();
        me.clkMn4_clrBfactorNorm();
        me.clkMn4_clrConserved();
        me.clkMn4_clrIdentity();
        me.clkMn4_clrRed();
        me.clkMn4_clrGreen();
        me.clkMn4_clrBlue();
        me.clkMn4_clrMagenta();
        me.clkMn4_clrYellow();
        me.clkMn4_clrCyan();
        me.clkMn4_clrWhite();
        me.clkMn4_clrGrey();
        me.clkMn4_clrCustom();
        me.clkMn4_clrSave();
        me.clkMn4_clrApplySave();
        me.clkMn3_styleSave();
        me.clkMn3_styleApplySave();
        me.clkMn5_neighborsYes();
        me.clkMn5_neighborsNo();
        me.clkMn5_surfaceVDW();
        //me.clkMn5_surfaceSES();
        me.clkMn5_surfaceSAS();
        me.clkMn5_surfaceMolecular();
        me.clkMn5_surfaceVDWContext();
        me.clkMn5_surfaceSASContext();
        me.clkMn5_surfaceMolecularContext();
        me.clkMn5_surfaceNo();
        me.clkMn5_opacity10();
        me.clkMn5_opacity09();
        me.clkMn5_opacity08();
        me.clkMn5_opacity07();
        me.clkMn5_opacity06();
        me.clkMn5_opacity05();
        me.clkMn5_opacity04();
        me.clkMn5_opacity03();
        me.clkMn5_opacity02();
        me.clkMn5_opacity01();
        me.clkMn5_wireframeYes();
        me.clkMn5_wireframeNo();
        me.clkMn5_elecmap2fofc();
        me.clkMn5_elecmapfofc();
        me.clkMn5_elecmapNo();
        me.clkMn5_mapwireframeYes();
        me.clkMn5_mapwireframeNo();

        me.clkMn5_emmap();
        me.clkMn5_emmapNo();
        me.clickApplyemmap();
        me.clkMn5_emmapwireframeYes();
        me.clkMn5_emmapwireframeNo();

        me.clkMn6_assemblyYes();
        me.clkMn6_assemblyNo();
        me.clkMn6_addlabelResidues();
        me.clkMn6_addlabelChains();
        me.clkMn6_addlabelTermini();
        me.clkMn6_addlabelYes();
        me.clkMn6_addlabelSelection();
        me.clkMn2_saveselection();
        me.clkMn6_addlabelNo();
        me.clkMn6_distanceYes();
        me.clkmn1_stabilizerOne();
        me.clkmn1_stabilizerRmOne();
        me.clkmn1_thicknessSet();
        me.clkmn5_setThickness();
        me.clkmn1_thicknessReset();
        me.clkMn6_distanceNo();
        me.clkMn2_selectedcenter();
        me.clkMn6_center();
        me.clkMn6_resetOrientation();
        me.clkMn6_chemicalbindingshow();
        me.clkMn6_chemicalbindinghide();
        me.clkMn6_rotateleft();
        me.clkMn6_rotateright();
        me.clkMn6_rotateup();
        me.clkMn6_rotatedown();
        me.clkMn6_cameraPers();
        me.clkMn6_cameraOrth();
        me.clkMn6_bkgdBlack();
        me.clkMn6_bkgdGrey();
        me.clkMn6_bkgdWhite();
        me.clkMn6_bkgdTransparent();
        me.clkMn6_showfogYes();
        me.clkMn6_showfogNo();
        me.clkMn6_showslabYes();
        me.clkMn6_showslabNo();
        me.clkMn6_showaxisYes();
        me.clkMn6_showaxisNo();
        me.clkMn6_hbondsYes();
        me.clkMn6_hbondsNo();
        me.clkmn1_stabilizerYes();
        me.clkmn1_stabilizerNo();
        me.clkMn6_ssbondsYes();
        me.clkMn6_ssbondsNo();
        me.clkMn6_clbondsYes();
        me.clkMn6_clbondsNo();
        me.clickCustomAtoms();
        me.clickShow_selected();
        me.clickShow_annotations();
        me.clickShowallchains();
//        me.clickShow_sequences();
        me.clickShow_alignsequences();
        me.clickShow_2ddgm();
//        me.clickShow_selected_atom();
        me.clickCommand_apply();
        me.clickSearchSeq();
        me.clickReload_pdb();
        me.clickReload_align_refined();
        me.clickReload_align_ori();
        me.clickReload_mmtf();
        me.clickReload_pdbfile();
        me.clickReload_mol2file();
        me.clickReload_sdffile();
        me.clickReload_xyzfile();
        me.clickReload_urlfile();
        me.clickReload_mmciffile();
        me.clickReload_mmcif();
        me.clickReload_mmdb();
        me.clickReload_blast_rep_id();
        me.clickReload_gi();
        me.clickReload_cid();
        me.clickReload_pngimage();
        me.clickReload_state();
        me.clickReload_selectionfile();
        me.clickApplycustomcolor();
        me.clickApplypick_aroundsphere();
        me.clickApplyhbonds();
        me.clickApplymap2fofc();
        me.clickApplymapfofc();
//        me.clickApplystabilizer();
        me.clickApplypick_labels();
        me.clickApplyselection_labels();
        me.clickApplypick_measuredistance();
        me.clickApplypick_stabilizer();
        me.clickApplypick_stabilizer_rm();
        me.pickColor();
        me.clickApply_thickness();
        me.clickReset();
        me.clickToggleHighlight();
        me.pressCommandtext();
//        me.clickFilter_ckbx_all();
//        me.clickFilter();
//        me.clickHighlight_3d_dgm();
        me.clickSeqSaveSelection();
        me.clickAlignSeqSaveSelection();
        me.clickOutputSelection();
        me.click2Ddgm();
        me.bindMouseup();
        me.bindMousedown();
        me.windowResize();
        me.setTabs();
        me.clickAddTrack();
        me.clickDefineHelix();
        me.clickDefineSheet();
        me.clickDefineCoil();
        me.clickDeleteSets();
        me.clickAddTrackButton();

        me.expandShrink();
        me.scrollAnno();
        me.switchHighlightLevel();
    }
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

/*! The following are shared by full_ui.js and simple_ui.js */

if (typeof jQuery === 'undefined') { throw new Error('iCn3DUI requires jQuery') }
if (typeof iCn3D === 'undefined') { throw new Error('iCn3DUI requires iCn3D') }

/*
iCn3DUI.prototype.clickHighlight_3d_dgm = function() { var me = this;
    $("#" + me.pre + "highlight_3d_dgm").click(function (e) {
       //e.preventDefault();
       me.icn3d.removeHlObjects();

       var ckbxes = document.getElementsByName(me.pre + "filter_ckbx");

       var mols = "";

       var molid2ssTmp = {}, molid2colorTmp = {};

       me.icn3d.hAtoms = {};
       for(var i = 0, il = ckbxes.length; i < il; ++i) { // skip the first "all" checkbox
         if(ckbxes[i].checked && ckbxes[i].value != 'chemicals') {
           var value = ckbxes[i].value;
           var chain = ckbxes[i].getAttribute('chain');

           if(me.icn3d.molid2ss.hasOwnProperty(value)) { // condensed view
               molid2ssTmp[value] = me.icn3d.molid2ss[value];
               molid2colorTmp[value] = me.icn3d.molid2color[value];
           }
           else { // all atom view
               me.icn3d.hAtoms = me.icn3d.unionHash(me.icn3d.hAtoms, me.icn3d.chains[chain]);
           }
         }
       }

       me.icn3d.drawHelixBrick(molid2ssTmp, molid2colorTmp, me.icn3d.bHighlight); // condensed view
       me.icn3d.addHlObjects(undefined, false); // all atom view

       me.icn3d.render();
    });
};
*/

iCn3DUI.prototype.rotStruc = function (direction, bInitial) { var me = this;
    if(me.icn3d.bStopRotate) return false;
    if(me.icn3d.rotateCount > me.icn3d.rotateCountMax) {
        // back to the original orientation
        me.icn3d.resetOrientation();

        return false;
    }
    ++me.icn3d.rotateCount;

    if(bInitial !== undefined && bInitial) {
        if(direction === 'left') {
          me.ROT_DIR = 'left';
        }
        else if(direction === 'right') {
          me.ROT_DIR = 'right';
        }
        else if(direction === 'up') {
          me.ROT_DIR = 'up';
        }
        else if(direction === 'down') {
          me.ROT_DIR = 'down';
        }
        else {
          return false;
        }
    }

    if(direction === 'left' && me.ROT_DIR === 'left') {
      me.icn3d.rotateLeft(1);
    }
    else if(direction === 'right' && me.ROT_DIR === 'right') {
      me.icn3d.rotateRight(1);
    }
    else if(direction === 'up' && me.ROT_DIR === 'up') {
      me.icn3d.rotateUp(1);
    }
    else if(direction === 'down' && me.ROT_DIR === 'down') {
      me.icn3d.rotateDown(1);
    }
    else {
      return false;
    }

    setTimeout(function(){ me.rotStruc(direction); }, 100);
};

iCn3DUI.prototype.showTitle = function() { var me = this;
    if(me.icn3d.molTitle !== undefined && me.icn3d.molTitle !== '') {
        var title = me.icn3d.molTitle;

        if(me.inputid === undefined) {
            if(me.icn3d.molTitle.length > 40) title = me.icn3d.molTitle.substr(0, 40) + "...";

            $("#" + me.pre + "title").html(title);
        }
        else if(me.cfg.cid !== undefined) {
            var url = me.getLinkToStructureSummary();

            $("#" + me.pre + "title").html("PubChem CID <a href='" + url + "' target='_blank' style='color:" + me.GREYD + "'>" + me.inputid.toUpperCase() + "</a>: " + title);
        }
        else if(me.cfg.align !== undefined) {
            $("#" + me.pre + "title").html(title);
        }
        else {
            var url = me.getLinkToStructureSummary();

            if(me.icn3d.molTitle.length > 40) title = me.icn3d.molTitle.substr(0, 40) + "...";

            //var asymmetricStr = (me.bAssemblyUseAsu) ? " (Asymmetric Unit)" : "";
            var asymmetricStr = "";

            $("#" + me.pre + "title").html("PDB ID <a href='" + url + "' target='_blank' style='color:" + me.GREYD + "'>" + me.inputid.toUpperCase() + "</a>" + asymmetricStr + ": " + title);
        }
    }
    else {
        $("#" + me.pre + "title").html("");
    }
};

iCn3DUI.prototype.getLinkToStructureSummary = function(bLog) { var me = this;

       var url = "https://www.ncbi.nlm.nih.gov/structure/?term=";

       if(me.cfg.cid !== undefined) {
           url = "https://www.ncbi.nlm.nih.gov/pccompound/?term=";
       }
       else {
           if(me.inputid.indexOf(",") !== -1) {
               url = "https://www.ncbi.nlm.nih.gov/structure/?term=";
           }
           else {
               //url = "https://www.ncbi.nlm.nih.gov/Structure/mmdb/mmdbsrv.cgi?uid=";
               url = "https://www.ncbi.nlm.nih.gov/Structure/pdb/";
           }
       }

       if(me.inputid === undefined) {
           url = "https://www.ncbi.nlm.nih.gov/pccompound/?term=" + me.molTitle;
       }
       else {
           var idArray = me.inputid.split('_');

           if(idArray.length === 1) {
               url += me.inputid;
               if(bLog !== undefined && bLog) me.setLogCmd("link to Structure Summary " + me.inputid + ": " + url, false);
           }
           else if(idArray.length === 2) {
               url += idArray[0] + " OR " + idArray[1];
               if(bLog !== undefined && bLog) me.setLogCmd("link to structures " + idArray[0] + " and " + idArray[1] + ": " + url, false);
           }
       }

       return url;
},

iCn3DUI.prototype.isIE = function() { var me = this;
    //http://stackoverflow.com/questions/19999388/check-if-user-is-using-ie-with-jquery
    var ua = window.navigator.userAgent;
    var msie = ua.indexOf("MSIE ");

    if (msie > 0 || !!navigator.userAgent.match(/Trident.*rv\:11\./))      // If Internet Explorer
        return true;
    else                 // If another browser, return 0
        return false;
};

iCn3DUI.prototype.passFloat32 = function( array, output ){ var me = this;
    var n = array.length;
    if( !output ) output = new Uint8Array( 4 * n );
    var dv = me.getDataView( output );
    for( var i = 0; i < n; ++i ){
        dv.setFloat32( 4 * i, array[ i ], true); // litteEndian = true
    };
    return me.getUint8View( output );
};

iCn3DUI.prototype.passInt8 = function( array, output ){ var me = this;
    var n = array.length;
    if( !output ) output = new Uint8Array( 1 * n );
    var dv = me.getDataView( output );
    for( var i = 0; i < n; ++i ){
        dv.setInt8( 1 * i, array[ i ], true); // litteEndian = true
    };
    return me.getUint8View( output );
};

iCn3DUI.prototype.passInt16 = function( array, output ){ var me = this;
    var n = array.length;
    if( !output ) output = new Uint8Array( 2 * n );
    var dv = me.getDataView( output );
    for( var i = 0; i < n; ++i ){
        dv.setInt16( 2 * i, array[ i ], true); // litteEndian = true
    };
    return me.getUint8View( output );
};

iCn3DUI.prototype.passInt32 = function( array, output ){ var me = this;
    var n = array.length;
    if( !output ) output = new Uint8Array( 4 * n );
    var dv = me.getDataView( output );
    for( var i = 0; i < n; ++i ){
        dv.setInt32( 4 * i, array[ i ], true); // litteEndian = true
    };
    return me.getUint8View( output );
};

// ------------

iCn3DUI.prototype.getUint8View = function( typedArray ){ var me = this;
    return me.getView( Uint8Array, typedArray );
};

iCn3DUI.prototype.getDataView = function( typedArray ){ var me = this;
    return me.getView( DataView, typedArray );
};

iCn3DUI.prototype.getView = function( ctor, typedArray, elemSize ){ var me = this;
    return typedArray ? new ctor(
        typedArray.buffer,
        typedArray.byteOffset,
        typedArray.byteLength / ( elemSize || 1 )
    ) : undefined;
};

iCn3DUI.prototype.getBlobFromBufferAndText = function(arrayBuffer, text) { var me = this;
    //var start = "data:image/png;base64,";

    //var strArray0 = new Uint8Array(start.length);
    //for(var i = 0; i < start.length; ++i) {
    //   strArray0[i] = me.passInt8([start.charCodeAt(i)])[0];
    //}

    var strArray = new Uint8Array(arrayBuffer);

    var strArray2 = new Uint8Array(text.length);
    for(var i = 0; i < text.length; ++i) {
       strArray2[i] = me.passInt8([text.charCodeAt(i)])[0];
    }

    var blobArray = []; // hold blobs

    //blobArray.push(new Blob([strArray0],{ type: "application/octet-stream"}));
    blobArray.push(new Blob([strArray],{ type: "application/octet-stream"}));
    blobArray.push(new Blob([strArray2],{ type: "application/octet-stream"}));

    //var blob = new Blob(blobArray,{ type: "application/octet-stream"});
    var blob = new Blob(blobArray,{ type: "image/png"});

    return blob;
};

iCn3DUI.prototype.getTransformationStr = function(transformation) { var me = this;
    var transformation2 = {"factor": 1.0, "mouseChange": {"x": 0, "y": 0}, "quaternion": {"_x": 0, "_y": 0, "_z": 0, "_w": 1} };
    transformation2.factor = parseFloat(transformation.factor).toPrecision(5);
    transformation2.mouseChange.x = parseFloat(transformation.mouseChange.x).toPrecision(5);
    transformation2.mouseChange.y = parseFloat(transformation.mouseChange.y).toPrecision(5);
    transformation2.quaternion._x = parseFloat(transformation.quaternion._x).toPrecision(5);
    transformation2.quaternion._y = parseFloat(transformation.quaternion._y).toPrecision(5);
    transformation2.quaternion._z = parseFloat(transformation.quaternion._z).toPrecision(5);
    transformation2.quaternion._w = parseFloat(transformation.quaternion._w).toPrecision(5);

    if(transformation2.factor == '1.0000') transformation2.factor = 1;
    if(transformation2.mouseChange.x == '0.0000') transformation2.mouseChange.x = 0;
    if(transformation2.mouseChange.y == '0.0000') transformation2.mouseChange.y = 0;

    if(transformation2.quaternion._x == '0.0000') transformation2.quaternion._x = 0;
    if(transformation2.quaternion._y == '0.0000') transformation2.quaternion._y = 0;
    if(transformation2.quaternion._z == '0.0000') transformation2.quaternion._z = 0;
    if(transformation2.quaternion._w == '1.0000') transformation2.quaternion._w = 1;

    return JSON.stringify(transformation2);
};

/*
iCn3DUI.prototype.createLinkForBlob = function(blob, filename) { var me = this;
    var link = document.createElement('a');
    link.href = window.URL.createObjectURL(blob);
    link.setAttribute('download', filename);
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
};
*/

iCn3DUI.prototype.saveFile = function(filename, type, text) { var me = this;
    //Save file
    var blob;

    if(type === 'command') {
        var dataStr = '';
        for(var i = 0, il = me.icn3d.commands.length; i < il; ++i) {
            var command = me.icn3d.commands[i].trim();
            if(i == il - 1) {
               var command_tf = command.split('|||');

               var transformation = {};
               transformation.factor = me.icn3d._zoomFactor;
               transformation.mouseChange = me.icn3d.mouseChange;
               transformation.quaternion = me.icn3d.quaternion;

               command = command_tf[0] + '|||' + me.getTransformationStr(transformation);
            }

            dataStr += command + '\n';
        }
        var data = decodeURIComponent(dataStr);

        blob = new Blob([data],{ type: "text;charset=utf-8;"});
    }
    else if(type === 'png') {
        me.icn3d.render();

        var bAddURL = true;
        if (!window.File || !window.FileReader || !window.FileList || !window.Blob) {
            bAddURL = false;
        }

        if(me.isIE()) {
            blob = me.icn3d.renderer.domElement.msToBlob();

            if(bAddURL) {
                var reader = new FileReader();
                reader.onload = function (e) {
                    var arrayBuffer = e.target.result; // or = reader.result;

                    var url = me.shareLinkUrl();

                    var text = "";
                    if(me.bInputfile) {
                        text += "\nStart of type file======\n";
                        text += me.InputfileType + "\n";
                        text += "End of type file======\n";

                        text += "Start of data file======\n";
                        text += me.InputfileData;
                        text += "End of data file======\n";

                        text += "Start of state file======\n";
                        text += url;
                        text += "End of state file======\n";
                    }
                    else {
                        text += "\nShare Link: " + url;
                    }

                    blob = me.getBlobFromBufferAndText(arrayBuffer, text);

                    //if(window.navigator.msSaveBlob) navigator.msSaveBlob(blob, filename);
                    saveAs(blob, filename);

                    return;
                };

                reader.readAsArrayBuffer(blob);
            }
        }
        else {
            me.icn3d.renderer.domElement.toBlob(function(data) {
                if(bAddURL) {
                    var reader = new FileReader();
                    reader.onload = function (e) {
                        var arrayBuffer = e.target.result; // or = reader.result;

                        var url = me.shareLinkUrl();

                        var text = "";
                        if(me.bInputfile) {
                            text += "\nStart of type file======\n";
                            text += me.InputfileType + "\n";
                            text += "End of type file======\n";

                            text += "Start of data file======\n";
                            text += me.InputfileData;
                            text += "End of data file======\n";

                            text += "Start of state file======\n";
                            text += url;
                            text += "End of state file======\n";
                        }
                        else {
                            text += "\nShare Link: " + url;
                        }
                        blob = me.getBlobFromBufferAndText(arrayBuffer, text);

                        //me.createLinkForBlob(blob, filename);
                        saveAs(blob, filename);

                        return;
                    };

                    reader.readAsArrayBuffer(data);
                }
                else {
                    blob = data;

                    //me.createLinkForBlob(blob, filename);
                    saveAs(blob, filename);

                    return;
                }
            });
        }
    }
    else if(type === 'html') {
        var dataStr = text;
        var data = decodeURIComponent(dataStr);

        blob = new Blob([data],{ type: "text/html;charset=utf-8;"});
    }
    else if(type === 'text') {
        //var dataStr = text;
        //var data = decodeURIComponent(dataStr);

        //blob = new Blob([data],{ type: "text;charset=utf-8;"});

        var data = text; // here text is an array of text

        blob = new Blob(data,{ type: "text;charset=utf-8;"});
    }
    else if(type === 'binary') {
        var data = text; // here text is an array of blobs

        //blob = new Blob([data],{ type: "application/octet-stream"});
        blob = new Blob(data,{ type: "application/octet-stream"});
    }

/*
    //https://github.com/mholt/PapaParse/issues/175
    //IE11 & Edge
    if(me.isIE() && window.navigator.msSaveBlob){
        navigator.msSaveBlob(blob, filename);
    } else {
        //In FF link must be added to DOM to be clicked
        var link = document.createElement('a');
        link.href = window.URL.createObjectURL(blob);
        link.setAttribute('download', filename);
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
*/

    if(type !== 'png') {
        //https://github.com/eligrey/FileSaver.js/
        saveAs(blob, filename);
    }
};


iCn3DUI.prototype.isMobile = function() {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
};

iCn3DUI.prototype.isMac = function() {
    return /Mac/i.test(navigator.userAgent);
};

iCn3DUI.prototype.isSessionStorageSupported = function() {
  var testKey = 'test';
  try {
    sessionStorage.setItem(testKey, '1');
    sessionStorage.removeItem(testKey);
    return true;
  } catch (error) {
    return false;
  }
};

iCn3DUI.prototype.resizeCanvas = function (width, height, bForceResize, bDraw) { var me = this;
  if( (bForceResize !== undefined && bForceResize) || (me.cfg.resize !== undefined && me.cfg.resize) ) {
    //var heightTmp = parseInt(height) - me.EXTRAHEIGHT;
    var heightTmp = height;
    $("#" + me.pre + "canvas").width(width).height(heightTmp);

    $("#" + me.pre + "viewer").width(width).height(height);

    me.icn3d.setWidthHeight(width, heightTmp);

    if(bDraw === undefined || bDraw) {
        me.icn3d.draw();
    }
  }
};

iCn3DUI.prototype.handleContextLost = function() { var me = this;
    //https://www.khronos.org/webgl/wiki/HandlingContextLost
    // 1 add a lost context handler and tell it to prevent the default behavior

    var canvas = $("#" + me.pre + "canvas")[0];
    canvas.addEventListener("webglcontextlost", function(event) {
        event.preventDefault();
    }, false);

    // 2 re-setup all your WebGL state and re-create all your WebGL resources when the context is restored.
    canvas.addEventListener("webglcontextrestored", function(event) {
        // IE11 error: WebGL content is taking too long to render on your GPU. Temporarily switching to software rendering.
        console.log("WebGL context was lost. Reset WebGLRenderer and launch iCn3D again.");

        me.icn3d.renderer = new THREE.WebGLRenderer({
            canvas: me.icn3d.container.get(0),
            antialias: true,
            preserveDrawingBuffer: true,
            alpha: true
        });

        me.icn3d.draw();

    }, false);
};

iCn3DUI.prototype.windowResize = function() { var me = this;
    if(me.cfg.resize !== undefined && me.cfg.resize && !me.isMobile() ) {
        $(window).resize(function() {
            me.WIDTH = $( window ).width();
            me.HEIGHT = $( window ).height();

            var width = me.WIDTH - me.LESSWIDTH_RESIZE;
            var height = me.HEIGHT - me.LESSHEIGHT - me.EXTRAHEIGHT;

            if(me.icn3d !== undefined) me.resizeCanvas(width, height);
        });
    }
};

iCn3DUI.prototype.setViewerWidthHeight = function() { var me = this;
    me.WIDTH = $( window ).width();
    me.HEIGHT = $( window ).height();

    var viewer_width = $( "#" + me.pre + "viewer" ).width();
    var viewer_height = $( "#" + me.pre + "viewer" ).height();

    if(viewer_width && me.WIDTH > viewer_width) me.WIDTH = viewer_width;
    if(viewer_height && me.HEIGHT > viewer_height) me.HEIGHT = viewer_height;

    if(me.isMac() && me.isMobile()) {
      if(me.WIDTH < me.MENU_WIDTH) me.WIDTH = me.MENU_WIDTH;

      me.HEIGHT = $( window ).height() / $( window ).width() * me.MENU_WIDTH;
    }

    if(me.cfg.width.toString().indexOf('%') === -1) {
        me.WIDTH = parseInt(me.cfg.width) + me.LESSWIDTH;
    }

    if(me.cfg.height.toString().indexOf('%') === -1) {
        me.HEIGHT = parseInt(me.cfg.height) + me.EXTRAHEIGHT + me.LESSHEIGHT;
    }
};

iCn3DUI.prototype.shareLinkUrl = function() { var me = this;
       var url = "https://www.ncbi.nlm.nih.gov/Structure/icn3d/full.html?";

       var pos = -1;
       if(me.cfg.inpara !== undefined) pos = me.cfg.inpara.indexOf('&command=');
       var inparaWithoutCommand = (pos !== -1 ) ? me.cfg.inpara.substr(0, pos) : me.cfg.inpara;

       var start = 0;
       if(inparaWithoutCommand !== undefined) {
         url += inparaWithoutCommand.substr(1) + '&command=';
         start = 1;
       }
       else {
         url += 'command=';
         start = 0;
       }

       if(me.bInputfile) start = 0;

       var transformation = {};
       transformation.factor = me.icn3d._zoomFactor;
       transformation.mouseChange = me.icn3d.mouseChange;
       transformation.quaternion = me.icn3d.quaternion;

       var bCommands = false;
       var statefile = "";
       for(var i = start, il = me.icn3d.commands.length; i < il; ++i) {
           bCommands = true;

           var command_tf = me.icn3d.commands[i].split('|||');
           var commandStr = command_tf[0].trim();

           if(i === il - 1) {
               //var transformation = (command_tf.length > 1) ? ('|||' + command_tf[1]) : '';
               if(i !== 1 && i !== 0) {
                   url += '; ';
               }
               url += commandStr + '|||' + me.getTransformationStr(transformation);
           }
           else if(i === 1) {
               url += commandStr;
           }
           else if(i !== 1 && i !== il - 1) {
               url += '; ' + commandStr;
           }

           statefile += me.icn3d.commands[i] + "\n";
       }

       // remove "&command="
       if(!bCommands) {
           url = url.substr(0, url.length - 9);
       }

       if(me.bInputfile) url = statefile;

       return url;
};

iCn3DUI.prototype.addLabel = function (text, x, y, z, size, color, background, type) { var me = this;
    var label = {}; // Each label contains 'position', 'text', 'color', 'background'

    if(size === '0' || size === '' || size === 'undefined') size = undefined;
    if(color === '0' || color === '' || color === 'undefined') color = undefined;
    if(background === '0' || background === '' || background === 'undefined') background = undefined;

    var position = new THREE.Vector3();
    position.x = x;
    position.y = y;
    position.z = z;

    label.position = position;

    label.text = text;
    label.size = size;
    label.color = color;
    label.background = background;

    if(me.icn3d.labels[type] === undefined) me.icn3d.labels[type] = [];

    if(type !== undefined) {
        me.icn3d.labels[type].push(label);
    }
    else {
        me.icn3d.labels['custom'].push(label);
    }

    me.icn3d.removeHlObjects();

    //me.icn3d.draw();
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3DUI.prototype.showLoading = function () { var me = this;
      if($("#" + me.pre + "wait")) $("#" + me.pre + "wait").show();
      if($("#" + me.pre + "canvas")) $("#" + me.pre + "canvas").hide();
      if($("#" + me.pre + "cmdlog")) $("#" + me.pre + "cmdlog").hide();
};

iCn3DUI.prototype.hideLoading = function () { var me = this;
    if(me.bCommandLoad === undefined || !me.bCommandLoad) {
      if($("#" + me.pre + "wait")) $("#" + me.pre + "wait").hide();
      if($("#" + me.pre + "canvas")) $("#" + me.pre + "canvas").show();
      if($("#" + me.pre + "cmdlog")) $("#" + me.pre + "cmdlog").show();
    }
};

iCn3DUI.prototype.downloadMmcif = function (mmcifid) { var me = this;
   var url, dataType;

   url = "https://files.rcsb.org/view/" + mmcifid + ".cif";

   dataType = "text";

   me.icn3d.bCid = undefined;

   $.ajax({
      url: url,
      dataType: dataType,
      cache: true,
      tryCount : 0,
      retryLimit : 1,
      beforeSend: function() {
          me.showLoading();
      },
      complete: function() {
          me.hideLoading();
      },
      success: function(data) {
           url = "https://www.ncbi.nlm.nih.gov/Structure/mmcifparser/mmcifparser.cgi";
           $.ajax({
              url: url,
              type: 'POST',
              data : {'mmciffile': data},
              dataType: 'jsonp',
              cache: true,
              tryCount : 0,
              retryLimit : 1,
              beforeSend: function() {
                  me.showLoading();
              },
              complete: function() {
                  me.hideLoading();
              },
              success: function(data) {
                  me.loadMmcifData(data);
              },
              error : function(xhr, textStatus, errorThrown ) {
                this.tryCount++;
                if (this.tryCount <= this.retryLimit) {
                    //try again
                    $.ajax(this);
                    return;
                }
                return;
              }
            });
      },
      error : function(xhr, textStatus, errorThrown ) {
        this.tryCount++;
        if (this.tryCount <= this.retryLimit) {
            //try again
            $.ajax(this);
            return;
        }
        return;
      }
    });
};

iCn3DUI.prototype.downloadMmcifSymmetry = function (mmcifid, type) { var me = this;
  // chain functions together
  me.deferredSymmetry = $.Deferred(function() {
      me.downloadMmcifSymmetryBase(mmcifid, type);
  }); // end of me.deferred = $.Deferred(function() {

  return me.deferredSymmetry.promise();
};

iCn3DUI.prototype.downloadMmcifSymmetryBase = function (mmcifid, type) { var me = this;
   var url, dataType;

   if(me.isMac()) { // safari has a problem in getting data from https://files.rcsb.org/header/
       url = "https://files.rcsb.org/view/" + mmcifid + ".cif";
   }
   else {
       url = "https://files.rcsb.org/header/" + mmcifid + ".cif";
   }

   dataType = "text";

   me.icn3d.bCid = undefined;

   $.ajax({
      url: url,
      dataType: dataType,
      cache: true,
      tryCount : 0,
      retryLimit : 1,
      success: function(data) {
           url = "https://www.ncbi.nlm.nih.gov/Structure/mmcifparser/mmcifparser.cgi";

           $.ajax({
              url: url,
              type: 'POST',
              data : {'mmcifheader': data},
              dataType: 'jsonp',
              cache: true,
              tryCount : 0,
              retryLimit : 1,
              success: function(data) {
                  if(data.emd !== undefined) me.icn3d.emd = data.emd;

                  if(me.bAssemblyUseAsu) me.loadMmcifSymmetry(data);

                  if(type === 'mmtfid' && data.missingseq !== undefined) {
                        // adjust missing residues
                        var maxMissingResi = 0, prevMissingChain = '';
                        var chainMissingResidueArray = {};
                        for(var i = 0, il = data.missingseq.length; i < il; ++i) {

                            var resn = data.missingseq[i].resn;
                            var chain = data.missingseq[i].chain;
                            var resi = data.missingseq[i].resi;

                            var chainNum = mmcifid + '_' + chain;

                            if(chainMissingResidueArray[chainNum] === undefined) chainMissingResidueArray[chainNum] = [];
                            var resObject = {};
                            resObject.resi = resi;
                            resObject.name = me.icn3d.residueName2Abbr(resn).toLowerCase();

                            if(chain != prevMissingChain) {
                                maxMissingResi = 0;
                            }

                            // not all listed residues are considered missing, e.g., PDB ID 4OR2, only the firts four residues are considered missing
                            if(!isNaN(resi) && (prevMissingChain == '' || (chain != prevMissingChain) || (chain == prevMissingChain && resi > maxMissingResi)) ) {
                                chainMissingResidueArray[chainNum].push(resObject);

                                maxMissingResi = resi;
                                prevMissingChain = chain;
                            }
                        }

                        me.icn3d.adjustSeq(chainMissingResidueArray);
                  }

                  if(me.deferredSymmetry !== undefined) me.deferredSymmetry.resolve();
              },
              error : function(xhr, textStatus, errorThrown ) {
                this.tryCount++;
                if (this.tryCount <= this.retryLimit) {
                    //try again
                    $.ajax(this);
                    return;
                }

                if(me.deferredSymmetry !== undefined) me.deferredSymmetry.resolve();
                return;
              }
            });
      },
      error : function(xhr, textStatus, errorThrown ) {
        this.tryCount++;
        if (this.tryCount <= this.retryLimit) {
            //try again
            $.ajax(this);
            return;
        }

        return;
      }
    });
};

iCn3DUI.prototype.loadMmcifData = function(data) { var me = this;
    if (data.atoms !== undefined) {
        me.icn3d.init();

        if(data.emd !== undefined) me.icn3d.emd = data.emd;

        if(me.icn3d.emd !== undefined) {
          $("#" + me.pre + "mapWrapper1").hide();
          $("#" + me.pre + "mapWrapper2").hide();
          $("#" + me.pre + "mapWrapper3").hide();
        }
        else {
          $("#" + me.pre + "emmapWrapper1").hide();
          $("#" + me.pre + "emmapWrapper2").hide();
          $("#" + me.pre + "emmapWrapper3").hide();
        }

        me.loadAtomDataIn(data, data.mmcif, 'mmcifid');

        if(me.cfg.align === undefined && Object.keys(me.icn3d.structures).length == 1) {
            $("#" + me.pre + "alternateWrapper").hide();
        }

        // load assembly info
        var assembly = (data.assembly !== undefined) ? data.assembly : [];
        for(var i = 0, il = assembly.length; i < il; ++i) {
          if (me.icn3d.biomtMatrices[i] == undefined) me.icn3d.biomtMatrices[i] = new THREE.Matrix4().identity();

          for(var j = 0, jl = assembly[i].length; j < jl; ++j) {
            me.icn3d.biomtMatrices[i].elements[j] = assembly[i][j];
          }
        }

        if(me.icn3d.biomtMatrices !== undefined && me.icn3d.biomtMatrices.length > 1) {
            $("#" + me.pre + "assemblyWrapper").show();

            me.icn3d.asuCnt = me.icn3d.biomtMatrices.length;
        }
        else {
            $("#" + me.pre + "assemblyWrapper").hide();
        }

        me.icn3d.setAtomStyleByOptions(me.opts);
        me.icn3d.setColorByOptions(me.opts, me.icn3d.atoms);

        me.renderStructure();

        if(me.cfg.rotate !== undefined) me.rotStruc(me.cfg.rotate, true);

        //if(me.cfg.showseq !== undefined && me.cfg.showseq) me.openDialog(me.pre + 'dl_selectresidues', 'Select residues in sequences');

        if(me.deferred !== undefined) me.deferred.resolve(); if(me.deferred2 !== undefined) me.deferred2.resolve();
    }
    else {
        alert('invalid atoms data.');
        return false;
    }
};

iCn3DUI.prototype.loadMmcifSymmetry = function(data) { var me = this;
    // load assembly info
    var assembly = data.assembly;
    var pmatrix = data.pmatrix;

    for(var i = 0, il = assembly.length; i < il; ++i) {
      var mat4 = new THREE.Matrix4();
      mat4.fromArray(assembly[i]);

      me.icn3d.biomtMatrices[i] = mat4;
    }

    me.icn3d.asuCnt = me.icn3d.biomtMatrices.length;
};

iCn3DUI.prototype.parseMmdbData = function (data) { var me = this;
        if(data.atoms === undefined && data.molid2rescount === undefined) {
            alert('invalid MMDB data.');
            return false;
        }

        me.icn3d.init();

        // used in download2Ddgm()
        me.interactionData = {"moleculeInfor": data.moleculeInfor, "intrac": data.intrac, "intracResidues": data.intracResidues};

        me.mmdb_data = data;

        var id = (data.pdbId !== undefined) ? data.pdbId : data.mmdbId;
        me.inputid = id;

        // get molid2color = {}, chain2molid = {}, molid2chain = {};
        var labelsize = 40;

        //var molid2rescount = data.molid2rescount;
        var molid2rescount = data.moleculeInfor;
        var molid2color = {}, chain2molid = {}, molid2chain = {};
        me.icn3d.chainsColor = {};
        me.icn3d.chainsGene = {};

        var html = "<table width='100%'><tr><td></td><th>#</th><th align='center'>Chain</th><th align='center'>Residue Count</th></tr>";

        var index = 1;
        var chainNameHash = {};
        for(var i in molid2rescount) {
          var color = '#' + ( '000000' + molid2rescount[i].color.toString( 16 ) ).slice( - 6 );
          var chainName = molid2rescount[i].chain.trim();
          if(chainNameHash[chainName] === undefined) {
              chainNameHash[chainName] = 1;
          }
          else {
              ++chainNameHash[chainName];
          }

          var chainNameFinal = (chainNameHash[chainName] === 1) ? chainName : chainName + chainNameHash[chainName].toString();
          var chain = id + '_' + chainNameFinal;
          html += "<tr style='color:" + color + "'><td><input type='checkbox' name='" + me.pre + "filter_ckbx' value='" + i + "' chain='" + chain + "'/></td><td align='center'>" + index + "</td><td align='center'>" + chainNameFinal + "</td><td align='center'>" + molid2rescount[i].resCount + "</td></tr>";

          molid2color[i] = color;
          chain2molid[chain] = i;
          molid2chain[i] = chain;

          me.icn3d.chainsColor[chain] = new THREE.Color(color);

          me.icn3d.chainsGene[chain] = {'geneId': molid2rescount[i].geneId, 'geneSymbol': molid2rescount[i].geneSymbol, 'geneDesc': molid2rescount[i].geneDesc};
          ++index;
        }

        if(me.icn3d.chemicals !== undefined && Object.keys(me.icn3d.chemicals).length > 0) {
          html += "<tr><td><input type='checkbox' name='" + me.pre + "filter_ckbx' value='chemicals'/></td><td align='center'>" + index + "</td><td align='center'>Chemicals</td><td align='center'>" + Object.keys(me.icn3d.chemicals).length + " atoms</td></tr>";
        }

        html += "</table>";

        me.icn3d.molid2color = molid2color;
        me.icn3d.chain2molid = chain2molid;
        me.icn3d.molid2chain = molid2chain;

        //if ((me.cfg.inpara !== undefined && me.cfg.inpara.indexOf('mols=') != -1) || (data.atomCount <= maxatomcnt && data.atoms !== undefined) ) {
        // small structure with all atoms
        // show surface options
        $("#" + me.pre + "accordion5").show();

        me.loadAtomDataIn(data, id, 'mmdbid');

        // "asuAtomCount" is defined when: 1) atom count is over the threshold 2) buidx=1 3) asu atom count is smaller than biological unit atom count
        me.bAssemblyUseAsu = (data.asuAtomCount !== undefined) ? true : false;

/*
        if(me.bAssemblyUseAsu) { // set up symmetric matrices
            $("#" + me.pre + "assemblyWrapper").show();
            me.icn3d.bAssembly = true;

            //me.downloadMmcifSymmetry(id);

            $.when(me.downloadMmcifSymmetry(id)).then(function() {
                me.downloadMmdbPart2();
            });
        }
        else {
            $("#" + me.pre + "assemblyWrapper").hide();
            me.icn3d.bAssembly = false;

            me.downloadMmdbPart2();
        }
*/

        $.when(me.downloadMmcifSymmetry(id)).then(function() {
            me.downloadMmdbPart2();
        });
};

iCn3DUI.prototype.downloadMmdb = function (mmdbid, bGi) { var me = this;
   //var maxatomcnt = (me.cfg.maxatomcnt === undefined) ? 50000 : me.cfg.maxatomcnt;
   //var maxatomcnt = 100000; // asymmetric unit (buidx=0) will be returned if above this threshold

   var url;
/*
   if(bGi !== undefined && bGi) {
       url = "https://www.ncbi.nlm.nih.gov/Structure/mmdb/mmdb_strview.cgi?program=w3d&seq=1&b&complexity=3&gi=" + mmdbid + "&ath=" + maxatomcnt;
   }
   else {
       url = "https://www.ncbi.nlm.nih.gov/Structure/mmdb/mmdb_strview.cgi?program=w3d&seq=1&b&complexity=3&uid=" + mmdbid + "&ath=" + maxatomcnt;
   }
*/

   // b: b-factor, s: water, ft: pdbsite
   //&ft=1
   if(bGi !== undefined && bGi) {
       url = "https://www.ncbi.nlm.nih.gov/Structure/mmdb/mmdb_strview.cgi?v=2&program=icn3d&b=1&s=1&ft=1&gi=" + mmdbid;
   }
   else {
       url = "https://www.ncbi.nlm.nih.gov/Structure/mmdb/mmdb_strview.cgi?v=2&program=icn3d&b=1&s=1&ft=1&uid=" + mmdbid;
   }

   me.icn3d.bCid = undefined;

   if(me.cfg.inpara !== undefined) {
     url += me.cfg.inpara;
   }

   if(me.chainids2resids === undefined) me.chainids2resids = {}; // me.chainids2resids[chainid1][chainid2] = [resid, resid]

   $.ajax({
      url: url,
      dataType: 'jsonp',
      cache: true,
      tryCount : 0,
      retryLimit : 1,
      beforeSend: function() {
          me.showLoading();
      },
      complete: function() {
          me.hideLoading();
      },
      success: function(data) {
        var bCalphaOnly = me.icn3d.isCalphaPhosOnly(data.atoms); //, 'CA');

        if(bCalphaOnly || data.atomCount <= me.icn3d.maxatomcnt) {
            me.parseMmdbData(data);
        }
        else {
            data = null;

            $.ajax({
              url: url + '&complexity=2', // alpha carbons
              dataType: 'jsonp',
              cache: true,
              tryCount : 0,
              retryLimit : 1,
              beforeSend: function() {
                  me.showLoading();
              },
              complete: function() {
                  me.hideLoading();
              },
              success: function(data2) {
                  me.parseMmdbData(data2);
              },
              error : function(xhr, textStatus, errorThrown ) {
                this.tryCount++;
                if (this.tryCount <= this.retryLimit) {
                    //try again
                    $.ajax(this);
                    return;
                }

                if(bGi) {
                  alert("This gi " + mmdbid + " has no corresponding 3D structure...");
                }
                else {
                  alert("This mmdbid " + mmdbid + " with the parameters " + me.cfg.inpara
                    + " may not have 3D structure data. Please visit the summary page for details: https://www.ncbi.nlm.nih.gov/Structure/pdb/" + mmdbid);
                }

                return;
              } // success
            }); // ajax
        }
      },
      error : function(xhr, textStatus, errorThrown ) {
        this.tryCount++;
        if (this.tryCount <= this.retryLimit) {
            //try again
            $.ajax(this);
            return;
        }

        if(bGi) {
          alert("This gi " + mmdbid + " has no corresponding 3D structure...");
        }
        else {
          alert("This mmdbid " + mmdbid + " with the parameters " + me.cfg.inpara
            + " may not have 3D structure data. Please visit the summary page for details: https://www.ncbi.nlm.nih.gov/Structure/pdb/" + mmdbid);
        }

        return;
      } // success
    }); // ajax
};

iCn3DUI.prototype.downloadMmdbPart2 = function () { var me = this;
    if(me.bAssemblyUseAsu) { // set up symmetric matrices
        $("#" + me.pre + "assemblyWrapper").show();
        me.icn3d.bAssembly = true;
    }
    else {
        $("#" + me.pre + "assemblyWrapper").hide();
        me.icn3d.bAssembly = false;
    }

    if(me.icn3d.emd !== undefined) {
      $("#" + me.pre + "mapWrapper1").hide();
      $("#" + me.pre + "mapWrapper2").hide();
      $("#" + me.pre + "mapWrapper3").hide();
    }
    else {
      $("#" + me.pre + "emmapWrapper1").hide();
      $("#" + me.pre + "emmapWrapper2").hide();
      $("#" + me.pre + "emmapWrapper3").hide();
    }

    me.icn3d.setAtomStyleByOptions(me.opts);
    // use the original color from cgi output
    if(me.cfg.blast_rep_id !== undefined) {
      me.icn3d.setColorByOptions(me.opts, me.icn3d.atoms);
    }
    else {
      me.icn3d.setColorByOptions(me.opts, me.icn3d.atoms, true);
    }

    me.renderStructure();
    if(me.cfg.rotate !== undefined) me.rotStruc(me.cfg.rotate, true);

    me.html2ddgm = '';
    if(me.cfg.show2d !== undefined && me.cfg.show2d) {
        me.openDialog(me.pre + 'dl_2ddgm', 'Interactions');
        if(me.bFullUi) me.download2Ddgm(me.inputid.toUpperCase());
        //me.download2Ddgm(Object.keys(me.icn3d.structures)[0].toUpperCase());
    }

    if(me.cfg.align === undefined && Object.keys(me.icn3d.structures).length == 1) {
        if($("#" + me.pre + "alternateWrapper") !== null) $("#" + me.pre + "alternateWrapper").hide();
    }

    if(me.deferred !== undefined) me.deferred.resolve(); if(me.deferred2 !== undefined) me.deferred2.resolve();
};

iCn3DUI.prototype.downloadGi = function (gi) { var me = this;
    me.icn3d.bCid = undefined;
    var bGi = true;
    me.downloadMmdb(gi, bGi);
};

iCn3DUI.prototype.downloadBlast_rep_id = function (sequence_structure_ids) { var me = this;
    me.icn3d.bCid = undefined;

    var idArray = sequence_structure_ids.split(',');
    me.cfg.query_id = idArray[0];
    me.cfg.blast_rep_id = idArray[1];

    var mmdbid = me.cfg.blast_rep_id.split('_')[0];

    me.downloadMmdb(mmdbid);
};

iCn3DUI.prototype.getMissingResidues = function (seqArray, type, chainid) { var me = this;
    var prevResi = -9999;
    var missingResBegin = 0;
    var bCount = true;

    for(var i = 0, il = seqArray.length; i < il; ++i) {
        var seqName, resiPos;
        // mmdbid: ["0","R","ARG"],["502","V","VAL"]; mmcifid: [1, "ARG"]; align: [1, "0","R","ARG"]
        if(type === 'mmdbid') {
            seqName = seqArray[i][1];
            resiPos = 0;
        }
        else if(type === 'mmcifid') {
            seqName = seqArray[i][1];
            seqName = me.icn3d.residueName2Abbr(seqName);
            resiPos = 0;
        }
        else if(type === 'align') {
            seqName = seqArray[i][2];
            resiPos = 1;
        }

        // fixe some missing residue names such as residue 6 in 5C1M_A
        if(seqName === '') {
            seqName = 'x';
        }

        var resObject = {};
        resObject.resi = i + 1;
        var resi = parseInt(seqArray[i][resiPos]);
        var nextResi = (i == il - 1) ? 9999 : parseInt(seqArray[i+1][resiPos]);

        if(resi !== 0 ||
          (resi === 0 && (prevResi === -1 || nextResi == 1) )
          ) {
            resObject.name = seqName.toLowerCase();

            if(bCount && missingResBegin > 0) {
                if(me.countNextresiArray[chainid] === undefined) me.countNextresiArray[chainid] = [];

                var count_nextresi = [missingResBegin, parseInt(seqArray[i][0])];

                me.countNextresiArray[chainid].push(count_nextresi);

                missingResBegin = 0;
            }

            bCount = false;
        }
        //else if(resi === 0 && prevResi !== -1) { // sometimes resi could be -4, -3, -2, -1, 0 e.g., PDBID 4YPS
        else { // sometimes resi could be -4, -3, -2, -1, 0 e.g., PDBID 4YPS
            resObject.name = seqName.toLowerCase();
            ++missingResBegin;

            //if(me.chainMissingResidueArray[chainid] === undefined) me.chainMissingResidueArray[chainid] = [];
            //me.chainMissingResidueArray[chainid].push(resObject);

            bCount = true;
        }

        if(me.icn3d.chainsSeq[chainid] === undefined) me.icn3d.chainsSeq[chainid] = [];

        var numberStr = '';
        if(resObject.resi % 10 === 0) numberStr = resObject.resi.toString();

        me.icn3d.chainsSeq[chainid].push(resObject);

        prevResi = resi;
    }
};

iCn3DUI.prototype.loadAtomDataIn = function (data, id, type, seqalign) { var me = this;
    //me.icn3d.init();

    var pmin = new THREE.Vector3( 9999, 9999, 9999);
    var pmax = new THREE.Vector3(-9999,-9999,-9999);
    var psum = new THREE.Vector3();

    var atoms = data.atoms;

    var serial = 0;
    var prevResi = 0;

    var serial2structure = {}; // for "align" only
    var mmdbid2pdbid = {}; // for "align" only

    me.pmid = data.pubmedId;

    var chainid2seq = {}, chainid2kind = {}, chainid2color = {};
    me.chainid2title = {};
    me.chainid2sid = {};

    if(type === 'align') {
      //serial2structure
      me.pmid = "";
      var refinedStr = (me.cfg.inpara.indexOf('atype=1') !== -1) ? 'Invariant Core ' : '';
      me.icn3d.molTitle = refinedStr + 'Structure Alignment of ';

      for (var i = 0, il = data.alignedStructures[0].length; i < il; ++i) {
          var structure = data.alignedStructures[0][i];

          if(i === 1) {
              me.icn3d.secondId = structure.pdbId; // set the second pdbid to add indent in the structure and chain mns
          }

          var pdbidTmp = structure.pdbId;
          var mmdbidTmp = structure.mmdbId;

          for(var j = structure.serialInterval[0], jl = structure.serialInterval[1]; j <= jl; ++j) {
              serial2structure[j] = pdbidTmp.toString();
              mmdbid2pdbid[mmdbidTmp] = pdbidTmp;
          }

          for(var j = 0, jl = structure.molecules.length; j < jl; ++j) {
              var chain = structure.molecules[j].chain;
              var kind = structure.molecules[j].kind;
              var title = structure.molecules[j].name;
              var seq = structure.molecules[j].sequence;
              var sid = structure.molecules[j].sid;

              var chainid = pdbidTmp + '_' + chain;

              if(me.bFullUi) chainid2seq[chainid] = seq;
              chainid2kind[chainid] = kind;

              me.chainid2title[chainid] = title;
              if(sid !== undefined) me.chainid2sid[chainid] = sid;
          }

          me.icn3d.molTitle +=  "<a href=\"https://www.ncbi.nlm.nih.gov/Structure/mmdb/mmdbsrv.cgi?uid=" + structure.pdbId.toUpperCase() + "\" target=\"_blank\" style=\"color: " + me.GREYD + ";\">" + structure.pdbId.toUpperCase() + "</a>";

          if(structure.descr !== undefined) me.pmid += structure.descr.pubmedid;
          if(i === 0) {
              me.icn3d.molTitle += " and ";
              if(structure.descr !== undefined) me.pmid += "_";
          }
      }

      me.icn3d.molTitle += ' from VAST+';

    }
    else { // mmdbid or mmcifid
        if(data.descr !== undefined) me.icn3d.molTitle += data.descr.name;

        if(type === 'mmdbid') {
          var pdbidTmp = data.pdbId;
          var chainHash = {};
          for(var molid in data.moleculeInfor) {
              var chain = data.moleculeInfor[molid].chain.trim();
              var chainid = pdbidTmp + '_' + chain;
              if(chainHash.hasOwnProperty(chain)) {
                  ++chainHash[chain];
                  chainid += chainHash[chain];
              }
              else {
                  chainHash[chain] = 1;
              }

              var kind = data.moleculeInfor[molid].kind;
              var color = data.moleculeInfor[molid].color;
              var sid = data.moleculeInfor[molid].sid;

              chainid2kind[chainid] = kind;
              chainid2color[chainid] = color;

              if(sid !== undefined) me.chainid2sid[chainid] = sid;
          }
        }
    }

    me.countNextresiArray = {};
    //me.chainMissingResidueArray = {};
    if(me.bFullUi) {
        if(type === 'mmdbid' || type === 'mmcifid') {
            for(var chain in data.sequences) {
                var seqArray = data.sequences[chain];
                var chainid = id + '_' + chain;
                //if(type === 'mmcifid') chainid = '1_' + chain;

                me.getMissingResidues(seqArray, type, chainid); // assign me.icn3d.chainsSeq
            }
        }
        else if(type === 'align') {
            for(var chainid in chainid2seq) {
                var seqArray = chainid2seq[chainid];

                me.getMissingResidues(seqArray, type, chainid);
            }
        }
    }

    var atomid2serial = {};
    var prevStructureNum = '', prevChainNum = '', prevResidueNum = '';
    var structureNum = '', chainNum = '', residueNum = '';
    var currContinueSeq = '';
    var oldResi, prevOldResi = -999;
    var prevResi = 0; // continuous from 1 for each chain
    var missingResIndex = 0;
    var bChainSeqSet = true;
    var bAddedNewSeq = false;

    // In align, chemicals do not have assigned chains. Assembly will have the same residue id so that two different residues will be combined in one residue. To avoid this, build an array to check for molid
    var resiArray = [];
    var molid, prevMolid = '', prevmmdbId = '';

    // set mmdbMolidResid2mmdbChainResi
    me.mmdbMolidResid2mmdbChainResi = {};

    var bPhosphorusOnly = me.icn3d.isCalphaPhosOnly(atoms); //, "O3'", "O3*") || me.icn3d.isCalphaPhosOnly(atoms, "P");
    var miscCnt = 0;

    biopolymerChainsHash = {};

    for (var i in atoms) {
        ++serial;

        atomid2serial[i] = serial;

        var atm = atoms[i];
        atm.serial = serial;

        var mmdbId;

        if(type === 'mmdbid' || type === 'mmcifid') {
          mmdbId = id; // here mmdbId is pdbid or mmcif id
        }
        else if(type === 'align') {
          mmdbId = serial2structure[serial]; // here mmdbId is pdbid
        }

        var resiCorrection = 0;
        if(type === 'mmdbid' || type === 'align') {
            atm.resi_ori = parseInt(atm.resi); // original PDB residue number, has to be integer
            atm.resi = atm.ids.r; // corrected for residue insertion code

            resiCorrection = atm.resi - atm.resi_ori;
        }
        else {
            atm.resi = parseInt(atm.resi);
        }

        //if(mmdbId !== prevmmdbId) resiArray = [];
        if(atm.chain === undefined && (type === 'mmdbid' || type === 'align')) {
            if(type === 'mmdbid') {
              molid = atm.ids.m;

              if(me.icn3d.molid2chain[molid] !== undefined) {
                  var pos = me.icn3d.molid2chain[molid].indexOf('_');
                  atm.chain = me.icn3d.molid2chain[molid].substr(pos + 1);
              }
              else {
/*
                  if(molid !== prevMolid) {
                      resiArray.push(atm.resi);
                  }

                  var miscName;
                  if($.inArray(atm.resi, resiArray) === resiArray.length - 1) {
                      miscName = 'Misc';
                  }
                  else {
                      miscName = 'Misc2';
                  }
*/
                  var miscName = 'Misc';

                  ++miscCnt;
                  if(chainid2kind[chainNum] === 'solvent' || atm.resn === 'HOH') {
                      atm.resi = miscCnt;
                  }

                  //if all are defined in the chain section, no "Misc" should appear
                  atm.chain = miscName;
              }
            }
            else if(type === 'align') {
              molid = atm.ids.m;

              if(me.icn3d.pdbid_molid2chain[mmdbId + '_' + molid] !== undefined) {
                  atm.chain = me.icn3d.pdbid_molid2chain[mmdbId + '_' + molid];
              }
              else {
/*
                  if(molid !== prevMolid) {
                      resiArray.push(atm.resi);
                  }

                  var miscName;
                  if($.inArray(atm.resi, resiArray) === resiArray.length - 1) {
                      miscName = 'Misc';
                  }
                  else {
                      miscName = 'Misc2';
                  }
*/
                  var miscName = 'Misc';
                  ++miscCnt;
                  if(chainid2kind[chainNum] === 'solvent' || atm.resn === 'HOH') {
                      atm.resi = miscCnt;
                  }

                  // chemicals do not have assigned chains.
                  atm.chain = miscName;
              }
            }
        }
        else {
          atm.chain = (atm.chain === '') ? 'Misc' : atm.chain;
        }

        atm.chain = atm.chain.trim();

        // mmcif has pre-assigned structure in mmcifparser.cgi output
        if(type === 'mmdbid' || type === 'align') {
            atm.structure = mmdbId;
        }

        structureNum = atm.structure;
        chainNum = structureNum + '_' + atm.chain;

        if(chainNum !== prevChainNum) {
            missingResIndex = 0;
            prevResi = 0;
        }

        if(type === 'mmdbid') {
            atm.coord = new THREE.Vector3(atm.coord[0], atm.coord[1], atm.coord[2]);
        }
        else {
            atm.coord = new THREE.Vector3(atm.coord.x, atm.coord.y, atm.coord.z);
        }

        var oneLetterRes = me.icn3d.residueName2Abbr(atm.resn.substr(0, 3));

/*
        // modify resi since MMDB used the same resi as in PDB where resi is not continuous
        // No need to modify mmcif resi
        //if(type === 'mmdbid' || type === 'align') {
        if(type === 'mmdbid') {
            // bfactor
            //if(type === 'mmdbid') atm.b = (atm.b !== undefined) ? atm.b : 1;

            oldResi = atm.resi;

//          if(atm.resi !== prevOldResi && atm.resi !== prevOldResi + 1) {
            if(me.countNextresiArray[chainNum] !== undefined
              && me.countNextresiArray[chainNum][missingResIndex] !== undefined
              && atm.resi === me.countNextresiArray[chainNum][missingResIndex][1] + resiCorrection) {
                // add missed residues
                var count = me.countNextresiArray[chainNum][missingResIndex][0];
                prevResi += count;

                ++missingResIndex;
            }
//          }

            if(molid !== prevMolid) {
                atm.resi = atm.resi; // don't change the assigned resi
            }
            else if(atm.resi !== prevOldResi) {
                atm.resi = prevResi + 1;
            }

            else {
                atm.resi = prevResi;
            }

            prevOldResi = oldResi;
        }
*/

        if( (type === 'mmdbid' || type === 'align') && me.bFullUi ) {
            // set me.mmdbMolidResid2mmdbChainResi
            me.mmdbMolidResid2mmdbChainResi[mmdbId + '_' + atm.ids.m + '_' + atm.ids.r] = mmdbId + '_' + atm.chain + '_' + atm.resi;
        }

        pmin.min(atm.coord);
        pmax.max(atm.coord);
        psum.add(atm.coord);

        var bProtein = (me.cfg.mmcifid === undefined) ? chainid2kind[chainNum] === 'protein' : atm.mt === 'p';
        var bNucleotide = (me.cfg.mmcifid === undefined) ? chainid2kind[chainNum] === 'nucleotide' : atm.mt === 'n';
        var bSolvent = (me.cfg.mmcifid === undefined) ? chainid2kind[chainNum] === 'solvent' : atm.mt === 's';
        // in vastplus.cgi, ions arenotlisted in alignedStructures...molecules, thus chainid2kind[chainNum] === undefined is used.
        // ions will be separated from chemicals later.
        // here "ligand" is used in the cgi output
        //var bChemicalIons = (me.cfg.mmcifid === undefined) ? (chainid2kind[chainNum] === 'ligand' || chainid2kind[chainNum] === 'otherPolymer' || chainid2kind[chainNum] === undefined) : atm.mt === 'l';
        // kind: other, otherPolymer, etc
        var bChemicalIons = (me.cfg.mmcifid === undefined) ? (chainid2kind[chainNum] === 'ligand' || (chainid2kind[chainNum] !== undefined && chainid2kind[chainNum].indexOf('other') !== -1) || chainid2kind[chainNum] === undefined) : atm.mt === 'l';

        if((atm.chain === 'Misc' || chainid2kind[chainNum] === 'other') && biopolymerChainsHash[chainNum] !== 'protein' && biopolymerChainsHash[chainNum] !== 'nucleotide') { // biopolymer, could be protein or nucleotide
            if(atm.name === 'CA') {
                biopolymerChainsHash[chainNum] = 'protein';
            }
            else if(atm.name === 'P') {
                biopolymerChainsHash[chainNum] = 'nucleotide';
            }
            else {
                biopolymerChainsHash[chainNum] = 'chemical';
            }
        }

/*
        // sometimes proteins or nucleotide may input as chemicals
        // use the hash residueColors for protein residues
        var nucleotideRes = {'G': 1, 'A': 1, 'T': 1, 'C': 1, 'U': 1, 'DG': 1, 'DA': 1, 'DT': 1, 'DC': 1, 'DU': 1};
        if(me.icn3d.residueColors.hasOwnProperty(atm.resn)) {
            bProtein = true;
        }
        else if(nucleotideRes.hasOwnProperty(atm.resn)) {
            bNucleotide = true;
        }
*/

        if (bProtein || bNucleotide)
        {
            if (bProtein) {
              me.icn3d.proteins[serial] = 1;

              if (atm.name === 'CA') me.icn3d.calphas[serial] = 1;
              if (atm.name !== 'N' && atm.name !== 'CA' && atm.name !== 'C' && atm.name !== 'O') me.icn3d.sidec[serial] = 1;
            }
            else if (bNucleotide) {
              me.icn3d.nucleotides[serial] = 1;

              //if (atm.name == 'P') me.icn3d.nucleotidesO3[serial] = 1;
              if (atm.name == "O3'" || atm.name == "O3*" || (bPhosphorusOnly && atm.name == 'P') ) {
                  me.icn3d.nucleotidesO3[serial] = 1;
              }
            }

            atm.het = false;
        }
        else if (bSolvent) { // solvent
          me.icn3d.water[serial] = 1;

          atm.het = true;
        }
        else if (bChemicalIons) { // chemicals and ions
          //if (atm.bonds.length === 0) me.icn3d.ions[serial] = 1;
          if (atm.resn === 'HOH' || atm.resn === 'O') {
              me.icn3d.water[serial] = 1;
          }
          else if (atm.elem === atm.resn) {
              me.icn3d.ions[serial] = 1;
          }
          else {
              me.icn3d.chemicals[serial] = 1;
          }

          atm.het = true;
        }

        if(type === 'mmdbid') {
            //atm.color = (!atm.het) ? new THREE.Color(chainid2color[chainNum]) : me.icn3d.atomColors[atm.elem] || me.icn3d.defaultAtomColor;
            if(!atm.het) {
                atm.color = (chainid2color[chainNum] !== undefined) ? new THREE.Color(chainid2color[chainNum]) : me.icn3d.chargeColors[atm.resn];
            }
            else {
                atm.color = me.icn3d.atomColors[atm.elem] || me.icn3d.defaultAtomColor;
            }
        }
        else {
            if(atm.color !== undefined) atm.color = new THREE.Color(atm.color);
        }

        if(atm.resn.charAt(0) !== ' ' && atm.resn.charAt(1) === ' ') {
          atm.resn = atm.resn.charAt(0);
        }

        // double check
        if (atm.resn == 'HOH') me.icn3d.water[serial] = 1

        me.icn3d.atoms[serial] = atm;
        me.icn3d.dAtoms[serial] = 1;
        me.icn3d.hAtoms[serial] = 1;

        // chain level
        var chainid = atm.structure + '_' + atm.chain;
        if (me.icn3d.chains[chainid] === undefined) me.icn3d.chains[chainid] = {};
        me.icn3d.chains[chainid][serial] = 1;

        // residue level
        var residueid = atm.structure + '_' + atm.chain + '_' + atm.resi;
        if (me.icn3d.residues[residueid] === undefined) me.icn3d.residues[residueid] = {};
        me.icn3d.residues[residueid][serial] = 1;

        residueNum = chainNum + '_' + atm.resi;

        // different residue
        if(residueNum !== prevResidueNum) {
            // different chain
            if(chainNum !== prevChainNum) {
                bChainSeqSet = true;

                if(serial !== 1) {
                    if(me.icn3d.structures[prevStructureNum] === undefined) me.icn3d.structures[prevStructureNum] = [];
                    me.icn3d.structures[prevStructureNum].push(prevChainNum);
                }
            }
        }

        me.icn3d.residueId2Name[residueid] = oneLetterRes;

        var secondaries = '-';
        if(atm.ss === 'helix') {
            secondaries = 'H';
        }
        else if(atm.ss === 'sheet') {
            secondaries = 'E';
        }
        else if(atm.het || bNucleotide ) {
            secondaries = 'o';
        }
        else if(!atm.het && me.icn3d.residueColors.hasOwnProperty(atm.resn.toUpperCase()) ) {
            secondaries = 'c';
        }
        else if(atm.ss === 'coil') {
            secondaries = 'c';
        }

        me.icn3d.secondaries[atm.structure + '_' + atm.chain + '_' + atm.resi] = secondaries;

        if( (atm.resi != prevResi || molid != prevMolid) && me.bFullUi) { // mmdbid 1tup has different molid, same resi
          if(me.icn3d.chainsSeq[chainid] === undefined) {
              me.icn3d.chainsSeq[chainid] = [];
              bChainSeqSet = false;
          }

          // me.icn3d.chainsSeq[chainid][atm.resi - 1] should have been defined for major chains
          if( bChainSeqSet && !bAddedNewSeq && me.icn3d.chainsSeq[chainid][atm.resi - 1] !== undefined) {
              me.icn3d.chainsSeq[chainid][atm.resi - 1].name = oneLetterRes;
          }
          else if(!bChainSeqSet || !me.icn3d.chainsSeq[chainid].hasOwnProperty(atm.resi - 1)) {
              var resObject = {};
              resObject.resi = atm.resi;
              resObject.name = oneLetterRes;
              var numberStr = '';
              if(atm.resi % 10 === 0) numberStr = atm.resi.toString();

              me.icn3d.chainsSeq[chainid].push(resObject);

              bAddedNewSeq = true;
          }
        }

        prevResi = atm.resi;

        prevStructureNum = structureNum;
        prevChainNum = chainNum;
        prevResidueNum = residueNum;

        prevMolid = molid;
        prevmmdbId = mmdbId;
    }

    // adjust biopolymer type
    for(var chainid in biopolymerChainsHash) {
        if(Object.keys(me.icn3d.chains[chainid]).length < 10) continue;

        if(biopolymerChainsHash[chainid] === 'chemical') continue;

        for(var serial in me.icn3d.chains[chainid]) {
            var atm = me.icn3d.atoms[serial];

            delete me.icn3d.chemicals[serial];
            atm.het = false;

            if(biopolymerChainsHash[chainid] === 'protein') {
              me.icn3d.proteins[serial] = 1;
              //atm.style = (me.cfg.align !== undefined) ? 'c alpha trace' : 'ribbon';

              if (atm.name === 'CA') me.icn3d.calphas[serial] = 1;
              if (atm.name !== 'N' && atm.name !== 'CA' && atm.name !== 'C' && atm.name !== 'O') me.icn3d.sidec[serial] = 1;
            }
            else if(biopolymerChainsHash[chainid] === 'nucleotide') {
              me.icn3d.nucleotides[serial] = 1;
              //atm.style = 'nucleotide cartoon';

              if (atm.name == "O3'" || atm.name == "O3*" || (bPhosphorusOnly && atm.name == 'P') ) {
                  me.icn3d.nucleotidesO3[serial] = 1;
              }
            }
        }
    }

    // me.icn3d.adjustSeq(me.chainMissingResidueArray);

    // remove the reference
    data.atoms = {};

    // add the last residue set
    if(me.icn3d.structures[structureNum] === undefined) me.icn3d.structures[structureNum] = [];
    me.icn3d.structures[structureNum].push(chainNum);

    // update bonds info
    if(type !== 'mmcifid') {
    for (var i in me.icn3d.atoms) {
        var bondLength = (me.icn3d.atoms[i].bonds === undefined) ? 0 : me.icn3d.atoms[i].bonds.length;

        for(var j = 0; j < bondLength; ++j) {
            me.icn3d.atoms[i].bonds[j] = atomid2serial[me.icn3d.atoms[i].bonds[j]];
        }
    }
    }

    me.icn3d.cnt = serial;

    if(me.icn3d.cnt > me.icn3d.maxatomcnt || (me.icn3d.biomtMatrices !== undefined && me.icn3d.biomtMatrices.length * me.icn3d.cnt > 10 * me.icn3d.maxatomcnt) ) {
        me.opts['proteins'] = 'c alpha trace'; //ribbon, strand, cylinder and plate, schematic, c alpha trace, b factor tube, lines, stick, ball and stick, sphere, nothing
        me.opts['nucleotides'] = 'o3 trace'; //nucleotide cartoon, o3 trace, schematic, lines, stick,
    }

    me.icn3d.pmin = pmin;
    me.icn3d.pmax = pmax;
    me.icn3d.maxD = pmax.distanceTo(pmin);
    me.icn3d.center = psum.multiplyScalar(1.0 / me.icn3d.cnt);

    if (me.icn3d.maxD < 5) me.icn3d.maxD = 5;
    me.icn3d.oriMaxD = me.icn3d.maxD;
    me.icn3d.oriCenter = me.icn3d.center.clone();

    // set up disulfide bonds
    if(type === 'mmdbid') {
        var disulfideArray = data.disulfides;

        if(disulfideArray !== undefined) {
            for(var i = 0, il = disulfideArray.length; i < il; ++i) {
                var serial1 = disulfideArray[i][0].ca;
                var serial2 = disulfideArray[i][1].ca;

                var atom1 = me.icn3d.atoms[serial1];
                var atom2 = me.icn3d.atoms[serial2];

                var resid1 = atom1.structure + '_' + atom1.chain + '_' + atom1.resi;
                var resid2 = atom2.structure + '_' + atom2.chain + '_' + atom2.resi;

                if(me.icn3d.ssbondpnts[atom1.structure] === undefined) me.icn3d.ssbondpnts[atom1.structure] = [];

                me.icn3d.ssbondpnts[atom1.structure].push(resid1);
                me.icn3d.ssbondpnts[atom1.structure].push(resid2);
            }
        }
    }
    else if(type === 'mmcifid') {
        var disulfideArray = data.disulfides;

        if(disulfideArray !== undefined) {
            if(me.icn3d.ssbondpnts[id] === undefined) me.icn3d.ssbondpnts[id] = [];

            for(var i = 0, il = disulfideArray.length; i < il; ++i) {
                var resid1 = disulfideArray[i][0];
                var resid2 = disulfideArray[i][1];

                me.icn3d.ssbondpnts[id].push(resid1);
                me.icn3d.ssbondpnts[id].push(resid2);
            }

            // copy disulfide bonds
            var structureArray = Object.keys(me.icn3d.structures);
            for(var s = 0, sl = structureArray.length; s < sl; ++s) {
                var structure = structureArray[s];

                if(structure == id) continue;

                if(me.icn3d.ssbondpnts[structure] === undefined) me.icn3d.ssbondpnts[structure] = [];

                for(var j = 0, jl = me.icn3d.ssbondpnts[id].length; j < jl; ++j) {
                    var ori_resid = me.icn3d.ssbondpnts[id][j];
                    var pos = ori_resid.indexOf('_');
                    var resid = structure + ori_resid.substr(pos);

                    me.icn3d.ssbondpnts[structure].push(resid);
                }
            }
        }
    }
    else if(type === 'align') { // calculate disulfide bonds
        // get all Cys residues
        var structure2cys_resid = {};
        for(var chainid in chainid2seq) {
            if(chainid2kind[chainid] == 'protein') {
                var seq = chainid2seq[chainid];
                var structure = chainid.substr(0, chainid.indexOf('_'));

                for(var i = 0, il = seq.length; i < il; ++i) {
                    // each seq[i] = [1,"1","V","VAL NH3+"],
                    if(seq[i][2] == 'C') {
                        if(structure2cys_resid[structure] == undefined) structure2cys_resid[structure] = [];
                        structure2cys_resid[structure].push(chainid + '_' + seq[i][0]);
                    }
                }
            }
        }

        // determine whether there are disulfide bonds
        // disulfide bond is about 2.05 angstrom
        var distMax = 4; //3; // https://icn3d.page.link/5KRXx6XYfig1fkye7
        var distSqrMax = distMax * distMax;
        for(var structure in structure2cys_resid) {
            var cysArray = structure2cys_resid[structure];

            for(var i = 0, il = cysArray.length; i < il; ++i) {
                for(var j = i + 1, jl = cysArray.length; j < jl; ++j) {
                    var resid1 = cysArray[i];
                    var resid2 = cysArray[j];

                    var coord1 = undefined, coord2 = undefined;
                    for(var serial in me.icn3d.residues[resid1]) {
                        if(me.icn3d.atoms[serial].elem == 'S') {
                            coord1 = me.icn3d.atoms[serial].coord;
                            break;
                        }
                    }
                    for(var serial in me.icn3d.residues[resid2]) {
                        if(me.icn3d.atoms[serial].elem == 'S') {
                            coord2 = me.icn3d.atoms[serial].coord;
                            break;
                        }
                    }

                    if(coord1 === undefined || coord2 === undefined) continue;

                    if(Math.abs(coord1.x - coord2.x) > distMax) continue;
                    if(Math.abs(coord1.y - coord2.y) > distMax) continue;
                    if(Math.abs(coord1.z - coord2.z) > distMax) continue;
                    distSqr = (coord1.x - coord2.x)*(coord1.x - coord2.x) + (coord1.y - coord2.y)*(coord1.y - coord2.y) + (coord1.z - coord2.z)*(coord1.z - coord2.z);

                    if(distSqr < distSqrMax) { // disulfide bond
                        if(me.icn3d.ssbondpnts[structure] === undefined) me.icn3d.ssbondpnts[structure] = [];
                        me.icn3d.ssbondpnts[structure].push(resid1);
                        me.icn3d.ssbondpnts[structure].push(resid2);
                    }
                }
            }
        }
    }

    // set up sequence alignment
    // display the structure right away. load the mns and sequences later
//        setTimeout(function(){
    if(type === 'align' && seqalign !== undefined && me.bFullUi) {
        me.setSeqAlign(seqalign, data.alignedStructures);
    } // if(align

    me.showTitle();

    data = {};
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

// from the 2016 NCBI hackathon in Orlando: https://github.com/NCBI-Hackathons/iCN3D-MMTF
// Contributors: Jiyao Wang, Alexander Rose, Peter Rose
// requires the library mmtf.js
iCn3DUI.prototype.downloadMmtf = function (mmtfid) { var me = this;
    MMTF.fetchReduced(
        mmtfid,
        // onLoad callback
        function( mmtfData ){
            if(mmtfData.numAtoms * 10 > me.icn3d.maxatomcnt) {
                var bFull = false;
                me.parseMmtfData(mmtfData, bFull);
            }
            else {
                mmtfData = null;

                MMTF.fetch(
                    mmtfid,
                    // onLoad callback
                    function( mmtfData2 ){
                        var bFull = true;
                        me.parseMmtfData(mmtfData2, bFull);
                    },
                    // onError callback
                    function( error ){
                        console.error( error )
                    }
                );
            }
        },
        // onError callback
        function( error ){
            console.error( error )
        }
    );
};

iCn3DUI.prototype.parseMmtfData = function (mmtfData, bFull) { var me = this;
    var cnt = mmtfData.numAtoms;

    me.icn3d.init();

    var pmin = new THREE.Vector3( 9999, 9999, 9999);
    var pmax = new THREE.Vector3(-9999,-9999,-9999);
    var psum = new THREE.Vector3();

    var id = mmtfData.structureId;

    me.icn3d.molTitle = mmtfData.title;

    // bioAsembly
    if(mmtfData.bioAssemblyList !== undefined && mmtfData.bioAssemblyList[0]!== undefined && mmtfData.bioAssemblyList[0].transformList.length > 1) {
        me.icn3d.biomtMatrices = [];

        for(var i = 0, il = mmtfData.bioAssemblyList[0].transformList.length; i < il; ++i) {
            //var biomt = new THREE.Matrix4().identity();

            //for(var j = 0, jl = mmtfData.bioAssemblyList[0].transformList[i].matrix.length; j < jl; ++j) {
                //biomt.elements[j] = mmtfData.bioAssemblyList[0].transformList[i].matrix[j];
            //}

            var biomt = new THREE.Matrix4().fromArray(mmtfData.bioAssemblyList[0].transformList[i].matrix).transpose();

            me.icn3d.biomtMatrices.push(biomt);
        }
    }

    if(me.icn3d.biomtMatrices !== undefined && me.icn3d.biomtMatrices.length > 1) {
        $("#" + me.pre + "assemblyWrapper").show();

        me.icn3d.asuCnt = me.icn3d.biomtMatrices.length;
    }
    else {
        $("#" + me.pre + "assemblyWrapper").hide();
    }

    var oriindex2serial = {};

    // save SG atoms in CYS residues
    var SGAtomSerialArray = [];

    var prevSS = 'coil';
    var prevChain = '';
    var prevResi = 0;

    var serial = 0;

    var structure, chain, resn, resi, ss, ssbegin, ssend;
    var het, bProtein, bNucleotide;
    var elem, atomName, coord, b, alt;

    var bModifyResi = false;

    var callbackDict = {
        onModel: function( modelData ){
            structure = (modelData.modelIndex === 0) ? id : id + (modelData.modelIndex + 1).toString();
        },
        onChain: function( chainData ){
            bModifyResi = false;

            chain = chainData.chainName; // or chainData.chainId
            var chainid = structure + '_' + chain;

            if(me.icn3d.structures[structure] === undefined) me.icn3d.structures[structure] = [];
            me.icn3d.structures[structure].push(chainid);

/*
            if(me.icn3d.chainsAnTitle[chainid] === undefined ) me.icn3d.chainsAnTitle[chainid] = [];
            if(me.icn3d.chainsAnTitle[chainid][0] === undefined ) me.icn3d.chainsAnTitle[chainid][0] = [];
            if(me.icn3d.chainsAnTitle[chainid][1] === undefined ) me.icn3d.chainsAnTitle[chainid][1] = [];
            me.icn3d.chainsAnTitle[chainid][0].push('');
            me.icn3d.chainsAnTitle[chainid][1].push('SS');
*/
        },
        onGroup: function( groupData ){
            resn = groupData.groupName;
            resi = groupData.groupId;

            //if(resi == prevResi || bModifyResi) {
            //    bModifyResi = true;
            //    resi = prevResi + 1; // for residue insertion code
            //}

            var resid = structure + '_' + chain + '_' + resi;

            if(groupData.secStruct === 0 || groupData.secStruct === 2 || groupData.secStruct === 4) {
                ss = 'helix';
            }
            else if(groupData.secStruct === 3) {
                ss = 'sheet';
            }
            else if(groupData.secStruct === -1) {
                ss = 'other';
            }
            else {
                ss = 'coil';
            }

            // no residue can be both ssbegin and ssend in DSSP calculated secondary structures
            var bSetPrevSsend = false;

            if(chain !== prevChain) {
                // new chain
                if(ss !== 'coil' && ss !== 'other') {
                    ssbegin = true;
                    ssend = false;
                }
                else {
                    ssbegin = false;
                    ssend = false;
                }

                // set up the end of previous chain
                if(prevSS !== 'coil' && prevSS !== 'other') {
                    var prevResid = structure + '_' + prevChain + '_' + prevResi.toString();

                    for(var i in me.icn3d.residues[prevResid]) {
                        me.icn3d.atoms[i].ssbegin = false;
                        me.icn3d.atoms[i].ssend = true;
                    }
                }
            }
            else if(ss !== prevSS) {
                if(prevSS === 'coil' || prevSS === 'other') {
                    ssbegin = true;
                    ssend = false;
                }
                else if(ss === 'coil' || ss === 'other') {
                    bSetPrevSsend = true;
                    ssbegin = false;
                    ssend = false;
                }
                else if( (prevSS === 'sheet' && ss === 'helix') || (prevSS === 'helix' && ss === 'sheet')) {
                    bSetPrevSsend = true;
                    ssbegin = true;
                    ssend = false;
                }
            }
            else {
                    ssbegin = false;
                    ssend = false;
            }

            if(bSetPrevSsend) {
                var prevResid = structure + '_' + chain + '_' + (resi - 1).toString();
                for(var i in me.icn3d.residues[prevResid]) {
                    me.icn3d.atoms[i].ssbegin = false;
                    me.icn3d.atoms[i].ssend = true;
                }
            }

            prevSS = ss;
            prevChain = chain;
            prevResi = resi;

            het = false;
            bProtein = false;
            bNucleotide = false;
            if(groupData.chemCompType.toLowerCase() === 'non-polymer' || groupData.chemCompType.toLowerCase() === 'other' || groupData.chemCompType.toLowerCase().indexOf('saccharide') !== -1) {
                het = true;
            }
            else if(groupData.chemCompType.toLowerCase().indexOf('peptide') !== -1) {
                bProtein = true;
            }
            else if(groupData.chemCompType.toLowerCase().indexOf('dna') !== -1 || groupData.chemCompType.toLowerCase().indexOf('rna') !== -1) {
                bNucleotide = true;
            }
            else {
                bProtein = true;
            }

              // add sequence information
              var chainid = structure + '_' + chain;

              var resObject = {};
              resObject.resi = resi;
              resObject.name = me.icn3d.residueName2Abbr(resn);

              me.icn3d.residueId2Name[resid] = resObject.name;

              var numberStr = '';
              if(resObject.resi % 10 === 0) numberStr = resObject.resi.toString();

              var secondaries = '-';
              if(ss === 'helix') {
                  secondaries = 'H';
              }
              else if(ss === 'sheet') {
                  secondaries = 'E';
              }
              else if(ss === 'coil') {
                  secondaries = 'c';
              }
              else if(ss === 'other') {
                  secondaries = 'o';
              }

              if(me.icn3d.chainsSeq[chainid] === undefined) me.icn3d.chainsSeq[chainid] = [];
              if(me.bFullUi) me.icn3d.chainsSeq[chainid].push(resObject);

              me.icn3d.secondaries[resid] = secondaries;
        },
        onAtom: function( atomData ){
            elem = atomData.element;
            atomName = atomData.atomName;
            coord = new THREE.Vector3(atomData.xCoord, atomData.yCoord, atomData.zCoord);
            b = atomData.bFactor;

            alt = atomData.altLoc;
            if(atomData.altLoc === '\u0000') { // a temp value, should be ''
                alt = '';
            }

            // skip the atoms where alt is not '' or 'A'
            if(alt === '' || alt === 'A') {
                ++serial;

                if(atomName === 'SG') SGAtomSerialArray.push(serial);

                oriindex2serial[atomData.atomIndex] = serial;

                var atomDetails = {
                    het: het, // optional, used to determine chemicals, water, ions, etc
                    serial: serial,         // required, unique atom id
                    name: atomName,             // required, atom name
                    alt: alt,               // optional, some alternative coordinates
                    resn: resn,             // optional, used to determine protein or nucleotide
                    structure: structure,   // optional, used to identify structure
                    chain: chain,           // optional, used to identify chain
                    resi: resi,             // optional, used to identify residue ID
                    //insc: line.substr(26, 1),
                    coord: coord,           // required, used to draw 3D shape
                    b: b,         // optional, used to draw B-factor tube
                    elem: elem,             // optional, used to determine hydrogen bond
                    bonds: [],              // required, used to connect atoms
                    bondOrder: [],
                    ss: ss,             // optional, used to show secondary structures
                    ssbegin: ssbegin,         // optional, used to show the beginning of secondary structures
                    ssend: ssend            // optional, used to show the end of secondary structures
                };

                me.icn3d.atoms[serial] = atomDetails;

                pmin.min(coord);
                pmax.max(coord);
                psum.add(coord);

                var chainid = structure + '_' + chain;
                var resid = chainid + '_' + resi;

                if(me.icn3d.chains[chainid] === undefined) me.icn3d.chains[chainid] = {};
                me.icn3d.chains[chainid][serial] = 1;

                if(me.icn3d.residues[resid] === undefined) me.icn3d.residues[resid] = {};
                me.icn3d.residues[resid][serial] = 1;

                if (bProtein) {
                  me.icn3d.proteins[serial] = 1;

                  if (atomName === 'CA') me.icn3d.calphas[serial] = 1;
                  if (atomName !== 'N' && atomName !== 'CA' && atomName !== 'C' && atomName !== 'O') me.icn3d.sidec[serial] = 1;
                }
                else if (bNucleotide) {
                  me.icn3d.nucleotides[serial] = 1;

                  if (bFull && (atomName == "O3'" || atomName == "O3*")) {
                      me.icn3d.nucleotidesO3[serial] = 1;
                  }
                  else if (!bFull && atomName == 'P') {
                      me.icn3d.nucleotidesO3[serial] = 1;
                  }
                }
                else {
                  if (elem.toLowerCase() === resn.toLowerCase()) {
                      me.icn3d.ions[serial] = 1;
                  }
                  else if(resn === 'HOH' || resn === 'WAT' || resn === 'SQL' || resn === 'H2O' || resn === 'W' || resn === 'DOD' || resn === 'D3O') {
                      me.icn3d.water[serial] = 1;
                  }
                  else {
                      me.icn3d.chemicals[serial] = 1;
                  }
                }

                me.icn3d.dAtoms[serial] = 1;
                me.icn3d.hAtoms[serial] = 1;
            }
        },
        onBond: function( bondData ){
            var from = oriindex2serial[bondData.atomIndex1];
            var to = oriindex2serial[bondData.atomIndex2];

            if(oriindex2serial.hasOwnProperty(bondData.atomIndex1) && oriindex2serial.hasOwnProperty(bondData.atomIndex2)) { // some alt atoms were skipped
                me.icn3d.atoms[from].bonds.push(to);
                me.icn3d.atoms[to].bonds.push(from);

                if(het) {
                    var order = bondData.bondOrder;

                    me.icn3d.atoms[from].bondOrder.push(order);
                    me.icn3d.atoms[to].bondOrder.push(order);

                    if(order === 2) {
                        me.icn3d.doublebonds[from + '_' + to] = 1;
                        me.icn3d.doublebonds[to + '_' + from] = 1;
                    }
                    else if(order === 3) {
                        me.icn3d.triplebonds[from + '_' + to] = 1;
                        me.icn3d.triplebonds[to + '_' + from] = 1;
                    }
                }
            }
        }
    };

    // traverse
    MMTF.traverse( mmtfData, callbackDict );

    // set up disulfide bonds
    var sgLength = SGAtomSerialArray.length;
    for(var i = 0, il = sgLength; i < il; ++i) {
        for(var j = i+1, jl = sgLength; j < il; ++j) {

            var serial1 = SGAtomSerialArray[i];
            var serial2 = SGAtomSerialArray[j];

            var atom1 = me.icn3d.atoms[serial1];
            var atom2 = me.icn3d.atoms[serial2];

            if($.inArray(serial2, atom1.bonds) !== -1) {
                var resid1 = atom1.structure + '_' + atom1.chain + '_' + atom1.resi;
                var resid2 = atom2.structure + '_' + atom2.chain + '_' + atom2.resi;

                if(me.icn3d.ssbondpnts[atom1.structure] === undefined) me.icn3d.ssbondpnts[atom1.structure] = [];

                me.icn3d.ssbondpnts[atom1.structure].push(resid1);
                me.icn3d.ssbondpnts[atom1.structure].push(resid2);
            }
        }
    }

    me.icn3d.cnt = serial;

    if(me.icn3d.cnt > me.icn3d.maxatomcnt || (me.icn3d.biomtMatrices !== undefined && me.icn3d.biomtMatrices.length * me.icn3d.cnt > 10 * me.icn3d.maxatomcnt) ) {
        me.opts['proteins'] = 'c alpha trace'; //ribbon, strand, cylinder and plate, schematic, c alpha trace, b factor tube, lines, stick, ball and stick, sphere, nothing
        me.opts['nucleotides'] = 'o3 trace'; //nucleotide cartoon, o3 trace, schematic, lines, stick,
    }

    me.icn3d.pmin = pmin;
    me.icn3d.pmax = pmax;
    me.icn3d.maxD = pmax.distanceTo(pmin);
    me.icn3d.center = psum.multiplyScalar(1.0 / me.icn3d.cnt);

    if (me.icn3d.maxD < 5) me.icn3d.maxD = 5;
    me.icn3d.oriMaxD = me.icn3d.maxD;
    me.icn3d.oriCenter = me.icn3d.center.clone();

    if(me.cfg.align === undefined && Object.keys(me.icn3d.structures).length == 1) {
        $("#" + me.pre + "alternateWrapper").hide();
    }

    me.icn3d.setAtomStyleByOptions(me.opts);
    me.icn3d.setColorByOptions(me.opts, me.icn3d.atoms);

    me.renderStructure();

    me.showTitle();

    if(me.cfg.rotate !== undefined) me.rotStruc(me.cfg.rotate, true);

    //if(me.cfg.showseq !== undefined && me.cfg.showseq) me.openDialog(me.pre + 'dl_selectresidues', 'Select residues in sequences');

    if(me.deferred !== undefined) me.deferred.resolve(); if(me.deferred2 !== undefined) me.deferred2.resolve();
};



/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3DUI.prototype.downloadPdb = function (pdbid) { var me = this;
   var url, dataType;

   url = "https://files.rcsb.org/view/" + pdbid + ".pdb";

   dataType = "text";

   me.icn3d.bCid = undefined;

   $.ajax({
      url: url,
      dataType: dataType,
      cache: true,
      tryCount : 0,
      retryLimit : 1,
      beforeSend: function() {
          me.showLoading();
      },
      complete: function() {
          me.hideLoading();
      },
      success: function(data) {
          me.loadPdbData(data);
      },
      error : function(xhr, textStatus, errorThrown ) {
        this.tryCount++;
        if (this.tryCount <= this.retryLimit) {
            //try again
            $.ajax(this);
            return;
        }
        return;
      }
   });
};

iCn3DUI.prototype.downloadUrl = function (url, type) { var me = this;
   var dataType = "text";

   me.icn3d.bCid = undefined;

   //var url = '//www.ncbi.nlm.nih.gov/Structure/mmcifparser/mmcifparser.cgi?dataurl=' + encodeURIComponent(url);

   $.ajax({
      url: url,
      dataType: dataType,
      cache: true,
      tryCount : 0,
      retryLimit : 1,
      beforeSend: function() {
          if($("#" + me.pre + "wait")) $("#" + me.pre + "wait").show();
          if($("#" + me.pre + "canvas")) $("#" + me.pre + "canvas").hide();
          if($("#" + me.pre + "cmdlog")) $("#" + me.pre + "cmdlog").hide();
      },
      complete: function() {
          if($("#" + me.pre + "wait")) $("#" + me.pre + "wait").hide();
          if($("#" + me.pre + "canvas")) $("#" + me.pre + "canvas").show();
          if($("#" + me.pre + "cmdlog")) $("#" + me.pre + "cmdlog").show();
      },
      success: function(data) {
        me.InputfileData = data;
        me.InputfileType = type;

        if(type === 'pdb') {
            me.loadPdbData(data);
        }
        else if(type === 'mol2') {
            me.loadMol2Data(data);
        }
        else if(type === 'sdf') {
            me.loadSdfData(data);
        }
        else if(type === 'xyz') {
            me.loadXyzData(data);
        }
        else if(type === 'mmcif') {
            me.loadMmcifData(data);
        }
      },
      error : function(xhr, textStatus, errorThrown ) {
        this.tryCount++;
        if (this.tryCount <= this.retryLimit) {
            //try again
            $.ajax(this);
            return;
        }
        return;
      }
   });
};

iCn3DUI.prototype.loadPdbData = function(data) { var me = this;
      me.icn3d.loadPDB(data); // defined in the core library

      if(me.icn3d.biomtMatrices !== undefined && me.icn3d.biomtMatrices.length > 1) {
        $("#" + me.pre + "assemblyWrapper").show();

        me.icn3d.asuCnt = me.icn3d.biomtMatrices.length;
      }
      else {
        $("#" + me.pre + "assemblyWrapper").hide();
      }

      if(me.icn3d.emd !== undefined) {
          $("#" + me.pre + "mapWrapper1").hide();
          $("#" + me.pre + "mapWrapper2").hide();
          $("#" + me.pre + "mapWrapper3").hide();
      }
      else {
          $("#" + me.pre + "emmapWrapper1").hide();
          $("#" + me.pre + "emmapWrapper2").hide();
          $("#" + me.pre + "emmapWrapper3").hide();
      }

    // calculate secondary structures if not available
    // DSSP only works for structures with all atoms. The Calpha only strucutres didn't work
    //if(!me.icn3d.bSecondaryStructure && !bCalphaOnly) {
    if(!me.icn3d.bSecondaryStructure) {
      me.deferredSecondary = $.Deferred(function() {
          var bCalphaOnly = me.icn3d.isCalphaPhosOnly(me.icn3d.hash2Atoms(me.icn3d.proteins));//, 'CA');
          var calphaonly = (bCalphaOnly) ? '1' : '0';

          me.loadPdbDataBase(data, calphaonly);
      }); // end of me.deferred = $.Deferred(function() {

      return me.deferredSecondary.promise();
    }
    else {
        me.loadPdbDataRender();
    }
};

iCn3DUI.prototype.loadPdbDataBase = function(data, calphaonly) { var me = this;
   var url = "https://www.ncbi.nlm.nih.gov/Structure/mmcifparser/mmcifparser.cgi";

   $.ajax({
      url: url,
      type: 'POST',
      data: {'dssp':'t', 'calphaonly': calphaonly, 'pdbfile': data},
      dataType: 'jsonp',
      cache: true,
      tryCount : 0,
      retryLimit : 1,
      success: function(ssdata) {
        var ssHash = ssdata;

        if(JSON.stringify(ssdata).indexOf('Oops there was a problem') === -1) {
          for(var chainNum in me.icn3d.chainsSeq) {
              var pos = chainNum.indexOf('_');
              var chain = chainNum.substr(pos + 1);

              var residueObjectArray = me.icn3d.chainsSeq[chainNum];
              var prevSS = 'coil';

              for(var i = 0, il = residueObjectArray.length; i < il; ++i) {
                var resi = residueObjectArray[i].resi;
                var chain_resi = chain + '_' + resi;

                var ssOneLetter = 'c';
                if(ssHash.hasOwnProperty(chain_resi)) {
                    ssOneLetter = ssHash[chain_resi];
                }

                var ss;
                if(ssOneLetter === 'H') {
                    ss = 'helix';
                }
                else if(ssOneLetter === 'E') {
                    ss = 'sheet';
                }
                else {
                    ss = 'coil';
                }

                // update ss in sequence window
                //me.icn3d.chainsAn[chainNum][1][i] = ssOneLetter;

                // assign atom ss, ssbegin, and ssend
                var resid = chainNum + '_' + resi;

                me.icn3d.secondaries[resid] = ssOneLetter;

                // no residue can be both ssbegin and ssend in DSSP calculated secondary structures
                var bSetPrevResidue = 0; // 0: no need to reset, 1: reset previous residue to "ssbegin = true", 2: reset previous residue to "ssend = true"

                if(ss !== prevSS) {
                    if(prevSS === 'coil') {
                        ssbegin = true;
                        ssend = false;
                    }
                    else if(ss === 'coil') {
                        bSetPrevResidue = 2;
                        ssbegin = false;
                        ssend = false;
                    }
                    else if( (prevSS === 'sheet' && ss === 'helix') || (prevSS === 'helix' && ss === 'sheet')) {
                        bSetPrevResidue = 1;
                        ssbegin = true;
                        ssend = false;
                    }
                }
                else {
                        ssbegin = false;
                        ssend = false;
                }

                if(bSetPrevResidue == 1) { //1: reset previous residue to "ssbegin = true"
                    var prevResid = chainNum + '_' + (resi - 1).toString();
                    for(var j in me.icn3d.residues[prevResid]) {
                        me.icn3d.atoms[j].ssbegin = true;
                        me.icn3d.atoms[j].ssend = false;
                    }
                }
                else if(bSetPrevResidue == 2) { //2: reset previous residue to "ssend = true"
                    var prevResid = chainNum + '_' + (resi - 1).toString();
                    for(var j in me.icn3d.residues[prevResid]) {
                        me.icn3d.atoms[j].ssbegin = false;
                        me.icn3d.atoms[j].ssend = true;
                    }
                }

                // set the current residue
                for(var j in me.icn3d.residues[resid]) {
                    me.icn3d.atoms[j].ss = ss;
                    me.icn3d.atoms[j].ssbegin = ssbegin;
                    me.icn3d.atoms[j].ssend = ssend;
                }

                prevSS = ss;
              } // for each residue
          } // for each chain
        } // if no error

        me.loadPdbDataRender();

        if(me.deferredSecondary !== undefined) me.deferredSecondary.resolve();
      },
      error : function(xhr, textStatus, errorThrown ) {
        this.tryCount++;
        if (this.tryCount <= this.retryLimit) {
            //try again
            $.ajax(this);
            return;
        }

        me.loadPdbDataRender();
        if(me.deferredSecondary !== undefined) me.deferredSecondary.resolve();
        return;
      }
    });
};

iCn3DUI.prototype.loadPdbDataRender = function() {
    var me = this;

    me.pmid = me.icn3d.pmid;

    if(me.cfg.align === undefined && Object.keys(me.icn3d.structures).length == 1) {
        $("#" + me.pre + "alternateWrapper").hide();
    }

    me.icn3d.setAtomStyleByOptions(me.opts);
    me.icn3d.setColorByOptions(me.opts, me.icn3d.atoms);

    me.renderStructure();

    me.showTitle();

    if(me.cfg.rotate !== undefined) me.rotStruc(me.cfg.rotate, true);

    if(me.deferred !== undefined) me.deferred.resolve(); if(me.deferred2 !== undefined) me.deferred2.resolve();
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3DUI.prototype.downloadCid = function (cid) { var me = this;
    var uri = "https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/" + cid + "/record/SDF/?record_type=3d&response_type=display";

    me.opts['pk'] = 'atom';
    me.opts['chemicals'] = 'ball and stick';

    me.icn3d.opts['pk'] = 'atom';
    me.icn3d.opts['chemicals'] = 'ball and stick';

    me.icn3d.bCid = true;

    $.ajax({
      url: uri,
      dataType: 'text',
      cache: true,
      tryCount : 0,
      retryLimit : 1,
      beforeSend: function() {
          me.showLoading();
      },
      complete: function() {
          me.hideLoading();
      },
      success: function(data) {
        var bResult = me.loadSdfAtomData(data, cid);

        if(me.cfg.align === undefined && Object.keys(me.icn3d.structures).length == 1) {
            $("#" + me.pre + "alternateWrapper").hide();
        }

        if(!bResult) {
          alert('The SDF of CID ' + cid + ' has the wrong format...');
        }
        else {

          me.icn3d.setAtomStyleByOptions(me.opts);
          me.icn3d.setColorByOptions(me.opts, me.icn3d.atoms);

          me.renderStructure();

          if(me.cfg.rotate !== undefined) me.rotStruc(me.cfg.rotate, true);

          if(me.deferred !== undefined) me.deferred.resolve(); if(me.deferred2 !== undefined) me.deferred2.resolve();
        }
      },
      error : function(xhr, textStatus, errorThrown ) {
        this.tryCount++;
        if (this.tryCount <= this.retryLimit) {
            //try again
            $.ajax(this);
            return;
        }
        return;
      }
    })
    .fail(function() {
        alert( "This CID may not have 3D structure..." );
    });
};

iCn3DUI.prototype.loadSdfData = function(data) {
    var me = this;

    var bResult = me.loadSdfAtomData(data);

    if(me.cfg.align === undefined && Object.keys(me.icn3d.structures).length == 1) {
        $("#" + me.pre + "alternateWrapper").hide();
    }

    if(!bResult) {
      alert('The SDF file has the wrong format...');
    }
    else {
      me.icn3d.setAtomStyleByOptions(me.opts);
      me.icn3d.setColorByOptions(me.opts, me.icn3d.atoms);

      me.renderStructure();

      if(me.cfg.rotate !== undefined) me.rotStruc(me.cfg.rotate, true);

      if(me.deferred !== undefined) me.deferred.resolve(); if(me.deferred2 !== undefined) me.deferred2.resolve();
    }
};

iCn3DUI.prototype.loadSdfAtomData = function (data, cid) { var me = this;
    var lines = data.split(/\r?\n|\r/);
    if (lines.length < 4) return false;

    me.icn3d.init();

    var structure = cid ? cid : 1;
    var chain = 'A';
    var resi = 1;
    var resn = 'LIG';

    var moleculeNum = structure;
    var chainNum = structure + '_' + chain;
    var residueNum = chainNum + '_' + resi;

    var atomCount = parseInt(lines[3].substr(0, 3));
    if (isNaN(atomCount) || atomCount <= 0) return false;

    var bondCount = parseInt(lines[3].substr(3, 3));
    var offset = 4;
    if (lines.length < offset + atomCount + bondCount) return false;

    var start = 0;
    var end = atomCount;
    var i, line;

    var atomid2serial = {};
    var skipAtomids = {}; // skip hydrgen atom

    var AtomHash = {};
    var serial = 1;
    for (i = start; i < end; i++) {
        line = lines[offset];
        offset++;

        var name = line.substr(31, 3).replace(/ /g, "");

        if(name !== 'H') {
            var x = parseFloat(line.substr(0, 10));
            var y = parseFloat(line.substr(10, 10));
            var z = parseFloat(line.substr(20, 10));
            var coord = new THREE.Vector3(x, y, z);

            var atomDetails = {
                het: true,              // optional, used to determine chemicals, water, ions, etc
                serial: serial,         // required, unique atom id
                name: name,             // required, atom name
                resn: resn,             // optional, used to determine protein or nucleotide
                structure: structure,   // optional, used to identify structure
                chain: chain,           // optional, used to identify chain
                resi: resi,             // optional, used to identify residue ID
                coord: coord,           // required, used to draw 3D shape
                b: 0,                   // optional, used to draw B-factor tube
                elem: name,             // optional, used to determine hydrogen bond
                bonds: [],              // required, used to connect atoms
                ss: 'coil',             // optional, used to show secondary structures
                ssbegin: false,         // optional, used to show the beginning of secondary structures
                ssend: false,           // optional, used to show the end of secondary structures

                bondOrder: []           // optional, specific for chemicals
            };

            me.icn3d.atoms[serial] = atomDetails;
            AtomHash[serial] = 1;

            atomid2serial[i] = serial;

            ++serial;
        }
        else {
            skipAtomids[i] = 1;
        }
    }

    me.icn3d.dAtoms = AtomHash;
    me.icn3d.hAtoms= AtomHash;
    me.icn3d.structures[moleculeNum] = [chainNum]; //AtomHash;
    me.icn3d.chains[chainNum] = AtomHash;
    me.icn3d.residues[residueNum] = AtomHash;

    me.icn3d.residueId2Name[residueNum] = resn;

    if(me.icn3d.chainsSeq[chainNum] === undefined) me.icn3d.chainsSeq[chainNum] = [];
/*
    if(me.icn3d.chainsAn[chainNum] === undefined ) me.icn3d.chainsAn[chainNum] = [];
    if(me.icn3d.chainsAn[chainNum][0] === undefined ) me.icn3d.chainsAn[chainNum][0] = [];
    if(me.icn3d.chainsAnTitle[chainNum] === undefined ) me.icn3d.chainsAnTitle[chainNum] = [];
    if(me.icn3d.chainsAnTitle[chainNum][0] === undefined ) me.icn3d.chainsAnTitle[chainNum][0] = [];
*/
      var resObject = {};
      resObject.resi = resi;
      resObject.name = resn;

    me.icn3d.chainsSeq[chainNum].push(resObject);
//        me.icn3d.chainsAn[chainNum][0].push(resi);
//        me.icn3d.chainsAnTitle[chainNum][0].push('');

    for (i = 0; i < bondCount; i++) {
        line = lines[offset];
        offset++;
        var fromAtomid = parseInt(line.substr(0, 3)) - 1 + start;
        var toAtomid = parseInt(line.substr(3, 3)) - 1 + start;
        //var order = parseInt(line.substr(6, 3));
        var order = line.substr(6, 3).trim();

        if(!skipAtomids.hasOwnProperty(fromAtomid) && !skipAtomids.hasOwnProperty(toAtomid)) {
            var from = atomid2serial[fromAtomid];
            var to = atomid2serial[toAtomid];

            me.icn3d.atoms[from].bonds.push(to);
            me.icn3d.atoms[from].bondOrder.push(order);
            me.icn3d.atoms[to].bonds.push(from);
            me.icn3d.atoms[to].bondOrder.push(order);
            if(order == '2') {
                me.icn3d.doublebonds[from + '_' + to] = 1;
                me.icn3d.doublebonds[to + '_' + from] = 1;
            }
            else if(order == '3') {
                me.icn3d.triplebonds[from + '_' + to] = 1;
                me.icn3d.triplebonds[to + '_' + from] = 1;
            }
        }
    }

    me.setMaxD();

    me.showTitle();

    return true;
};

iCn3DUI.prototype.setMaxD = function () { var me = this;
    var pmin = new THREE.Vector3( 9999, 9999, 9999);
    var pmax = new THREE.Vector3(-9999,-9999,-9999);
    var psum = new THREE.Vector3();
    var cnt = 0;
    // assign atoms
    for (var i in me.icn3d.atoms) {
        var atom = me.icn3d.atoms[i];
        var coord = atom.coord;
        psum.add(coord);
        pmin.min(coord);
        pmax.max(coord);
        ++cnt;

        if(atom.het) {
          if($.inArray(atom.elem, me.icn3d.ionsArray) !== -1) {
            me.icn3d.ions[atom.serial] = 1;
          }
          else {
            me.icn3d.chemicals[atom.serial] = 1;
          }
        }
    } // end of for


    me.icn3d.pmin = pmin;
    me.icn3d.pmax = pmax;

    me.icn3d.cnt = cnt;

    me.icn3d.maxD = me.icn3d.pmax.distanceTo(me.icn3d.pmin);
    me.icn3d.center = psum.multiplyScalar(1.0 / me.icn3d.cnt);

    if (me.icn3d.maxD < 5) me.icn3d.maxD = 5;
    me.icn3d.oriMaxD = me.icn3d.maxD;
    me.icn3d.oriCenter = me.icn3d.center.clone();
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

// generate a binary STL file for 3D printing
// https://en.wikipedia.org/wiki/STL_(file_format)#Binary_STL
/*
UINT8[80] � Header
UINT32 � Number of triangles

foreach triangle
REAL32[3] � Normal vector
REAL32[3] � Vertex 1
REAL32[3] � Vertex 2
REAL32[3] � Vertex 3
UINT16 � Attribute byte count
end
*/
iCn3DUI.prototype.saveStlFile = function( mat ){ 
    var me = this;
    if(Object.keys(me.icn3d.dAtoms).length > 70000) {
        alert('Please display a subset of the structure to export 3D files. Then merge the files for 3D printing...');
        return [''];
    }

    me.prepareFor3Dprint();

    var cntFaces = 0;
    for(var i = 0, il = me.icn3d.mdl.children.length; i < il; ++i) {
         var mesh = me.icn3d.mdl.children[i];
         if(mesh.type === 'Sprite') continue;

         var geometry = mesh.geometry;

         var faces = geometry.faces;
         if(faces !== undefined) {
             for(var j = 0, jl = faces.length; j < jl; ++j) {
                 ++cntFaces;
             }
         }
    }

    for(var i = 0, il = me.icn3d.mdl_ghost.children.length; i < il; ++i) {
         var mesh = me.icn3d.mdl_ghost.children[i];
         if(mesh.type === 'Sprite') continue;

         var geometry = mesh.geometry;

         var faces = geometry.faces;
         if(faces !== undefined) {
             for(var j = 0, jl = faces.length; j < jl; ++j) {
                 ++cntFaces;
             }
         }
    }

    var blobArray = []; // hold blobs

    var stlArray = new Uint8Array(84);

    // UINT8[80] � Header
    var title = 'STL file for the structure(s) ';
    var structureArray = Object.keys(me.icn3d.structures);
    for(var i = 0, il = structureArray.length; i < il; ++i) {
        title += structureArray[i];
        if(i < il - 1) title += ', ';
    }

    if(title.length > 80) title = title.substr(0, 80);

    for(var i = 0; i < 80; ++i) {
        if(i < title.length) {
            stlArray[i] = me.passInt8([title.charCodeAt(i)])[0];
        }
        else {
            stlArray[i] = me.passInt8([' '.charCodeAt(0)])[0];
        }
    }

    // UINT32 � Number of triangles
    if(me.icn3d.biomtMatrices !== undefined && me.icn3d.biomtMatrices.length > 1 && me.icn3d.bAssembly
      && Object.keys(me.icn3d.dAtoms).length * me.icn3d.biomtMatrices.length <= me.icn3d.maxAtoms3DMultiFile ) {
        stlArray = me.updateArray( stlArray, me.passInt32([cntFaces * me.icn3d.biomtMatrices.length]), 80 );
    }
    else {
        stlArray = me.updateArray( stlArray, me.passInt32([cntFaces]), 80 );
    }

    blobArray.push(new Blob([stlArray],{ type: "application/octet-stream"}));

    blobArray = me.processStlMeshGroup( me.icn3d.mdl, blobArray, mat );

    blobArray = me.processStlMeshGroup( me.icn3d.mdl_ghost, blobArray, mat );

   // assemblies
   if(me.icn3d.biomtMatrices !== undefined && me.icn3d.biomtMatrices.length > 1 && me.icn3d.bAssembly
     && Object.keys(me.icn3d.dAtoms).length * me.icn3d.biomtMatrices.length <= me.icn3d.maxAtoms3DMultiFile ) {
        var identity = new THREE.Matrix4();
        identity.identity();

        for (var i = 0; i < me.icn3d.biomtMatrices.length; i++) {  // skip itself
          var mat1 = me.icn3d.biomtMatrices[i];
          if (mat1 === undefined) continue;

          // skip itself
          if(mat1.equals(identity)) continue;

          blobArray = me.processStlMeshGroup( me.icn3d.mdl, blobArray, mat1 );

          blobArray = me.processStlMeshGroup( me.icn3d.mdl_ghost, blobArray, mat1 );
        }
    }

    //me.resetAfter3Dprint();

    return blobArray;
};

iCn3DUI.prototype.updateArray = function( array, inArray, indexBase ){ var me = this;
    for( var i = 0, il = inArray.length; i < il; ++i ){
        array[indexBase + i] = inArray[i];
    };
    return array;
};

iCn3DUI.prototype.processStlMeshGroup = function( mdl, blobArray, mat ){ var me = this;
    for(var i = 0, il = mdl.children.length; i < il; ++i) {
         var mesh = mdl.children[i];
         if(mesh.type === 'Sprite') continue;

         var geometry = mesh.geometry;

         var vertices = geometry.vertices;
         var faces = geometry.faces;

         if(faces === undefined) continue;

         var position = mesh.position;
         var scale = mesh.scale;

         var matrix = mesh.matrix;

         var stlArray = new Uint8Array(faces.length * 50);

         var index = 0;

         for(var j = 0, jl = faces.length; j < jl; ++j) {
             var a = faces[j].a;
             var b = faces[j].b;
             var c = faces[j].c;
             var normal = faces[j].normal;

             var v1, v2, v3;

             if(geometry.type == 'SphereGeometry' || geometry.type == 'BoxGeometry') {
                 v1 = vertices[a].clone().multiply(scale).add(position);
                 v2 = vertices[b].clone().multiply(scale).add(position);
                 v3 = vertices[c].clone().multiply(scale).add(position);
             }
              else if(geometry.type == 'CylinderGeometry') {
                 v1 = vertices[a].clone().applyMatrix4(matrix);
                 v2 = vertices[b].clone().applyMatrix4(matrix);
                 v3 = vertices[c].clone().applyMatrix4(matrix);
             }
             else {
                 v1 = vertices[a].clone();
                 v2 = vertices[b].clone();
                 v3 = vertices[c].clone();
             }

             //REAL32[3] � Normal vector
             //REAL32[3] � Vertex 1
             //REAL32[3] � Vertex 2
             //REAL32[3] � Vertex 3
             //UINT16 � Attribute byte count

             if(normal !== undefined) {
                 if(mat !== undefined) normal.applyMatrix4(mat);

                 stlArray = me.updateArray( stlArray, me.passFloat32([normal.x, normal.y, normal.z]), index );
                 index += 12;
             }
             else {
                 stlArray = me.updateArray( stlArray, me.passFloat32([0.0, 0.0, 0.0]), index );
                 index += 12;
             }

             if(mat !== undefined) {
                 v1.applyMatrix4(mat);
                 v2.applyMatrix4(mat);
                 v3.applyMatrix4(mat);
             }

             stlArray = me.updateArray( stlArray, me.passFloat32([v1.x, v1.y, v1.z]), index );
             index += 12;
             stlArray = me.updateArray( stlArray, me.passFloat32([v2.x, v2.y, v2.z]), index );
             index += 12;
             stlArray = me.updateArray( stlArray, me.passFloat32([v3.x, v3.y, v3.z]), index );
             index += 12;

             v1 = v2 = v3 = undefined;

             stlArray = me.updateArray( stlArray, me.passInt16([0]), index );
             index += 2;
         }

         blobArray.push(new Blob([stlArray],{ type: "application/octet-stream"}));
         stlArray = null;
    }

    return blobArray;
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

//http://gun.teipir.gr/VRML-amgem/spec/part1/examples.html
iCn3DUI.prototype.saveVrmlFile = function( mat ){ var me = this;
    if(Object.keys(me.icn3d.dAtoms).length > 50000) {
        alert('Please display a subset of the structure to export 3D files. Then merge the files for 3D printing...');
        return [''];
    }

    me.prepareFor3Dprint();

    var vrmlStrArray = [];
    vrmlStrArray.push('#VRML V2.0 utf8\n');

//    vrmlStrArray += 'Transform {\n';
//    vrmlStrArray += '        translation ' + (-1 * me.icn3d.center.x.toPrecision(4)).toString() + ' ' + (-1 * me.icn3d.center.y.toPrecision(4)).toString() + ' ' + (-1 * me.icn3d.center.z.toPrecision(4)).toString() + '\n';
//    vrmlStrArray += '        children [\n';

    var vertexCnt = 0;
    var result = me.processVrmlMeshGroup( me.icn3d.mdl, vrmlStrArray, vertexCnt, mat );
    vrmlStrArray = result.vrmlStrArray;
    vertexCnt = result.vertexCnt;

    result = me.processVrmlMeshGroup( me.icn3d.mdl_ghost, vrmlStrArray, vertexCnt, mat );
    vrmlStrArray = result.vrmlStrArray;
    vertexCnt = result.vertexCnt;

   // assemblies
   if(me.icn3d.biomtMatrices !== undefined && me.icn3d.biomtMatrices.length > 1 && me.icn3d.bAssembly
     && Object.keys(me.icn3d.dAtoms).length * me.icn3d.biomtMatrices.length <= me.icn3d.maxAtoms3DMultiFile ) {
        var identity = new THREE.Matrix4();
        identity.identity();

        for (var i = 0; i < me.icn3d.biomtMatrices.length; i++) {  // skip itself
          var mat1 = me.icn3d.biomtMatrices[i];
          if (mat1 === undefined) continue;

          // skip itself
          if(mat1.equals(identity)) continue;

            result = me.processVrmlMeshGroup( me.icn3d.mdl, vrmlStrArray, vertexCnt, mat1 );
            vrmlStrArray = result.vrmlStrArray;
            vertexCnt = result.vertexCnt;

            result = me.processVrmlMeshGroup( me.icn3d.mdl_ghost, vrmlStrArray, vertexCnt, mat1 );
            vrmlStrArray = result.vrmlStrArray;
            vertexCnt = result.vertexCnt;
        }
    }

    // remove the last ',\n';
//    var vrmlStrArray = vrmlStrArray.substr(0, vrmlStrArray.lastIndexOf(',')) + '\n';

//    vrmlStrArray += '        ]\n';
//    vrmlStrArray += '}\n';

    //me.resetAfter3Dprint();

    //return vrmlStrArray.join('');
    return vrmlStrArray;
};

// The file lost face color after being repaired by https://service.netfabb.com/. It only works with vertex color
// convert face color to vertex color
iCn3DUI.prototype.processVrmlMeshGroup = function( mdl, vrmlStrArray, vertexCnt, mat ){ var me = this;
    for(var i = 0, il = mdl.children.length; i < il; ++i) {
         var mesh = mdl.children[i];
         if(mesh.type === 'Sprite') continue;

         var geometry = mesh.geometry;

         var materialType = mesh.material.type;
         var bSurfaceVertex = (geometry.type == 'Surface') ? true : false;

         var vertices = geometry.vertices;

         if(vertices === undefined) continue;
         vertexCnt += vertices.length;

         var faces = geometry.faces;

         var position = mesh.position;
         var scale = mesh.scale;

         var matrix = mesh.matrix;

         var meshColor = new THREE.Color(1, 1, 1);
         if(geometry.type == 'SphereGeometry' || geometry.type == 'BoxGeometry' || geometry.type == 'CylinderGeometry') {
             if(mesh.material !== undefined) meshColor = mesh.material.color;
         }

         vrmlStrArray.push('Shape {\n');
         vrmlStrArray.push('geometry IndexedFaceSet {\n');

         vrmlStrArray.push('coord Coordinate { point [ ');

         var vertexColorStrArray = [];
         for(var j = 0, jl = vertices.length; j < jl; ++j) {
             var vertex;
             if(geometry.type == 'SphereGeometry' || geometry.type == 'BoxGeometry') {
                 vertex = vertices[j].clone().multiply(scale).add(position);
             }
              else if(geometry.type == 'CylinderGeometry') {
                 vertex = vertices[j].clone().applyMatrix4(matrix);
             }
             else {
                 vertex = vertices[j].clone()
             }

             if(mat !== undefined) vertex.applyMatrix4(mat);

             vrmlStrArray.push(vertex.x.toPrecision(5) + ' ' + vertex.y.toPrecision(5) + ' ' + vertex.z.toPrecision(5));
             vertex = undefined;

             if(j < jl - 1) vrmlStrArray.push(', ');

             vertexColorStrArray.push(new THREE.Color(1, 1, 1));
         }
         vrmlStrArray.push(' ] }\n');

         var coordIndexStr = '', colorStr = '', colorIndexStr = '';
         if(bSurfaceVertex) {
             for(var j = 0, jl = faces.length; j < jl; ++j) {
                 var a = faces[j].a;
                 var b = faces[j].b;
                 var c = faces[j].c;

                 coordIndexStr += a + ' ' + b + ' ' + c;
                 // http://www.lighthouse3d.com/vrml/tutorial/index.shtml?indfs
                 // use -1 to separate polygons
                 if(j < jl - 1) coordIndexStr += ', -1, ';

                 // update vertexColorStrArray
                 vertexColorStrArray[a] = faces[j].vertexColors[0];
                 vertexColorStrArray[b] = faces[j].vertexColors[1];
                 vertexColorStrArray[c] = faces[j].vertexColors[2];
             }

             for(var j = 0, jl = vertexColorStrArray.length; j < jl; ++j) {
                 var color = vertexColorStrArray[j];
                 colorStr += color.r.toPrecision(3) + ' ' + color.g.toPrecision(3) + ' ' + color.b.toPrecision(3);
                 if(j < jl - 1) colorStr += ', ';
             }

             vrmlStrArray.push('coordIndex [ ' + coordIndexStr + ' ]\n');
             vrmlStrArray.push('color Color { color [ ' + colorStr + ' ] } colorPerVertex TRUE\n');
         }
         else {
             for(var j = 0, jl = faces.length; j < jl; ++j) {
                 var a = faces[j].a;
                 var b = faces[j].b;
                 var c = faces[j].c;
                 var color;
                 if(geometry.type == 'SphereGeometry' || geometry.type == 'BoxGeometry' || geometry.type == 'CylinderGeometry') {
                     color = meshColor;
                 }
                 else {
                     color = faces[j].color;
                 }

                 coordIndexStr += a + ' ' + b + ' ' + c;
                 // http://www.lighthouse3d.com/vrml/tutorial/index.shtml?indfs
                 // use -1 to separate polygons
                 if(j < jl - 1) coordIndexStr += ', -1, ';

                 // update vertexColorStrArray
                 vertexColorStrArray[a] = color;
                 vertexColorStrArray[b] = color;
                 vertexColorStrArray[c] = color;
             }

             for(var j = 0, jl = vertexColorStrArray.length; j < jl; ++j) {
                 var color = vertexColorStrArray[j];
                 colorStr += color.r.toPrecision(3) + ' ' + color.g.toPrecision(3) + ' ' + color.b.toPrecision(3);
                 if(j < jl - 1) colorStr += ', ';
             }

             vrmlStrArray.push('coordIndex [ ' + coordIndexStr + ' ]\n');
             vrmlStrArray.push('color Color { color [ ' + colorStr + ' ] } colorPerVertex TRUE\n');
         }

         vrmlStrArray.push('  }\n');
         vrmlStrArray.push('}\n');
    }

    return {'vrmlStrArray': vrmlStrArray,'vertexCnt': vertexCnt};
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3DUI.prototype.setThichknessFor3Dprint = function(  ){ var me = this;
    me.icn3d.lineRadius = 1; //0.1; // hbonds, distance lines
    me.icn3d.coilWidth = 1.2; //0.3; // style cartoon-coil
    me.icn3d.cylinderRadius = 0.8; //0.4; // style stick
    me.icn3d.traceRadius = 1; //0.4; // style c alpha trace, nucleotide stick
    me.icn3d.dotSphereScale = 0.6; //0.3; // style ball and stick, dot

    me.icn3d.sphereRadius = 1.5; // style sphere
    //me.icn3d.cylinderHelixRadius = 1.6; // style sylinder and plate

    me.icn3d.ribbonthickness = 1.0; //0.2; // style ribbon, nucleotide cartoon, stand thickness
    me.icn3d.helixSheetWidth = 2.0; //1.3; // style ribbon, stand thickness
    me.icn3d.nucleicAcidWidth = 1.4; //0.8; // nucleotide cartoon
};

iCn3DUI.prototype.prepareFor3Dprint = function(  ){ var me = this;
    // turn off hilight
    me.icn3d.bShowHighlight = false;
    me.icn3d.removeHlObjects();

    me.bDashedLines = false;

    if(!me.bSetThickness && me.cfg.cid === undefined) {
        me.setThichknessFor3Dprint();
    }

    // change hbond and distance lines from dashed to solid for 3d printing
    if(me.icn3d.lines['hbond'] !== undefined) {
        for(var i = 0, il = me.icn3d.lines['hbond'].length; i < il; ++i) {
            var line = me.icn3d.lines['hbond'][i];
            line.dashed = false;

            me.bDashedLines = true;
        }
    }

/*
    // hbonds within selection
    if(me.icn3d.lines['stabilizer'] !== undefined) {
        for(var i = 0, il = me.icn3d.lines['stabilizer'].length; i < il; ++i) {
            var line = me.icn3d.lines['stabilizer'][i];
            line.dashed = false;

            me.bDashedLines = true;
        }
    }
*/

    if(me.icn3d.lines['distance'] !== undefined) {
        for(var i = 0, il = me.icn3d.lines['distance'].length; i < il; ++i) {
            var line = me.icn3d.lines['distance'][i];
            line.dashed = false;

            me.bDashedLines = true;
        }
    }

    me.icn3d.draw();
};

iCn3DUI.prototype.resetAfter3Dprint = function(  ){ var me = this;
    // change hbond and distance lines from dashed to solid for 3d printing
    //if(me.bDashedLines) {
      if(me.icn3d.lines['hbond'] !== undefined) {
        for(var i = 0, il = me.icn3d.lines['hbond'].length; i < il; ++i) {
            var line = me.icn3d.lines['hbond'][i];
            line.dashed = true;
        }
      }

      if(me.icn3d.lines['distance'] !== undefined) {
        for(var i = 0, il = me.icn3d.lines['distance'].length; i < il; ++i) {
            var line = me.icn3d.lines['distance'][i];
            line.dashed = true;
        }
      }

      me.icn3d.lineRadius = 0.1; // hbonds, distance lines
      me.icn3d.coilWidth = 0.3; // style cartoon-coil
      me.icn3d.cylinderRadius = 0.4; // style stick
      me.icn3d.traceRadius = 0.4; //0.2; // style c alpha trace, nucleotide stick
      me.icn3d.dotSphereScale = 0.3; // style ball and stick, dot
      me.icn3d.sphereRadius = 1.5; // style sphere
      me.icn3d.cylinderHelixRadius = 1.6; // style sylinder and plate

      me.icn3d.ribbonthickness = 0.2; // style ribbon, nucleotide cartoon, stand thickness
      me.icn3d.helixSheetWidth = 1.3; // style ribbon, nucleotide cartoon, stand thickness
      me.icn3d.nucleicAcidWidth = 0.8; // nucleotide cartoon

      //me.icn3d.draw();
    //}
};

iCn3DUI.prototype.removeOneStabilizer = function(rmLineArray) { var me = this;
    var index;
    for(var i = 0, il = me.icn3d.pairArray.length; i < il; i += 2) {
        var atom1 = me.getResidueRepAtom(me.icn3d.pairArray[i]);
        var atom2 = me.getResidueRepAtom(me.icn3d.pairArray[i+1]);

        if(rmLineArray != undefined) {
            for(var j = 0, jl = rmLineArray.length; j < jl; j += 2) {
                var atomb1 = me.getResidueRepAtom(rmLineArray[j]);
                var atomb2 = me.getResidueRepAtom(rmLineArray[j+1]);
                if( (atom1.serial == atomb1.serial && atom2.serial == atomb2.serial)
                  || (atom1.serial == atomb2.serial && atom2.serial == atomb1.serial)
                  ) {
                    index = i;
                    break;
                }
            }
        }

        if(index !== undefined) break;
    }

    if(index !== undefined) {
        me.icn3d.pairArray.splice(index, 2); // removetwoelements at index i
    }
};

iCn3DUI.prototype.outputSelection = function() { var me = this;
    var residues = {};
    for(var i in me.icn3d.hAtoms) {
        var residueId = me.icn3d.atoms[i].structure + '_' + me.icn3d.atoms[i].chain + '_' + me.icn3d.atoms[i].resi;
        residues[residueId] = 1;
    }

    var residueArray = Object.keys(residues).sort(function(a, b) {
                if(a !== '' && !isNaN(a)) {
                    return parseInt(a) - parseInt(b);
                }
                else {
                    var lastPosA = a.lastIndexOf('_');
                    var lastPosB = b.lastIndexOf('_');
                    if(a.substr(0, lastPosA) < b.substr(0, lastPosA)) return -1;
                    else if(a.substr(0, lastPosA) > b.substr(0, lastPosA)) return 1;
                    else if(a.substr(0, lastPosA) == b.substr(0, lastPosA)) {
                        if(parseInt(a.substr(lastPosA + 1)) < parseInt(b.substr(lastPosB + 1)) ) return -1;
                        else if(parseInt(a.substr(lastPosA + 1)) > parseInt(b.substr(lastPosB + 1)) ) return 1;
                        else if(parseInt(a.substr(lastPosA + 1)) == parseInt(b.substr(lastPosB + 1)) ) return 0;
                    }
                }
            });

    var output = "<table><tr><th>Structure</th><th>Chain</th><th>Residue Number</th></tr>";
    for(var i = 0, il = residueArray.length; i < il; ++i) {
        //if(typeof(residueArray[i]) === 'function') continue;

        var firstPos = residueArray[i].indexOf('_');
        var lastPos = residueArray[i].lastIndexOf('_');
        var structure = residueArray[i].substr(0, firstPos);
        var chain = residueArray[i].substr(firstPos + 1, lastPos - firstPos - 1);
        var resi = residueArray[i].substr(lastPos + 1);

        output += "<tr><td>" + structure + "</td><td>" + chain + "</td><td>" + resi + "</td></tr>";
    }

    var file_pref = (me.inputid) ? me.inputid : "custom";
    me.saveFile(file_pref + '_residues.txt', 'html', output);

};

// within the display atoms, show the bonds between C alpha or nucleotide N3
// 1. add hbonds in protein and nucleotide
// 2. add stabilizer between chemicals/ions and proteins
iCn3DUI.prototype.addStabilizer = function () { var me = this;
    var threshold = 3.5; //between 3.2 and 4.0

    var minHbondLen = 3.2;

    //me.icn3d.opts["stabilizer"] = "yes";
    me.icn3d.opts["water"] = "dot";

    if(Object.keys(me.icn3d.dAtoms).length > 0) {

        // 1. add hbonds in nucleotide
        var atomHbond = {};
        var chain_resi_atom;

        var maxlengthSq = threshold * threshold;
        var minlengthSq = minHbondLen * minHbondLen;

        for (var i in me.icn3d.dAtoms) {
          var atom = me.icn3d.atoms[i];

          // protein: N, O
          // DNA: C: O2, N3, N4; G: N1, N2, O6; A: N1, N6; T: N1, N6
          if(me.icn3d.nucleotides.hasOwnProperty(atom.serial) && (atom.name === "N1" || atom.name === "N2"
              || atom.name === "N3" || atom.name === "N4" || atom.name === "N6" || atom.name === "O2" || atom.name === "O6")
              ) { // calculate hydrogen bond in residue backbone
            chain_resi_atom = atom.structure + "_" + atom.chain + "_" + atom.resi + "_" + atom.name;

            atomHbond[chain_resi_atom] = atom;
          }
        } // end of for (var i in molecule) {

        var atomArray = Object.keys(atomHbond);
        var len = atomArray.length;

        if(me.icn3d.pairArray === undefined) me.icn3d.pairArray = [];
        for (var i = 0; i < len; ++i) {
            for (var j = i + 1; j < len; ++j) {
              var atomid1 = atomArray[i];
              var atomid2 = atomArray[j];

              var xdiff = Math.abs(atomHbond[atomid1].coord.x - atomHbond[atomid2].coord.x);
              if(xdiff > threshold) continue;

              var ydiff = Math.abs(atomHbond[atomid1].coord.y - atomHbond[atomid2].coord.y);
              if(ydiff > threshold) continue;

              var zdiff = Math.abs(atomHbond[atomid1].coord.z - atomHbond[atomid2].coord.z);
              if(zdiff > threshold) continue;

              var dist = xdiff * xdiff + ydiff * ydiff + zdiff * zdiff;
              if(dist > maxlengthSq || dist < minlengthSq) continue;

              // output hydrogen bonds
              me.icn3d.pairArray.push(atomHbond[atomid1].serial);
              me.icn3d.pairArray.push(atomHbond[atomid2].serial);
            } // end of for (var j
        } // end of for (var i

        // 2. add stabilizer for chemicals/ions and proteins
        var maxDistance = 6; // connect within 6 angstrom, use 6 since some proteins such as 1FFK_A has large distance between residues

        //displayed residues
        var displayResidueHash = {};
        for(var i in me.icn3d.dAtoms) {
            var atom = me.icn3d.atoms[i];

            var residueid = atom.structure + "_" + atom.chain + "_" + atom.resi;
            displayResidueHash[residueid] = 1;
        }

        // connect chemicals, ions, and every third protein residues to neighbors (within 4 angstrom)
        var residueHash = {};
        //chemicals
        for(var i in me.icn3d.chemicals) {
            var atom = me.icn3d.atoms[i];

            var residueid = atom.structure + "_" + atom.chain + "_" + atom.resi;
            if(displayResidueHash.hasOwnProperty(residueid)) residueHash[residueid] = 1;
        }
        //ions
        for(var i in me.icn3d.ions) {
            var atom = me.icn3d.atoms[i];

            var residueid = atom.structure + "_" + atom.chain + "_" + atom.resi;
            if(displayResidueHash.hasOwnProperty(residueid)) residueHash[residueid] = 1;
        }

        //every third protein residues
        var chainArray = Object.keys(me.icn3d.chains);
        for(var i = 0, il = chainArray.length; i < il; ++i) {
            var chainid = chainArray[i];
            var coilCnt = 0;
            var residueid;
            var prevResi = 0;
            for(var j = 0, jl = me.icn3d.chainsSeq[chainid].length; j < jl; ++j) {
                residueid = chainid + '_' + me.icn3d.chainsSeq[chainid][j].resi;
                if(me.icn3d.secondaries[residueid] == 'c' || me.icn3d.secondaries[residueid] == 'E' || me.icn3d.secondaries[residueid] == 'H') {
                    // add every third residue
                    if(coilCnt % 3 == 0 || me.icn3d.chainsSeq[chainid][j].resi != prevResi + 1) {
                        if(displayResidueHash.hasOwnProperty(residueid)) residueHash[residueid] = 1;
                    }

                    ++coilCnt;

                    prevResi = me.icn3d.chainsSeq[chainid][j].resi;
                }
            }

            // last residue
            if(me.icn3d.secondaries[residueid] == 'c' || me.icn3d.secondaries[residueid] == 'E' || me.icn3d.secondaries[residueid] == 'H') {
                if(displayResidueHash.hasOwnProperty(residueid)) residueHash[residueid] = 1;
            }
        }

        var residueArray = Object.keys(residueHash);

        if(me.icn3d.pairArray === undefined) me.icn3d.pairArray = [];
        // displayed atoms except water
        var dAtomsNotWater = me.icn3d.exclHash(me.icn3d.dAtoms, me.icn3d.water);

        for(var i = 0, il = residueArray.length; i < il; ++i) {
            var residueid = residueArray[i];
            var ss = me.icn3d.secondaries[residueid];

            //var sphere = me.icn3d.getNeighboringAtoms(me.icn3d.dAtoms, me.icn3d.hash2Atoms(me.icn3d.residues[residueid]), maxDistance);
            var sphere = me.icn3d.getNeighboringAtoms(dAtomsNotWater, me.icn3d.hash2Atoms(me.icn3d.residues[residueid]), maxDistance);

            // original atoms
            var sphereArray = Object.keys(sphere).sort();
            var atomArray = Object.keys(me.icn3d.residues[residueid]).sort();

            var bProtein = false;
            if(me.icn3d.proteins.hasOwnProperty(atomArray[0])) { // protein
                atomArray = [atomArray[0]]; // one atom from the residue

                bProtein = true;

                // remove the previous, current and the next residues, chemicals, and ions from "sphere"
                var resi = parseInt(residueid.substr(residueid.lastIndexOf('_') + 1));

                var simSphere = {};
                for(var serial in sphere) {
                    if(me.icn3d.chemicals.hasOwnProperty(serial) || me.icn3d.ions.hasOwnProperty(serial)) continue;

                    var atom = me.icn3d.atoms[serial];
                    if( (ss == 'c' && (atom.resi > resi + 1 || atom.resi < resi - 1) )
                      || (ss == 'E' && (atom.resi > resi + 2 || atom.resi < resi - 2) )
                      || (ss == 'H' && (atom.resi > resi + 4 || atom.resi < resi - 4) )
                      ) {
                        simSphere[serial] = 1;
                    }
                }

                sphereArray = Object.keys(simSphere).sort();
            }

            // one line per each protein residue
            if(sphereArray.length > 0 && atomArray.length > 0) {
                if(bProtein) {
                        var inter2 = parseInt((sphereArray.length + 0.5) / 2.0);
                        me.icn3d.pairArray.push(atomArray[0]);
                        me.icn3d.pairArray.push(sphereArray[inter2]);
                }
                else { // chemicals or ions
                    var n = 10;
                    var step = parseInt(sphereArray.length / (n+1));

                    for(var j = 0, jl = atomArray.length; j < jl; ++j) {
                        if(j % n == 0) { // make one line for every other 10 atoms
                            var sphereIndex = parseInt(j/n) * step;
                            var inter2 = (sphereIndex < sphereArray.length) ?  sphereIndex : sphereArray.length - 1;
                            me.icn3d.pairArray.push(atomArray[j]);
                            me.icn3d.pairArray.push(sphereArray[inter2]);

                            if(atomArray.length < n + 1) {
                                me.icn3d.pairArray.push(atomArray[j]);
                                me.icn3d.pairArray.push(sphereArray[sphereArray.length - 1]);
                            }
                        }
                    }
                } // else
            } // if(sphereArray.length > 0) {
        } // for

        //me.updateStabilizer();

        //me.prepareFor3Dprint();
    }
};

iCn3DUI.prototype.hideStabilizer = function () { var me = this;
    //me.icn3d.opts["stabilizer"] = "no";
    me.icn3d.pairArray = [];

    me.icn3d.lines['stabilizer'] = [];
    me.icn3d.stabilizerpnts = [];

    for(var i in me.icn3d.water) {
        me.icn3d.atoms[i].style = me.icn3d.opts["water"];
    }

    //me.icn3d.draw();
};

iCn3DUI.prototype.getResidueRepPos = function (serial) { var me = this;
    var atomIn = me.icn3d.atoms[serial];
    var residueid = atomIn.structure + "_" + atomIn.chain + "_" + atomIn.resi;

    var pos;
    if(!me.icn3d.proteins.hasOwnProperty(serial) && !me.icn3d.nucleotides.hasOwnProperty(serial)) { // chemicals or ions
        pos = atomIn.coord;
    }
    else {
        for(var i in me.icn3d.residues[residueid]) {
            var atom = me.icn3d.atoms[i];
            if(atom.name === 'N3') { // nucleotide: N3
                pos = me.icn3d.atoms[i].coord;
                break;
            }
            else if(atom.name === 'CA' && atom.ss == 'coil') { // protein coil: CA
                pos = me.icn3d.atoms[i].coord;
                break;
            }
            else if(atom.name === 'CA' && (atom.ss == 'helix' || atom.ss == 'sheet')) { // protein secondary: CA
                pos = (me.icn3d.atoms[i].coord2 !== undefined) ? me.icn3d.atoms[i].coord2 : me.icn3d.atoms[i].coord;
                break;
            }
        }
    }

    if(pos === undefined) pos = atomIn.coord;

    return pos;
};

iCn3DUI.prototype.getResidueRepAtom = function (serial) { var me = this;
    var atomIn = me.icn3d.atoms[serial];
    var residueid = atomIn.structure + "_" + atomIn.chain + "_" + atomIn.resi;

    var foundAtom;
    if(!me.icn3d.proteins.hasOwnProperty(serial) && !me.icn3d.nucleotides.hasOwnProperty(serial)) { // chemicals or ions
        foundAtom = atomIn;
    }
    else {
        for(var i in me.icn3d.residues[residueid]) {
            var atom = me.icn3d.atoms[i];
            if(atom.name === 'CA' || atom.name === 'N3') { // protein: CA, nucleotide: N3
                foundAtom = me.icn3d.atoms[i];
                break;
            }
        }
    }

    if(foundAtom === undefined) foundAtom = atomIn;

    return foundAtom;
};


/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3DUI.prototype.downloadAlignment = function (align) { var me = this;
    me.opts['proteins'] = 'c alpha trace';
    me.icn3d.opts['proteins'] = 'c alpha trace';

    if(me.bFullUi && me.isMac() && me.isMobile) {
        me.MENU_WIDTH = 950; // have enough space to show image in iphone

        me.setViewerWidthHeight();

        var width = me.WIDTH - me.LESSWIDTH;
        var height = me.HEIGHT - me.LESSHEIGHT;

        me.resizeCanvas(width, height, true, false);
    }

    var alignArray = align.split(',');
    //var ids_str = (alignArray.length === 2? 'uids=' : 'ids=') + align;
    var ids_str = 'ids=' + align;
    //var url = 'https://www.ncbi.nlm.nih.gov/Structure/vastplus/vastplus.cgi?cmd=c&w3d&' + ids_str;
    //var url2 = 'https://www.ncbi.nlm.nih.gov/Structure/vastplus/vastplus.cgi?cmd=c1&d&' + ids_str;

    var url = 'https://www.ncbi.nlm.nih.gov/Structure/vastplus/vastplus.cgi?v=2&cmd=c&b=1&s=1&w3d&' + ids_str;
    var url2 = 'https://www.ncbi.nlm.nih.gov/Structure/vastplus/vastplus.cgi?v=2&cmd=c1&b=1&s=1&d=1&' + ids_str;

    if(me.cfg.inpara !== undefined) {
      url += me.cfg.inpara;
      url2 += me.cfg.inpara;
    }

    me.icn3d.bCid = undefined;

    // define for 'align' only
    me.icn3d.pdbid_chain2title = {};

    if(me.chainids2resids === undefined) me.chainids2resids = {}; // me.chainids2resids[chainid1][chainid2] = [resid, resid]

    var request = $.ajax({
       url: url2,
       dataType: 'jsonp',
       cache: true
    });

    var seqalign = {};

    var chained = request.then(function( data ) {
        seqalign = data.seqalign;
        if(seqalign === undefined) {
            alert("These two MMDB IDs " + alignArray + " do not have 3D alignment data.");
            return false;
        }

        // set me.icn3d.pdbid_molid2chain and me.icn3d.chainsColor
        me.icn3d.pdbid_molid2chain = {};
        me.icn3d.chainsColor = {};
        //me.mmdbidArray = [];
        //for(var i in data) {

        for(var i = 0, il = 2; i < il; ++i) {
            //if(i === 'seqalign') continue;
            var mmdbTmp = data['alignedStructures'][0][i];

            //var pdbid = (data[i].pdbid !== undefined) ? data[i].pdbid : i;
            var pdbid = (mmdbTmp.pdbId !== undefined) ? mmdbTmp.pdbId : mmdbTmp.mmdbId;
            //me.mmdbidArray.push(pdbid); // here two molecules are in alphabatic order, themaster molecule could not be the first one

            var chainNameHash = {}; // chain name may be the same in assembly
            for(var molid in mmdbTmp.molecules) {
              var chainName = mmdbTmp.molecules[molid].chain.trim();
              if(chainNameHash[chainName] === undefined) {
                  chainNameHash[chainName] = 1;
              }
              else {
                  ++chainNameHash[chainName];
              }

              var finalChain = (chainNameHash[chainName] === 1) ? chainName : chainName + chainNameHash[chainName].toString();

              me.icn3d.pdbid_molid2chain[pdbid + '_' + molid] = finalChain;

              if(mmdbTmp.molecules[molid].kind === 'p' || mmdbTmp.molecules[molid].kind === 'n') {
                  me.icn3d.chainsColor[pdbid + '_' + finalChain] = new THREE.Color(me.GREY8);
              }
            }
        }

        //var index = 0;
        //for(var mmdbid in data) {
        for(var i = 0, il = 2; i < il; ++i) {
            //if(index < 2) {
                var mmdbTmp = data['alignedStructures'][0][i];

                var pdbid = mmdbTmp.pdbId;

                var molecule = mmdbTmp.molecules;
                for(var molname in molecule) {
                    var chain = molecule[molname].chain;
                    me.icn3d.pdbid_chain2title[pdbid + '_' + chain] = molecule[molname].name;
                }
            //}

            //++index;
        }

        // get the color for each aligned chain pair
        me.alignmolid2color = [];
        me.alignmolid2color[0] = {};
        me.alignmolid2color[1] = {};
        var colorLength = me.icn3d.stdChainColors.length;

        for(var i = 0, il = seqalign.length; i < il; ++i) {
            var molid1 = seqalign[i][0].moleculeId;
            var molid2 = seqalign[i][1].moleculeId;

            me.alignmolid2color[0][molid1] = (i+1).toString();
            me.alignmolid2color[1][molid2] = (i+1).toString();
        }

        return $.ajax({
          url: url,
          dataType: 'jsonp',
          //jsonp: 'jpf',
          cache: true,
          beforeSend: function() {
              me.showLoading();
          },
          complete: function() {
              me.hideLoading();
          }
        });
    });

    chained.done(function( data ) { // url
        if (data.atoms !== undefined) {
            me.icn3d.init();

            me.loadAtomDataIn(data, undefined, 'align', seqalign);

            if(me.cfg.align === undefined && Object.keys(me.icn3d.structures).length == 1) {
                $("#" + me.pre + "alternateWrapper").hide();
            }

            // show all
            var allAtoms = {};
            for(var i in me.icn3d.atoms) {
                allAtoms[i] = 1;
            }
            me.icn3d.dAtoms = allAtoms;
            me.icn3d.hAtoms = allAtoms;

            me.icn3d.setAtomStyleByOptions(me.opts);
            // change the default color to "Identity"
            me.icn3d.setColorByOptions(me.opts, me.icn3d.atoms);

            //var mmdbidArray = me.inputid.split('_');
            me.mmdbidArray = [];
            for(var i = 0, il = data.alignedStructures[0].length; i < il; ++i) {
                me.mmdbidArray.push(data.alignedStructures[0][i].pdbId);
            }

            me.renderStructure();

            if(me.cfg.rotate !== undefined) me.rotStruc(me.cfg.rotate, true);

            me.html2ddgm = '';

            //setTimeout(function(){
            //    me.set2DDiagramsForAlign(me.mmdbidArray[0].toUpperCase(), me.mmdbidArray[1].toUpperCase());
            //}, 0);

            // by default, open the seq alignment window
            //if(me.cfg.show2d !== undefined && me.cfg.show2d) me.openDialog(me.pre + 'dl_2ddgm', 'Interactions');
            if(me.cfg.showalignseq !== undefined && me.cfg.showalignseq) {
                me.openDialog(me.pre + 'dl_alignment', 'Select residues in aligned sequences');
            }

            if(me.cfg.show2d !== undefined && me.cfg.show2d && me.bFullUi) {
                me.set2DDiagramsForAlign(me.mmdbidArray[0].toUpperCase(), me.mmdbidArray[1].toUpperCase());
            }

            //if(me.cfg.showseq !== undefined && me.cfg.showseq) me.openDialog(me.pre + 'dl_selectresidues', 'Select residues in sequences');

            if(me.deferred !== undefined) me.deferred.resolve(); if(me.deferred2 !== undefined) me.deferred2.resolve();
        }
        else {
            alert('invalid atoms data.');
            return false;
        }
    });
};

iCn3DUI.prototype.set2DDiagramsForAlign = function (mmdbid1, mmdbid2) { var me = this;
   me.openDialog(me.pre + 'dl_2ddgm', 'Interactions');

   var url1="https://www.ncbi.nlm.nih.gov/Structure/mmdb/mmdb_strview.cgi?v=2&program=icn3d&uid="+mmdbid1+"&intrac=1";
   var url2="https://www.ncbi.nlm.nih.gov/Structure/mmdb/mmdb_strview.cgi?v=2&program=icn3d&uid="+mmdbid2+"&intrac=1";

   if(me.cfg.inpara !== undefined) {
      url1 += me.cfg.inpara;
      url2 += me.cfg.inpara;
   }

   var request1 = $.ajax({
        url: url1,
        dataType: 'jsonp',
        cache: true
   });

   var request2 = request1.then(function( data ) {
        me.interactionData1 = data;

        me.html2ddgm = '';

        me.draw2Ddgm(data, mmdbid1, 0);
        if(me.cfg.show2d !== undefined && me.cfg.show2d) me.openDialog(me.pre + 'dl_2ddgm', 'Interactions');

        return $.ajax({
          url: url2,
          dataType: 'jsonp',
          cache: true
        });
   });

   request2.done(function( data ) {
        me.interactionData2 = data;

        me.draw2Ddgm(data, mmdbid2, 1);

        me.html2ddgm += "<br>" + me.set2DdgmNote(true);
        $("#" + me.pre + "dl_2ddgm").html(me.html2ddgm);

        me.b2DShown = true;
        //if(me.cfg.show2d !== undefined && me.cfg.show2d) me.openDialog(me.pre + 'dl_2ddgm', 'Interactions');

        if(me.deferredViewinteraction !== undefined) me.deferredViewinteraction.resolve();
   });
};

iCn3DUI.prototype.download2Ddgm = function(mmdbid, structureIndex) {var me = this;
/*
  me.deferred3 = $.Deferred(function() {
    var url="https://www.ncbi.nlm.nih.gov/Structure/mmdb/mmdb_strview.cgi?uid="+mmdbid+"&format=json&intrac=3";

   if(me.cfg.inpara !== undefined) {
      url += me.cfg.inpara;
   }

    $.ajax({
        url: url,
        dataType: 'jsonp',
        tryCount : 0,
        retryLimit : 1,
        success: function( data ) {
            me.draw2Ddgm(data, mmdbid, structureIndex);

            if(me.cfg.show2d !== undefined && me.cfg.show2d) me.openDialog(me.pre + 'dl_2ddgm', 'Interactions');
            if(me.deferred3 !== undefined) me.deferred3.resolve();
        },
        error : function(xhr, textStatus, errorThrown ) {
            this.tryCount++;
            if (this.tryCount <= this.retryLimit) {
                //try again
                $.ajax(this);
                return;
            }
            return;
        }
    });
  });

  return me.deferred3.promise();
*/

    me.set2DDiagrams(mmdbid);
};

iCn3DUI.prototype.set2DDiagrams = function (mmdbid) { var me = this;
    me.openDialog(me.pre + 'dl_2ddgm', 'Interactions');

    if(me.b2DShown === undefined || !me.b2DShown) {
        me.html2ddgm = '';

        me.draw2Ddgm(me.interactionData, mmdbid);

        me.html2ddgm += "<br>" + me.set2DdgmNote();
        $("#" + me.pre + "dl_2ddgm").html(me.html2ddgm);
    }

    me.b2DShown = true;
};

iCn3DUI.prototype.setSeqAlign = function (seqalign, alignedStructures) { var me = this;
      //loadSeqAlignment
      var alignedAtoms = {};
      var mmdbid1 = alignedStructures[0][0].pdbId;
      var mmdbid2 = alignedStructures[0][1].pdbId;

      me.conservedName1 = mmdbid1 + '_cons';
      me.nonConservedName1 = mmdbid1 + '_ncons';
      me.notAlignedName1 = mmdbid1 + '_nalign';

      me.conservedName2 = mmdbid2 + '_cons';
      me.nonConservedName2 = mmdbid2 + '_ncons';
      me.notAlignedName2 = mmdbid2 + '_nalign';

      me.consHash1 = {};
      me.nconsHash1 = {};
      me.nalignHash1 = {};

      me.consHash2 = {};
      me.nconsHash2 = {};
      me.nalignHash2 = {};

      for (var i = 0, il = seqalign.length; i < il; ++i) {
          // first sequence
          var alignData = seqalign[i][0];
          var molid1 = alignData.moleculeId;

          var chain1 = me.icn3d.pdbid_molid2chain[mmdbid1 + '_' + molid1];
          var chainid1 = mmdbid1 + '_' + chain1;

          var id2aligninfo = {};
          var start = alignData.sequence.length, end = -1;
          var bStart = false;
          for(var j = 0, jl = alignData.sequence.length; j < jl; ++j) {
              // 0: internal resi id, 1: pdb resi id, 2: resn, 3: aligned or not
              //var resi = alignData.sequence[j][1];
              var resi = alignData.sequence[j][0];
              var resn = (alignData.sequence[j][2] === '~') ? '-' : alignData.sequence[j][2];
              //resn = resn.toUpperCase();

              var aligned = (alignData.sequence[j][3]) ? 1 : 0; // alignData.sequence[j][3]: 0, false, 1, true

              if(aligned == 1) {
                  if(j < start && !bStart) {
                      start = j;
                      bStart = true; // set start just once
                  }
                  if(j > end) end = j;
              }

              id2aligninfo[j] = {"resi": resi, "resn": resn, "aligned": aligned};
          }

          // second sequence
          alignData = seqalign[i][1];
          var molid2 = alignData.moleculeId;

          var chain2 = me.icn3d.pdbid_molid2chain[mmdbid2 + '_' + molid2];
          var chainid2 = mmdbid2 + '_' + chain2;

          // annoation title for the master seq only
          if(me.icn3d.alnChainsAnTtl[chainid1] === undefined ) me.icn3d.alnChainsAnTtl[chainid1] = [];
          if(me.icn3d.alnChainsAnTtl[chainid1][0] === undefined ) me.icn3d.alnChainsAnTtl[chainid1][0] = [];
          if(me.icn3d.alnChainsAnTtl[chainid1][1] === undefined ) me.icn3d.alnChainsAnTtl[chainid1][1] = [];
          if(me.icn3d.alnChainsAnTtl[chainid1][2] === undefined ) me.icn3d.alnChainsAnTtl[chainid1][2] = [];
          if(me.icn3d.alnChainsAnTtl[chainid1][3] === undefined ) me.icn3d.alnChainsAnTtl[chainid1][3] = [];
          if(me.icn3d.alnChainsAnTtl[chainid1][4] === undefined ) me.icn3d.alnChainsAnTtl[chainid1][4] = [];
          if(me.icn3d.alnChainsAnTtl[chainid1][5] === undefined ) me.icn3d.alnChainsAnTtl[chainid1][5] = [];
          if(me.icn3d.alnChainsAnTtl[chainid1][6] === undefined ) me.icn3d.alnChainsAnTtl[chainid1][6] = [];

          // two annotations without titles
          me.icn3d.alnChainsAnTtl[chainid1][0].push(chainid2);
          me.icn3d.alnChainsAnTtl[chainid1][1].push(chainid1);
          me.icn3d.alnChainsAnTtl[chainid1][2].push("");
          me.icn3d.alnChainsAnTtl[chainid1][3].push("");

          // 2nd chain title
          me.icn3d.alnChainsAnTtl[chainid1][4].push(chainid2);
          // master chain title
          me.icn3d.alnChainsAnTtl[chainid1][5].push(chainid1);
          // empty line
          me.icn3d.alnChainsAnTtl[chainid1][6].push("");

          var alignIndex = 1;
          //for(var j = 0, jl = alignData.sseq.length; j < jl; ++j) {
          for(var j = start; j <= end; ++j) {
              // 0: internal resi id, 1: pdb resi id, 2: resn, 3: aligned or not
              //var resi = alignData.sequence[j][1];
              var resi = alignData.sequence[j][0];
              var resn = (alignData.sequence[j][2] === '~') ? '-' : alignData.sequence[j][2];
              //resn = resn.toUpperCase();

              var alignedTmp = (alignData.sequence[j][3]) ? 1 : 0; // alignData.sequence[j][3]: 0, false, 1, true

              var aligned = id2aligninfo[j].aligned + alignedTmp; // 0 or 2

              var color, color2, classname;
              if(aligned === 2) { // aligned
                  if(id2aligninfo[j].resn === resn) {
                      color = '#FF0000';
                      classname = 'icn3d-cons';

                      me.consHash1[chainid1 + '_' + id2aligninfo[j].resi] = 1;
                      me.consHash2[chainid2 + '_' + resi] = 1;
                  }
                  else {
                      color = '#0000FF';
                      classname = 'icn3d-ncons';

                      me.nconsHash1[chainid1 + '_' + id2aligninfo[j].resi] = 1;
                      me.nconsHash2[chainid2 + '_' + resi] = 1;
                  }

                  color2 = '#' + me.getColorhexFromBlosum62(id2aligninfo[j].resn, resn);

                  // expensive and thus remove
                  //alignedAtoms = me.icn3d.unionHash(alignedAtoms, me.icn3d.residues[chainid1 + '_' + id2aligninfo[j].resi]);
                  //alignedAtoms = me.icn3d.unionHash(alignedAtoms, me.icn3d.residues[chainid2 + '_' + resi]);
              }
              else {
                  color = me.GREY8;
                  classname = 'icn3d-nalign';

                  me.nalignHash1[chainid1 + '_' + id2aligninfo[j].resi] = 1;
                  me.nalignHash2[chainid2 + '_' + resi] = 1;
              }

              // chain1
              if(me.icn3d.alnChainsSeq[chainid1] === undefined) me.icn3d.alnChainsSeq[chainid1] = [];

              var resObject = {};
              resObject.mmdbid = mmdbid1;
              resObject.chain = chain1;
              resObject.resi = id2aligninfo[j].resi;
              // resi will be empty if there is no coordinates
              resObject.resn = (resObject.resi === '' || classname === 'icn3d-nalign') ? id2aligninfo[j].resn.toLowerCase() : id2aligninfo[j].resn;
              resObject.aligned = aligned;
              // resi will be empty if there is no coordinates
              resObject.color = (resObject.resi === '') ? me.GREYC : color; // color by identity
              resObject.color2 = (resObject.resi === '') ? me.GREYC : color2; // color by conservation
              resObject.class = classname;

              me.icn3d.alnChainsSeq[chainid1].push(resObject);

              if(id2aligninfo[j].resi !== '') {
                  if(me.icn3d.alnChains[chainid1] === undefined) me.icn3d.alnChains[chainid1] = {};
                  $.extend(me.icn3d.alnChains[chainid1], me.icn3d.residues[chainid1 + '_' + id2aligninfo[j].resi] );
              }

              // chain2
              if(me.icn3d.alnChainsSeq[chainid2] === undefined) me.icn3d.alnChainsSeq[chainid2] = [];

              resObject = {};
              resObject.mmdbid = mmdbid2;
              resObject.chain = chain2;
              resObject.resi = resi;
              // resi will be empty if there is no coordinates
              resObject.resn = (resObject.resi === '' || classname === 'icn3d-nalign') ? resn.toLowerCase() : resn;
              resObject.aligned = aligned;
              // resi will be empty if there is no coordinates
              resObject.color = (resObject.resi === '') ? me.GREYC : color; // color by identity
              resObject.color2 = (resObject.resi === '') ? me.GREYC : color2; // color by conservation
              resObject.class = classname;

              me.icn3d.alnChainsSeq[chainid2].push(resObject);

              if(resObject.resi !== '') {
                  if(me.icn3d.alnChains[chainid2] === undefined) me.icn3d.alnChains[chainid2] = {};
                  $.extend(me.icn3d.alnChains[chainid2], me.icn3d.residues[chainid2 + '_' + resi] );
              }

              // annotation is for the master seq only
              if(me.icn3d.alnChainsAnno[chainid1] === undefined ) me.icn3d.alnChainsAnno[chainid1] = [];
              if(me.icn3d.alnChainsAnno[chainid1][0] === undefined ) me.icn3d.alnChainsAnno[chainid1][0] = [];
              if(me.icn3d.alnChainsAnno[chainid1][1] === undefined ) me.icn3d.alnChainsAnno[chainid1][1] = [];
              if(me.icn3d.alnChainsAnno[chainid1][2] === undefined ) me.icn3d.alnChainsAnno[chainid1][2] = [];
              if(me.icn3d.alnChainsAnno[chainid1][3] === undefined ) me.icn3d.alnChainsAnno[chainid1][3] = [];
              if(j === start) {
                  // empty line
                  // 2nd chain title
                  if(me.icn3d.alnChainsAnno[chainid1][4] === undefined ) me.icn3d.alnChainsAnno[chainid1][4] = [];
                  // master chain title
                  if(me.icn3d.alnChainsAnno[chainid1][5] === undefined ) me.icn3d.alnChainsAnno[chainid1][5] = [];
                  // empty line
                  if(me.icn3d.alnChainsAnno[chainid1][6] === undefined ) me.icn3d.alnChainsAnno[chainid1][6] = [];

                  me.icn3d.alnChainsAnno[chainid1][4].push(me.icn3d.pdbid_chain2title[chainid2]);
                  me.icn3d.alnChainsAnno[chainid1][5].push(me.icn3d.pdbid_chain2title[chainid1]);
                  me.icn3d.alnChainsAnno[chainid1][6].push('');
              }

              var residueid1 = chainid1 + '_' + id2aligninfo[j].resi;
              var residueid2 = chainid2 + '_' + resi;
              var ss1 = me.icn3d.secondaries[residueid1];
              var ss2 = me.icn3d.secondaries[residueid2];
              if(ss2 !== undefined) {
                  me.icn3d.alnChainsAnno[chainid1][0].push(ss2);
              }
              else {
                  me.icn3d.alnChainsAnno[chainid1][0].push('-');
              }

              if(ss1 !== undefined) {
                  me.icn3d.alnChainsAnno[chainid1][1].push(ss1);
              }
              else {
                  me.icn3d.alnChainsAnno[chainid1][1].push('-');
              }

              var symbol = '.';
              if(alignIndex % 5 === 0) symbol = '*';
              if(alignIndex % 10 === 0) symbol = '|';
              me.icn3d.alnChainsAnno[chainid1][2].push(symbol); // symbol: | for 10th, * for 5th, . for rest

              var numberStr = '';
              if(alignIndex % 10 === 0) numberStr = alignIndex.toString();
              me.icn3d.alnChainsAnno[chainid1][3].push(numberStr); // symbol: 10, 20, etc, empty for rest

              ++alignIndex;
          } // end for(var j
      } // end for(var i

      seqalign = {};
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3DUI.prototype.loadMol2Data = function(data) {
    var me = this;

    var bResult = me.loadMol2AtomData(data);

    if(me.cfg.align === undefined && Object.keys(me.icn3d.structures).length == 1) {
        $("#" + me.pre + "alternateWrapper").hide();
    }

    if(!bResult) {
      alert('The Mol2 file has the wrong format...');
    }
    else {
      me.icn3d.setAtomStyleByOptions(me.opts);
      me.icn3d.setColorByOptions(me.opts, me.icn3d.atoms);

      me.renderStructure();

      if(me.cfg.rotate !== undefined) me.rotStruc(me.cfg.rotate, true);

      if(me.deferred !== undefined) me.deferred.resolve(); if(me.deferred2 !== undefined) me.deferred2.resolve();
    }
};

iCn3DUI.prototype.loadMol2AtomData = function (data) { var me = this;
    var lines = data.split(/\r?\n|\r/);
    if (lines.length < 4) return false;

    me.icn3d.init();

    var structure = 1;
    var chain = 'A';
    var resn = 'LIG';
    var resi = 1;

    var AtomHash = {};
    var moleculeNum = 1, chainNum = '1_A', residueNum = '1_A_1';
    var atomCount, bondCount, atomIndex = 0, bondIndex = 0;
    var serial=1;

    var bAtomSection = false, bBondSection = false;

    var atomid2serial = {};
    var skipAtomids = {};

    var prevBondType = '', contiArrBondCnt = 0;

    for (var i = 0, il = lines.length; i < il; ++i) {
        var line = lines[i].trim();
        if(line === '') continue;
        if(line.substr(0, 1) === '#') continue;

        if(line == '@<TRIPOS>MOLECULE') {
            me.icn3d.molTitle = lines[i + 1].trim();
            var atomCnt_bondCnt = lines[i + 2].trim().replace(/\s+/g, " ").split(" ");
            atomCount = atomCnt_bondCnt[0];
            bondCount = atomCnt_bondCnt[1];
            i = i + 4;
        }
        else if(line == '@<TRIPOS>ATOM') { // 1    C1    1.207    2.091    0.000    C.ar    1    BENZENE    0.000
            serial = 1;

            bAtomSection = true;

            ++i;
        }
        else if(line == '@<TRIPOS>BOND') { // 1    1    2    ar
            bBondSection = true;
            bAtomSection = false;

            ++i;
        }
        else if(line == '@<TRIPOS>SUBSTRUCTURE') { // 1    1    2    ar
            bBondSection = false;

            ++i;
        }

        line = lines[i].trim();
        if(line === '') continue;
        if(line.substr(0, 1) === '#') continue;

        if(bAtomSection && atomIndex < atomCount) {
            // 1    C1    1.207    2.091    0.000    C.ar    1    BENZENE    0.000
            var atomArray = line.replace(/\s+/g, " ").split(" ");

            var atomid = parseInt(atomArray[0]);
            atomid2serial[atomid] = serial;

            var name = atomArray[1];
            var x = parseFloat(atomArray[2]);
            var y = parseFloat(atomArray[3]);
            var z = parseFloat(atomArray[4]);
            var coord = new THREE.Vector3(x, y, z);

            var elemFull = atomArray[5];
            var pos = elemFull.indexOf('.');

            var elem;
            if(pos === -1) {
                elem = elemFull;
            }
            else {
                elem = elemFull.substr(0, pos);
            }

            // skip H, but keep H.spc, H.t3p, etc
            if(elem === 'H' && elem === elemFull) {
                skipAtomids[atomid] = 1;
            }
            else {
                var atomDetails = {
                    het: true,              // optional, used to determine chemicals, water, ions, etc
                    serial: serial,         // required, unique atom id
                    name: name,             // required, atom name
                    resn: resn,             // optional, used to determine protein or nucleotide
                    structure: structure,   // optional, used to identify structure
                    chain: chain,           // optional, used to identify chain
                    resi: resi,             // optional, used to identify residue ID
                    coord: coord,           // required, used to draw 3D shape
                    b: 0,                   // optional, used to draw B-factor tube
                    elem: elem,             // optional, used to determine hydrogen bond
                    bonds: [],              // required, used to connect atoms
                    ss: 'coil',             // optional, used to show secondary structures
                    ssbegin: false,         // optional, used to show the beginning of secondary structures
                    ssend: false,           // optional, used to show the end of secondary structures

                    bondOrder: []           // optional, specific for chemicals
                };

                me.icn3d.atoms[serial] = atomDetails;
                AtomHash[serial] = 1;

                ++serial;
            }

            ++atomIndex;
        }

        if(bBondSection && bondIndex < bondCount) {
            // 1    1    2    ar
            var bondArray = line.replace(/\s+/g, " ").split(" ");
            var fromAtomid = parseInt(bondArray[1]);
            var toAtomid = parseInt(bondArray[2]);
            var bondType = bondArray[3];
            var finalBondType = bondType;

            //� 1 = single � 2 = double � 3 = triple � am = amide � ar = aromatic � du = dummy � un = unknown (cannot be determined from the parameter tables) � nc = not connected
            if(bondType === 'am') {
                finalBondType = '1';
            }

            if(bondType === 'ar') {
                finalBondType = '1.5';
            }

            if(!skipAtomids.hasOwnProperty(fromAtomid) && !skipAtomids.hasOwnProperty(toAtomid) && (finalBondType === '1' || finalBondType === '2' || finalBondType === '3' || finalBondType === '1.5') ) {
                var order = finalBondType;
                var from = atomid2serial[fromAtomid];
                var to = atomid2serial[toAtomid];

                // skip all bonds between H and C
                //if( !(me.icn3d.atoms[from].elem === 'H' && me.icn3d.atoms[to].elem === 'C') && !(me.icn3d.atoms[from].elem === 'C' && me.icn3d.atoms[to].elem === 'H') ) {
                    me.icn3d.atoms[from].bonds.push(to);
                    me.icn3d.atoms[from].bondOrder.push(order);
                    me.icn3d.atoms[to].bonds.push(from);
                    me.icn3d.atoms[to].bondOrder.push(order);

                    if(order == '2') {
                        me.icn3d.doublebonds[from + '_' + to] = 1;
                        me.icn3d.doublebonds[to + '_' + from] = 1;
                    }
                    else if(order == '3') {
                        me.icn3d.triplebonds[from + '_' + to] = 1;
                        me.icn3d.triplebonds[to + '_' + from] = 1;
                    }
                    else if(order == '1.5') {
                        me.icn3d.aromaticbonds[from + '_' + to] = 1;
                        me.icn3d.aromaticbonds[to + '_' + from] = 1;
                    }
                //}
            }

            ++bondIndex;
            prevBondType = bondType;
        }
    }

    me.icn3d.dAtoms = AtomHash;
    me.icn3d.hAtoms= AtomHash;
    me.icn3d.structures[moleculeNum] = [chainNum]; //AtomHash;
    me.icn3d.chains[chainNum] = AtomHash;
    me.icn3d.residues[residueNum] = AtomHash;

    me.icn3d.residueId2Name[residueNum] = resn;

    if(me.icn3d.chainsSeq[chainNum] === undefined) me.icn3d.chainsSeq[chainNum] = [];
/*
    if(me.icn3d.chainsAn[chainNum] === undefined ) me.icn3d.chainsAn[chainNum] = [];
    if(me.icn3d.chainsAn[chainNum][0] === undefined ) me.icn3d.chainsAn[chainNum][0] = [];
    if(me.icn3d.chainsAnTitle[chainNum] === undefined ) me.icn3d.chainsAnTitle[chainNum] = [];
    if(me.icn3d.chainsAnTitle[chainNum][0] === undefined ) me.icn3d.chainsAnTitle[chainNum][0] = [];
*/
      var resObject = {};
      resObject.resi = resi;
      resObject.name = resn;

    me.icn3d.chainsSeq[chainNum].push(resObject);
//        me.icn3d.chainsAn[chainNum][0].push(resi);
//        me.icn3d.chainsAnTitle[chainNum][0].push('');

    me.setMaxD();

    me.showTitle();

    return true;
};


/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3DUI.prototype.loadXyzData = function(data) {
    var me = this;

    var bResult = me.loadXyzAtomData(data);

    if(me.cfg.align === undefined && Object.keys(me.icn3d.structures).length == 1) {
        $("#" + me.pre + "alternateWrapper").hide();
    }

    if(!bResult) {
      alert('The XYZ file has the wrong format...');
    }
    else {
      me.icn3d.setAtomStyleByOptions(me.opts);
      me.icn3d.setColorByOptions(me.opts, me.icn3d.atoms);

      me.renderStructure();

      if(me.cfg.rotate !== undefined) me.rotStruc(me.cfg.rotate, true);

      if(me.deferred !== undefined) me.deferred.resolve(); if(me.deferred2 !== undefined) me.deferred2.resolve();
    }
};

iCn3DUI.prototype.setXyzAtomSeq = function (AtomHash, moleculeNum, chainNum, residueNum) { var me = this;
    me.icn3d.dAtoms = me.icn3d.unionHash(me.icn3d.dAtoms, AtomHash);
    me.icn3d.hAtoms= me.icn3d.unionHash(me.icn3d.hAtoms, AtomHash);

    me.icn3d.structures[moleculeNum] = [chainNum]; //AtomHash;
    me.icn3d.chains[chainNum] = AtomHash;
    me.icn3d.residues[residueNum] = AtomHash;

    me.icn3d.residueId2Name[residueNum] = 'LIG';

    if(me.icn3d.chainsSeq[chainNum] === undefined) me.icn3d.chainsSeq[chainNum] = [];
/*
    if(me.icn3d.chainsAn[chainNum] === undefined ) me.icn3d.chainsAn[chainNum] = [];
    if(me.icn3d.chainsAn[chainNum][0] === undefined ) me.icn3d.chainsAn[chainNum][0] = [];
    if(me.icn3d.chainsAnTitle[chainNum] === undefined ) me.icn3d.chainsAnTitle[chainNum] = [];
    if(me.icn3d.chainsAnTitle[chainNum][0] === undefined ) me.icn3d.chainsAnTitle[chainNum][0] = [];
*/
      var resObject = {};
      resObject.resi = 1;
      resObject.name = 'LIG';

    me.icn3d.chainsSeq[chainNum].push(resObject);
//        me.icn3d.chainsAn[chainNum][0].push(1);
//        me.icn3d.chainsAnTitle[chainNum][0].push('');

    // determine bonds
    var serialArray = Object.keys(AtomHash);
    for(var j = 0, jl = serialArray.length; j < jl; ++j) {
        var atom0 = me.icn3d.atoms[serialArray[j]];

        for(var k = j + 1, kl = serialArray.length; k < kl; ++k) {
            var atom1 = me.icn3d.atoms[serialArray[k]];
            var maxR = 1.2 * (me.icn3d.covalentRadii[atom0.elem] + me.icn3d.covalentRadii[atom1.elem]);
            if(Math.abs(atom0.coord.x - atom1.coord.x) > maxR) continue;
            if(Math.abs(atom0.coord.y - atom1.coord.y) > maxR) continue;
            if(Math.abs(atom0.coord.z - atom1.coord.z) > maxR) continue;

            if(me.icn3d.hasCovalentBond(atom0, atom1)) {
                me.icn3d.atoms[serialArray[j]].bonds.push(serialArray[k]);
                me.icn3d.atoms[serialArray[k]].bonds.push(serialArray[j]);
            }
        }
    }
},

iCn3DUI.prototype.loadXyzAtomData = function (data) { var me = this;
    var lines = data.split(/\r?\n|\r/);
    if (lines.length < 3) return false;

    me.icn3d.init();

    var chain = 'A';
    var resn = 'LIG';
    var resi = 1;

    var AtomHash = {};
    var moleculeNum = 0, chainNum, residueNum;
    var structure, atomCount, serial=1, offset = 2;

    me.icn3d.molTitle = "";

    for (var i = 0, il = lines.length; i < il; ++i) {
        var line = lines[i].trim();
        if(line === '') continue;

        if(line !== '' && !isNaN(line)) { // start a new molecule
            if(i !== 0) {
                me.setXyzAtomSeq(AtomHash, moleculeNum, chainNum, residueNum);
            }

            ++moleculeNum;
            AtomHash = {};

            structure = moleculeNum;
            chainNum = structure + '_' + chain;
            residueNum = chainNum + '_' + resi;

//12
//glucose from 2gbp
//C  35.884  30.895  49.120

            atomCount = parseInt(line);
            if(moleculeNum > 1) {
                me.icn3d.molTitle += "; ";
            }
            me.icn3d.molTitle += lines[i+1].trim();

            i = i + offset;
        }

        line = lines[i].trim();
        if(line === '') continue;

        var name_x_y_z = line.replace(/,/, " ").replace(/\s+/g, " ").split(" ");

        var name = name_x_y_z[0];
        var x = parseFloat(name_x_y_z[1]);
        var y = parseFloat(name_x_y_z[2]);
        var z = parseFloat(name_x_y_z[3]);
        var coord = new THREE.Vector3(x, y, z);

        var atomDetails = {
            het: true,              // optional, used to determine chemicals, water, ions, etc
            serial: serial,         // required, unique atom id
            name: name,             // required, atom name
            resn: resn,             // optional, used to determine protein or nucleotide
            structure: structure,   // optional, used to identify structure
            chain: chain,           // optional, used to identify chain
            resi: resi,             // optional, used to identify residue ID
            coord: coord,           // required, used to draw 3D shape
            b: 0,                   // optional, used to draw B-factor tube
            elem: name,             // optional, used to determine hydrogen bond
            bonds: [],              // required, used to connect atoms
            ss: 'coil',             // optional, used to show secondary structures
            ssbegin: false,         // optional, used to show the beginning of secondary structures
            ssend: false,           // optional, used to show the end of secondary structures

            bondOrder: []           // optional, specific for chemicals
        };

        me.icn3d.atoms[serial] = atomDetails;
        AtomHash[serial] = 1;

        ++serial;
    }

    me.setXyzAtomSeq(AtomHash, moleculeNum, chainNum, residueNum);

    me.setMaxD();

    me.showTitle();

    return true;
};

/**
 * @file Dsn6 Parser
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 * @private
 * Modified by Jiyao Wang / https://github.com/ncbi/icn3d
 */


iCn3DUI.prototype.Dsn6Parser = function(pdbid, type, sigma) { var me = this;
   var url, dataType;
   // https://edmaps.rcsb.org/maps/1kq2_2fofc.dsn6
   // https://edmaps.rcsb.org/maps/1kq2_fofc.dsn6

   url = "https://edmaps.rcsb.org/maps/" + pdbid.toLowerCase() + "_" + type + ".dsn6";

   bCid = undefined;

/*
   dataType = "text";

   $.ajax({
      url: url,
      dataType: dataType,
      cache: true,
      tryCount : 0,
      retryLimit : 1,
      beforeSend: function() {
          me.showLoading();
      },
      complete: function() {
          me.hideLoading();
      },
      success: function(dsn6data) {
          me.loadDsn6Data(dsn6data, type);
      },
      error : function(xhr, textStatus, errorThrown ) {
        this.tryCount++;
        if (this.tryCount <= this.retryLimit) {
            //try again
            $.ajax(this);
            return;
        }

        alert("RCSB server has no corresponding eletron density map for this structure.");

        return;
      }
   });
*/

    //https://stackoverflow.com/questions/33902299/using-jquery-ajax-to-download-a-binary-file
    if(type == '2fofc' && me.bAjax2fofc) {
        me.icn3d.mapData.sigma2 = sigma;
        me.setOption('map', type);
    }
    else if(type == 'fofc' && me.bAjaxfofc) {
        me.icn3d.mapData.sigma = sigma;
        me.setOption('map', type);
    }
    else {
        var oReq = new XMLHttpRequest();
        oReq.open("GET", url, true);
        oReq.responseType = "arraybuffer";

        oReq.onreadystatechange = function() {
            if (this.readyState == 4) {
               me.hideLoading();

               if(this.status == 200) {
                   var arrayBuffer = oReq.response;
                   me.loadDsn6Data(arrayBuffer, type, sigma);

                   if(type == '2fofc') {
                       me.bAjax2fofc = true;
                   }
                   else if(type == 'fofc') {
                       me.bAjaxfofc = true;
                   }

                   me.setOption('map', type);
                }
                else {
                    alert("RCSB server has no corresponding eletron density map for this structure.");
                }

                if(me.deferredMap !== undefined) me.deferredMap.resolve();
            }
            else {
                me.showLoading();
            }
        };

        oReq.send();
    }
};

iCn3DUI.prototype.loadDsn6Data = function(dsn6data, type, sigma) { var me = this;
    // DSN6 http://www.uoxray.uoregon.edu/tnt/manual/node104.html
    // BRIX http://svn.cgl.ucsf.edu/svn/chimera/trunk/libs/VolumeData/dsn6/brix-1.html

    var voxelSize = 1;

    var header = {};
    var divisor, summand;

    var bin = (dsn6data.buffer && dsn6data.buffer instanceof ArrayBuffer) ? dsn6data.buffer : dsn6data;
    var intView = new Int16Array(bin);
    var byteView = new Uint8Array(bin);
    var brixStr = String.fromCharCode.apply(null, byteView.subarray(0, 512));

    if (brixStr.indexOf(':-)') == 0) {
      header.xStart = parseInt(brixStr.substr(10, 5)); // NXSTART
      header.yStart = parseInt(brixStr.substr(15, 5));
      header.zStart = parseInt(brixStr.substr(20, 5));

      header.xExtent = parseInt(brixStr.substr(32, 5)); // NX
      header.yExtent = parseInt(brixStr.substr(38, 5));
      header.zExtent = parseInt(brixStr.substr(42, 5));

      header.xRate = parseInt(brixStr.substr(52, 5)); // MX
      header.yRate = parseInt(brixStr.substr(58, 5));
      header.zRate = parseInt(brixStr.substr(62, 5));

      header.xlen = parseFloat(brixStr.substr(73, 10)) * voxelSize;
      header.ylen = parseFloat(brixStr.substr(83, 10)) * voxelSize;
      header.zlen = parseFloat(brixStr.substr(93, 10)) * voxelSize;

      header.alpha = parseFloat(brixStr.substr(103, 10));
      header.beta = parseFloat(brixStr.substr(113, 10));
      header.gamma = parseFloat(brixStr.substr(123, 10));

      divisor = parseFloat(brixStr.substr(138, 12)) / 100;
      summand = parseInt(brixStr.substr(155, 8));

      header.sigma = parseFloat(brixStr.substr(170, 12)) * 100;
    } else {
      // swap byte order when big endian
      if(intView[ 18 ] !== 100) { // true
        for (var i = 0, n = intView.length; i < n; ++i) {
          var val = intView[ i ];

          intView[ i ] = ((val & 0xff) << 8) | ((val >> 8) & 0xff);
        }
      }

      header.zStart = intView[ 2 ];
      header.xStart = intView[ 0 ]; // NXSTART
      header.yStart = intView[ 1 ];

      header.xExtent = intView[ 3 ]; // NX
      header.yExtent = intView[ 4 ];
      header.zExtent = intView[ 5 ];

      header.xRate = intView[ 6 ]; // MX
      header.yRate = intView[ 7 ];
      header.zRate = intView[ 8 ];

      var factor = 1 / intView[ 17 ];
      var scalingFactor = factor * voxelSize;

      header.xlen = intView[ 9 ] * scalingFactor;
      header.ylen = intView[ 10 ] * scalingFactor;
      header.zlen = intView[ 11 ] * scalingFactor;

      header.alpha = intView[ 12 ] * factor;
      header.beta = intView[ 13 ] * factor;
      header.gamma = intView[ 14 ] * factor;

      divisor = intView[ 15 ] / 100;
      summand = intView[ 16 ];
    }

    var data = new Float32Array(
      header.xExtent * header.yExtent * header.zExtent
    );

    var offset = 512;
    var xBlocks = Math.ceil(header.xExtent / 8);
    var yBlocks = Math.ceil(header.yExtent / 8);
    var zBlocks = Math.ceil(header.zExtent / 8);

    // loop over blocks
    for (var zz = 0; zz < zBlocks; ++zz) {
      for (var yy = 0; yy < yBlocks; ++yy) {
        for (var xx = 0; xx < xBlocks; ++xx) {
          // loop inside block
          for (var k = 0; k < 8; ++k) {
            var z = 8 * zz + k;
            for (var j = 0; j < 8; ++j) {
              var y = 8 * yy + j;
              for (var i = 0; i < 8; ++i) {
                var x = 8 * xx + i;

                // check if remaining slice-part contains data
                if (x < header.xExtent && y < header.yExtent && z < header.zExtent) {
                  var idx = ((((x * header.yExtent) + y) * header.zExtent) + z);
                  data[ idx ] = (byteView[ offset ] - summand) / divisor;
                  ++offset;
                } else {
                  offset += 8 - i;
                  break;
                }
              }
            }
          }
        }
      }
    }

    //var v = this.volume
    //v.header = header;
    //v.setData(data, header.zExtent, header.yExtent, header.xExtent);
    //v.setMatrix(me.getMatrix(header));

    if(type == '2fofc') {
        me.icn3d.mapData.header2 = header;
        me.icn3d.mapData.data2 = data;
        me.icn3d.mapData.matrix2 = me.getMatrix(header);
        me.icn3d.mapData.type2 = type;
        me.icn3d.mapData.sigma2 = sigma;
    }
    else {
        me.icn3d.mapData.header = header;
        me.icn3d.mapData.data = data;
        me.icn3d.mapData.matrix = me.getMatrix(header);
        me.icn3d.mapData.type = type;
        me.icn3d.mapData.sigma = sigma;
    }

//console.log("header: " + JSON.stringify(header));
//console.log("data: " + data);

    // for 1KQ2
    // header: {"zStart":11,"xStart":0,"yStart":2,"xExtent":63,"yExtent":70,"zExtent":54,"xRate":88,"yRate":128,"zRate":112,"xlen":80.86250000000001,"ylen":115.5875,"zlen":101.8375,"alpha":90,"beta":90,"gamma":90}
    // data: [-1.724900484085083,-1.4153029918670654,-0.5749668478965759,-0.17691287398338318,-0.6634232401847839,-1.2826182842254639,-1.1941618919372559,-0.30959752202033997,...

    // for 1TOP
    //header: {"zStart":-35,"xStart":-11,"yStart":18,"xExtent":83,"yExtent":118,"zExtent":88,"xRate":114,"yRate":114,"zRate":102,"xlen":66.6875,"ylen":66.6875,"zlen":60.7875,"alpha":90,"beta":90,"gamma":120}
    //data: -0.7147111296653748,-1.0720666646957397,-0.9529482126235962,-0.05955926328897476,0.7147111296653748,0.5360333323478699,-0.1786777824163437

    //if (header.sigma) {
    //  v.setStats(undefined, undefined, undefined, header.sigma);
    //}

    //return true;
};

iCn3DUI.prototype.getMatrix = function(header) { var me = this;
    var h = header;

    var basisX = [
      h.xlen,
      0,
      0
    ];

    var basisY = [
      h.ylen * Math.cos(Math.PI / 180.0 * h.gamma),
      h.ylen * Math.sin(Math.PI / 180.0 * h.gamma),
      0
    ];

    var basisZ = [
      h.zlen * Math.cos(Math.PI / 180.0 * h.beta),
      h.zlen * (
        Math.cos(Math.PI / 180.0 * h.alpha) -
        Math.cos(Math.PI / 180.0 * h.gamma) *
        Math.cos(Math.PI / 180.0 * h.beta)
      ) / Math.sin(Math.PI / 180.0 * h.gamma),
      0
    ];
    basisZ[ 2 ] = Math.sqrt(
      h.zlen * h.zlen * Math.sin(Math.PI / 180.0 * h.beta) *
      Math.sin(Math.PI / 180.0 * h.beta) - basisZ[ 1 ] * basisZ[ 1 ]
    );

    var basis = [ [], basisX, basisY, basisZ ];
    var nxyz = [ 0, h.xRate, h.yRate, h.zRate ];
    var mapcrs = [ 0, 1, 2, 3 ];

    var matrix = new THREE.Matrix4();

    matrix.set(
      basis[ mapcrs[1] ][0] / nxyz[ mapcrs[1] ],
      basis[ mapcrs[2] ][0] / nxyz[ mapcrs[2] ],
      basis[ mapcrs[3] ][0] / nxyz[ mapcrs[3] ],
      0,
      basis[ mapcrs[1] ][1] / nxyz[ mapcrs[1] ],
      basis[ mapcrs[2] ][1] / nxyz[ mapcrs[2] ],
      basis[ mapcrs[3] ][1] / nxyz[ mapcrs[3] ],
      0,
      basis[ mapcrs[1] ][2] / nxyz[ mapcrs[1] ],
      basis[ mapcrs[2] ][2] / nxyz[ mapcrs[2] ],
      basis[ mapcrs[3] ][2] / nxyz[ mapcrs[3] ],
      0,
      0, 0, 0, 1
    );

/*
    matrix.multiply(
      new THREE.Matrix4().makeRotationY(Math.PI * 0.5)
    );

    matrix.multiply(new THREE.Matrix4().makeTranslation(
      -h.zStart, h.yStart, h.xStart
    ));

    matrix.multiply(new THREE.Matrix4().makeScale(
      -1, 1, 1
    ));
*/

    matrix.multiply(new THREE.Matrix4().makeTranslation(
      h.xStart, h.yStart, h.zStart
    ));

    return matrix;
};

/**
 * @file Density Cif Parser
 * @author David Sehnal dsehnal <alexander.rose@weirdbyte.de>
 * Modified by Jiyao Wang / https://github.com/ncbi/icn3d
 */


iCn3DUI.prototype.DensityCifParser = function(pdbid, type, sigma, emd) { var me = this;
   var url;
   var detail = (me.isMobile()) ? 0 : 4; //4;

   //https://www.ebi.ac.uk/pdbe/densities/doc.html
   if(type == '2fofc' || type == 'fofc') {
       url = "https://www.ebi.ac.uk/pdbe/densities/x-ray/" + pdbid.toLowerCase() + "/cell?detail=" + detail;
   }
   else if(type == 'em') {
       url = "https://www.ebi.ac.uk/pdbe/densities/emd/" + emd.toLowerCase() + "/cell?detail=" + detail;
   }

   bCid = undefined;

    //https://stackoverflow.com/questions/33902299/using-jquery-ajax-to-download-a-binary-file
    if(type == '2fofc' && me.bAjax2fofc) {
        me.icn3d.mapData.sigma2 = sigma;
        me.setOption('map', type);
    }
    else if(type == 'fofc' && me.bAjaxfofc) {
        me.icn3d.mapData.sigma = sigma;
        me.setOption('map', type);
    }
    else if(type == 'em' && me.bAjaxEm) {
        me.icn3d.mapData.sigmaEm = sigma;
        me.setOption('emmap', type);
    }
    else {
        var oReq = new XMLHttpRequest();
        oReq.open("GET", url, true);
        oReq.responseType = "arraybuffer";

        oReq.onreadystatechange = function() {
            if (this.readyState == 4) {
               me.hideLoading();

               if(this.status == 200) {
                   var arrayBuffer = oReq.response;

                   me.parseChannels(arrayBuffer, type, sigma);

                   if(type == '2fofc' || type == 'fofc') {
                       me.bAjax2fofc = true;
                       me.bAjaxfofc = true;

                       me.setOption('map', type);
                   }
                   else if(type == 'em') {
                       me.bAjaxEm = true;

                       me.setOption('emmap', type);
                   }
                }
                else {
                   if(type == '2fofc' || type == 'fofc') {
                       alert("Density server at EBI has no corresponding electron density map for this structure.");
                   }
                   else if(type == 'em') {
                       alert("Density server at EBI has no corresponding EM density map for this structure.");
                   }
                }

                if(me.deferredEmmap !== undefined) me.deferredEmmap.resolve();
            }
            else {
                me.showLoading();
            }
        };

        oReq.send();
    }
};

iCn3DUI.prototype.parseChannels = function(densitydata, type, sigma) { var me = this;
    var cif = me.BinaryParse(densitydata);

    if(type == '2fofc' || type == 'fofc') {
        var twoDensity = me.getChannel(cif, '2FO-FC');
        var oneDensity = me.getChannel(cif, 'FO-FC');

        // '2fofc'
        var density = twoDensity;
        var sampleCount = density.box.sampleCount;
        var header = {xExtent: sampleCount[0], yExtent: sampleCount[1], zExtent: sampleCount[2], mean: density.valuesInfo.mean, sigma: density.valuesInfo.sigma};
        me.icn3d.mapData.header2 = header;

        me.icn3d.mapData.data2 = density.data;

        var origin = density.box.origin;
        var dimensions = density.box.dimensions;
        var basis = density.spacegroup.basis;
        var scale = new THREE.Matrix4().makeScale(
            dimensions[0] / (sampleCount[0] ),
            dimensions[1] / (sampleCount[1] ),
            dimensions[2] / (sampleCount[2] ));
        var translate = new THREE.Matrix4().makeTranslation(origin[0], origin[1], origin[2]);
        var fromFrac = new THREE.Matrix4().set(
            basis.x[0], basis.y[0], basis.z[0], 0.0,
            0.0, basis.y[1], basis.z[1], 0.0,
            0.0, 0.0, basis.z[2], 0.0,
            0.0, 0.0, 0.0, 1.0);

        //var toFrac = new LiteMol.Visualization.THREE.Matrix4().getInverse(fromFrac);
        var matrix = fromFrac.multiply(translate).multiply(scale);

        me.icn3d.mapData.matrix2 = matrix;

        me.icn3d.mapData.type2 = type;
        me.icn3d.mapData.sigma2 = sigma;

        // 'fofc'
        var density = oneDensity;
        var sampleCount = density.box.sampleCount;
        var header = {xExtent: sampleCount[0], yExtent: sampleCount[1], zExtent: sampleCount[2], mean: density.valuesInfo.mean, sigma: density.valuesInfo.sigma};
        me.icn3d.mapData.header = header;

        me.icn3d.mapData.data = density.data;

        var origin = density.box.origin;
        var dimensions = density.box.dimensions;
        var basis = density.spacegroup.basis;
        var scale = new THREE.Matrix4().makeScale(
            dimensions[0] / (sampleCount[0] ),
            dimensions[1] / (sampleCount[1] ),
            dimensions[2] / (sampleCount[2] ));
        var translate = new THREE.Matrix4().makeTranslation(origin[0], origin[1], origin[2]);
        var fromFrac = new THREE.Matrix4().set(
            basis.x[0], basis.y[0], basis.z[0], 0.0,
            0.0, basis.y[1], basis.z[1], 0.0,
            0.0, 0.0, basis.z[2], 0.0,
            0.0, 0.0, 0.0, 1.0);
        //var toFrac = new LiteMol.Visualization.THREE.Matrix4().getInverse(fromFrac);
        var matrix = fromFrac.multiply(translate).multiply(scale);
        me.icn3d.mapData.matrix = matrix;

        me.icn3d.mapData.type = type;
        me.icn3d.mapData.sigma = sigma;
    }
    else if(type == 'em') {
        var density = me.getChannel(cif, 'EM');

        var sampleCount = density.box.sampleCount;
        var header = {xExtent: sampleCount[0], yExtent: sampleCount[1], zExtent: sampleCount[2], max: density.valuesInfo.max, min: density.valuesInfo.min};
        me.icn3d.mapData.headerEm = header;

        me.icn3d.mapData.dataEm = density.data;

        var origin = density.box.origin;
        var dimensions = density.box.dimensions;
        var basis = density.spacegroup.basis;
        var scale = new THREE.Matrix4().makeScale(
            dimensions[0] / (sampleCount[0] ),
            dimensions[1] / (sampleCount[1] ),
            dimensions[2] / (sampleCount[2] ));
        var translate = new THREE.Matrix4().makeTranslation(origin[0], origin[1], origin[2]);
        var fromFrac = new THREE.Matrix4().set(
            basis.x[0], basis.y[0], basis.z[0], 0.0,
            0.0, basis.y[1], basis.z[1], 0.0,
            0.0, 0.0, basis.z[2], 0.0,
            0.0, 0.0, 0.0, 1.0);
        //var toFrac = new LiteMol.Visualization.THREE.Matrix4().getInverse(fromFrac);
        var matrix = fromFrac.multiply(translate).multiply(scale);
        me.icn3d.mapData.matrixEm = matrix;

        me.icn3d.mapData.typeEm = type;
        //me.icn3d.mapData.sigmaEm = sigma;
        me.icn3d.mapData.sigmaEm = sigma;
    }
};

iCn3DUI.prototype.getChannel = function(data, name) { var me = this;
    //var block = data.dataBlocks.filter(b => b.header === name)[0];
    //var block = data.dataBlocks.filter(b => b.id === name)[0];

    var jsonData = data.toJSON();

    var block;
    for(var i = 0, il = jsonData.length; i < il; ++i) {
        if(jsonData[i].id == name) block = data.dataBlocks[i];
    }

    var density = me.CIFParse(block);

    return density;
};

iCn3DUI.prototype.CIFParse = function(block) { var me = this;
    var info = block.getCategory('_volume_data_3d_info');

    if (!info) {
        conole.log('_volume_data_3d_info category is missing.');
        return undefined;
    }
    if (!block.getCategory('_volume_data_3d')) {
        conole.log('_volume_data_3d category is missing.');
        return undefined;
    }

    function getVector3(name) {
        var ret = [0, 0, 0];
        for (var i = 0; i < 3; i++) {
            ret[i] = info.getColumn(name + '[' + i + ']').getFloat(0);
        }
        return ret;
    }

    function getNum(name) { return info.getColumn(name).getFloat(0); }

    var header = {
        name: info.getColumn('name').getString(0),
        axisOrder: getVector3('axis_order'),

        origin: getVector3('origin'),
        dimensions: getVector3('dimensions'),

        sampleCount: getVector3('sample_count'),

        spacegroupNumber: getNum('spacegroup_number') | 0,
        cellSize: getVector3('spacegroup_cell_size'),
        cellAngles: getVector3('spacegroup_cell_angles'),

        mean: getNum('mean_sampled'),
        sigma: getNum('sigma_sampled')
    };

    var indices = [0, 0, 0];
    indices[header.axisOrder[0]] = 0;
    indices[header.axisOrder[1]] = 1;
    indices[header.axisOrder[2]] = 2;

    function normalizeOrder(xs) {
        return [xs[indices[0]], xs[indices[1]], xs[indices[2]]];
    }

    function readValues(col, xyzSampleCount, sampleCount, axisIndices) {
        var data = new Float32Array(xyzSampleCount[0] * xyzSampleCount[1] * xyzSampleCount[2]);
        var coord = [0, 0, 0];
        var iX = axisIndices[0], iY = axisIndices[1], iZ = axisIndices[2];
        var mX = sampleCount[0], mY = sampleCount[1], mZ = sampleCount[2];


        var xSize = xyzSampleCount[0];
        var xySize = xyzSampleCount[0] * xyzSampleCount[1];

        var zSize = xyzSampleCount[2];
        var yzSize = xyzSampleCount[1] * xyzSampleCount[2];

        var offset = 0;
        var min = col.getFloat(0), max = min;

        for (var cZ = 0; cZ < mZ; cZ++) {
            coord[2] = cZ;
            for (var cY = 0; cY < mY; cY++) {
                coord[1] = cY;
                for (var cX = 0; cX < mX; cX++) {
                    coord[0] = cX;
                    var v = col.getFloat(offset);
                    offset += 1;
                    //data[coord[iX] + coord[iY] * xSize + coord[iZ] * xySize] = v;
                    data[coord[iZ] + coord[iY] * zSize + coord[iX] * yzSize] = v;
                    if (v < min) min = v;
                    else if (v > max) max = v;
                }
            }
        }

        return { data: data, min: min, max: max };
    }

    function createSpacegroup(number, size, angles) {
        var alpha = (Math.PI / 180.0) * angles[0], beta = (Math.PI / 180.0) * angles[1], gamma = (Math.PI / 180.0) * angles[2];
        var xScale = size[0], yScale = size[1], zScale = size[2];

        var z1 = Math.cos(beta),
              z2 = (Math.cos(alpha) - Math.cos(beta) * Math.cos(gamma)) / Math.sin(gamma),
              z3 = Math.sqrt(1.0 - z1 * z1 - z2 * z2);

        var x = [xScale, 0.0, 0.0];
        var y = [Math.cos(gamma) * yScale, Math.sin(gamma) * yScale, 0.0];
        var z = [z1 * zScale, z2 * zScale, z3 * zScale];

        return {
            number: number,
            size: size,
            angles: angles,
            basis: { x: x, y: y, z: z }
        };
    }

    var sampleCount = normalizeOrder(header.sampleCount);

    var rawData = readValues(block.getCategory('_volume_data_3d').getColumn('values'), sampleCount, header.sampleCount, indices);
    //var field = new Field3DZYX(rawData.data, sampleCount);

    var data = {
        name: header.name,
        spacegroup: createSpacegroup(header.spacegroupNumber, header.cellSize, header.cellAngles),
        box: {
            origin: normalizeOrder(header.origin),
            dimensions: normalizeOrder(header.dimensions),
            sampleCount: sampleCount
        },
        //data: field,
        data: rawData.data,
        valuesInfo: { min: rawData.min, max: rawData.max, mean: header.mean, sigma: header.sigma }
    };

    return data;
};

iCn3DUI.prototype.BinaryParse = function(data) { var me = this;
//    var minVersion = [0, 3];
//    try {
        var array = new Uint8Array(data);

        var unpacked = me.MessagePackParse({
                    buffer: array,
                    offset: 0,
                    dataView: new DataView(array.buffer)
        });

        var DataBlock = (function () {
            function DataBlock(data) {
                this.additionalData = {};
                this.header = data.header;
                this.categoryList = data.categories.map(function (c) { return new Category(c); });
                this.categoryMap = new Map();
                for (var _i = 0, _a = this.categoryList; _i < _a.length; _i++) {
                    var c = _a[_i];
                    this.categoryMap.set(c.name, c);
                }
            }
            Object.defineProperty(DataBlock.prototype, "categories", {
                get: function () { return this.categoryList; },
                enumerable: true,
                configurable: true
            });
            DataBlock.prototype.getCategory = function (name) { return this.categoryMap.get(name); };
            DataBlock.prototype.toJSON = function () {
                return {
                    id: this.header,
                    categories: this.categoryList.map(function (c) { return c.toJSON(); }),
                    additionalData: this.additionalData
                };
            };
            return DataBlock;
        }());

        var Category = (function () {
            function Category(data) {
                this.name = data.name;
                this.columnCount = data.columns.length;
                this.rowCount = data.rowCount;
                this.columnNameList = [];
                this.encodedColumns = new Map();
                for (var _i = 0, _a = data.columns; _i < _a.length; _i++) {
                    var c = _a[_i];
                    this.encodedColumns.set(c.name, c);
                    this.columnNameList.push(c.name);
                }
            }
            Object.defineProperty(Category.prototype, "columnNames", {
                get: function () { return this.columnNameList; },
                enumerable: true,
                configurable: true
            });

            var _UndefinedColumn = (function () {
                function _UndefinedColumn() {
                    this.isDefined = false;
                }
                _UndefinedColumn.prototype.getString = function (row) { return null; };
                ;
                _UndefinedColumn.prototype.getInteger = function (row) { return 0; };
                _UndefinedColumn.prototype.getFloat = function (row) { return 0.0; };
                _UndefinedColumn.prototype.getValuePresence = function (row) { return 1 /* NotSpecified */; };
                _UndefinedColumn.prototype.areValuesEqual = function (rowA, rowB) { return true; };
                _UndefinedColumn.prototype.stringEquals = function (row, value) { return value === null; };
                return _UndefinedColumn;
            }());

            Category.prototype.getColumn = function (name) {
                var w = this.encodedColumns.get(name);
                if (w)
                    return wrapColumn(w);
                return _UndefinedColumn;
            };
            Category.prototype.toJSON = function () {
                var _this = this;
                var rows = [];
                var columns = this.columnNameList.map(function (name) { return ({ name: name, column: _this.getColumn(name) }); });
                for (var i = 0; i < this.rowCount; i++) {
                    var item = {};
                    for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {
                        var c = columns_1[_i];
                        var d = c.column.getValuePresence(i);
                        if (d === 0 /* Present */)
                            item[c.name] = c.column.getString(i);
                        else if (d === 1 /* NotSpecified */)
                            item[c.name] = '.';
                        else
                            item[c.name] = '?';
                    }
                    rows[i] = item;
                }
                return { name: this.name, columns: this.columnNames, rows: rows };
            };
            return Category;
        }());

        function getIntArray(type, size) {
            switch (type) {
                case 1 /* Int8 */: return new Int8Array(size);
                case 2 /* Int16 */: return new Int16Array(size);
                case 3 /* Int32 */: return new Int32Array(size);
                case 4 /* Uint8 */: return new Uint8Array(size);
                case 5 /* Uint16 */: return new Uint16Array(size);
                case 6 /* Uint32 */: return new Uint32Array(size);
                default: throw new Error('Unsupported integer data type.');
            }
        }
        function getFloatArray(type, size) {
            switch (type) {
                case 32 /* Float32 */: return new Float32Array(size);
                case 33 /* Float64 */: return new Float64Array(size);
                default: throw new Error('Unsupported floating data type.');
            }
        }
        // http://stackoverflow.com/questions/7869752/javascript-typed-arrays-and-endianness
        var isLittleEndian = (function () {
            var arrayBuffer = new ArrayBuffer(2);
            var uint8Array = new Uint8Array(arrayBuffer);
            var uint16array = new Uint16Array(arrayBuffer);
            uint8Array[0] = 0xAA;
            uint8Array[1] = 0xBB;
            if (uint16array[0] === 0xBBAA)
                return true;
            return false;
        })();
        function int8(data) { return new Int8Array(data.buffer, data.byteOffset); }
        function flipByteOrder(data, bytes) {
            var buffer = new ArrayBuffer(data.length);
            var ret = new Uint8Array(buffer);
            for (var i = 0, n = data.length; i < n; i += bytes) {
                for (var j = 0; j < bytes; j++) {
                    ret[i + bytes - j - 1] = data[i + j];
                }
            }
            return buffer;
        }
        function view(data, byteSize, c) {
            if (isLittleEndian)
                return new c(data.buffer);
            return new c(flipByteOrder(data, byteSize));
        }
        function int16(data) { return view(data, 2, Int16Array); }
        function uint16(data) { return view(data, 2, Uint16Array); }
        function int32(data) { return view(data, 4, Int32Array); }
        function uint32(data) { return view(data, 4, Uint32Array); }
        function float32(data) { return view(data, 4, Float32Array); }
        function float64(data) { return view(data, 8, Float64Array); }
        function fixedPoint(data, encoding) {
            var n = data.length;
            var output = getFloatArray(encoding.srcType, n);
            var f = 1 / encoding.factor;
            for (var i = 0; i < n; i++) {
                output[i] = f * data[i];
            }
            return output;
        }
        function intervalQuantization(data, encoding) {
            var n = data.length;
            var output = getFloatArray(encoding.srcType, n);
            var delta = (encoding.max - encoding.min) / (encoding.numSteps - 1);
            var min = encoding.min;
            for (var i = 0; i < n; i++) {
                output[i] = min + delta * data[i];
            }
            return output;
        }
        function runLength(data, encoding) {
            var output = getIntArray(encoding.srcType, encoding.srcSize);
            var dataOffset = 0;
            for (var i = 0, il = data.length; i < il; i += 2) {
                var value = data[i]; // value to be repeated
                var length_7 = data[i + 1]; // number of repeats
                for (var j = 0; j < length_7; ++j) {
                    output[dataOffset++] = value;
                }
            }
            return output;
        }
        function delta(data, encoding) {
            var n = data.length;
            var output = getIntArray(encoding.srcType, n);
            if (!n)
                return output;
            output[0] = data[0] + (encoding.origin | 0);
            for (var i = 1; i < n; ++i) {
                output[i] = data[i] + output[i - 1];
            }
            return output;
        }
        function integerPackingSigned(data, encoding) {
            var upperLimit = encoding.byteCount === 1 ? 0x7F : 0x7FFF;
            var lowerLimit = -upperLimit - 1;
            var n = data.length;
            var output = new Int32Array(encoding.srcSize);
            var i = 0;
            var j = 0;
            while (i < n) {
                var value = 0, t = data[i];
                while (t === upperLimit || t === lowerLimit) {
                    value += t;
                    i++;
                    t = data[i];
                }
                value += t;
                output[j] = value;
                i++;
                j++;
            }
            return output;
        }
        function integerPackingUnsigned(data, encoding) {
            var upperLimit = encoding.byteCount === 1 ? 0xFF : 0xFFFF;
            var n = data.length;
            var output = new Int32Array(encoding.srcSize);
            var i = 0;
            var j = 0;
            while (i < n) {
                var value = 0, t = data[i];
                while (t === upperLimit) {
                    value += t;
                    i++;
                    t = data[i];
                }
                value += t;
                output[j] = value;
                i++;
                j++;
            }
            return output;
        }
        function integerPacking(data, encoding) {
            return encoding.isUnsigned ? integerPackingUnsigned(data, encoding) : integerPackingSigned(data, encoding);
        }
        function stringArray(data, encoding) {
            var str = encoding.stringData;
            var offsets = decode({ encoding: encoding.offsetEncoding, data: encoding.offsets });
            var indices = decode({ encoding: encoding.dataEncoding, data: data });
            var cache = Object.create(null);
            var result = new Array(indices.length);
            var offset = 0;
            for (var _i = 0, indices_1 = indices; _i < indices_1.length; _i++) {
                var i = indices_1[_i];
                if (i < 0) {
                    result[offset++] = null;
                    continue;
                }
                var v = cache[i];
                if (v === void 0) {
                    v = str.substring(offsets[i], offsets[i + 1]);
                    cache[i] = v;
                }
                result[offset++] = v;
            }
            return result;
        }

        function decodeStep(data, encoding) {
            switch (encoding.kind) {
                case 'ByteArray': {
                    switch (encoding.type) {
                        case 4 /* Uint8 */: return data;
                        case 1 /* Int8 */: return int8(data);
                        case 2 /* Int16 */: return int16(data);
                        case 5 /* Uint16 */: return uint16(data);
                        case 3 /* Int32 */: return int32(data);
                        case 6 /* Uint32 */: return uint32(data);
                        case 32 /* Float32 */: return float32(data);
                        case 33 /* Float64 */: return float64(data);
                        default: throw new Error('Unsupported ByteArray type.');
                    }
                }
                case 'FixedPoint': return fixedPoint(data, encoding);
                case 'IntervalQuantization': return intervalQuantization(data, encoding);
                case 'RunLength': return runLength(data, encoding);
                case 'Delta': return delta(data, encoding);
                case 'IntegerPacking': return integerPacking(data, encoding);
                case 'StringArray': return stringArray(data, encoding);
            }
        }

        function decode(data) {
            var current = data.data;
            for (var i = data.encoding.length - 1; i >= 0; i--) {
                current = decodeStep(current, data.encoding[i]);
            }
            return current;
        }

        function wrapColumn(column) {
            if (!column.data.data)
                return _UndefinedColumn;
            var data = decode(column.data);
            var mask = void 0;
            if (column.mask)
                mask = decode(column.mask);
            if (data.buffer && data.byteLength && data.BYTES_PER_ELEMENT) {
                return mask ? new MaskedNumericColumn(data, mask) : new NumericColumn(data);
            }
            return mask ? new MaskedStringColumn(data, mask) : new StringColumn(data);
        }
        //var fastParseInt = CIFTools.Utils.FastNumberParsers.parseInt;
        function fastParseInt(str, start, end) {
            var ret = 0, neg = 1;
            if (str.charCodeAt(start) === 45 /* - */) {
                neg = -1;
                start++;
            }
            for (; start < end; start++) {
                var c = str.charCodeAt(start) - 48;
                if (c > 9 || c < 0)
                    return (neg * ret) | 0;
                else
                    ret = (10 * ret + c) | 0;
            }
            return neg * ret;
        }
        //var fastParseFloat = CIFTools.Utils.FastNumberParsers.parseFloat;
        function fastParseFloat(str, start, end) {
            var neg = 1.0, ret = 0.0, point = 0.0, div = 1.0;
            if (str.charCodeAt(start) === 45) {
                neg = -1.0;
                ++start;
            }
            while (start < end) {
                var c = str.charCodeAt(start) - 48;
                if (c >= 0 && c < 10) {
                    ret = ret * 10 + c;
                    ++start;
                }
                else if (c === -2) {
                    ++start;
                    while (start < end) {
                        c = str.charCodeAt(start) - 48;
                        if (c >= 0 && c < 10) {
                            point = 10.0 * point + c;
                            div = 10.0 * div;
                            ++start;
                        }
                        else if (c === 53 || c === 21) {
                            return parseScientific(neg * (ret + point / div), str, start + 1, end);
                        }
                        else {
                            return neg * (ret + point / div);
                        }
                    }
                    return neg * (ret + point / div);
                }
                else if (c === 53 || c === 21) {
                    return parseScientific(neg * ret, str, start + 1, end);
                }
                else
                    break;
            }
            return neg * ret;
        }

        var NumericColumn = (function () {
            function NumericColumn(data) {
                this.data = data;
                this.isDefined = true;
            }
            NumericColumn.prototype.getString = function (row) { return "" + this.data[row]; };
            NumericColumn.prototype.getInteger = function (row) { return this.data[row] | 0; };
            NumericColumn.prototype.getFloat = function (row) { return 1.0 * this.data[row]; };
            NumericColumn.prototype.stringEquals = function (row, value) { return this.data[row] === fastParseFloat(value, 0, value.length); };
            NumericColumn.prototype.areValuesEqual = function (rowA, rowB) { return this.data[rowA] === this.data[rowB]; };
            NumericColumn.prototype.getValuePresence = function (row) { return 0 /* Present */; };
            return NumericColumn;
        }());
        var MaskedNumericColumn = (function () {
            function MaskedNumericColumn(data, mask) {
                this.data = data;
                this.mask = mask;
                this.isDefined = true;
            }
            MaskedNumericColumn.prototype.getString = function (row) { return this.mask[row] === 0 /* Present */ ? "" + this.data[row] : null; };
            MaskedNumericColumn.prototype.getInteger = function (row) { return this.mask[row] === 0 /* Present */ ? this.data[row] : 0; };
            MaskedNumericColumn.prototype.getFloat = function (row) { return this.mask[row] === 0 /* Present */ ? this.data[row] : 0; };
            MaskedNumericColumn.prototype.stringEquals = function (row, value) { return this.mask[row] === 0 /* Present */ ? this.data[row] === fastParseFloat(value, 0, value.length) : value === null || value === void 0; };
            MaskedNumericColumn.prototype.areValuesEqual = function (rowA, rowB) { return this.data[rowA] === this.data[rowB]; };
            MaskedNumericColumn.prototype.getValuePresence = function (row) { return this.mask[row]; };
            return MaskedNumericColumn;
        }());
        var StringColumn = (function () {
            function StringColumn(data) {
                this.data = data;
                this.isDefined = true;
            }
            StringColumn.prototype.getString = function (row) { return this.data[row]; };
            StringColumn.prototype.getInteger = function (row) { var v = this.data[row]; return fastParseInt(v, 0, v.length); };
            StringColumn.prototype.getFloat = function (row) { var v = this.data[row]; return fastParseFloat(v, 0, v.length); };
            StringColumn.prototype.stringEquals = function (row, value) { return this.data[row] === value; };
            StringColumn.prototype.areValuesEqual = function (rowA, rowB) { return this.data[rowA] === this.data[rowB]; };
            StringColumn.prototype.getValuePresence = function (row) { return 0 /* Present */; };
            return StringColumn;
        }());
        var MaskedStringColumn = (function () {
            function MaskedStringColumn(data, mask) {
                this.data = data;
                this.mask = mask;
                this.isDefined = true;
            }
            MaskedStringColumn.prototype.getString = function (row) { return this.mask[row] === 0 /* Present */ ? this.data[row] : null; };
            MaskedStringColumn.prototype.getInteger = function (row) { if (this.mask[row] !== 0 /* Present */)
                return 0; var v = this.data[row]; return fastParseInt(v || '', 0, (v || '').length); };
            MaskedStringColumn.prototype.getFloat = function (row) { if (this.mask[row] !== 0 /* Present */)
                return 0; var v = this.data[row]; return fastParseFloat(v || '', 0, (v || '').length); };
            MaskedStringColumn.prototype.stringEquals = function (row, value) { return this.data[row] === value; };
            MaskedStringColumn.prototype.areValuesEqual = function (rowA, rowB) { return this.data[rowA] === this.data[rowB]; };
            MaskedStringColumn.prototype.getValuePresence = function (row) { return this.mask[row]; };
            return MaskedStringColumn;
        }());

        var File = (function () {
                    function File(data) {
                        this.dataBlocks = data.dataBlocks.map(function (b) { return new DataBlock(b); });
                    }
                    File.prototype.toJSON = function () {
                        return this.dataBlocks.map(function (b) { return b.toJSON(); });
                    };
                    return File;
        }());

        var file = new File(unpacked);
        return file;

//    }
//    catch (e) {
//        return CIFTools.ParserResult.error('' + e);
//    }
};

iCn3DUI.prototype.MessagePackParse = function(state) { var me = this;
    /*
     * Adapted from https://github.com/rcsb/mmtf-javascript
     * by Alexander Rose <alexander.rose@weirdbyte.de>, MIT License, Copyright (c) 2016
     */
    /**
     * decode all key-value pairs of a map into an object
     * @param  {Integer} length - number of key-value pairs
     * @return {Object} decoded map
     */
    function map(state, length) {
        var value = {};
        for (var i = 0; i < length; i++) {
            var key = me.MessagePackParse(state);
            value[key] = me.MessagePackParse(state);
        }
        return value;
    }
    /**
     * decode binary array
     * @param  {Integer} length - number of elements in the array
     * @return {Uint8Array} decoded array
     */
    function bin(state, length) {
        // This approach to binary parsing wastes a bit of memory to trade for speed compared to:
        //
        //   var value = buffer.subarray(offset, offset + length); //new Uint8Array(buffer.buffer, offset, length);
        //
        // It turns out that using the view created by subarray probably uses DataView
        // in the background, which causes the element access to be several times slower
        // than creating the new byte array.
        var value = new Uint8Array(length);
        var o = state.offset;
        for (var i = 0; i < length; i++)
            value[i] = state.buffer[i + o];
        state.offset += length;
        return value;
    }
    /**
         * decode array
         * @param  {Integer} length - number of array elements
         * @return {Array} decoded array
         */
    function array(state, length) {
        var value = new Array(length);
        for (var i = 0; i < length; i++) {
            value[i] = me.MessagePackParse(state);
        }
        return value;
    }

    /**
     * decode string
     * @param  {Integer} length - number string characters
     * @return {String} decoded string
     */
    function str(state, length) {
        var value = utf8Read(state.buffer, state.offset, length);
        state.offset += length;
        return value;
    }

    var __chars = function () {
        var data = [];
        for (var i = 0; i < 1024; i++)
            data[i] = String.fromCharCode(i);
        return data;
    }();

    function utf8Read(data, offset, length) {
        var chars = __chars;
        var str = void 0, chunk = [], chunkSize = 512, chunkOffset = 0;
        for (var i = offset, end = offset + length; i < end; i++) {
            var byte = data[i];
            // One byte character
            if ((byte & 0x80) === 0x00) {
                chunk[chunkOffset++] = chars[byte];
            }
            else if ((byte & 0xe0) === 0xc0) {
                chunk[chunkOffset++] = chars[((byte & 0x0f) << 6) | (data[++i] & 0x3f)];
            }
            else if ((byte & 0xf0) === 0xe0) {
                chunk[chunkOffset++] = String.fromCharCode(((byte & 0x0f) << 12) |
                    ((data[++i] & 0x3f) << 6) |
                    ((data[++i] & 0x3f) << 0));
            }
            else if ((byte & 0xf8) === 0xf0) {
                chunk[chunkOffset++] = String.fromCharCode(((byte & 0x07) << 18) |
                    ((data[++i] & 0x3f) << 12) |
                    ((data[++i] & 0x3f) << 6) |
                    ((data[++i] & 0x3f) << 0));
            }
            else
                throwError("Invalid byte " + byte.toString(16));
            if (chunkOffset === chunkSize) {
                str = str || [];
                str[str.length] = chunk.join('');
                chunkOffset = 0;
            }
        }
        if (!str)
            return chunk.slice(0, chunkOffset).join('');
        if (chunkOffset > 0) {
            str[str.length] = chunk.slice(0, chunkOffset).join('');
        }
        return str.join('');
    }

    var type = state.buffer[state.offset];

    var value, length;
    // Positive FixInt
    if ((type & 0x80) === 0x00) {
        state.offset++;
        return type;
    }
    // FixMap
    if ((type & 0xf0) === 0x80) {
        length = type & 0x0f;
        state.offset++;
        return map(state, length);
    }
    // FixArray
    if ((type & 0xf0) === 0x90) {
        length = type & 0x0f;
        state.offset++;
        return array(state, length);
    }
    // FixStr
    if ((type & 0xe0) === 0xa0) {
        length = type & 0x1f;
        state.offset++;
        return str(state, length);
    }
    // Negative FixInt
    if ((type & 0xe0) === 0xe0) {
        value = state.dataView.getInt8(state.offset);
        state.offset++;
        return value;
    }
    switch (type) {
        // nil
        case 0xc0:
            state.offset++;
            return null;
        // false
        case 0xc2:
            state.offset++;
            return false;
        // true
        case 0xc3:
            state.offset++;
            return true;
        // bin 8
        case 0xc4:
            length = state.dataView.getUint8(state.offset + 1);
            state.offset += 2;
            return bin(state, length);
        // bin 16
        case 0xc5:
            length = state.dataView.getUint16(state.offset + 1);
            state.offset += 3;
            return bin(state, length);
        // bin 32
        case 0xc6:
            length = state.dataView.getUint32(state.offset + 1);
            state.offset += 5;
            return bin(state, length);
        // float 32
        case 0xca:
            value = state.dataView.getFloat32(state.offset + 1);
            state.offset += 5;
            return value;
        // float 64
        case 0xcb:
            value = state.dataView.getFloat64(state.offset + 1);
            state.offset += 9;
            return value;
        // uint8
        case 0xcc:
            value = state.buffer[state.offset + 1];
            state.offset += 2;
            return value;
        // uint 16
        case 0xcd:
            value = state.dataView.getUint16(state.offset + 1);
            state.offset += 3;
            return value;
        // uint 32
        case 0xce:
            value = state.dataView.getUint32(state.offset + 1);
            state.offset += 5;
            return value;
        // int 8
        case 0xd0:
            value = state.dataView.getInt8(state.offset + 1);
            state.offset += 2;
            return value;
        // int 16
        case 0xd1:
            value = state.dataView.getInt16(state.offset + 1);
            state.offset += 3;
            return value;
        // int 32
        case 0xd2:
            value = state.dataView.getInt32(state.offset + 1);
            state.offset += 5;
            return value;
        // str 8
        case 0xd9:
            length = state.dataView.getUint8(state.offset + 1);
            state.offset += 2;
            return str(state, length);
        // str 16
        case 0xda:
            length = state.dataView.getUint16(state.offset + 1);
            state.offset += 3;
            return str(state, length);
        // str 32
        case 0xdb:
            length = state.dataView.getUint32(state.offset + 1);
            state.offset += 5;
            return str(state, length);
        // array 16
        case 0xdc:
            length = state.dataView.getUint16(state.offset + 1);
            state.offset += 3;
            return array(state, length);
        // array 32
        case 0xdd:
            length = state.dataView.getUint32(state.offset + 1);
            state.offset += 5;
            return array(state, length);
        // map 16:
        case 0xde:
            length = state.dataView.getUint16(state.offset + 1);
            state.offset += 3;
            return map(state, length);
        // map 32
        case 0xdf:
            length = state.dataView.getUint32(state.offset + 1);
            state.offset += 5;
            return map(state, length);
    }
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3DUI.prototype.showAnnotations = function() { var me = this;
    me.openDialog(me.pre + 'dl_selectannotations', 'Sequences and Annotations');

    // add note about assembly
    if( (me.bAssemblyNote === undefined || !me.bAssemblyNote) && me.icn3d.asuCnt !== undefined ) {
        var html = "     <br><div id='" + me.pre + "assembly_note' style='margin-left:5px;'><span class='icn3d-annoLargeTitle'>Assembly Tips:</span> Only the asymmetric unit is shown in the sequence window.<br>Click \"Assembly\" in the menu \"View\" to switch between asymmetric unit and biological assembly (<b>" + me.icn3d.asuCnt + "</b> asymmetric unit).</div>";

        $("#" + me.pre + "dl_annotations_tabs").append(html);

        me.bAssemblyNote = true;
    }

    if(me.bAnnoShown === undefined || !me.bAnnoShown) {
        //me.setLogCmd("view annotations", true);

    //if(me.giSeq !== undefined) { // clear the previous data
    //    $("#" + me.pre + "dl_annotations").html('');
    //}

        var chainArray = Object.keys(me.icn3d.chains);
        if(me.giSeq === undefined) me.giSeq = {};
        if(me.currClin === undefined) me.currClin = {};
        if(me.resi2disease_nonempty === undefined) me.resi2disease_nonempty = {};
        if(me.baseResi === undefined) me.baseResi = {};
        if(me.matchedPos === undefined) me.matchedPos = {};

        //me.customTracks = {};

        var dialogWidth = $("#" + me.pre + "dl_selectannotations").dialog( "option", "width" );
        me.seqAnnWidth = dialogWidth - 120 - 30*2 - 50; // title: 120px, start and end resi: 30px, extra space on the left and right: 50px

        me.maxAnnoLength = 1;
        for(var chainid in me.icn3d.chainsSeq) {
            if(me.icn3d.chainsSeq[chainid].length > me.maxAnnoLength) {
                me.maxAnnoLength = me.icn3d.chainsSeq[chainid].length;
            }
        }

        var nucleotide_chainid = {}, chemical_chainid = {}, chemical_set = {};
        me.protein_chainid = {};

        for(var i = 0, il = chainArray.length; i < il; ++i) {
            var pos = Math.round(chainArray[i].indexOf('_'));
            //if(pos > 4) continue; // NMR structures with structure id such as 2K042,2K043, ...

            var atom = me.icn3d.getFirstCalphaAtomObj(me.icn3d.chains[chainArray[i]]);
            // only single letter chain has accession such as 1P9M_A
            var chainLetter = chainArray[i].substr(chainArray[i].indexOf('_') + 1);

            var chainidBase;
            if(chainLetter.indexOf('_') !== -1) { // NCBI modified chainid, e.g., A_1
                chainLetter = chainLetter.substr(0, chainLetter.indexOf('_'));

                chainidBase = chainArray[i].substr(0, chainArray[i].indexOf('_')) + '_' + chainLetter;
            }
            else {
                chainidBase = chainArray[i];
            }

            //if(me.cfg.mmdbid !== undefined) { // protein and chemicals/ions are in different chains
            if(me.icn3d.proteins.hasOwnProperty(atom.serial)) {
                me.protein_chainid[chainArray[i]] = chainidBase;
            }
            else if(me.icn3d.nucleotides.hasOwnProperty(atom.serial)) {
                nucleotide_chainid[chainArray[i]] = chainidBase;
            }
            else {
                if(me.icn3d.chainsSeq[chainArray[i]].length > 1) {
                    chemical_chainid[chainArray[i]] = chainidBase;
                }
                else {
                    var name = me.icn3d.chainsSeq[chainArray[i]][0].name;
                    var resid = chainArray[i] + '_' + me.icn3d.chainsSeq[chainArray[i]][0].resi;

                    if(chemical_set[name] === undefined) chemical_set[name] = [];
                    chemical_set[name].push(resid);
                }
            }
            //}

            // protein and nucleotide chain may have chemicals/ions attached at the end
            if( (me.cfg.pdbid !== undefined || me.cfg.mmcifid !== undefined || me.cfg.mmtfid !== undefined)
              && (me.icn3d.proteins.hasOwnProperty(atom.serial) || me.icn3d.nucleotides.hasOwnProperty(atom.serial)) ) {
                for(var r = 0, rl = me.icn3d.chainsSeq[chainArray[i]].length; r < rl; ++r) {
                    var resObj = me.icn3d.chainsSeq[chainArray[i]][r];
                    if(resObj.name !== '' && resObj.name !== '-' && resObj.name == resObj.name.toUpperCase()) {
                        var resid = chainArray[i] + '_' + resObj.resi;
                        var atom = me.icn3d.getFirstCalphaAtomObj(me.icn3d.residues[resid]);

                        if(me.icn3d.proteins.hasOwnProperty(atom.serial) || me.icn3d.nucleotides.hasOwnProperty(atom.serial)) {
                            continue;
                        }
                        else {
                            var name = resObj.name.trim();

                            if(chemical_set[name] === undefined) chemical_set[name] = [];
                            chemical_set[name].push(resid);
                        }
                    } // if(resObj.name !== ''
                } // for(var r = 0
            } // if(me.cfg.mmdbid
        } // for(var i = 0

/*
        var i = 0;
        for(var chain in me.protein_chainid) {
            me.getAnnotationData(chain, me.protein_chainid[chain], i);
            ++i;
        }
*/

        if(me.cfg.blast_rep_id === undefined) {
           if(me.bFullUi) {
               if(me.cfg.mmtfid !== undefined) { // mmtf data do NOT have the missing residues
                   var id = chainArray[0].substr(0, chainArray[0].indexOf('_'));

                   $.when(me.downloadMmcifSymmetry(id, 'mmtfid')).then(function() {
                       me.showAnnoSeqData(nucleotide_chainid, chemical_chainid, chemical_set);
                   });
               }
               else {
                   me.showAnnoSeqData(nucleotide_chainid, chemical_chainid, chemical_set);
               }
           }
        }
        else if(me.cfg.blast_rep_id !== undefined) { // align sequence to structure
           var url = 'https://www.ncbi.nlm.nih.gov/Structure/pwaln/pwaln.fcgi?from=querytarget';
           var dataObj = {'targets': me.cfg.blast_rep_id, 'queries': me.cfg.query_id};

           if(me.cfg.query_from_to !== undefined ) {
               // convert from 1-based to 0-based
               var query_from_to_array = me.cfg.query_from_to.split(':');
               for(var i = 0, il = query_from_to_array.length; i < il; ++i) {
                   query_from_to_array[i] = parseInt(query_from_to_array[i]) - 1;
               }

               dataObj['queries'] = me.cfg.query_id + ':' + query_from_to_array.join(':');
           }

           if(me.cfg.target_from_to !== undefined) {
               // convert from 1-based to 0-based
               var target_from_to_array = me.cfg.target_from_to.split(':');
               for(var i = 0, il = target_from_to_array.length; i < il; ++i) {
                   target_from_to_array[i] = parseInt(target_from_to_array[i]) - 1;
               }

               dataObj['targets'] = me.cfg.blast_rep_id + ':' + target_from_to_array.join(':');
           }

           $.ajax({
              url: url,
              type: 'POST',
              data : dataObj,
              dataType: 'jsonp',
              //dataType: 'json',
              tryCount : 0,
              retryLimit : 1,
              success: function(data) {
                me.seqStructAlignData = data;

                me.showAnnoSeqData(nucleotide_chainid, chemical_chainid, chemical_set);
              },
              error : function(xhr, textStatus, errorThrown ) {
                this.tryCount++;
                if (this.tryCount <= this.retryLimit) {
                    //try again
                    $.ajax(this);
                    return;
                }
                return;
              }
            });
        } // align seq to structure
    }

    me.bAnnoShown = true;
};

iCn3DUI.prototype.showAnnoSeqData = function(nucleotide_chainid, chemical_chainid, chemical_set) { var me = this;
    me.getAnnotationData();

    var i = 0;
    for(var chain in nucleotide_chainid) {
        me.getSequenceData(chain, nucleotide_chainid[chain], 'nucleotide', i);
        ++i;
    }

    me.interactChainChainbase = me.icn3d.unionHash(me.protein_chainid, nucleotide_chainid);

    i = 0;
    for(var chain in chemical_chainid) {
        me.getSequenceData(chain, chemical_chainid[chain], 'chemical', i);
        ++i;
    }

    me.interactChainChainbase = me.icn3d.unionHash(me.interactChainChainbase, chemical_chainid);
    me.ssbondChainChainbase = me.icn3d.unionHash(me.protein_chainid, chemical_chainid);

    for(var name in chemical_set) {
        me.getCombinedSequenceData(name, chemical_set[name], i);
        ++i;
    }

    me.enableHlSeq();

    setTimeout(function(){
      //me.setAnnoViewAndDisplay('overview');
      me.hideAllAnno();
      me.clickCdd();
    }, 0);
};

iCn3DUI.prototype.enableHlSeq = function() { var me = this;
    if(! me.isMobile()) {
        me.selectSequenceNonMobile();
    }
    else {
        me.selectSequenceMobile();
        me.selectChainMobile();
    }

    // highlight seq after the ajax calls
    if(Object.keys(me.icn3d.hAtoms).length < Object.keys(me.icn3d.dAtoms).length) {
        me.updateHlSeq();
    }
};

// by default, showSeq and showCddSite are called at showAnnotations
// the following will be called only when the annotation is selected: showSnpClinvar, showDomain, showInteraction
// showSnpClinvar and showDomain will loop through me.protein_chainid
// showInteraction will loop through me.interactChainChainbase
iCn3DUI.prototype.updateSnpClinvar = function() { var me = this;
    if(me.bSnpClinvarShown === undefined || !me.bSnpClinvarShown) {
        for(var chainid in me.protein_chainid) {
            var chainidBase = me.protein_chainid[chainid];
            me.showSnpClinvar(chainid, chainidBase);
        }
    }

    me.bSnpClinvarShown = true;
};

iCn3DUI.prototype.updateDomain = function() { var me = this;
    if(me.bDomainShown === undefined || !me.bDomainShown) {
/*
        for(var chainid in me.protein_chainid) {
            var chainidBase = me.protein_chainid[chainid];
            me.showDomain(chainid, chainidBase);
        }
*/
        me.showDomainAll();
    }

    me.bDomainShown = true;
};

iCn3DUI.prototype.updateInteraction = function() { var me = this;
    if(me.bInteractionShown === undefined || !me.bInteractionShown) {
        for(var chainid in me.interactChainChainbase) {
            var chainidBase = me.interactChainChainbase[chainid];
            me.showInteraction(chainid, chainidBase);
        }
    }

    me.bInteractionShown = true;
};

iCn3DUI.prototype.updateSsbond = function() { var me = this;
    if(me.bSSbondShown === undefined || !me.bSSbondShown) {
        for(var chainid in me.ssbondChainChainbase) {
            var chainidBase = me.interactChainChainbase[chainid];
            me.showSsbond(chainid, chainidBase);
        }
    }

    me.bSSbondShown = true;
};

iCn3DUI.prototype.getAnDiv = function(chnid, anno) { var me = this;
    var message = 'Loading ' + anno + '...';
    if(anno == 'custom') {
        message = ''
    }
    else if(anno == 'domain') {
        message = 'Loading 3D ' + anno + '...';
    }

    return "<div id='" + me.pre + anno + "_" + chnid + "'><div id='" + me.pre + "tt_" + anno + "_" + chnid + "' class='icn3d-fixed-pos' style='display:none!important'></div><div id='" + me.pre + "dt_" + anno + "_" + chnid + "' style='display:none'>" + message + "</div><div id='" + me.pre + "ov_" + anno + "_" + chnid + "'>" + message + "</div></div>";
};

iCn3DUI.prototype.addButton = function(chnid, classvalue, name, desc, width, buttonStyle) { var me = this;
    return "<div class='" + classvalue + "' chainid='" + chnid + "' style='display:inline-block; font-size:11px; font-weight:bold; width:" + width + "px!important;'><button style='-webkit-appearance:" + buttonStyle + "; height:18px; width:" + width + "px;'><span style='white-space:nowrap; margin-left:-3px;' title='" + desc + "'>" + name + "</span></button></div>";
};

iCn3DUI.prototype.conservativeReplacement = function(resA, resB) { var me = this;
    var iA = (me.b62ResArray.indexOf(resA) !== -1) ? me.b62ResArray.indexOf(resA) : me.b62ResArray.length - 1; // or the last one "*"
    var iB = (me.b62ResArray.indexOf(resB) !== -1) ? me.b62ResArray.indexOf(resB) : me.b62ResArray.length - 1; // or the last one "*"

    var matrixValue = me.b62Matrix[iA][iB];

    if(matrixValue > 0) {
        return true;
    }
    else {
        return false;
    }
};

iCn3DUI.prototype.getColorhexFromBlosum62 = function(resA, resB) { var me = this;
    var iA = (me.b62ResArray.indexOf(resA) !== -1) ? me.b62ResArray.indexOf(resA) : me.b62ResArray.length - 1; // or the last one "*"
    var iB = (me.b62ResArray.indexOf(resB) !== -1) ? me.b62ResArray.indexOf(resB) : me.b62ResArray.length - 1; // or the last one "*"

    var matrixValue = me.b62Matrix[iA][iB];

    if(matrixValue === undefined) return '333333';

    // range and color: blue for -4 ~ 0, red for 0 ~ 11
    // max value 221 to avoid white
    var color = '333333';
    if(matrixValue > 0) {
        var c = 221 - parseInt(matrixValue / 11.0 * 221);
        var cStr = (c < 10) ? '0' + c.toString(16) : c.toString(16);
        color = 'DD' + cStr + cStr;
    }
    else {
        var c = 221 - parseInt(-1.0 * matrixValue / 4.0 * 221);
        var cStr = (c < 10) ? '0' + c.toString(16) : c.toString(16);
        color = cStr + cStr + 'DD';
    }

    return color;
};

iCn3DUI.prototype.getAnnotationData = function() { var me = this;
    var chnidBaseArray = $.map(me.protein_chainid, function(v) { return v; });

    var index = 0;
    for(var chnid in me.protein_chainid) {
        var buttonStyle = me.isMobile() ? 'none' : 'button';

        var fullProteinName = me.getProteinName(chnid);
        var proteinName = fullProteinName;
        //if(proteinName.length > 40) proteinName = proteinName.substr(0, 40) + "...";

        var categoryStr = (index == 0) ? "<span class='icn3d-annoLargeTitle'><b>Proteins</b>: </span><br><br>" : "";

        var geneLink = (me.icn3d.chainsGene[chnid] && me.icn3d.chainsGene[chnid].geneId) ? " (Gene: <a href='https://www.ncbi.nlm.nih.gov/gene/" + me.icn3d.chainsGene[chnid].geneId + "' target='_blank' title='" + me.icn3d.chainsGene[chnid].geneDesc + "'>" + me.icn3d.chainsGene[chnid].geneSymbol + "</a>)" : '';

        var chainHtml = "<div id='" + me.pre + "anno_" + chnid + "' class='icn3d-annotation'>" + categoryStr + "<span style='font-weight:bold;'>Annotations of " + chnid + "</span>: <a class='icn3d-blue' href='https://www.ncbi.nlm.nih.gov/protein?term=" + chnid + "' target='_blank' title='" + fullProteinName + "'>" + proteinName + "</a>" + geneLink + "&nbsp;&nbsp;&nbsp;"
        + me.addButton(chnid, "icn3d-addtrack", "Add Track", "Add a custom track", 60, buttonStyle) + "&nbsp;&nbsp;&nbsp;"
        + me.addButton(chnid, "icn3d-helixsets", "Helix Sets", "Define sets for each helix in this chain and add them to the menu of \"Defined Sets\"", 60, buttonStyle) + "&nbsp;"
        + me.addButton(chnid, "icn3d-sheetsets", "Sheet Sets", "Define sets for each sheet in this chain and add them to the menu of \"Defined Sets\"", 60, buttonStyle) + "&nbsp;"
        + me.addButton(chnid, "icn3d-coilsets", "Coil Sets", "Define sets for each coil in this chain and add them to the menu of \"Defined Sets\"", 60, buttonStyle);

        $("#" + me.pre + "dl_annotations").append(chainHtml);

        // dt: detailed view, hide by default; ov: overview, show by default
        $("#" + me.pre + "anno_" + chnid).append(me.getAnDiv(chnid, 'giseq'));
        $("#" + me.pre + "anno_" + chnid).append(me.getAnDiv(chnid, 'cdd'));
        $("#" + me.pre + "anno_" + chnid).append(me.getAnDiv(chnid, 'clinvar'));
        $("#" + me.pre + "anno_" + chnid).append(me.getAnDiv(chnid, 'snp'));
        $("#" + me.pre + "anno_" + chnid).append(me.getAnDiv(chnid, 'domain'));
        $("#" + me.pre + "anno_" + chnid).append(me.getAnDiv(chnid, 'site'));
        $("#" + me.pre + "anno_" + chnid).append(me.getAnDiv(chnid, 'interaction'));
        $("#" + me.pre + "anno_" + chnid).append(me.getAnDiv(chnid, 'custom'));
        $("#" + me.pre + "anno_" + chnid).append(me.getAnDiv(chnid, 'ssbond'));

        $("#" + me.pre + "anno_" + chnid).append("<br><hr><br>");

        ++index;
    }

    me.setToolTip();

    // set me.chain2gi
    me.chain2gi = {};

    // get gi from acc
    var url2 = "https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esummary.fcgi?db=protein&retmode=json&id=" + chnidBaseArray;

    $.ajax({
      url: url2,
      dataType: 'json',
      cache: true,
      tryCount : 0,
      retryLimit : 1,
      success: function(data2) {
        for(var id in data2.result) {
          if(id !== 'uids') {
            me.chain2gi[data2.result[id].caption] = id;
          }
        }
      },
      error : function(xhr, textStatus, errorThrown ) {
        this.tryCount++;
        if (this.tryCount <= this.retryLimit) {
            //try again
            $.ajax(this);
            //return;
        }

        //return;
      }
    });

    // show the sequence and 3D structure
    var url = "https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=protein&retmode=json&rettype=fasta&id=" + chnidBaseArray;
    $.ajax({
      url: url,
      dataType: 'text',
      cache: true,
      tryCount : 0,
      retryLimit : 1,
      success: function(data) {
        var chainArray = data.split('\n\n');

        var chainid_seq = {};
        for(var i = 0, il = chainArray.length; i < il; ++i) {
            var strArray = chainArray[i].split('\n');

            if(strArray.length > 0) {
                var title = strArray[0]; // >pdb|1HHO|B Chain B, Hemoglobin A (oxy) (beta Chain)
                var fieldArray = title.split(' ');
                var idArray = fieldArray[0].split('|');
                var chainid = idArray[1] + '_' + idArray[2];

                strArray.shift();
                var allSeq = strArray.join('');
                chainid_seq[chainid] = allSeq;
            }
        }

        for(var chnid in me.protein_chainid) {
            var chnidBase = me.protein_chainid[chnid];

            if(chainid_seq.hasOwnProperty(chnid)) {
                var allSeq = chainid_seq[chnid];
                me.giSeq[chnid] = allSeq;

                // the first 10 residues from sequences with structure
                var startResStr = '';
                for(var i = 0; i < 10 && i < me.icn3d.chainsSeq[chnid].length; ++i) {
                    startResStr += me.icn3d.chainsSeq[chnid][i].name.substr(0, 1);
                }

                var pos = allSeq.toLowerCase().indexOf(startResStr.toLowerCase());
                if(pos == -1) {
                    console.log("The gi sequence didn't match the protein sequence. The start of 3D protein sequence: " + startResStr + ". The gi sequence: " + allSeq.substr(0, 10) + ".");

                    me.setAlternativeSeq(chnid, chnidBase);
                }
                else {
                    me.matchedPos[chnid] = pos;
                    me.baseResi[chnid] = me.icn3d.chainsSeq[chnid][0].resi - me.matchedPos[chnid] - 1;
                }
            }
            else {
                console.log( "No data were found for the protein " + chnid + "..." );

                me.setAlternativeSeq(chnid, chnidBase);
            }

            if(me.cfg.blast_rep_id != chnid) {
                me.showSeq(chnid, chnidBase);
            }
            else if(me.cfg.blast_rep_id == chnid && me.seqStructAlignData.data === undefined) {
              var title;
              if(me.cfg.query_id.length > 14) {
                  title = 'Query: ' + me.cfg.query_id.substr(0, 6);
              }
              else {
                  title = (isNaN(me.cfg.query_id)) ? 'Query: ' + me.cfg.query_id : 'Query: gi ' + me.cfg.query_id;
              }

              compTitle = undefined;
              compText = undefined;

              var text = "cannot be aligned";

              me.queryStart = '';
              me.queryEnd = '';

              alert('The sequence can NOT be aligned to the structure');

              me.showSeq(chnid, chnidBase, undefined, title, compTitle, text, compText);
            }
            else if(me.cfg.blast_rep_id == chnid && me.seqStructAlignData.data !== undefined) { // align sequence to structure
              //var title = 'Query: ' + me.cfg.query_id.substr(0, 6);
              var title;
              if(me.cfg.query_id.length > 14) {
                  title = 'Query: ' + me.cfg.query_id.substr(0, 6);
              }
              else {
                  title = (isNaN(me.cfg.query_id)) ? 'Query: ' + me.cfg.query_id : 'Query: gi ' + me.cfg.query_id;
              }

              var data = me.seqStructAlignData;

              var query, target;

              if(data.data !== undefined) {
                  query = data.data[0].query;
                  target = data.data[0].targets[chnid.replace(/_/g, '')];

                  target = (target.hsps.length > 0) ? target.hsps[0] : undefined;
              }

              var text = '', compText = '';

              me.queryStart = '';
              me.queryEnd = '';

              if(query !== undefined && target !== undefined) {
                  var evalue = target.scores.e_value.toPrecision(2);
                  if(evalue > 1e-200) evalue = parseFloat(evalue).toExponential();

                  var bitscore = target.scores.bit_score;

                  var targetSeq = data.targets[chnid.replace(/_/g, '')].seqdata;
                  var querySeq = query.seqdata;

                  var segArray = target.segs;
                  var target2queryHash = {};
                  me.targetGapHash = {};
                  me.fullpos2ConsTargetpos = {};
                  me.consrvResPosArray = [];

                  var prevTargetTo = 0, prevQueryTo = 0;
                  me.nTotalGap = 0;
                  me.queryStart = segArray[0].from + 1;
                  me.queryEnd = segArray[segArray.length - 1].to + 1;

                  for(var i = 0, il = segArray.length; i < il; ++i) {
                      var seg = segArray[i];
                      if(i > 0) { // determine gap
                        if(seg.orifrom - prevTargetTo < seg.from - prevQueryTo) { // gap in target
                            me.targetGapHash[seg.orifrom] = {'from': prevQueryTo + 1, 'to': seg.from - 1};
                            me.nTotalGap += me.targetGapHash[seg.orifrom].to - me.targetGapHash[seg.orifrom].from + 1;
                        }
                        else if(seg.orifrom - prevTargetTo > seg.from - prevQueryTo) { // gap in query
                            for(var j = prevTargetTo + 1; j < seg.orifrom; ++j) {
                              target2queryHash[j] = -1; // means gap in query
                            }
                        }
                      }

                      for(var j = 0; j <= seg.orito - seg.orifrom; ++j) {
                          target2queryHash[j + seg.orifrom] = j + seg.from;
                      }
                      prevTargetTo = seg.orito;
                      prevQueryTo = seg.to;
                  }

                  // the missing residuesatthe end ofthe seq will be filled up in the API showNewTrack()
                  var nGap = 0;
                  me.icn3d.alnChainsSeq[chnid] = [];

                  for(var i = 0, il = targetSeq.length; i < il; ++i) {
                      //text += me.insertGap(chnid, i, '-', true);
                      if(me.targetGapHash.hasOwnProperty(i)) {
                          for(var j = me.targetGapHash[i].from; j <= me.targetGapHash[i].to; ++j) {
                              text += querySeq[j];
                          }
                      }

                      compText += me.insertGap(chnid, i, '-', true);
                      if(me.targetGapHash.hasOwnProperty(i)) nGap += me.targetGapHash[i].to - me.targetGapHash[i].from + 1;

                      if(target2queryHash.hasOwnProperty(i) && target2queryHash[i] !== -1) {
                          text += querySeq[target2queryHash[i]];
                          var colorHexStr = me.getColorhexFromBlosum62(targetSeq[i], querySeq[target2queryHash[i]]);

                          if(targetSeq[i] == querySeq[target2queryHash[i]]) {
                              compText += targetSeq[i];
                              me.fullpos2ConsTargetpos[i + nGap] = {'same': 1, 'pos': i+1, 'res': targetSeq[i], 'color': colorHexStr};
                              me.consrvResPosArray.push(i+1);

                              me.icn3d.alnChainsSeq[chnid].push({'resi': i+1, 'color': '#FF0000', 'color2': '#' + colorHexStr});
                          }
                          else if(me.conservativeReplacement(targetSeq[i], querySeq[target2queryHash[i]])) {
                              compText += '+';
                              me.fullpos2ConsTargetpos[i + nGap] = {'same': 0, 'pos': i+1, 'res': targetSeq[i], 'color': colorHexStr};
                              me.consrvResPosArray.push(i+1);

                              me.icn3d.alnChainsSeq[chnid].push({'resi': i+1, 'color': '#0000FF', 'color2': '#' + colorHexStr});
                          }
                          else {
                              compText += ' ';
                              me.fullpos2ConsTargetpos[i + nGap] = {'same': -1, 'pos': i+1, 'res': targetSeq[i], 'color': colorHexStr};

                              me.icn3d.alnChainsSeq[chnid].push({'resi': i+1, 'color': me.GREYC, 'color2': '#' + colorHexStr});
                          }
                      }
                      else {
                          text += '-';
                          compText += ' ';
                      }
                  }

                  //title += ', E: ' + evalue;
              }
              else {
                  text += "cannot be aligned";

                  alert('The sequence can NOT be aligned to the structure');
              }

              var compTitle = 'BLAST, E: ' + evalue;
              me.showSeq(chnid, chnidBase, undefined, title, compTitle, text, compText);

              var residueidHash = {};
              var residueid;
              if(me.consrvResPosArray !== undefined) {
                for(var i = 0, il = me.consrvResPosArray.length; i < il; ++i) {
                    residueid = chnidBase + '_' + me.consrvResPosArray[i];

                    residueidHash[residueid] = 1;
                    //atomHash = me.icn3d.unionHash(atomHash, me.icn3d.residues[residueid]);
                }
              }

              //me.selectResidueList(residueidHash, chnidBase + '_blast', compTitle, false);
              me.selectResidueList(residueidHash, 'aligned_protein', compTitle, false);
            } // align seq to structure
        } // for loop

        me.enableHlSeq();

        // get CDD/Binding sites
        me.showCddSiteAll();
      },
      error : function(xhr, textStatus, errorThrown ) {
        this.tryCount++;
        if (this.tryCount <= this.retryLimit) {
            //try again
            $.ajax(this);
            return;
        }

        me.enableHlSeq();

        console.log( "No data were found for the protein " + chnidBaseArray + "..." );

        for(var chnid in me.protein_chainid) {
            var chnidBase = me.protein_chainid[chnid];
            me.setAlternativeSeq(chnid, chnidBase);
            me.showSeq(chnid, chnidBase);
        }

        // get CDD/Binding sites
        me.showCddSiteAll();

        return;
      }
    });
};

iCn3DUI.prototype.setAlternativeSeq = function(chnid, chnidBase) { var me = this;
    //if(me.icn3d.chainsSeq[chnid] !== undefined) {
    var resArray = me.icn3d.chainsSeq[chnid];

    me.giSeq[chnid] = [];

    for(var i = 0, il = resArray.length; i < il; ++i) {
        var res = resArray[i].name;
        me.giSeq[chnid][i] = res;
    }

    me.matchedPos[chnid] = 0;
    me.baseResi[chnid] = me.icn3d.chainsSeq[chnid][0].resi - me.matchedPos[chnid] - 1;
};

iCn3DUI.prototype.getProteinName= function(chnid) { var me = this;
    var fullProteinName = '';
    if( (me.cfg.mmdbid !== undefined || me.cfg.gi !== undefined || me.cfg.blast_rep_id !== undefined) && me.mmdb_data !== undefined) {
        var moleculeInfor = me.mmdb_data.moleculeInfor;
        var chain = chnid.substr(chnid.indexOf('_') + 1);
        for(var i in moleculeInfor) {
            if(moleculeInfor[i].chain == chain) {
                fullProteinName = moleculeInfor[i].name.replace(/\'/g, '&prime;');
                proteinName = fullProteinName;
                //if(proteinName.length > 40) proteinName = proteinName.substr(0, 40) + "...";
                break;
            }
        }
    }
    else if(me.cfg.align !== undefined && me.chainid2title !== undefined) {
        if(me.chainid2title[chnid] !== undefined) {
            fullProteinName = me.chainid2title[chnid];
        }
    }

    return fullProteinName;
};

iCn3DUI.prototype.getSequenceData = function(chnid, chnidBase, type, index) { var me = this;
    var fullProteinName = me.getProteinName(chnid);
    var proteinName = fullProteinName;
    if(proteinName.length > 40) proteinName = proteinName.substr(0, 40) + "...";

    var categoryStr = "";

    if(index == 0) {
        if(type == 'protein') {
            categoryStr = "<span class='icn3d-annoLargeTitle'><b>Proteins</b>: </span><br><br>";
        }
        else if(type == 'nucleotide') {
            categoryStr = "<span class='icn3d-annoLargeTitle'><b>Nucleotides</b>: </span><br><br>";
        }
        else if(type == 'chemical') {
            categoryStr = "<span class='icn3d-annoLargeTitle'><b>Chemicals/Ions/Water</b>: </span><br><br>";
        }
    }

//    $("#" + me.pre + "dl_annotations").append("<div id='" + me.pre + "anno_" + chnid + "' class='icn3d-annotation'><span style='font-weight:bold;' title='Sequences of " + chnid + "'>Sequences of " + chnid + proteinName + "</span> <div class='addtrack' chainid='" + chnid + "' style='display:inline-block; font-size:11px; font-weight:bold; width:60px!important;'><button class='link' style='-webkit-appearance:" + buttonStyle + "; height:18px; width:60px;'><span style='white-space:nowrap; margin-left:-3px;' title='Add a custom track'>Add Track</span></button></div></div>");
    $("#" + me.pre + "dl_annotations").append("<div id='" + me.pre + "anno_" + chnid + "' class='icn3d-annotation'>" + categoryStr + "<b>" + chnid + "</b>: " + "<span title='" + fullProteinName + "'>" + proteinName + "</span> </div>");

    // dt: detailed view, hide by default; ov: overview, show by default
    $("#" + me.pre + "anno_" + chnid).append(me.getAnDiv(chnid, 'giseq'));
    //$("#" + me.pre + "anno_" + chnid).append(me.getAnDiv(chnid, 'custom'));
    $("#" + me.pre + "anno_" + chnid).append(me.getAnDiv(chnid, 'interaction'));

    $("#" + me.pre + "anno_" + chnid).append("<br><hr><br>");

    // show the sequence and 3D structure
    me.giSeq[chnid] = [];
    for(var i = 0; i < me.icn3d.chainsSeq[chnid].length; ++i) {
        var res = me.icn3d.chainsSeq[chnid][i].name;
        //me.giSeq[chnid][i] = (res.length > 1) ? res.substr(0, 1) : res;
        me.giSeq[chnid][i] = res;
    }

    me.matchedPos[chnid] = 0;
    me.baseResi[chnid] = me.icn3d.chainsSeq[chnid][0].resi - me.matchedPos[chnid] - 1;

    me.showSeq(chnid, chnidBase, type);

    //me.showInteraction(chnid, chnidBase);
};

iCn3DUI.prototype.getCombinedSequenceData = function(name, residArray, index) { var me = this;

    var categoryStr = (index == 0) ? "<span class='icn3d-annoLargeTitle'><b>Chemicals/Ions/Water</b>: </span><br><br>" : "";

    var chemName;
    var pos = residArray[0].lastIndexOf('_');
    var firstChainid = residArray[0].substr(0, pos);

    var sid = (me.cfg.mmdbid !== undefined) ? me.chainid2sid[firstChainid] : undefined;
    if(sid !== undefined) {
        chemName = "<b><a class='icn3d-blue' href='https://pubchem.ncbi.nlm.nih.gov/substance/" + sid + "#section=2D-Structure' target='_blank'>" + name + " <img src='https://pubchem.ncbi.nlm.nih.gov/image/imgsrv.fcgi?sid=" + sid + "'></a></b>";
    }
    else {
        chemName = "<b>" + name + "</b>";
    }

    $("#" + me.pre + "dl_annotations").append("<div id='" + me.pre + "anno_" + name + "' class='icn3d-annotation'>" + categoryStr + chemName + "</div>");

    // dt: detailed view, hide by default; ov: overview, show by default
    $("#" + me.pre + "anno_" + name).append("<div id='" + me.pre + "giseq_" + name + "'><div id='" + me.pre + "dt_giseq_" + name + "' style='display:none'></div><div id='" + me.pre + "ov_giseq_" + name + "'></div></div>");

    $("#" + me.pre + "anno_" + name).append("<br><hr><br>");


    // sequence, detailed view
    var htmlTmp = '<div id="' + me.pre + 'giseq_sequence" class="icn3d-dl_sequence">';

    var chainType = 'Chem.', chainTypeFull = 'Chemical';

    htmlTmp += '<div class="icn3d-seqTitle" anno="sequence"><span style="white-space:nowrap;" title="' + chainTypeFull + ' ' + name + '">' + chainType + ' ' + name + '</span></div>';

    htmlTmp += '<span class="icn3d-residueNum" style="width:60px!important;" title="starting protein sequence number">Count: ' + residArray.length + '</span>';
    htmlTmp += '<span class="icn3d-seqLine">';

    // sequence, overview
    var html = htmlTmp;
    var html2 = htmlTmp;

    for(var i = 0, il = residArray.length; i < il; ++i) {
      var cFull = name;

      var c = cFull;
      if(cFull.length > 3) {
          c = cFull.substr(0,3);
      }

      if(i < residArray.length - 1) c = c + ',';

      var resid = residArray[i];
      var resi = resid.substr(resid.lastIndexOf('_') + 1);

      html += '<span id="giseq_' + me.pre + resid + '" title="' + cFull + resi + '" class="icn3d-residue icn3d-chemical">' + c + '</span>';
    }

    var color = me.GREY8;

    //html2 += '<div class="icn3d-seqTitle" style="display:inline-block; color:white; font-weight:bold; background-color:' + color + '; width:' + Math.round(me.seqAnnWidth * residArray.length / me.maxAnnoLength) + 'px;">' + name + '</div>';
    var width = Math.round(me.seqAnnWidth * residArray.length / me.maxAnnoLength);
    if(width < 1) width = 1;
    html2 += '<div class="icn3d-seqTitle" style="display:inline-block; color:white; font-weight:bold; background-color:' + color + '; width:' + width + 'px;">&nbsp;</div>';

    //htmlTmp = '<span class="icn3d-residueNum" title="ending protein sequence number">' + residArray.length + '</span>';
    //htmlTmp += '</span>';
    htmlTmp = '</span>';
    htmlTmp += '<br>';

    htmlTmp += '</div>';

    html += htmlTmp;
    html2 += htmlTmp;

    $("#" + me.pre + 'dt_giseq_' + name).html(html);
    $("#" + me.pre + 'ov_giseq_' + name).html(html2);
};

iCn3DUI.prototype.insertGap = function(chnid, seqIndex, text, bNohtml) {  var me = this;
  var html = '';

  if(me.cfg.blast_rep_id == chnid && me.targetGapHash!== undefined && me.targetGapHash.hasOwnProperty(seqIndex)) {
      for(var j = 0; j < (me.targetGapHash[seqIndex].to - me.targetGapHash[seqIndex].from + 1); ++j) {
          if(bNohtml !== undefined && bNohtml) {
             html += text;
          }
          else {
             html += '<span>' + text + '</span>';
          }
      }
  }

  return html;
};

iCn3DUI.prototype.insertGapOverview = function(chnid, seqIndex) {  var me = this;
  var html2 = '';

  if(me.cfg.blast_rep_id == chnid && me.targetGapHash!== undefined && me.targetGapHash.hasOwnProperty(seqIndex)) {
      var width = me.seqAnnWidth * (me.targetGapHash[seqIndex].to - me.targetGapHash[seqIndex].from + 1) / (me.maxAnnoLength + me.nTotalGap);

      html2 += '<div style="display:inline-block; background-color:#333; width:' + width + 'px; height:3px;">&nbsp;</div>';
  }

  return html2;
};

iCn3DUI.prototype.showSeq = function(chnid, chnidBase, type, queryTitle, compTitle, queryText, compText) {  var me = this;
    var bNonMmdb = false;

    var giSeq;
    if(me.cfg.mmdbid === undefined && me.cfg.gi === undefined && me.cfg.blast_rep_id === undefined && me.cfg.align === undefined) {
        bNonMmdb = true;

        giSeq = [];
        for(var i = 0; i < me.giSeq[chnid].length; ++i) {
            giSeq.push(me.icn3d.chainsSeq[chnid][i]);
        }
    }
    else {
        giSeq = me.giSeq[chnid];
    }

    var divLength = me.RESIDUE_WIDTH * me.giSeq[chnid].length + 200;
    var seqLength = me.giSeq[chnid].length

    if(seqLength > me.maxAnnoLength) {
        me.maxAnnoLength = seqLength;
    }

    $("#" + me.pre + "giseq_" + chnid).width(divLength);
    $("#" + me.pre + "interaction_" + chnid).width(divLength);
    $("#" + me.pre + "ssbond_" + chnid).width(divLength);
    if($("#" + me.pre + "custom_" + chnid).length) $("#" + me.pre + "custom_" + chnid).width(divLength);
    if($("#" + me.pre + "clinvar_" + chnid).length) $("#" + me.pre + "clinvar_" + chnid).width(divLength);
    if($("#" + me.pre + "snp_" + chnid).length) $("#" + me.pre + "snp_" + chnid).width(divLength);
    if($("#" + me.pre + "cddsite_" + chnid).length) $("#" + me.pre + "cddsite_" + chnid).width(divLength);
    if($("#" + me.pre + "domain_" + chnid).length) $("#" + me.pre + "domain_" + chnid).width(divLength);

    // gi html
    var html = '', html2 = '', html3 = '', htmlTmp;

    html += '<div class="icn3d-dl_sequence">';
    html3 += '<div class="icn3d-dl_sequence">';

    // html to display protein positions (10, 20, etc)
    //if(Object.keys(me.icn3d.chains[chnid]).length > 10) {
    if(me.giSeq[chnid].length > 10) {
        htmlTmp = '<div class="icn3d-residueLine" style="white-space:nowrap;">';
        var atom = me.icn3d.getFirstCalphaAtomObj(me.icn3d.chains[chnid]);

        //if(me.baseResi[chnid] != 0 && (me.cfg.mmdbid !== undefined || me.cfg.gi !== undefined || me.cfg.align !== undefined)) {
        if((me.cfg.mmdbid !== undefined || me.cfg.gi !== undefined || me.cfg.blast_rep_id !== undefined || me.cfg.align !== undefined) && atom.resi_ori !== undefined && atom.resi_ori != atom.resi && chnid.indexOf('Misc') == -1 ) {
            htmlTmp += '<div class="icn3d-annoTitle" anno="0" title="NCBI Residue Numbers">NCBI Residue Numbers</div>';
        }
        else {
            htmlTmp += '<div class="icn3d-annoTitle" anno="0"></div>';
        }

        htmlTmp += '<span class="icn3d-residueNum"></span>';

        html3 += htmlTmp + '<br>';

        html += htmlTmp + '<span class="icn3d-seqLine">';

        var helixCnt = 0, sheetCnt = 0;

        for(var i = 0, il = giSeq.length; i < il; ++i) {
          html += me.insertGap(chnid, i, '-');

          var currResi;
          if(bNonMmdb) {
            currResi = giSeq[i].resi;
          }
          else {
            currResi = (i >= me.matchedPos[chnid] && i - me.matchedPos[chnid] < me.icn3d.chainsSeq[chnid].length) ? me.icn3d.chainsSeq[chnid][i - me.matchedPos[chnid]].resi : me.baseResi[chnid] + 1 + i;
          }

          html += '<span>'

          if( currResi % 10 === 0) {
            html += currResi + ' ';
          }

          // name of secondary structures
          var residueid = chnid + '_' + currResi;

          if( me.icn3d.residues.hasOwnProperty(residueid) ) {
            var atom = me.icn3d.getFirstCalphaAtomObj(me.icn3d.residues[residueid]);

            if(me.icn3d.secondaries[residueid] == 'H' && atom.ssbegin) {
                ++helixCnt;
                html += '<span class="icn3d-helix-color">H' + helixCnt + '</span>';
            }
            else if(me.icn3d.secondaries[residueid] == 'E' && atom.ssbegin) {
                ++sheetCnt;
                if(me.icn3d.sheetcolor == 'green') {
                    html += '<span class="icn3d-sheet-color">S' + sheetCnt + '</span>';
                }
                else if(me.icn3d.sheetcolor == 'yellow') {
                    html += '<span class="icn3d-sheet-colory">S' + sheetCnt + '</span>';
                }
            }
          }

          html += '</span>'
        }
        html += '<span class="icn3d-residueNum"></span>';
        html += '</span>';
        html += '<br>';
        html += '</div>';

        html3 += '</div>';
    }

    // html to display secondary structures
    htmlTmp = '<div class="icn3d-residueLine" style="white-space:nowrap;">';
    htmlTmp += '<div class="icn3d-annoTitle" anno="0"></div>';
    htmlTmp += '<span class="icn3d-residueNum"></span>';

    html3 += htmlTmp + '<br>';
    html += htmlTmp + '<span class="icn3d-seqLine">';

    for(var i = 0, il = giSeq.length; i < il; ++i) {
      html += me.insertGap(chnid, i, '-');
//      var resi = (me.baseResi[chnid] + i+1).toString();
//      var resi = me.icn3d.chainsSeq[chnid][i - me.matchedPos[chnid] ].resi;
      var resi = (i >= me.matchedPos[chnid] && i - me.matchedPos[chnid] < me.icn3d.chainsSeq[chnid].length) ? me.icn3d.chainsSeq[chnid][i - me.matchedPos[chnid]].resi : me.baseResi[chnid] + 1 + i;

      var residueid = chnid + '_' + resi;

      if( me.icn3d.residues.hasOwnProperty(residueid) ) {
        if(me.icn3d.secondaries[residueid] == 'H') {
            if(i % 2 == 0) {
                html += '<span class="icn3d-helix">';
            }
            else {
                html += '<span class="icn3d-helix2">';
            }

            html += '&nbsp;</span>';
        }
        else if(me.icn3d.secondaries[residueid] == 'E') {
            var atom = me.icn3d.getFirstCalphaAtomObj(me.icn3d.residues[residueid]);

            if(atom.ssend) {
                if(me.icn3d.sheetcolor == 'green') {
                    html += '<span class="icn3d-sheet2">';
                }
                else if(me.icn3d.sheetcolor == 'yellow') {
                    html += '<span class="icn3d-sheet2y">';
                }
            }
            else {
                if(me.icn3d.sheetcolor == 'green') {
                    html += '<span class="icn3d-sheet">';
                }
                else if(me.icn3d.sheetcolor == 'yellow') {
                    html += '<span class="icn3d-sheety">';
                }
            }

            html += '&nbsp;</span>';
        }
        else if(me.icn3d.secondaries[residueid] == 'c') {
            html += '<span class="icn3d-coil">&nbsp;</span>';
        }
        else if(me.icn3d.secondaries[residueid] == 'o') {
            html += '<span class="icn3d-other">&nbsp;</span>';
        }
      }
      else {
        html += '<span>-</span>'; //'<span>-</span>';
      }
    }
    html += '<span class="icn3d-residueNum"></span>';
    html += '</span>';
    html += '<br>';
    html += '</div>';

    html += '</div>'; // corresponds to above: html += '<div class="icn3d-dl_sequence">';

    html3 += '</div></div>';

    if(me.cfg.blast_rep_id === chnid) {
        htmlTmp = '<div id="' + me.pre + 'giseq_sequence" class="icn3d-dl_sequence" style="border: solid 1px #000;">';
    }
    else {
        htmlTmp = '<div id="' + me.pre + 'giseq_sequence" class="icn3d-dl_sequence">';
    }

    var chainType = 'Protein', chainTypeFull = 'Protein';
    if(type !== undefined) {
        if(type == 'nucleotide') {
            chainType = 'Nucl.';
            chainTypeFull = 'Nucleotide';
        }
        else if(type == 'chemical') {
            chainType = 'Chem.';
            chainTypeFull = 'Chemical';
        }
    }

    // sequence, detailed view
    htmlTmp += '<div class="icn3d-seqTitle icn3d-link icn3d-blue" gi="' + chnid + '" anno="sequence" chain="' + chnid + '"><span style="white-space:nowrap;" title="' + chainTypeFull + ' ' + chnid + '">' + chainType + ' ' + chnid + '</span></div>';

    htmlTmp += '<span class="icn3d-residueNum" title="starting protein sequence number">' + (me.baseResi[chnid]+1).toString() + '</span>';

    html3 += htmlTmp + '<br>';

    var htmlTmp2 = '<span class="icn3d-seqLine">';

    html += htmlTmp + htmlTmp2;
    html2 += htmlTmp + htmlTmp2;

    var nGap = 0;
    for(var i = 0, il = giSeq.length; i < il; ++i) {
      html += me.insertGap(chnid, i, '-');

      if(me.targetGapHash !== undefined && me.targetGapHash.hasOwnProperty(i)) nGap += me.targetGapHash[i].to - me.targetGapHash[i].from + 1;

      var cFull = (bNonMmdb) ? giSeq[i].name : giSeq[i];

      var c = cFull;
      if(cFull.length > 1) {
          c = cFull[0] + '..';
      }

//      var pos = (me.baseResi[chnid] + i+1).toString();
//      var pos = me.icn3d.chainsSeq[chnid][i - me.matchedPos[chnid] ].resi;
      var pos = (i >= me.matchedPos[chnid] && i - me.matchedPos[chnid] < me.icn3d.chainsSeq[chnid].length) ? me.icn3d.chainsSeq[chnid][i - me.matchedPos[chnid]].resi : me.baseResi[chnid] + 1 + i;

      if( !me.icn3d.residues.hasOwnProperty(chnid + '_' + pos) ) {
          c = c.toLowerCase();
          html += '<span title="' + cFull + pos + '" class="icn3d-residue">' + c + '</span>';
      }
      else {
          //var atom = me.icn3d.getFirstCalphaAtomObj(me.icn3d.residues[chnid + '_' + pos]);
          //var color = (atom.color) ? atom.color.getHexString() : me.icn3d.defaultAtomColor;

          var color = '333333';
          if(me.cfg.blast_rep_id == chnid && me.fullpos2ConsTargetpos !== undefined && me.fullpos2ConsTargetpos[i + nGap] !== undefined) {
              color = me.fullpos2ConsTargetpos[i + nGap].color;
          }
          else {
              var atom = me.icn3d.getFirstCalphaAtomObj(me.icn3d.residues[chnid + '_' + pos]);
              color = (atom.color) ? atom.color.getHexString() : me.icn3d.defaultAtomColor;
          }

          html += '<span id="giseq_' + me.pre + chnid + '_' + pos + '" title="' + cFull + pos + '" class="icn3d-residue" style="color:#' + color + '">' + c + '</span>';
      }
    }

    if(me.cfg.blast_rep_id == chnid) {
      // change color in 3D
      me.opts['color'] = 'conservation';
      me.icn3d.setColorByOptions(me.opts, me.icn3d.atoms);

      // remove highlight
      //me.removeHlSeq();
    }

    // sequence, overview
    var atom = me.icn3d.getFirstCalphaAtomObj(me.icn3d.chains[chnid]);
    var color = (atom.color) ? atom.color.getHexString() : me.icn3d.defaultAtomColor;

    var width = Math.round(me.seqAnnWidth * giSeq.length / me.maxAnnoLength);
    if(width < 1) width = 1;

    if(me.cfg.blast_rep_id != chnid) { // regular
        html2 += '<div id="giseq_summary_' + me.pre + chnid + '" class="icn3d-seqTitle icn3d-link" gi chain="' + chnid + '" style="display:inline-block; color:white; font-weight:bold; background-color:#' + color + '; width:' + width + 'px;">' + chnid + '</div>';
    }
    else { // with potential gaps
        var fromArray2 = [], toArray2 = [];
        fromArray2.push(0);

        for(var i = 0, il = giSeq.length; i < il; ++i) {
            if(me.targetGapHash !== undefined && me.targetGapHash.hasOwnProperty(i)) {
                toArray2.push(i - 1);
                fromArray2.push(i);
            }
        }

        toArray2.push(giSeq.length - 1);

        html2 += '<div id="giseq_summary_' + me.pre + chnid + '" class="icn3d-seqTitle icn3d-link" gi chain="' + chnid + '" style="width:' + width + 'px;">';
        for(var i = 0, il = fromArray2.length; i < il; ++i) {
            html2 += me.insertGapOverview(chnid, fromArray2[i]);

            //var emptyWidth = (i == 0) ? Math.round(me.seqAnnWidth * fromArray2[i] / (me.maxAnnoLength + me.nTotalGap)) : Math.round(me.seqAnnWidth * (fromArray2[i] - toArray2[i-1] - 1) / (me.maxAnnoLength + me.nTotalGap));
            //html2 += '<div style="display:inline-block; width:' + emptyWidth + 'px;">&nbsp;</div>';

            html2 += '<div style="display:inline-block; color:white!important; font-weight:bold; background-color:#' + color + '; width:' + Math.round(me.seqAnnWidth * (toArray2[i] - fromArray2[i] + 1) / (me.maxAnnoLength + me.nTotalGap)) + 'px;" class="icn3d-seqTitle icn3d-link icn3d-blue" anno="sequence" gi chain="' + chnid + '" title="' + chnid + '">' + chnid + '</div>';
        }
        html2 += '</div>';
    }

    htmlTmp = '<span class="icn3d-residueNum" title="ending protein sequence number">' + pos + '</span>';
    htmlTmp += '</span>';
    htmlTmp += '<br>';

    html += htmlTmp;
    html2 += htmlTmp;

    if(me.cfg.blast_rep_id == chnid) {
        // 1. residue conservation
        if(compText !== undefined && compText !== '') {
        // conservation, detailed view
        htmlTmp = '<div class="icn3d-seqTitle icn3d-link icn3d-blue" blast="" posarray="' + me.consrvResPosArray.toString() + '" title="' + compTitle + '" setname="' + chnid + '_blast" anno="sequence" chain="' + chnid + '"><span style="white-space:nowrap;" title="' + compTitle + '">' + compTitle + '</span></div>';

        htmlTmp += '<span class="icn3d-residueNum"></span>';

        html3 += htmlTmp + '<br>';

        var htmlTmp2 = '<span class="icn3d-seqLine">';

        html += htmlTmp + htmlTmp2;
        html2 += htmlTmp + htmlTmp2;

        var prevEmptyWidth = 0;
        var prevLineWidth = 0;
        var widthPerRes = 1;

        var queryPos = me.queryStart;
        for(var i = 0, il = compText.length; i < il; ++i) {
          var c = compText[i];

          if(c == '-') {
              html += '<span>-</span>';
          }
          else if(c == ' ') {
              html += '<span> </span>';
          }
          else {
              var pos = me.fullpos2ConsTargetpos[i].pos;
              if( !me.icn3d.residues.hasOwnProperty(chnid + '_' + pos) ) {
                  c = c.toLowerCase();
                  html += '<span class="icn3d-residue">' + c + '</span>';
              }
              else {
                  /*
                  var color = "333";
                  if(me.fullpos2ConsTargetpos[i].same == 1) {
                      color = "F00";
                  }
                  else if(me.fullpos2ConsTargetpos[i].same == 0) {
                      color = "00F";
                  }
                  */

                  var color = me.fullpos2ConsTargetpos[i].color;

                  //html += '<span id="blast_' + me.pre + chnid + '_' + pos + '" title="' + me.fullpos2ConsTargetpos[i].res + pos + '" class="icn3d-residue" style="color:#' + color + '">' + c + '</span>';
                  html += '<span id="giseq_' + me.pre + chnid + '_' + pos + '" title="' + me.fullpos2ConsTargetpos[i].res + pos + '" class="icn3d-residue" style="color:#' + color + '">' + c + '</span>';
              }

              html2 += me.insertGapOverview(chnid, i);

              var emptyWidth = Math.round(me.seqAnnWidth * i / (me.maxAnnoLength + me.nTotalGap) - prevEmptyWidth - prevLineWidth);

              if(emptyWidth < 0) emptyWidth = 0;

              html2 += '<div style="display:inline-block; width:' + emptyWidth + 'px;">&nbsp;</div>';
              html2 += '<div style="display:inline-block; background-color:#F00; width:' + widthPerRes + 'px;" title="' + c + pos + '">&nbsp;</div>';

              prevEmptyWidth += emptyWidth;
              prevLineWidth += widthPerRes;

              ++queryPos;
          }
        }

        htmlTmp = '<span class="icn3d-residueNum"></span>';
        htmlTmp += '</span>';
        htmlTmp += '<br>';

        html += htmlTmp;
        html2 += htmlTmp;
        }


        // 2. Query text
        // query protein, detailed view
        htmlTmp = '<div class="icn3d-annoTitle" anno="sequence" chain="' + chnid + '"><span style="white-space:nowrap;" title="' + queryTitle + '">' + queryTitle + '</span></div>';

        htmlTmp += '<span class="icn3d-residueNum" title="starting protein sequence number">' + me.queryStart + '</span>';

        html3 += htmlTmp + '<br>';

        //var htmlTmp2 = '<span class="icn3d-seqLine">';
        var htmlTmp2 = '<span class="icn3d-seqLine" style="font-weight: bold;">';

        html += htmlTmp + htmlTmp2;
        html2 += htmlTmp + htmlTmp2;

        var queryPos = me.queryStart;
        for(var i = 0, il = queryText.length; i < il; ++i) {
          var c = queryText[i];

          if(c == ' ' || c == '-') {
              html += '<span>-</span>';
          }
          else {
              //var pos = (i >= me.matchedPos[chnid] && i - me.matchedPos[chnid] < me.icn3d.chainsSeq[chnid].length) ? me.icn3d.chainsSeq[chnid][i - me.matchedPos[chnid]].resi : me.baseResi[chnid] + 1 + i;
              if( me.fullpos2ConsTargetpos !== undefined && me.fullpos2ConsTargetpos[i] !== undefined && !me.icn3d.residues.hasOwnProperty(chnid + '_' + me.fullpos2ConsTargetpos[i].pos) ) {
                  c = c.toLowerCase();
                  html += '<span title="' + c + queryPos + '" class="icn3d-residue">' + c + '</span>';
              }
              else {
                  //var color = (me.fullpos2ConsTargetpos !== undefined && me.fullpos2ConsTargetpos[i] !== undefined) ? me.fullpos2ConsTargetpos[i].color : '333333';
                  //html += '<span title="' + c + queryPos + '" class="icn3d-residue" style="color:#' + color + '">' + c + '</span>';

                  html += '<span title="' + c + queryPos + '" class="icn3d-residue">' + c + '</span>';
              }

              ++queryPos;
          }
        }

        // query protein, overview
        var atom = me.icn3d.getFirstCalphaAtomObj(me.icn3d.chains[chnid]);
        var color = (atom.color) ? atom.color.getHexString() : me.icn3d.defaultAtomColor;

        var fromArray2 = [], toArray2 = [];

        var prevChar = '-';
        for(var i = 0, il = queryText.length; i < il; ++i) {
            var c = queryText[i];

            if(c != '-' && prevChar == '-') {
                fromArray2.push(i);
            }
            else if(c == '-' && prevChar != '-' ) {
                toArray2.push(i-1);
            }

            prevChar = c;
        }

        if(prevChar != '-') {
            toArray2.push(queryText.length - 1);
        }

        for(var i = 0, il = fromArray2.length; i < il; ++i) {
            var emptyWidth = (i == 0) ? Math.round(me.seqAnnWidth * fromArray2[i] / (me.maxAnnoLength + me.nTotalGap)) : Math.round(me.seqAnnWidth * (fromArray2[i] - toArray2[i-1] - 1) / (me.maxAnnoLength + me.nTotalGap));
            html2 += '<div style="display:inline-block; width:' + emptyWidth + 'px;">&nbsp;</div>';

            html2 += '<div style="display:inline-block; color:white!important; font-weight:bold; background-color:#' + color + '; width:' + Math.round(me.seqAnnWidth * (toArray2[i] - fromArray2[i] + 1) / (me.maxAnnoLength + me.nTotalGap)) + 'px;" anno="sequence" chain="' + chnid + '" title="' + queryTitle + '">' + queryTitle + '</div>';
        }

        htmlTmp = '<span class="icn3d-residueNum" title="ending protein sequence number">' + me.queryEnd + '</span>';
        htmlTmp += '</span>';
        htmlTmp += '<br>';

        html += htmlTmp;
        html2 += htmlTmp;
    }

    html += '</div>';
    html2 += '</div>';
    html3 += '</div>';

    //if(Object.keys(me.icn3d.chains[chnid]).length > 10) {
    if(me.giSeq[chnid].length > 10) {
        var atom = me.icn3d.getFirstCalphaAtomObj(me.icn3d.chains[chnid]);
        //if(me.baseResi[chnid] != 0 && (me.cfg.mmdbid !== undefined || me.cfg.gi !== undefined || me.cfg.align !== undefined)) {
        if((me.cfg.mmdbid !== undefined || me.cfg.gi !== undefined || me.cfg.blast_rep_id !== undefined || me.cfg.align !== undefined) && atom.resi_ori !== undefined && atom.resi_ori != atom.resi && chnid.indexOf('Misc') == -1 ) {
            htmlTmp = '<div class="icn3d-dl_sequence">';
            htmlTmp += '<div class="icn3d-residueLine" style="white-space:nowrap;">';
            htmlTmp += '<div class="icn3d-annoTitle" anno="0" title="PDB Residue Numbers">PDB Residue Numbers</div>';
            htmlTmp += '<span class="icn3d-residueNum"></span>';

            html3 += htmlTmp + '<br>';

            html += htmlTmp + '<span class="icn3d-seqLine">';

            for(var i = 0, il = giSeq.length; i < il; ++i) {
                html += me.insertGap(chnid, i, '-');

                if(i >= me.matchedPos[chnid] && i - me.matchedPos[chnid] < me.icn3d.chainsSeq[chnid].length) {
                  var currResi = me.icn3d.chainsSeq[chnid][i - me.matchedPos[chnid]].resi;

                  var residueid = chnid + '_' + currResi;

                  if(!me.icn3d.residues.hasOwnProperty(residueid)) {
                      html += '<span></span>';
                  }
                  else {
                      var atom = me.icn3d.getFirstCalphaAtomObj(me.icn3d.residues[residueid]);

                      var resi_ori = atom.resi_ori;

                      html += '<span>';

                      if( resi_ori % 10 === 0) {
                        html += resi_ori + ' ';
                      }

                      html += '</span>';
                  }
                }
                else {
                  html += '<span></span>';
                }
            }
            html += '<span class="icn3d-residueNum"></span>';
            html += '</span>';
            html += '<br>';
            html += '</div>';

            html += '</div>';

            html3 += '</div></div>';
        }
    }

    $("#" + me.pre + 'dt_giseq_' + chnid).html(html);
    $("#" + me.pre + 'ov_giseq_' + chnid).html(html2);
    $("#" + me.pre + 'tt_giseq_' + chnid).html(html3); // fixed title for scrolling
};

iCn3DUI.prototype.navClinVar = function(chnid) { var me = this;
    me.currClin[chnid] = - 1;

    $(document).on('click', "#" + me.pre + chnid + "_prevclin", function(e) {
      e.stopImmediatePropagation();
      //e.preventDefault();
      var maxLen = (me.resi2disease_nonempty[chnid] !== undefined) ? Object.keys(me.resi2disease_nonempty[chnid]).length : 0;

      --me.currClin[chnid];
      if(me.currClin[chnid] < 0) me.currClin[chnid] = maxLen - 1; // 0;

      me.showClinVarLabelOn3D(chnid);
    });

    $(document).on('click', "#" + me.pre + chnid + "_nextclin", function(e) {
      e.stopImmediatePropagation();
      //e.preventDefault();
      var maxLen = (me.resi2disease_nonempty[chnid] !== undefined) ? Object.keys(me.resi2disease_nonempty[chnid]).length : 0;

      ++me.currClin[chnid];
      if(me.currClin[chnid] > maxLen - 1) me.currClin[chnid] = 0; // me.resi2disease_nonempty[chnid].length - 1;

      me.showClinVarLabelOn3D(chnid);
    });
};

iCn3DUI.prototype.showClinVarLabelOn3D = function(chnid) { var me = this;
      var resiArray = Object.keys(me.resi2disease_nonempty[chnid]);

      var chainid, residueid;

      chainid = chnid;

      residueid = chainid + '_' + resiArray[me.currClin[chnid]];

      var label = '';

      var diseaseArray = me.resi2disease_nonempty[chnid][resiArray[me.currClin[chnid]]];

      for(var k = 0, kl = diseaseArray.length; k < kl; ++k) {
          if(diseaseArray[k] != '' && diseaseArray[k] != 'not specified' && diseaseArray[k] != 'not provided') {
            label = diseaseArray[k];
            break;
          }
      }

      var position = me.icn3d.centerAtoms(me.icn3d.hash2Atoms(me.icn3d.residues[residueid]));
      //position.center.add(new THREE.Vector3(3.0, 3.0, 3.0)); // shift a little bit

      var maxlen = 30;
      if(label.length > maxlen) label = label.substr(0, maxlen) + '...';

      me.removeSelection();

      if(me.icn3d.labels == undefined) me.icn3d.labels = {};
      me.icn3d.labels['clinvar'] = [];

      //var size = Math.round(me.icn3d.LABELSIZE * 10 / label.length);
      var size = me.icn3d.LABELSIZE;
      var color = "#FFFF00";
      me.addLabel(label, position.center.x + 1, position.center.y + 1, position.center.z + 1, size, color, undefined, 'clinvar');

      me.icn3d.hAtoms = {};

      for(var j in me.icn3d.residues[residueid]) {
          me.icn3d.hAtoms[j] = 1;
      }

      //me.icn3d.addResiudeLabels(me.icn3d.hAtoms);

      $("#clinvar_" + me.pre + residueid).addClass('icn3d-highlightSeq');

      if(!$("#" + me.pre + "modeswitch")[0].checked) {
          me.setMode('selection');
      }

      me.icn3d.draw();
};

iCn3DUI.prototype.getSnpLine = function(line, totalLineNum, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, bStartEndRes, chnid, bOverview, bClinvar, bTitleOnly, bSnpOnly) {
    var me = this;

    var html = '';

    var altName = bClinvar ? 'clinvar' : 'snp';

    if(bStartEndRes) {
        var title1 = 'ClinVar', title2 = 'SNP';

        if(bClinvar) {
            html += '<div class="icn3d-seqTitle icn3d-link icn3d-blue icn3d-clinvar-path" clinvar="clinvar" posarray="' + posClinArray + '" shorttitle="' + title1 + '" setname="' + chnid + '_' + title1 + '" anno="sequence" chain="' + chnid + '" title="' + title1 + '">' + title1 + '</div>';
        }
        else {
            html += '<div class="icn3d-seqTitle icn3d-link icn3d-blue" clinvar="clinvar" posarray="' + posarray + '" shorttitle="' + title2 + '" setname="' + chnid + '_' + title2 + '" anno="sequence" chain="' + chnid + '" title="' + title2 + '">' + title2 + '</div>';
        }
    }
    else if(line == 2 && bClinvar) {
        var buttonStyle = me.isMobile() ? 'none' : 'button';
        html += '<div id="' + me.pre + chnid + '_prevclin" style="display:inline-block; font-size:11px; font-weight:bold; width:60px!important;"><button class="link" style="-webkit-appearance:' + buttonStyle + '; height:18px; width:55px;"><span style="white-space:nowrap; margin-left:-40px;" title="Show the previous ClinVar on structure">&lt; ClinVar</span></button></div>';
        html += '<div id="' + me.pre + chnid + '_nextclin" style="display:inline-block; font-size:11px; font-weight:bold; width:60px!important;"><button class="link" style="-webkit-appearance:' + buttonStyle + '; height:18px; width:55px;"><span style="white-space:nowrap; margin-left:-40px;" title="Show the next ClinVar on structure">ClinVar &gt;</span></button></div>';
    }
    else {
        html += '<div class="icn3d-seqTitle"></div>';
    }

    var pre = altName;

    var snpCnt = 0, clinvarCnt = 0;

    var snpTypeHash = {}, currSnpTypeHash = {};

    for(var i = 1, il = me.giSeq[chnid].length; i <= il; ++i) {
        if(resi2index[i] !== undefined) {
            ++snpCnt;

            var snpType = '', allDiseaseTitle = '';
            for(var j = 0, jl = resi2snp[i].length; j < jl && !bSnpOnly; ++j) {
                var diseaseArray = resi2disease[i][j].split('; ');
                var sigArray = resi2sig[i][j].split('; ');

                var diseaseTitle = '';
                for(var k = 0, kl = diseaseArray.length; k < kl; ++k) {
                    if(diseaseArray[k] != '' && diseaseArray[k] != 'not specified' && diseaseArray[k] != 'not provided') {
                        diseaseTitle += diseaseArray[k] + ' (' + sigArray[k] + '); ';
                    }
                }

                if(diseaseTitle != '') {
                    snpTypeHash[i] = 'icn3d-clinvar';

                    if(j == line - 2) { // just check the current line, "line = 2" means the first SNP
                        currSnpTypeHash[i] = 'icn3d-clinvar';

                        if(diseaseTitle.indexOf('Pathogenic') != -1) {
                            currSnpTypeHash[i] = 'icn3d-clinvar-path';
                        }
                    }
                }

                allDiseaseTitle += diseaseTitle + ' | ';
            }

            if(allDiseaseTitle.indexOf('Pathogenic') != -1) {
                snpTypeHash[i] = 'icn3d-clinvar-path';
            }

            if(snpTypeHash[i] == 'icn3d-clinvar' || snpTypeHash[i] == 'icn3d-clinvar-path') {
                ++clinvarCnt;
            }
        }
    }

    if(snpCnt == 0) {
        $("#" + me.pre + 'dt_clinvar_' + chnid).html('');
        $("#" + me.pre + 'ov_clinvar_' + chnid).html('');
        $("#" + me.pre + 'tt_clinvar_' + chnid).html('');

        $("#" + me.pre + 'dt_snp_' + chnid).html('');
        $("#" + me.pre + 'ov_snp_' + chnid).html('');
        $("#" + me.pre + 'tt_snp_' + chnid).html('');

        return '';
    }

    if(clinvarCnt == 0 && bClinvar) {
        $("#" + me.pre + 'dt_clinvar_' + chnid).html('');
        $("#" + me.pre + 'ov_clinvar_' + chnid).html('');
        $("#" + me.pre + 'tt_clinvar_' + chnid).html('');

        return '';
    }

    var cnt = bClinvar ? clinvarCnt : snpCnt;

    if(clinvarCnt == 0) {
        me.bClinvarCnt = false;
    }
    else {
        me.bClinvarCnt = true;
    }

    //var start = bStartEndRes ? me.baseResi[chnid] + 1 : '';
    if(line == 1) {
        html += '<span class="icn3d-residueNum" title="residue count">' + cnt + ' Res</span>';
    }
    else {
        html += '<span class="icn3d-residueNum"></span>';
    }

    if(bTitleOnly !== undefined && bTitleOnly) {
        return html + '<br>';
    }

    html += '<span class="icn3d-seqLine">';
    var diseaseStr = '';

    var prevEmptyWidth = 0;
    var prevLineWidth = 0;
    var widthPerRes = 1;


    for(var i = 1, il = me.giSeq[chnid].length; i <= il; ++i) {
        if(bOverview) {
            if(resi2index[i] !== undefined) {
                // get the mouse over text
                var cFull = me.giSeq[chnid][i-1];

                var c = cFull;
                if(cFull.length > 1) {
                    c = cFull[0] + '..';
                }

                var pos = (i >= me.matchedPos[chnid] && i-1 - me.matchedPos[chnid] < me.icn3d.chainsSeq[chnid].length) ? me.icn3d.chainsSeq[chnid][i-1 - me.matchedPos[chnid]].resi : me.baseResi[chnid] + 1 + i-1;

                var snpTitle = pos + c + '>';
                var allDiseaseTitle = '';
                for(var j = 0, jl = resi2snp[i].length; j < jl; ++j) {
                    snpTitle += resi2snp[i][j];

                    if(!bSnpOnly) {
                        var diseaseArray = resi2disease[i][j].split('; ');
                        var sigArray = resi2sig[i][j].split('; ');

                        var diseaseTitle = '';
                        for(var k = 0, kl = diseaseArray.length; k < kl; ++k) {
                            if(diseaseArray[k] != '' && diseaseArray[k] != 'not specified' && diseaseArray[k] != 'not provided') {
                                diseaseTitle += diseaseArray[k] + ' (' + sigArray[k] + '); ';
                            }
                        }

                        allDiseaseTitle += diseaseTitle + ' | ';
                    }
                }

                html += me.insertGapOverview(chnid, i-1);

                var emptyWidth = (me.cfg.blast_rep_id == chnid) ? Math.round(me.seqAnnWidth * (i-1) / (me.maxAnnoLength + me.nTotalGap) - prevEmptyWidth - prevLineWidth) : Math.round(me.seqAnnWidth * (i-1) / me.maxAnnoLength - prevEmptyWidth - prevLineWidth);

                if(emptyWidth < 0) emptyWidth = 0;

                if(bClinvar) {
                    if(snpTypeHash[i] == 'icn3d-clinvar' || snpTypeHash[i] == 'icn3d-clinvar-path') {
                        if(emptyWidth > 0) html += '<div style="display:inline-block; width:' + emptyWidth + 'px;">&nbsp;</div>';

                        html += '<div style="display:inline-block; background-color:#000; width:' + widthPerRes + 'px;" title="' + snpTitle + '">&nbsp;</div>';

                        prevEmptyWidth += emptyWidth;
                        prevLineWidth += widthPerRes;
                    }
                }
                else {
                    if(emptyWidth > 0) html += '<div style="display:inline-block; width:' + emptyWidth + 'px;">&nbsp;</div>';

                    html += '<div style="display:inline-block; background-color:#000; width:' + widthPerRes + 'px;" title="' + snpTitle + '">&nbsp;</div>';

                    prevEmptyWidth += emptyWidth;
                    prevLineWidth += widthPerRes;
                }
            }
        }
        else { // detailed view
          html += me.insertGap(chnid, i-1, '-');

          if(resi2index[i] !== undefined) {
              if(!bClinvar && line == 1) {
                  html += '<span>&dArr;</span>'; // or down triangle &#9660;
              }
              else {
                var cFull = me.giSeq[chnid][i-1];

                var c = cFull;
                if(cFull.length > 1) {
                  c = cFull[0] + '..';
                }

                var pos = (i >= me.matchedPos[chnid] && i-1 - me.matchedPos[chnid] < me.icn3d.chainsSeq[chnid].length) ? me.icn3d.chainsSeq[chnid][i-1 - me.matchedPos[chnid]].resi : me.baseResi[chnid] + 1 + i-1;

                var snpStr = "", snpTitle = "<div class='snptip'>"

                //var snpType = '';

                var jl = resi2snp[i].length;

                var start = 0, end = 0;

                var shownResCnt;

                if(line == 2) {
                    start = 0;
                    end = 1;
                }
                else if(line == 3) {
                    start = 1;
                    end = jl;
                }

                if(!bClinvar) {
                    shownResCnt = 2;

                    for(var j = start; j < jl && j < end; ++j) {
                        if(j < shownResCnt) snpStr += resi2snp[i][j];

                        snpTitle += pos + c + '>' + resi2snp[i][j];

                        if(!bSnpOnly) {
                            // disease and significace
                            var diseaseArray = resi2disease[i][j].split('; ');
                            var sigArray = resi2sig[i][j].split('; ');

                            var diseaseTitle = '';
                            var index = 0;
                            for(var k = 0, kl = diseaseArray.length; k < kl; ++k) {
                                if(diseaseArray[k] != '' && diseaseArray[k] != 'not specified' && diseaseArray[k] != 'not provided') {
                                    if(index > 0) {
                                        diseaseTitle += '; ';
                                    }
                                    else {
                                        if( j === 0 || j === 1) diseaseStr = 'disease="' + diseaseArray[k] + '"';
                                    }

                                    diseaseTitle += diseaseArray[k] + ' (' + sigArray[k] + ')';
                                    ++index;
                                }
                            }

                            //resi2rsnum, resi2clinAllele,

                            if(diseaseTitle != '') {
                                //snpType = 'icn3d-clinvar';

                                snpTitle += ': ' + diseaseTitle;
                                snpTitle += "<br>Links: <a href='https://www.ncbi.nlm.nih.gov/clinvar/?term=" + resi2clinAllele[i][j] + "[AlleleID]' target='_blank'>ClinVar</a>, <a href='https://www.ncbi.nlm.nih.gov/snp/?term=" + resi2rsnum[i][j] + "' target='_blank'>dbSNP (rs" + resi2rsnum[i][j] + ")</a>";
                            }
                            else {
                                snpTitle += "<br>Link: <a href='https://www.ncbi.nlm.nih.gov/snp/?term=" + resi2rsnum[i][j] + "' target='_blank'>dbSNP (rs" + resi2rsnum[i][j] + ")</a>"
                            }

                            if(j < jl - 1) {
                                //if(j < 1) snpStr += ';';
                                snpTitle += '<br><br>';
                            }
                        }
                        else { //if(bSnpOnly) {
                            if(j < jl - 1) {
                                snpTitle += '<br>';
                            }
                        }
                    }

                    if(jl > shownResCnt && line == 3) snpStr += '..';
                }
                else { // if(bClinvar)
                    shownResCnt = 1;

                    var diseaseCnt = 0;
                    for(var j = start; j < jl && j < end; ++j) {
                        // disease and significace
                        var diseaseArray = resi2disease[i][j].split('; ');
                        var sigArray = resi2sig[i][j].split('; ');

                        var diseaseTitle = '';
                        var index = 0;
                        for(var k = 0, kl = diseaseArray.length; k < kl; ++k) {
                            if(diseaseArray[k] != '' && diseaseArray[k] != 'not specified' && diseaseArray[k] != 'not provided') {
                                if(index > 0) {
                                    diseaseTitle += '; ';
                                }
                                else {
                                    if( j === 0 || j === 1) diseaseStr = 'disease="' + diseaseArray[k] + '"';
                                }

                                diseaseTitle += diseaseArray[k] + ' (' + sigArray[k] + ')';
                                ++index;
                            }
                        }

                        if(diseaseTitle != '') {
                            if(diseaseCnt < shownResCnt) snpStr += resi2snp[i][j];

                            snpTitle += pos + c + '>' + resi2snp[i][j];

                            //snpType = 'icn3d-clinvar';

                            snpTitle += ': ' + diseaseTitle;
                            snpTitle += "<br>Links: <a href='https://www.ncbi.nlm.nih.gov/clinvar/?term=" + resi2clinAllele[i][j] + "[AlleleID]' target='_blank'>ClinVar</a>, <a href='https://www.ncbi.nlm.nih.gov/snp/?term=" + resi2rsnum[i][j] + "' target='_blank'>dbSNP (rs" + resi2rsnum[i][j] + ")</a>";

                            if(j < jl - 1) {
                                snpTitle += '<br><br>';
                            }

                            ++diseaseCnt;
                        } // if(diseaseTitle != '') {
                    } // for(var j = start; j < jl && j < end; ++j) {

                    if(diseaseCnt > shownResCnt && line == 3) snpStr += '..';
                } // else { // if(bClinvar)

                snpTitle += '</div>';

                if(bClinvar) {
                    if(snpTypeHash[i] == 'icn3d-clinvar' || snpTypeHash[i] == 'icn3d-clinvar-path') {
                        if(line == 1) {
                            html += '<span>&dArr;</span>'; // or down triangle &#9660;
                        }
                        else {
                            if(snpStr == '' || snpStr == ' ') {
                                html += '<span>-</span>';
                            }
                            else {
                                html += '<span id="' + pre + '_' + me.pre + chnid + '_' + pos + '" label title="' + snpTitle + '" ' + diseaseStr + ' class="icn3d-tooltip icn3d-residue ' + currSnpTypeHash[i] + '">' + snpStr + '</span>';
                            }
                        }
                    }
                    else {
                        html += '<span>-</span>';
                    }
                }
                else {
                    if(snpStr == '' || snpStr == ' ') {
                        html += '<span>-</span>';
                    }
                    else {
                        if(!bSnpOnly) {
                            html += '<span id="' + pre + '_' + me.pre + chnid + '_' + pos + '" label title="' + snpTitle + '" ' + diseaseStr + ' class="icn3d-tooltip icn3d-residue ' + currSnpTypeHash[i] + '">' + snpStr + '</span>';
                        }
                        else {
                            html += '<span id="' + pre + '_' + me.pre + chnid + '_' + pos + '" label title="' + snpTitle + '" class="icn3d-residue ' + currSnpTypeHash[i] + '">' + snpStr + '</span>';
                        }
                    }
                }
              } // if(!bClinvar && line == 1) {
          }
          else {
            html += '<span>-</span>'; //'<span>-</span>';
          }
        } // if(bOverview) {
    } // for

    //var end = bStartEndRes ? me.icn3d.chainsSeq[chnid][me.giSeq[chnid].length - 1 - me.matchedPos[chnid] ].resi : '';
    if(line == 1) {
        html += '<span class="icn3d-residueNum" title="residue count">&nbsp;' + cnt + ' Residues</span>';
    }
    else {
        html += '<span class="icn3d-residueNum"></span>';
    }

    html += '</span>';
    html += '<br>';

    return html;
};

iCn3DUI.prototype.processSnpClinvar = function(data, chnid, chnidBase, bSnpOnly) {
    var me = this;

    var html = '<div id="' + me.pre + chnid + '_snpseq_sequence" class="icn3d-dl_sequence">';
    var html2 = html;
    var html3 = html;

    var htmlClinvar = '<div id="' + me.pre + chnid + '_clinvarseq_sequence" class="icn3d-dl_sequence">';
    var htmlClinvar2 = htmlClinvar;
    var htmlClinvar3 = htmlClinvar;

    var lineArray = data.split('\n');

    var resi2snp = {};
    var resi2index = {};
    var resi2disease = {};
    me.resi2disease_nonempty[chnid] = {};
    var resi2sig = {};

    var resi2rsnum = {};
    var resi2clinAllele = {};

    var posHash = {}, posClinHash = {};

    var prevSnpStr = '';
    for(var i = 0, il = lineArray.length; i < il; ++i) {
     //bSnpOnly: false
     //1310770    13    14    14Y>H    368771578    150500    Hereditary cancer-predisposing syndrome; Li-Fraumeni syndrome; not specified; Li-Fraumeni syndrome 1    Likely benign; Uncertain significance; Uncertain significance; Uncertain significance    1TSR_A    120407068    NP_000537.3
     //Pdb_gi, Pos from, Pos to, Pos & Amino acid change, rs#, ClinVar Allele ID, Disease name, Clinical significance, master_gi, master_accession.version

     //bSnpOnly: true
     //1310770    13    14    14Y>H

     if(lineArray[i] != '') {
      var fieldArray = lineArray[i].split('\t');

      var snpStr = fieldArray[3];

      if(snpStr == prevSnpStr) continue;
      prevSnpStr = snpStr;

      var resiStr = snpStr.substr(0, snpStr.length - 3);

      var resi = Math.round(resiStr);

      var currRes = snpStr.substr(snpStr.length - 3, 1);
      var snpRes = snpStr.substr(snpStr.length - 1, 1);

      var rsnum = bSnpOnly ? '' : fieldArray[4];
      var clinAllele = bSnpOnly ? '' : fieldArray[5];
      var disease = bSnpOnly ? '' : fieldArray[6];  // When more than 2+ diseases, they are separated by "; "
                                    // Some are "not specified", "not provided"
      var clinSig = bSnpOnly ? '' : fieldArray[7];     // Clinical significance, When more than 2+ diseases, they are separated by "; "

      // "*" means terminating codon, "-" means deleted codon
      //if(currRes !== '-' && currRes !== '*' && snpRes !== '-' && snpRes !== '*') {
            posHash[resi + me.baseResi[chnid]] = 1;
            if(disease != '') posClinHash[resi + me.baseResi[chnid]] = 1;
            resi2index[resi] = i + 1;

            if(resi2snp[resi] === undefined) {
                resi2snp[resi] = [];
            }
            resi2snp[resi].push(snpRes);

            if(resi2rsnum[resi] === undefined) {
                resi2rsnum[resi] = [];
            }
            resi2rsnum[resi].push(rsnum);

            if(resi2clinAllele[resi] === undefined) {
                resi2clinAllele[resi] = [];
            }
            resi2clinAllele[resi].push(clinAllele);

            if(resi2disease[resi] === undefined) {
                resi2disease[resi] = [];
            }
            resi2disease[resi].push(disease);

            if(disease != '') {
                if(me.resi2disease_nonempty[chnid][resi] === undefined) {
                    me.resi2disease_nonempty[chnid][resi] = [];
                }
                me.resi2disease_nonempty[chnid][resi].push(disease);
            }

            if(resi2sig[resi] === undefined) {
                resi2sig[resi] = [];
            }
            resi2sig[resi].push(clinSig);

      //}
     }
    }

    var posarray = Object.keys(posHash);
    var posClinArray = Object.keys(posClinHash);

    var bClinvar = false;

    html += me.getSnpLine(1, 3, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 1, chnid, false, bClinvar, undefined, bSnpOnly);
    html += me.getSnpLine(2, 3, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 0, chnid, false, bClinvar, undefined, bSnpOnly);
    html += me.getSnpLine(3, 3, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 0, chnid, false, bClinvar, undefined, bSnpOnly);

    html3 += me.getSnpLine(1, 3, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 1, chnid, false, bClinvar, true, bSnpOnly);
    html3 += me.getSnpLine(2, 3, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 0, chnid, false, bClinvar, true, bSnpOnly);
    html3 += me.getSnpLine(3, 3, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 0, chnid, false, bClinvar, true, bSnpOnly);

    html2 += me.getSnpLine(1, 3, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 1, chnid, true, bClinvar, undefined, bSnpOnly);

    html += '</div>';
    html2 += '</div>';
    html3 += '</div>';

    $("#" + me.pre + 'dt_snp_' + chnid).html(html);
    $("#" + me.pre + 'ov_snp_' + chnid).html(html2);
    $("#" + me.pre + 'tt_snp_' + chnid).html(html3);

    if(!bSnpOnly && me.bClinvarCnt) {
        bClinvar = true;

        htmlClinvar += me.getSnpLine(1, 3, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 1, chnid, false, bClinvar, undefined, bSnpOnly);
        htmlClinvar += me.getSnpLine(2, 3, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 0, chnid, false, bClinvar, undefined, bSnpOnly);
        htmlClinvar += me.getSnpLine(3, 3, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 0, chnid, false, bClinvar, undefined, bSnpOnly);

        htmlClinvar3 += me.getSnpLine(1, 3, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 1, chnid, false, bClinvar, true, bSnpOnly);
        htmlClinvar3 += me.getSnpLine(2, 3, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 0, chnid, false, bClinvar, true, bSnpOnly);
        htmlClinvar3 += me.getSnpLine(3, 3, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 0, chnid, false, bClinvar, true, bSnpOnly);

        htmlClinvar2 += me.getSnpLine(1, 3, resi2snp, resi2rsnum, resi2clinAllele, resi2disease, resi2index, resi2sig, posarray, posClinArray, 1, chnid, true, bClinvar, undefined, bSnpOnly);

        htmlClinvar += '</div>';
        htmlClinvar2 += '</div>';
        htmlClinvar3 += '</div>';

        $("#" + me.pre + 'dt_clinvar_' + chnid).html(htmlClinvar);
        $("#" + me.pre + 'ov_clinvar_' + chnid).html(htmlClinvar2);
        $("#" + me.pre + 'tt_clinvar_' + chnid).html(htmlClinvar3);

        me.navClinVar(chnid, chnidBase);
    }
    else {
        $("#" + me.pre + 'dt_clinvar_' + chnid).html('');
        $("#" + me.pre + 'ov_clinvar_' + chnid).html('');
        $("#" + me.pre + 'tt_clinvar_' + chnid).html('');
    }

    // add here after the ajax call
    me.enableHlSeq();

    me.bAjaxSnpClinvar = true;
    if(me.deferredSnpClinvar !== undefined) me.deferredSnpClinvar.resolve();
};

iCn3DUI.prototype.showSnpClinvar = function(chnid, chnidBase) {
    var me = this;

    var url = "https://www.ncbi.nlm.nih.gov/projects/SNP/beVarSearch_mt.cgi?appname=iCn3D&format=bed&report=pdb2bed&acc=" + chnidBase;

    $.ajax({
      url: url,
      dataType: 'text',
      cache: true,
      tryCount : 0,
      retryLimit : 1,
      success: function(data) {
        if(data != "") {
            var bSnpOnly = false;
            me.processSnpClinvar(data, chnid, chnidBase, bSnpOnly);
        } //if(data != "") {
        else {
            if(me.chain2gi !== undefined && Object.keys(me.chain2gi).length > 0) {
               var gi = me.chain2gi[chnidBase];

               me.showSnpClinvarAlt(chnid, chnidBase, gi);
            }
            else {
               // get gi from acc
               var url2 = "https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esummary.fcgi?db=protein&retmode=json&id=" + chnidBase;

               $.ajax({
                  url: url2,
                  dataType: 'json',
                  cache: true,
                  tryCount : 0,
                  retryLimit : 1,
                  success: function(data2) {
                    var gi;
                    for(var id in data2.result) {
                      if(id !== 'uids') {
                        gi = id;
                      }
                    }

                    me.showSnpClinvarAlt(chnid, chnidBase, gi);

                  },
                  error : function(xhr, textStatus, errorThrown ) {
                    this.tryCount++;
                    if (this.tryCount <= this.retryLimit) {
                        //try again
                        $.ajax(this);
                        return;
                    }

                    me.processNoSnpClinvar(chnid);
                    return;
                  }
               });
           }
        }
      },
      error : function(xhr, textStatus, errorThrown ) {
        this.tryCount++;
        if (this.tryCount <= this.retryLimit) {
            //try again
            $.ajax(this);
            return;
        }

        me.processNoSnpClinvar(chnid);

        return;
      }
    });
};

iCn3DUI.prototype.showSnpClinvarAlt = function(chnid, chnidBase, gi) { var me = this;
    if(gi !== undefined) {
        var url3 = "https://www.ncbi.nlm.nih.gov/projects/SNP/beVarSearch.cgi?appname=iCn3D&format=bed&report=pdb2bed&gi=" + gi;

        $.ajax({
          url: url3,
          dataType: 'text',
          cache: true,
          tryCount : 0,
          retryLimit : 1,
          success: function(data3) {
            if(data3 != "") {
                var bSnpOnly = true;
                me.processSnpClinvar(data3, chnid, chnidBase, bSnpOnly);
            } //if(data3 != "") {
            else {
                me.processNoSnpClinvar(chnid);
            }
          },
          error : function(xhr, textStatus, errorThrown ) {
            this.tryCount++;
            if (this.tryCount <= this.retryLimit) {
                //try again
                $.ajax(this);
                return;
            }

            me.processNoSnpClinvar(chnid);
            return;
          }
        });
    }
    else {
        console.log( "No gi was found for the chain " + chnidBase + "..." );
    }
};

iCn3DUI.prototype.processNoSnpClinvar = function(chnid) { var me = this;
        console.log( "No SNP data were found for the protein " + chnid + "..." );

        $("#" + me.pre + 'dt_clinvar_' + chnid).html('');
        $("#" + me.pre + 'ov_clinvar_' + chnid).html('');

        $("#" + me.pre + 'dt_snp_' + chnid).html('');
        $("#" + me.pre + 'ov_snp_' + chnid).html('');

        me.enableHlSeq();

        me.bAjaxSnpClinvar = true;

        if(me.deferredSnpClinvar !== undefined) me.deferredSnpClinvar.resolve();
};

iCn3DUI.prototype.showCddSiteAll = function() { var me = this;
    var chnidBaseArray = $.map(me.protein_chainid, function(v) { return v; });
    var chnidArray = Object.keys(me.protein_chainid);

    // show conserved domains and binding sites
    var url = "https://www.ncbi.nlm.nih.gov/Structure/cdannots/cdannots.fcgi?fmt&queries=" + chnidBaseArray;
    $.ajax({
      url: url,
      dataType: 'jsonp',
      cache: true,
      tryCount : 0,
      retryLimit : 1,
      success: function(data) {
          var chainWithData = {};

          for(var chainI = 0, chainLen = data.data.length; chainI < chainLen; ++chainI) {
            var cddData = data.data[chainI];
            var chnidBase = cddData._id;
            //var pos = chnidBaseArray.indexOf(chnidBase);
            //var chnid = chnidArray[pos];
            var chnid = chnidArray[chainI];

            chainWithData[chnid] = 1;

            var html = '<div id="' + me.pre + chnid + '_cddseq_sequence" class="icn3d-cdd icn3d-dl_sequence">';
            var html2 = html;
            var html3 = html;

            var domainArray = cddData.doms;

            var indexl = (domainArray !== undefined) ? domainArray.length : 0;

            for(var index = 0; index < indexl; ++index) {
                var acc = domainArray[index].acc;

                var type = domainArray[index].type;
                type = 'domain';

                var domain = domainArray[index].title.split(':')[0];
                var defline = domainArray[index].defline;
                var title = type + ': ' + domain;
                if(title.length > 14) title = title.substr(0, 14) + '...';

                //var fulltitle = type + ": " + domainArray[index].title + " (accession: " + acc + ")";
                //var fulltitle = type + ": " + domainArray[index].title;
                var fulltitle = type + ": " + domain;

                // each domain may have several repeat. Treat each repeat as a domain
                var domainRepeatArray = domainArray[index].locs;

                for(var r = 0, rl = domainRepeatArray.length; r < rl; ++r) {
                    // each domain repeat or domain may have several segments, i.e., a domain may not be continous
                    var fromArray = [], toArray = [];

                    //var domainFrom = Math.round(domainArray[index].locs[r].segs[0].from);
                    //var domainTo = Math.round(domainArray[index].locs[r].segs[0].to);
                    //var range = domainTo - domainFrom + 1;

                    var resiHash = {};
                    var resCnt = 0;

                    for(var s = 0, sl = domainRepeatArray[r].segs.length; s < sl; ++s) {
                        var domainFrom = Math.round(domainRepeatArray[r].segs[s].from);
                        var domainTo = Math.round(domainRepeatArray[r].segs[s].to);

                        fromArray.push(domainFrom + me.baseResi[chnid]);
                        toArray.push(domainTo + me.baseResi[chnid]);

                        for(var i = domainFrom; i <= domainTo; ++i) {
                            resiHash[i] = 1;
                        }

                        resCnt += domainTo - domainFrom + 1;
                    }

                    //html += '<div class="icn3d-seqTitle icn3d-link icn3d-blue" domain="' + acc + '" from="' + fromArray + '" to="' + toArray + '" shorttitle="' + title + '" setname="' + chnid + '_' + type + '_' + index + '_' + r + '" anno="sequence" chain="' + chnid + '" title="' + fulltitle + '">' + title + ' </div>';

                    //var htmlTmp = '<span class="icn3d-residueNum" title="residue count">' + resCnt.toString() + ' Res</span>';

                    //htmlTmp += '<span class="icn3d-seqLine">';
                    //html += htmlTmp;

                    var htmlTmp2 = '<div class="icn3d-seqTitle icn3d-link icn3d-blue" domain="' + acc + '" from="' + fromArray + '" to="' + toArray + '" shorttitle="' + title + '" setname="' + chnid + '_' + type + '_' + index + '_' + r + '" anno="sequence" chain="' + chnid + '" title="' + fulltitle + '">' + title + ' </div>';

                    var htmlTmp3 = '<span class="icn3d-residueNum" title="residue count">' + resCnt.toString() + ' Res</span>';

                    html3 += htmlTmp2 + htmlTmp3 + '<br>';

                    var htmlTmp = '<span class="icn3d-seqLine">';

                    html += htmlTmp2 + htmlTmp3 + htmlTmp;

                    html2 += '<div style="width:20px; display:inline-block;"><span id="' + me.pre + chnid + '_' + acc + '_' + r + '_cddseq_expand" class="ui-icon ui-icon-plus icn3d-expand icn3d-link" style="width:15px;" title="Expand"></span><span id="' + me.pre + chnid + '_' + acc + '_' + r + '_cddseq_shrink" class="ui-icon ui-icon-minus icn3d-shrink icn3d-link" style="display:none; width:15px;" title="Shrink"></span></div>';
                    html2 += '<div style="width:100px!important;" class="icn3d-seqTitle icn3d-link icn3d-blue" domain="' + acc + '" from="' + fromArray + '" to="' + toArray + '" shorttitle="' + title + '" index="' + index + '" setname="' + chnid + '_' + type + '_' + index + '_' + r + '" anno="sequence" chain="' + chnid + '" title="' + fulltitle + '">' + title + ' </div>';
                    html2 += htmlTmp3 + htmlTmp;

                    var pre = type + index.toString();
                    for(var i = 0, il = me.giSeq[chnid].length; i < il; ++i) {
                      html += me.insertGap(chnid, i, '-');

                      if(resiHash.hasOwnProperty(i)) {
                        var cFull = me.giSeq[chnid][i];

                          var c = cFull;
                          if(cFull.length > 1) {
                              c = cFull[0] + '..';
                          }

        //                var pos = (me.baseResi[chnid] + i+1).toString();
        //                var pos = me.icn3d.chainsSeq[chnid][i - me.matchedPos[chnid] ].resi
                          var pos = (i >= me.matchedPos[chnid] && i - me.matchedPos[chnid] < me.icn3d.chainsSeq[chnid].length) ? me.icn3d.chainsSeq[chnid][i - me.matchedPos[chnid]].resi : me.baseResi[chnid] + 1 + i;

                        html += '<span id="' + pre + '_' + me.pre + chnid + '_' + pos + '" title="' + c + pos + '" class="icn3d-residue">' + cFull + '</span>';
                      }
                      else {
                        html += '<span>-</span>'; //'<span>-</span>';
                      }
                    }


                    var atom = me.icn3d.getFirstCalphaAtomObj(me.icn3d.chains[chnid]);
                    var color = (atom.color) ? atom.color.getHexString() : me.icn3d.defaultAtomColor;

                    //html2 += '<div style="display:inline-block; width:' + Math.round(me.seqAnnWidth * domainFrom / me.maxAnnoLength) + 'px;"></div>';
                    //html2 += '<div style="display:inline-block; color:white!important; font-weight:bold; background-color:#' + color + '; width:' + Math.round(me.seqAnnWidth * (domainTo - domainFrom + 1) / me.maxAnnoLength) + 'px;" class="icn3d-seqTitle icn3d-link icn3d-blue" domain="' + acc + '" from="' + domainFrom.toString() + '" to="' + domainTo.toString() + '" shorttitle="' + title + '" setname="' + chnid + '_' + type + '_' + index + '" anno="sequence" chain="' + chnid + '" title="' + fulltitle + '">' + domain + ' </div>';

                    if(me.cfg.blast_rep_id != chnid) { // regular
                        for(var i = 0, il = fromArray.length; i < il; ++i) {
                            var emptyWidth = (i == 0) ? Math.round(me.seqAnnWidth * fromArray[i] / me.maxAnnoLength) : Math.round(me.seqAnnWidth * (fromArray[i] - toArray[i-1] - 1) / me.maxAnnoLength);
                            html2 += '<div style="display:inline-block; width:' + emptyWidth + 'px;">&nbsp;</div>';

                            html2 += '<div style="display:inline-block; color:white!important; font-weight:bold; background-color:#' + color + '; width:' + Math.round(me.seqAnnWidth * (toArray[i] - fromArray[i] + 1) / me.maxAnnoLength) + 'px;" class="icn3d-seqTitle icn3d-link icn3d-blue" domain="' + (index+1).toString() + '" from="' + fromArray + '" to="' + toArray + '" shorttitle="' + title + '" index="' + index + '" setname="' + chnid + '_domain_' + index + '_' + r + '" id="' + chnid + '_domain_' + index + '_' + r + '" anno="sequence" chain="' + chnid + '" title="' + fulltitle + '">' + domain + ' </div>';
                        }
                    }
                    else { // with potential gaps
                        var fromArray2 = [], toArray2 = [];
                        for(var i = 0, il = fromArray.length; i < il; ++i) {
                            fromArray2.push(fromArray[i]);

                            for(var j = fromArray[i]; j <= toArray[i]; ++j) {
                                if(me.targetGapHash !== undefined && me.targetGapHash.hasOwnProperty(j)) {
                                    toArray2.push(j - 1);
                                    fromArray2.push(j);
                                }
                            }

                            toArray2.push(toArray[i]);
                        }

                        for(var i = 0, il = fromArray2.length; i < il; ++i) {
                            html2 += me.insertGapOverview(chnid, fromArray2[i]);

                            var emptyWidth = (i == 0) ? Math.round(me.seqAnnWidth * fromArray2[i] / (me.maxAnnoLength + me.nTotalGap)) : Math.round(me.seqAnnWidth * (fromArray2[i] - toArray2[i-1] - 1) / (me.maxAnnoLength + me.nTotalGap));
                            html2 += '<div style="display:inline-block; width:' + emptyWidth + 'px;">&nbsp;</div>';

                            html2 += '<div style="display:inline-block; color:white!important; font-weight:bold; background-color:#' + color + '; width:' + Math.round(me.seqAnnWidth * (toArray2[i] - fromArray2[i] + 1) / (me.maxAnnoLength + me.nTotalGap)) + 'px;" class="icn3d-seqTitle icn3d-link icn3d-blue" domain="' + (index+1).toString() + '" from="' + fromArray2 + '" to="' + toArray2 + '" shorttitle="' + title + '" index="' + index + '" setname="' + chnid + '_domain_' + index + '_' + r + '" id="' + chnid + '_domain_' + index + '_' + r + '" anno="sequence" chain="' + chnid + '" title="' + fulltitle + '">' + domain + ' </div>';
                        }
                    }

                    htmlTmp = '<span class="icn3d-residueNum" title="residue count">&nbsp;' + resCnt.toString() + ' Residues</span>';

                    htmlTmp += '</span>';
                    htmlTmp += '<br>';

                    html += htmlTmp;
                    html2 += htmlTmp;

                    html2 += '<div id="' + me.pre + chnid + '_' + acc + '_' + r + '_cddseq" style="display:none; white-space:normal;" class="icn3d-box">' + defline + ' (<a href="https://www.ncbi.nlm.nih.gov/Structure/cdd/cddsrv.cgi?uid=' + acc + '" target="_blank" class="icn3d-blue">open details view...</a>)</div>';
                } // for(var r = 0,
            }

            html += '</div>';
            html2 += '</div>';
            html3 += '</div>';

            $("#" + me.pre + "dt_cdd_" + chnid).html(html);
            $("#" + me.pre + "ov_cdd_" + chnid).html(html2);
            $("#" + me.pre + "tt_cdd_" + chnid).html(html3);

            html = '<div id="' + me.pre + chnid + '_siteseq_sequence" class="icn3d-dl_sequence">';
            html2 = html;
            html3 = html;

            var siteArray = data.data[chainI].sites;
            var indexl = (siteArray !== undefined) ? siteArray.length : 0;

            for(var index = 0; index < indexl; ++index) {
                var domain = siteArray[index].srcdom;
                var type = siteArray[index].type;
                var resCnt = siteArray[index].sz;

                var title = 'site: ' + siteArray[index].title;
                if(title.length > 17) title = title.substr(0, 17) + '...';

                //var fulltitle = "site: " + siteArray[index].title + " (domain: " + domain + ")";
                var fulltitle = siteArray[index].title;

                var resPosArray = siteArray[index].locs[0].coords;
                var adjustedResPosArray = [];
                for(var i = 0, il = resPosArray.length; i < il; ++i) {
                    adjustedResPosArray.push(Math.round(resPosArray[i]) + me.baseResi[chnid]);
                }

                var htmlTmp2 = '<div class="icn3d-seqTitle icn3d-link icn3d-blue" site="site" posarray="' + adjustedResPosArray.toString() + '" shorttitle="' + title + '" setname="' + chnid + '_site_' + index + '" anno="sequence" chain="' + chnid + '" title="' + fulltitle + '">' + title + ' </div>';
                var htmlTmp3 = '<span class="icn3d-residueNum" title="residue count">' + resCnt.toString() + ' Res</span>';
                var htmlTmp = '<span class="icn3d-seqLine">';

                html3 += htmlTmp2 + htmlTmp3 + '<br>';

                html += htmlTmp2 + htmlTmp3 + htmlTmp;
                html2 += htmlTmp2 + htmlTmp3 + htmlTmp;

                var pre = 'site' + index.toString();
                var widthPerRes = me.seqAnnWidth / me.maxAnnoLength;

                var prevEmptyWidth = 0;
                var prevLineWidth = 0;
                var widthPerRes = 1;
                for(var i = 0, il = me.giSeq[chnid].length; i < il; ++i) {
                  html += me.insertGap(chnid, i, '-');

                  if(resPosArray.indexOf(i) != -1) {
                    var cFull = me.giSeq[chnid][i];

                      var c = cFull;
                      if(cFull.length > 1) {
                          c = cFull[0] + '..';
                      }

    //                var pos = (me.baseResi[chnid] + i+1).toString();
    //                var pos = me.icn3d.chainsSeq[chnid][i - me.matchedPos[chnid] ].resi;
                      var pos = (i >= me.matchedPos[chnid] && i - me.matchedPos[chnid] < me.icn3d.chainsSeq[chnid].length) ? me.icn3d.chainsSeq[chnid][i - me.matchedPos[chnid]].resi : me.baseResi[chnid] + 1 + i;

                    html += '<span id="' + pre + '_' + me.pre + chnid + '_' + pos + '" title="' + c + pos + '" class="icn3d-residue">' + cFull + '</span>';

                    html2 += me.insertGapOverview(chnid, i);

                    var emptyWidth = (me.cfg.blast_rep_id == chnid) ? Math.round(me.seqAnnWidth * i / (me.maxAnnoLength + me.nTotalGap) - prevEmptyWidth - prevLineWidth) : Math.round(me.seqAnnWidth * i / me.maxAnnoLength - prevEmptyWidth - prevLineWidth);

                    if(emptyWidth < 0) emptyWidth = 0;

                    html2 += '<div style="display:inline-block; width:' + emptyWidth + 'px;">&nbsp;</div>';
                    html2 += '<div style="display:inline-block; background-color:#000; width:' + widthPerRes + 'px;" title="' + c + pos + '">&nbsp;</div>';

                    prevEmptyWidth += emptyWidth;
                    prevLineWidth += widthPerRes;
                  }
                  else {
                    html += '<span>-</span>'; //'<span>-</span>';
                  }
                }

                htmlTmp = '<span class="icn3d-residueNum" title="residue count">&nbsp;' + resCnt.toString() + ' Residues</span>';
                htmlTmp += '</span>';
                htmlTmp += '<br>';

                html += htmlTmp;
                html2 += htmlTmp;
            }

            html += '</div>';
            html2 += '</div>';
            html3 += '</div>';

            $("#" + me.pre + "dt_site_" + chnid).html(html);
            $("#" + me.pre + "ov_site_" + chnid).html(html2);
            $("#" + me.pre + "tt_site_" + chnid).html(html3);
        } // outer for loop

        // missing CDD data
        for(var chnid in me.protein_chainid) {
            if(!chainWithData.hasOwnProperty(chnid)) {
                $("#" + me.pre + "dt_cdd_" + chnid).html('');
                $("#" + me.pre + "ov_cdd_" + chnid).html('');
                $("#" + me.pre + "tt_cdd_" + chnid).html('');

                $("#" + me.pre + "dt_site_" + chnid).html('');
                $("#" + me.pre + "ov_site_" + chnid).html('');
                $("#" + me.pre + "tt_site_" + chnid).html('');
            }
        }

        // add here after the ajax call
        me.enableHlSeq();

        me.bAjaxCddSite = true;

        if(me.deferredAnnoCddSite !== undefined) me.deferredAnnoCddSite.resolve();
      },
      error : function(xhr, textStatus, errorThrown ) {
        this.tryCount++;
        if (this.tryCount <= this.retryLimit) {
            //try again
            $.ajax(this);
            return;
        }

        console.log( "No CDD data were found for the protein " + chnidBaseArray + "..." );

        for(var chnid in me.protein_chainid) {
            $("#" + me.pre + "dt_cdd_" + chnid).html('');
            $("#" + me.pre + "ov_cdd_" + chnid).html('');
            $("#" + me.pre + "tt_cdd_" + chnid).html('');

            $("#" + me.pre + "dt_site_" + chnid).html('');
            $("#" + me.pre + "ov_site_" + chnid).html('');
            $("#" + me.pre + "tt_site_" + chnid).html('');
        }

        // add here after the ajax call
        me.enableHlSeq();

        me.bAjaxCddSite = true;

        if(me.deferredAnnoCddSite !== undefined) me.deferredAnnoCddSite.resolve();
        return;
      }
    });
};

iCn3DUI.prototype.showDomainPerStructure = function(index) { var me = this;
    //var chnid = Object.keys(me.protein_chainid)[0];
    //var pdbid = chnid.substr(0, chnid.indexOf('_'));
    var pdbArray = Object.keys(me.icn3d.structures);

    // show 3D domains
    var pdbid = pdbArray[index];
    var url = "https://www.ncbi.nlm.nih.gov/Structure/mmdb/mmdb_strview.cgi?v=2&program=icn3d&domain&molinfor&uid=" + pdbid;

    if(index == 0 && me.mmdb_data !== undefined) {
        for(var chnid in me.protein_chainid) {
            if(chnid.indexOf(pdbid) !== -1) {
                me.showDomainWithData(chnid, me.mmdb_data);
            }
        }
    }
    else if(me.mmdb_dataArray[index] !== undefined) {
        for(var chnid in me.protein_chainid) {
            if(chnid.indexOf(pdbid) !== -1) {
                me.showDomainWithData(chnid, me.mmdb_dataArray[index]);
            }
        }
    }
    else {
        $.ajax({
          url: url,
          dataType: 'json',
          cache: true,
          tryCount : 0,
          retryLimit : 1,
          success: function(data) {
            me.mmdb_dataArray[index] = data;

            for(var chnid in me.protein_chainid) {
                if(chnid.indexOf(pdbid) !== -1) {
                    me.showDomainWithData(chnid, me.mmdb_dataArray[index]);
                }
            }

            // add here after the ajax call
            me.enableHlSeq();

            me.bAjax3ddomain = true;
            me.bAjaxDoneArray[index] = true;

            if(me.deferred3ddomain !== undefined) {
                if(me.cfg.align === undefined) {
                    me.deferred3ddomain.resolve();
                }
                else {
                    var bAjaxDoneAll = true;
                    for(var i = 0, il = pdbArray.length; i < il; ++i) {
                        bAjaxDoneAll = bAjaxDoneAll && me.bAjaxDoneArray[i];
                    }

                    if(bAjaxDoneAll) me.deferred3ddomain.resolve();
                }
            }
          },
          error : function(xhr, textStatus, errorThrown ) {
            this.tryCount++;
            if (this.tryCount <= this.retryLimit) {
                //try again
                $.ajax(this);
                return;
            }

            console.log( "No 3D domain data were found for the protein " + pdbid + "..." );

            for(var chnid in me.protein_chainid) {
                if(chnid.indexOf(pdbid) !== -1) {
                    $("#" + me.pre + "dt_domain_" + chnid).html('');
                    $("#" + me.pre + "ov_domain_" + chnid).html('');
                    $("#" + me.pre + "tt_domain_" + chnid).html('');
                }
            }

            me.enableHlSeq();

            me.bAjax3ddomain = true;
            bAjaxDone1 = true;

            if(me.deferred3ddomain !== undefined) {
                if(me.cfg.align === undefined) {
                    me.deferred3ddomain.resolve();
                }
                else {
                    var bAjaxDoneAll = true;
                    for(var i = 0, il = pdbArray.length; i < il; ++i) {
                        bAjaxDoneAll = bAjaxDoneAll && me.bAjaxDoneArray[i];
                    }

                    if(bAjaxDoneAll) me.deferred3ddomain.resolve();
                }
            }
            return;
          }
        });
    }
};

iCn3DUI.prototype.showDomainAll = function() { var me = this;
    //var chnid = Object.keys(me.protein_chainid)[0];
    //var pdbid = chnid.substr(0, chnid.indexOf('_'));
    var pdbArray = Object.keys(me.icn3d.structures);

    // show 3D domains
    me.mmdb_dataArray = [];

    me.bAjaxDoneArray = [];
    for(var i = 0, il = pdbArray.length; i < il; ++i) {
        me.bAjaxDoneArray[i] = false;
    }

    for(var i = 0, il = pdbArray.length; i < il; ++i) {
        me.showDomainPerStructure(i);
    }
};

iCn3DUI.prototype.showDomainWithData = function(chnid, data) { var me = this;
        var html = '<div id="' + me.pre + chnid + '_domainseq_sequence" class="icn3d-dl_sequence">';
        var html2 = html;
        var html3 = html;

        var domainArray, proteinname;

        var pos = chnid.indexOf('_');
        var chain = chnid.substr(pos + 1);

        var molinfo = data.moleculeInfor;
        var currMolid;
        for(var molid in molinfo) {
        if(molinfo[molid].chain === chain) {
          currMolid = molid;
          proteinname = molinfo[molid].name;
          break;
        }
        }

        if(currMolid !== undefined && data.domains[currMolid] !== undefined) {
          domainArray = data.domains[currMolid].domains;
        }

        if(domainArray === undefined) {
          domainArray = [];
        }

        for(var index = 0, indexl = domainArray.length; index < indexl; ++index) {
            //var fulltitle = '3D domain ' + (index+1).toString() + ' of ' + proteinname + ' (PDB ID: ' + data.pdbId + ')';
            var fulltitle = '3D domain ' + (index+1).toString() + ' of ' + proteinname;
            var title = (fulltitle.length > 17) ? fulltitle.substr(0,17) + '...' : fulltitle;

            var subdomainArray = domainArray[index].intervals;

            // remove duplicate, e.g., at https://www.ncbi.nlm.nih.gov/Structure/mmdb/mmdb_strview.cgi?v=2&program=icn3d&domain&molinfor&uid=1itw
            var domainHash = {};

            var fromArray = [], toArray = [];
            var resiHash = {};
            var resCnt = 0
            for(var i = 0, il = subdomainArray.length; i < il; ++i) {
                var domainFrom = Math.round(subdomainArray[i][0]) - 1; // 1-based
                var domainTo = Math.round(subdomainArray[i][1]) - 1;

                domainStr = domainFrom + "," + domainTo;

                if(domainHash.hasOwnProperty(domainStr)) {
                    continue; // do nothing for duplicates, e.g, PDBID 1ITW
                }
                else {
                    domainHash[domainStr] = 1;
                }

                fromArray.push(domainFrom + me.baseResi[chnid]);
                toArray.push(domainTo + me.baseResi[chnid]);
                resCnt += domainTo - domainFrom + 1;

                for(var j = domainFrom; j <= domainTo; ++j) {
                    resiHash[j+1] = 1;
                }
            }

            var htmlTmp2 = '<div class="icn3d-seqTitle icn3d-link icn3d-blue" 3ddomain="' + (index+1).toString() + '" from="' + fromArray + '" to="' + toArray + '" shorttitle="' + title + '" index="' + index + '" setname="' + chnid + '_3d_domain_' + index + '" anno="sequence" chain="' + chnid + '" title="' + fulltitle + '">' + title + ' </div>';

            var htmlTmp3 = '<span class="icn3d-residueNum" title="residue count">' + resCnt.toString() + ' Res</span>';

            html3 += htmlTmp2 + htmlTmp3 + '<br>';

            var htmlTmp = '<span class="icn3d-seqLine">';

            html += htmlTmp2 + htmlTmp3 + htmlTmp;
            html2 += htmlTmp2 + htmlTmp3 + htmlTmp;

            var pre = 'domain3d' + index.toString();
            for(var i = 0, il = me.giSeq[chnid].length; i < il; ++i) {
              html += me.insertGap(chnid, i, '-');

              //if(i >= domainFrom && i <= domainTo) {
              if(resiHash.hasOwnProperty(i+1)) {
                var cFull = me.giSeq[chnid][i];

                  var c = cFull;
                  if(cFull.length > 1) {
                      c = cFull[0] + '..';
                  }

//                var pos = (me.baseResi[chnid] + i+1).toString();
//                var pos = me.icn3d.chainsSeq[chnid][i - me.matchedPos[chnid] ].resi;
                  var pos = (i >= me.matchedPos[chnid] && i - me.matchedPos[chnid] < me.icn3d.chainsSeq[chnid].length) ? me.icn3d.chainsSeq[chnid][i - me.matchedPos[chnid]].resi : me.baseResi[chnid] + 1 + i;

                html += '<span id="' + pre + '_' + me.pre + chnid + '_' + pos + '" title="' + c + pos + '" class="icn3d-residue">' + cFull + '</span>';
              }
              else {
                html += '<span>-</span>'; //'<span>-</span>';
              }
            }

            var atom = me.icn3d.getFirstCalphaAtomObj(me.icn3d.chains[chnid]);
            var color = (atom.color) ? atom.color.getHexString() : me.icn3d.defaultAtomColor;

            if(me.cfg.blast_rep_id != chnid) { // regular
                for(var i = 0, il = fromArray.length; i < il; ++i) {
                    var emptyWidth = (i == 0) ? Math.round(me.seqAnnWidth * fromArray[i] / me.maxAnnoLength) : Math.round(me.seqAnnWidth * (fromArray[i] - toArray[i-1] - 1) / me.maxAnnoLength);
                    html2 += '<div style="display:inline-block; width:' + emptyWidth + 'px;">&nbsp;</div>';

                    html2 += '<div style="display:inline-block; color:white!important; font-weight:bold; background-color:#' + color + '; width:' + Math.round(me.seqAnnWidth * (toArray[i] - fromArray[i] + 1) / me.maxAnnoLength) + 'px;" class="icn3d-seqTitle icn3d-link icn3d-blue" 3ddomain="' + (index+1).toString() + '" from="' + fromArray + '" to="' + toArray + '" shorttitle="' + title + '" index="' + index + '" setname="' + chnid + '_3d_domain_' + index + '" id="' + chnid + '_3d_domain_' + index + '" anno="sequence" chain="' + chnid + '" title="' + fulltitle + '">3D domain ' + (index+1).toString() + '</div>';
                }
            }
            else { // with potential gaps
                var fromArray2 = [], toArray2 = [];
                for(var i = 0, il = fromArray.length; i < il; ++i) {
                    fromArray2.push(fromArray[i]);

                    for(var j = fromArray[i]; j <= toArray[i]; ++j) {
                        if(me.targetGapHash !== undefined && me.targetGapHash.hasOwnProperty(j)) {
                            toArray2.push(j - 1);
                            fromArray2.push(j);
                        }
                    }

                    toArray2.push(toArray[i]);
                }

                for(var i = 0, il = fromArray2.length; i < il; ++i) {
                    html2 += me.insertGapOverview(chnid, fromArray2[i]);

                    var emptyWidth = (i == 0) ? Math.round(me.seqAnnWidth * fromArray2[i] / (me.maxAnnoLength + me.nTotalGap)) : Math.round(me.seqAnnWidth * (fromArray2[i] - toArray2[i-1] - 1) / (me.maxAnnoLength + me.nTotalGap));
                    html2 += '<div style="display:inline-block; width:' + emptyWidth + 'px;">&nbsp;</div>';

                    html2 += '<div style="display:inline-block; color:white!important; font-weight:bold; background-color:#' + color + '; width:' + Math.round(me.seqAnnWidth * (toArray2[i] - fromArray2[i] + 1) / (me.maxAnnoLength + me.nTotalGap)) + 'px;" class="icn3d-seqTitle icn3d-link icn3d-blue" 3ddomain="' + (index+1).toString() + '" from="' + fromArray2 + '" to="' + toArray2 + '" shorttitle="' + title + '" index="' + index + '" setname="' + chnid + '_3d_domain_' + index + '" id="' + chnid + '_3d_domain_' + index + '" anno="sequence" chain="' + chnid + '" title="' + fulltitle + '">3D domain ' + (index+1).toString() + '</div>';
                }
            }

            //var lastToArray = toArray[toArray.length - 1];
            //var end = (lastToArray - me.matchedPos[chnid] < me.icn3d.chainsSeq[chnid].length) ? me.icn3d.chainsSeq[chnid][lastToArray - me.matchedPos[chnid] ].resi : me.baseResi[chnid] + 1 + lastToArray;
            //htmlTmp = '<span class="icn3d-residueNum" title="ending protein sequence number">&nbsp;' + end + '</span>';

            htmlTmp = '<span class="icn3d-residueNum" title="residue count">&nbsp;' + resCnt.toString() + ' Residues</span>';

            htmlTmp += '</span>';
            htmlTmp += '<br>';

            html += htmlTmp;
            html2 += htmlTmp;
        }

        html += '</div>';
        html2 += '</div>';
        html3 += '</div>';

        $("#" + me.pre + "dt_domain_" + chnid).html(html);
        $("#" + me.pre + "ov_domain_" + chnid).html(html2);
        $("#" + me.pre + "tt_domain_" + chnid).html(html3);
};

iCn3DUI.prototype.showInteraction = function(chnid, chnidBase) {
    var me = this;

    if(me.chainname2residues === undefined && (me.cfg.mmdbid !== undefined || me.cfg.gi !== undefined || me.cfg.blast_rep_id !== undefined || me.cfg.align !== undefined) ) {
        // 2d interaction didn't finish loading data yet
        setTimeout(function(){
          me.showInteraction_base(chnid, chnidBase);
        }, 1000);
    }
    else {
        me.showInteraction_base(chnid, chnidBase);
    }
};

iCn3DUI.prototype.showInteraction_base = function(chnid, chnidBase) {
    var me = this;

    // set interaction
    if(me.chainname2residues === undefined) me.chainname2residues = {};

    var radius = 4;
    var chainArray = Object.keys(me.icn3d.chains);

    var chainid = chnid;

    var pos = Math.round(chainid.indexOf('_'));
    if(pos > 4) return; // NMR structures with structure id such as 2K042,2K043, ...

    var atom = me.icn3d.getFirstCalphaAtomObj(me.icn3d.chains[chainid]);

    if(me.chainname2residues[chainid] === undefined) {
        me.chainname2residues[chainid] = {};

        var jl = chainArray.length;
        if(jl > 100 && me.cfg.mmdbid === undefined && me.cfg.gi === undefined && me.cfg.blast_rep_id === undefined && me.cfg.align === undefined) {
        //if(jl > 100) {
            //console.log("Do not show interactions if there are more than 100 chains");
            $("#" + me.pre + "dt_interaction_" + chnid).html("");
            $("#" + me.pre + "ov_interaction_" + chnid).html("");

            return; // skip interactions if there are more than 100 chains
        }

        for(var j = 0; j < jl; ++j) {
            var chainid2 = chainArray[j];
            if(chainid2 === chainid) continue;
            // interactions should be on the same structure
            if(chainid2.substr(0, chainid2.indexOf('_')) !== chainid.substr(0, chainid.indexOf('_'))) continue;

            pos = Math.round(chainid.indexOf('_'));
            if(pos > 4) continue; // NMR structures with structure id such as 2K042,2K043, ...

            var atom2 = me.icn3d.getFirstCalphaAtomObj(me.icn3d.chains[chainid2]);
            //if(me.chainname2residues[chainid2] === undefined) me.chainname2residues[chainid2] = {};

            var type2;
            if(me.icn3d.chemicals.hasOwnProperty(atom2.serial)) { // 1. chemical interacting with proteins
                type2 = 'chemical';
            }
            else if(me.icn3d.nucleotides.hasOwnProperty(atom2.serial)) { // 2. DNA interacting with proteins
                type2 = 'nucleotide';
            }
            else if(me.icn3d.ions.hasOwnProperty(atom2.serial)) { // 3. ions interacting with proteins
                type2 = 'ion';
            }
            else if(me.icn3d.proteins.hasOwnProperty(atom2.serial)) { // 4. protein interacting with proteins
                type2 = 'protein';
            }
            else if(me.icn3d.water.hasOwnProperty(atom2.serial)) { // 5. water interacting with proteins
                type2 = 'water';
            }

            // find atoms in chainid1, which interact with chainid2
            var atomsChainid1 = me.icn3d.getAtomsWithinAtom(me.icn3d.hash2Atoms(me.icn3d.chains[chainid]), me.icn3d.hash2Atoms(me.icn3d.chains[chainid2]), radius);

            if(Object.keys(atomsChainid1).length == 0) continue;

            var residues = {};

            for (var k in atomsChainid1) {
                var atom = me.icn3d.atoms[k];
                var residueid = atom.structure + '_' + atom.chain + '_' + atom.resi;
                residues[residueid] = 1;
            }

            var name = chainid2.substr(chainid2.indexOf('_') + 1) + " (" + type2 + ")";

            me.chainname2residues[chainid][name] = Object.keys(residues);
        } // for
    }

    var html = '<div id="' + me.pre + chnid + '_interseq_sequence" class="icn3d-dl_sequence">';
    var html2 = html;
    var html3 = html;

    var index = 0;
    for(var chainname in me.chainname2residues[chnid]) {
        var residueArray = me.chainname2residues[chnid][chainname];

        var title = "Interact ." + chainname;
        if(title.length > 17) title = title.substr(0, 17) + '...';

        var fulltitle = "Interact ." + chainname;

        var resPosArray = [];
        for(var i = 0, il = residueArray.length; i < il; ++i) {
            var resid = residueArray[i];
            var resi = Math.round(resid.substr(residueArray[i].lastIndexOf('_') + 1) );
            // exclude chemical, water and ions
            var serial = Object.keys(me.icn3d.residues[resid])[0];
            if(me.icn3d.proteins.hasOwnProperty(serial) || me.icn3d.nucleotides.hasOwnProperty(serial)) {
                resPosArray.push( resi );
            }
        }

        var resCnt = resPosArray.length;

        if(resCnt == 0) continue;

        var chainnameNospace = chainname.replace(/\s/g, '');

        var htmlTmp2 = '<div class="icn3d-seqTitle icn3d-link icn3d-blue" interaction="' + (index+1).toString() + '" posarray="' + resPosArray.toString() + '" shorttitle="' + title + '" setname="' + chnid + '_' + chainnameNospace + '" anno="sequence" chain="' + chnid + '" title="' + fulltitle + '">' + title + ' </div>';
        var htmlTmp3 = '<span class="icn3d-residueNum" title="residue count">' + resCnt.toString() + ' Res</span>';

        html3 += htmlTmp2 + htmlTmp3 + '<br>';

        var htmlTmp = '<span class="icn3d-seqLine">';

        html += htmlTmp2 + htmlTmp3 + htmlTmp;
        html2 += htmlTmp2 + htmlTmp3 + htmlTmp;

        var pre = 'inter' + index.toString();

        var prevEmptyWidth = 0;
        var prevLineWidth = 0;
        var widthPerRes = 1;

        for(var i = 0, il = me.giSeq[chnid].length; i < il; ++i) {
          html += me.insertGap(chnid, i, '-');

          if(resPosArray.indexOf(i+1 + me.baseResi[chnid]) != -1) {
              var cFull = me.giSeq[chnid][i];

              var c = cFull;
              if(cFull.length > 1) {
                  c = cFull[0] + '..';
              }

//            var pos = (me.baseResi[chnid] + i+1).toString();
//            var pos = me.icn3d.chainsSeq[chnid][i - me.matchedPos[chnid] ].resi;
              var pos = (i >= me.matchedPos[chnid] && i - me.matchedPos[chnid] < me.icn3d.chainsSeq[chnid].length) ? me.icn3d.chainsSeq[chnid][i - me.matchedPos[chnid]].resi : me.baseResi[chnid] + 1 + i;

              html += '<span id="' + pre + '_' + me.pre + chnid + '_' + pos + '" title="' + cFull + pos + '" class="icn3d-residue">' + c + '</span>';

              html2 += me.insertGapOverview(chnid, i);

              var emptyWidth = (me.cfg.blast_rep_id == chnid) ? Math.round(me.seqAnnWidth * i / (me.maxAnnoLength + me.nTotalGap) - prevEmptyWidth - prevLineWidth) : Math.round(me.seqAnnWidth * i / me.maxAnnoLength - prevEmptyWidth - prevLineWidth);

                if(emptyWidth < 0) emptyWidth = 0;

                html2 += '<div style="display:inline-block; width:' + emptyWidth + 'px;">&nbsp;</div>';
                html2 += '<div style="display:inline-block; background-color:#000; width:' + widthPerRes + 'px;" title="' + c + pos + '">&nbsp;</div>';

                prevEmptyWidth += emptyWidth;
                prevLineWidth += widthPerRes;
          }
          else {
            html += '<span>-</span>'; //'<span>-</span>';
          }
        }

        htmlTmp = '<span class="icn3d-residueNum" title="residue count">&nbsp;' + resCnt.toString() + ' Residues</span>';
        htmlTmp += '</span>';
        htmlTmp += '<br>';

        html += htmlTmp;
        html2 += htmlTmp;

        ++index;
    }

    html += '</div>';
    html2 += '</div>';
    html3 += '</div>';

    $("#" + me.pre + "dt_interaction_" + chnid).html(html);
    $("#" + me.pre + "ov_interaction_" + chnid).html(html2);
    $("#" + me.pre + "tt_interaction_" + chnid).html(html3);

    // add here after the ajax call
    if(! me.isMobile()) {
        me.selectSequenceNonMobile();
    }
    else {
        me.selectSequenceMobile();
        me.selectChainMobile();
    }
};

iCn3DUI.prototype.showSsbond = function(chnid, chnidBase) {
    var me = this;

    if(me.icn3d.ssbondpnts === undefined) {
        // didn't finish loading atom data yet
        setTimeout(function(){
          me.showSsbond_base(chnid, chnidBase);
        }, 1000);
    }
    else {
        me.showSsbond_base(chnid, chnidBase);
    }
};

iCn3DUI.prototype.showSsbond_base = function(chnid, chnidBase) {
    var me = this;

    var chainArray = Object.keys(me.icn3d.chains);

    //var chainid = chnid;
    var chainid = chnidBase;

    //var pos = Math.round(chainid.indexOf('_'));
    //if(pos > 4) return; // NMR structures with structure id such as 2K042,2K043, ...

    var atom = me.icn3d.getFirstCalphaAtomObj(me.icn3d.chains[chainid]);

    var html = '<div id="' + me.pre + chnid + '_ssbondseq_sequence" class="icn3d-dl_sequence">';
    var html2 = html;
    var html3 = html;

    //me.icn3d.ssbondpnts[atom1.structure].push(resid1);
    var resid2resids = {};

    var structure = chainid.substr(0, chainid.indexOf('_'));
    var ssbondArray = me.icn3d.ssbondpnts[structure];
    if(ssbondArray === undefined) {
        $("#" + me.pre + "dt_ssbond_" + chnid).html('');
        $("#" + me.pre + "ov_ssbond_" + chnid).html('');
        $("#" + me.pre + "tt_ssbond_" + chnid).html('');

        return;
    }

    for(var i = 0, il = ssbondArray.length; i < il; i = i + 2) {
        var resid1 = ssbondArray[i];
        var resid2 = ssbondArray[i+1];

        var chainid1 = resid1.substr(0, resid1.lastIndexOf('_'));
        var chainid2 = resid2.substr(0, resid2.lastIndexOf('_'));

        if(chainid === chainid1) {
            if(resid2resids[resid1] === undefined) resid2resids[resid1] = [];
            resid2resids[resid1].push(resid2);
        }

        if(chainid === chainid2) {
            if(resid2resids[resid2] === undefined) resid2resids[resid2] = [];
            resid2resids[resid2].push(resid1);
        }
    }

    var residueArray = Object.keys(resid2resids);

    var title = "Disulfide Bonds";
    if(title.length > 17) title = title.substr(0, 17) + '...';

    var fulltitle = title;

    var resPosArray = [];
    for(var i = 0, il = residueArray.length; i < il; ++i) {
        var resid = residueArray[i];
        var resi = Math.round(resid.substr(residueArray[i].lastIndexOf('_') + 1) );
        // exclude chemical, water and ions
        //var serial = Object.keys(me.icn3d.residues[resid])[0];
        //if(me.icn3d.proteins.hasOwnProperty(serial) || me.icn3d.nucleotides.hasOwnProperty(serial)) {
        //    resPosArray.push( resi );
        //}
        resPosArray.push( resi );
    }

    if(resPosArray.length === 0) {
        $("#" + me.pre + "dt_ssbond_" + chnid).html('');
        $("#" + me.pre + "ov_ssbond_" + chnid).html('');
        $("#" + me.pre + "tt_ssbond_" + chnid).html('');

        return;
    }

    var resCnt = resPosArray.length;

    var chainnameNospace = 'ssbond'; //chainname.replace(/\s/g, '');

    var htmlTmp2 = '<div class="icn3d-seqTitle icn3d-link icn3d-blue" ssbond="" posarray="' + resPosArray.toString() + '" shorttitle="' + title + '" setname="' + chnid + '_' + chainnameNospace + '" anno="sequence" chain="' + chnid + '" title="' + fulltitle + '">' + title + ' </div>';
    var htmlTmp3 = '<span class="icn3d-residueNum" title="residue count">' + resCnt.toString() + ' Res</span>';

    html3 += htmlTmp2 + htmlTmp3 + '<br>';

    var htmlTmp = '<span class="icn3d-seqLine">';

    html += htmlTmp2 + htmlTmp3 + htmlTmp;
    html2 += htmlTmp2 + htmlTmp3 + htmlTmp;

    var pre = 'ssbond';

    var prevEmptyWidth = 0;
    var prevLineWidth = 0;
    var widthPerRes = 1;

    for(var i = 0, il = me.giSeq[chnid].length; i < il; ++i) {
      html += me.insertGap(chnid, i, '-');

      if(resPosArray.indexOf(i+1 + me.baseResi[chnid]) != -1) {
          var cFull = me.giSeq[chnid][i];

          var c = cFull;
          if(cFull.length > 1) {
              c = cFull[0] + '..';
          }

          var pos = (i >= me.matchedPos[chnid] && i - me.matchedPos[chnid] < me.icn3d.chainsSeq[chnid].length) ? me.icn3d.chainsSeq[chnid][i - me.matchedPos[chnid]].resi : me.baseResi[chnid] + 1 + i;

          var resid = chnid + '_' + (i+1 + me.baseResi[chnid]).toString();
          var title = 'Residue ' + resid + ' has disulfide bond with';
          if(resid2resids[resid] !== undefined) {
              for(var j = 0, jl = resid2resids[resid].length; j < jl; ++j) {
                  title += ' residue ' + resid2resids[resid][j];
              }
          }

          html += '<span id="' + pre + '_' + me.pre + chnid + '_' + pos + '" title="' + title + '" class="icn3d-residue">' + c + '</span>';

          html2 += me.insertGapOverview(chnid, i);

          var emptyWidth = (me.cfg.blast_rep_id == chnid) ? Math.round(me.seqAnnWidth * i / (me.maxAnnoLength + me.nTotalGap) - prevEmptyWidth - prevLineWidth) : Math.round(me.seqAnnWidth * i / me.maxAnnoLength - prevEmptyWidth - prevLineWidth);

            if(emptyWidth < 0) emptyWidth = 0;

            html2 += '<div style="display:inline-block; width:' + emptyWidth + 'px;">&nbsp;</div>';
            html2 += '<div style="display:inline-block; background-color:#000; width:' + widthPerRes + 'px;" title="' + title + '">&nbsp;</div>';

            prevEmptyWidth += emptyWidth;
            prevLineWidth += widthPerRes;
      }
      else {
        html += '<span>-</span>'; //'<span>-</span>';
      }
    }

    htmlTmp = '<span class="icn3d-residueNum" title="residue count">&nbsp;' + resCnt.toString() + ' Residues</span>';
    htmlTmp += '</span>';
    htmlTmp += '<br>';

    html += htmlTmp;
    html2 += htmlTmp;


    html += '</div>';
    html2 += '</div>';
    html3 += '</div>';

    $("#" + me.pre + "dt_ssbond_" + chnid).html(html);
    $("#" + me.pre + "ov_ssbond_" + chnid).html(html2);
    $("#" + me.pre + "tt_ssbond_" + chnid).html(html3);

/*
    // add here after the ajax call
    if(! me.isMobile()) {
        me.selectSequenceNonMobile();
    }
    else {
        me.selectSequenceMobile();
        me.selectChainMobile();
    }
*/
};

iCn3DUI.prototype.hideAllAnno = function() { var me = this;
        $("[id^=" + me.pre + "site]").hide();
        $("[id^=" + me.pre + "snp]").hide();
        $("[id^=" + me.pre + "clinvar]").hide();
        $("[id^=" + me.pre + "cdd]").hide();
        $("[id^=" + me.pre + "domain]").hide();
        $("[id^=" + me.pre + "interaction]").hide();
        $("[id^=" + me.pre + "custom]").hide();
        $("[id^=" + me.pre + "ssbond]").hide();
};

iCn3DUI.prototype.setAnnoTabAll = function () {  var me = this;
    if($("#" + me.pre + "anno_all").length) $("#" + me.pre + "anno_all")[0].checked = true;

    if($("#" + me.pre + "anno_binding").length) $("#" + me.pre + "anno_binding")[0].checked = true;
    if($("#" + me.pre + "anno_snp").length) $("#" + me.pre + "anno_snp")[0].checked = true;
    if($("#" + me.pre + "anno_clinvar").length) $("#" + me.pre + "anno_clinvar")[0].checked = true;
    if($("#" + me.pre + "anno_cdd").length) $("#" + me.pre + "anno_cdd")[0].checked = true;
    if($("#" + me.pre + "anno_3dd").length) $("#" + me.pre + "anno_3dd")[0].checked = true;
    if($("#" + me.pre + "anno_interact").length) $("#" + me.pre + "anno_interact")[0].checked = true;
    if($("#" + me.pre + "anno_custom").length) $("#" + me.pre + "anno_custom")[0].checked = true;
    if($("#" + me.pre + "anno_ssbond").length) $("#" + me.pre + "anno_ssbond")[0].checked = true;

    //$("[id^=" + me.pre + "custom]").show();
    $("[id^=" + me.pre + "site]").show();
    $("[id^=" + me.pre + "snp]").show();
    $("[id^=" + me.pre + "clinvar]").show();
    $("[id^=" + me.pre + "cdd]").show();
    $("[id^=" + me.pre + "domain]").show();
    $("[id^=" + me.pre + "interaction]").show();
    $("[id^=" + me.pre + "custom]").show();
    $("[id^=" + me.pre + "ssbond]").show();

    me.updateSnpClinvar();
    me.updateDomain();
    me.updateInteraction();
    me.updateSsbond();
};

iCn3DUI.prototype.hideAnnoTabAll = function () {  var me = this;
    if($("#" + me.pre + "anno_all").length) $("#" + me.pre + "anno_all")[0].checked = false;

    if($("#" + me.pre + "anno_binding").length) $("#" + me.pre + "anno_binding")[0].checked = false;
    if($("#" + me.pre + "anno_snp").length) $("#" + me.pre + "anno_snp")[0].checked = false;
    if($("#" + me.pre + "anno_clinvar").length) $("#" + me.pre + "anno_clinvar")[0].checked = false;
    if($("#" + me.pre + "anno_cdd").length) $("#" + me.pre + "anno_cdd")[0].checked = false;
    if($("#" + me.pre + "anno_3dd").length) $("#" + me.pre + "anno_3dd")[0].checked = false;
    if($("#" + me.pre + "anno_interact").length) $("#" + me.pre + "anno_interact")[0].checked = false;
    if($("#" + me.pre + "anno_custom").length) $("#" + me.pre + "anno_custom")[0].checked = false;
    if($("#" + me.pre + "anno_ssbond").length) $("#" + me.pre + "anno_ssbond")[0].checked = false;

    me.hideAllAnno();
};

iCn3DUI.prototype.setAnnoTabCustom = function () {  var me = this;
    $("[id^=" + me.pre + "custom]").show();
    if($("#" + me.pre + "anno_custom").length) $("#" + me.pre + "anno_custom")[0].checked = true;
};

iCn3DUI.prototype.hideAnnoTabCustom = function () {  var me = this;
    $("[id^=" + me.pre + "custom]").hide();
    if($("#" + me.pre + "anno_custom").length) $("#" + me.pre + "anno_custom")[0].checked = false;
};

iCn3DUI.prototype.setAnnoTabClinvar = function () {  var me = this;
    $("[id^=" + me.pre + "clinvar]").show();
    if($("#" + me.pre + "anno_clinvar").length) $("#" + me.pre + "anno_clinvar")[0].checked = true;

    me.updateSnpClinvar();
};

iCn3DUI.prototype.hideAnnoTabClinvar = function () {  var me = this;
    $("[id^=" + me.pre + "clinvar]").hide();
    if($("#" + me.pre + "anno_clinvar").length) $("#" + me.pre + "anno_clinvar")[0].checked = false;
};

iCn3DUI.prototype.setAnnoTabSnp = function () {  var me = this;
    $("[id^=" + me.pre + "snp]").show();
    if($("#" + me.pre + "anno_snp").length) $("#" + me.pre + "anno_snp")[0].checked = true;

    me.updateSnpClinvar();
};

iCn3DUI.prototype.hideAnnoTabSnp = function () {  var me = this;
    $("[id^=" + me.pre + "snp]").hide();
    if($("#" + me.pre + "anno_snp").length) $("#" + me.pre + "anno_snp")[0].checked = false;
};

iCn3DUI.prototype.setAnnoTabCdd = function () {  var me = this;
    $("[id^=" + me.pre + "cdd]").show();
    if($("#" + me.pre + "anno_cdd").length) $("#" + me.pre + "anno_cdd")[0].checked = true;
};

iCn3DUI.prototype.hideAnnoTabCdd = function () {  var me = this;
    $("[id^=" + me.pre + "cdd]").hide();
    if($("#" + me.pre + "anno_cdd").length) $("#" + me.pre + "anno_cdd")[0].checked = false;
};

iCn3DUI.prototype.setAnnoTab3ddomain = function () {  var me = this;
    $("[id^=" + me.pre + "domain]").show();
    if($("#" + me.pre + "anno_3dd").length) $("#" + me.pre + "anno_3dd")[0].checked = true;

    me.updateDomain();
};

iCn3DUI.prototype.hideAnnoTab3ddomain = function () {  var me = this;
    $("[id^=" + me.pre + "domain]").hide();
    if($("#" + me.pre + "anno_3dd").length) $("#" + me.pre + "anno_3dd")[0].checked = false;
};

iCn3DUI.prototype.setAnnoTabSite = function () {  var me = this;
    $("[id^=" + me.pre + "site]").show();
    if($("#" + me.pre + "anno_binding").length) $("#" + me.pre + "anno_binding")[0].checked = true;
};

iCn3DUI.prototype.hideAnnoTabSite = function () {  var me = this;
    $("[id^=" + me.pre + "site]").hide();
    if($("#" + me.pre + "anno_binding").length) $("#" + me.pre + "anno_binding")[0].checked = false;
};

iCn3DUI.prototype.setAnnoTabInteraction = function () {  var me = this;
    $("[id^=" + me.pre + "interaction]").show();
    if($("#" + me.pre + "anno_interact").length) $("#" + me.pre + "anno_interact")[0].checked = true;

    me.updateInteraction();
};

iCn3DUI.prototype.hideAnnoTabInteraction = function () {  var me = this;
    $("[id^=" + me.pre + "interaction]").hide();
    if($("#" + me.pre + "anno_interact").length) $("#" + me.pre + "anno_interact")[0].checked = false;
};

iCn3DUI.prototype.setAnnoTabSsbond = function () {  var me = this;
    $("[id^=" + me.pre + "ssbond]").show();
    if($("#" + me.pre + "anno_ssbond").length) $("#" + me.pre + "anno_ssbond")[0].checked = true;

    me.updateSsbond();
};

iCn3DUI.prototype.hideAnnoTabSsbond = function () {  var me = this;
    $("[id^=" + me.pre + "ssbond]").hide();
    if($("#" + me.pre + "anno_ssbond").length) $("#" + me.pre + "anno_ssbond")[0].checked = false;
};

iCn3DUI.prototype.setTabs = function () {  var me = this;
//        $("#" + me.pre + "dl_annotations_tabs").tabs();
    $("#" + me.pre + "dl_addtrack_tabs").tabs();
    $("#" + me.pre + "dl_anno_view_tabs").tabs();

    $("#" + me.pre + "anno_all").click(function (e) {
    if($("#" + me.pre + "anno_all")[0].checked) {
        me.setAnnoTabAll();
        me.setLogCmd("set annotation all", true);
    }
    else{
        me.hideAnnoTabAll();
        me.setLogCmd("hide annotation all", true);
    }
    });

    $("#" + me.pre + "anno_binding").click(function (e) {
    if($("#" + me.pre + "anno_binding")[0].checked) {
        me.setAnnoTabSite();
        me.setLogCmd("set annotation site", true);
    }
    else{
        me.hideAnnoTabSite();
        me.setLogCmd("hide annotation site", true);
    }
    });

    $("#" + me.pre + "anno_snp").click(function (e) {
    if($("#" + me.pre + "anno_snp")[0].checked) {
        me.setAnnoTabSnp();
        me.setLogCmd("set annotation snp", true);
    }
    else{
        me.hideAnnoTabSnp();
        me.setLogCmd("hide annotation snp", true);
    }
    });

    $("#" + me.pre + "anno_clinvar").click(function (e) {
    if($("#" + me.pre + "anno_clinvar")[0].checked) {
        me.setAnnoTabClinvar();
        me.setLogCmd("set annotation clinvar", true);
    }
    else{
        me.hideAnnoTabClinvar();
        me.setLogCmd("hide annotation clinvar", true);
    }
    });

    $("#" + me.pre + "anno_cdd").click(function (e) {
        me.clickCdd();
    });

    $("#" + me.pre + "anno_3dd").click(function (e) {
    if($("#" + me.pre + "anno_3dd")[0].checked) {
        me.setAnnoTab3ddomain();
        me.setLogCmd("set annotation 3ddomain", true);
    }
    else{
        me.hideAnnoTab3ddomain();
        me.setLogCmd("hide annotation 3ddomain", true);
    }
    });

    $("#" + me.pre + "anno_interact").click(function (e) {
    if($("#" + me.pre + "anno_interact")[0].checked) {
        me.setAnnoTabInteraction();
        me.setLogCmd("set annotation interaction", true);
    }
    else{
        me.hideAnnoTabInteraction();
        me.setLogCmd("hide annotation interaction", true);
    }
    });


    $("#" + me.pre + "anno_custom").click(function (e) {
    if($("#" + me.pre + "anno_custom")[0].checked) {
        me.setAnnoTabCustom();
        me.setLogCmd("set annotation custom", true);
    }
    else{
        me.hideAnnoTabCustom();
        me.setLogCmd("hide annotation custom", true);
    }
    });

    $("#" + me.pre + "anno_ssbond").click(function (e) {
    if($("#" + me.pre + "anno_ssbond")[0].checked) {
        me.setAnnoTabSsbond();
        me.setLogCmd("set annotation ssbond", true);
    }
    else{
        me.hideAnnoTabSsbond();
        me.setLogCmd("hide annotation ssbond", true);
    }
    });
};

iCn3DUI.prototype.clickCdd = function() { var me = this;
  if($("[id^=" + me.pre + "cdd]").length > 0) {
    if($("#" + me.pre + "anno_cdd")[0].checked) {
        me.setAnnoTabCdd();
        me.setLogCmd("set annotation cdd", true);
    }
    else{
        me.hideAnnoTabCdd();
        me.setLogCmd("hide annotation cdd", true);
    }
  }
};

// jquery tooltip
//https://stackoverflow.com/questions/18231315/jquery-ui-tooltip-html-with-links
iCn3DUI.prototype.setToolTip = function () {  var me = this;
  $("[id^=" + me.pre + "snp]").add("[id^=" + me.pre + "clinvar]").add("[id^=" + me.pre + "ssbond]").tooltip({
    content: function () {
        return $(this).prop('title');
    },
    show: null,
    close: function (event, ui) {
        ui.tooltip.hover(

        function () {
            $(this).stop(true).fadeTo(400, 1);
        },

        function () {
            $(this).fadeOut("200", function () {
                $(this).remove();
            })
        });
    }
  });
};

iCn3DUI.prototype.showAnnoSelectedChains = function () {   var me = this;
    // show selected chains in annotation window
    var chainHash = {};
    for(var i in me.icn3d.hAtoms) {
        var atom = me.icn3d.atoms[i];
        var chainid = atom.structure + '_' + atom.chain;
        chainHash[chainid] = 1;
    }

    $("#" + me.pre + "dl_annotations > .icn3d-annotation").hide();
    for(var chainid in chainHash) {
        if($("#" + me.pre + "anno_" + chainid).length) {
            $("#" + me.pre + "anno_" + chainid).show();
        }

        var atom = me.icn3d.getFirstCalphaAtomObj(me.icn3d.chains[chainid]);
        var oneLetterRes = me.icn3d.residueName2Abbr(atom.resn.substr(0, 3));

        $("#" + me.pre + "anno_" + oneLetterRes).show();
    }
};

iCn3DUI.prototype.showAnnoAllChains = function () {   var me = this;
    $("#" + me.pre + "dl_annotations > .icn3d-annotation").show();
};

iCn3DUI.prototype.setAnnoView = function(view) { var me = this;
    if(view === 'detailed view') {
        me.view = 'detailed view';

        // set text
//        $("#" + me.pre + "viewdetail").show();
//        $("#" + me.pre + "overview").hide();

        //$("#" + me.pre + "viewswitch")[0].checked = false;

        $( "#" + me.pre + "dl_anno_view_tabs" ).tabs( "option", "active", 1 );
    }
    else { // overview
        me.view = 'overview';

        // set text
//        $("#" + me.pre + "viewdetail").hide();
//        $("#" + me.pre + "overview").show();

        //$("#" + me.pre + "viewswitch")[0].checked = true;

        $( "#" + me.pre + "dl_anno_view_tabs" ).tabs( "option", "active", 0 );
    }
};

iCn3DUI.prototype.showFixedTitle = function() { var me = this;
        var style = 'display:block;'
        $("[id^=" + me.pre + "tt_giseq]").attr('style', style);
        $("[id^=" + me.pre + "tt_custom]").attr('style', style);
        $("[id^=" + me.pre + "tt_site]").attr('style', style);
        $("[id^=" + me.pre + "tt_snp]").attr('style', style);
        $("[id^=" + me.pre + "tt_clinvar]").attr('style', style);
        $("[id^=" + me.pre + "tt_cdd]").attr('style', style);
        $("[id^=" + me.pre + "tt_domain]").attr('style', style);
        $("[id^=" + me.pre + "tt_interaction]").attr('style', style);
        $("[id^=" + me.pre + "tt_ssbond]").attr('style', style);
};

iCn3DUI.prototype.hideFixedTitle = function() { var me = this;
        var style = 'display:none!important;'
        $("[id^=" + me.pre + "tt_giseq]").attr('style', style);
        $("[id^=" + me.pre + "tt_custom]").attr('style', style);
        $("[id^=" + me.pre + "tt_site]").attr('style', style);
        $("[id^=" + me.pre + "tt_snp]").attr('style', style);
        $("[id^=" + me.pre + "tt_clinvar]").attr('style', style);
        $("[id^=" + me.pre + "tt_cdd]").attr('style', style);
        $("[id^=" + me.pre + "tt_domain]").attr('style', style);
        $("[id^=" + me.pre + "tt_interaction]").attr('style', style);
        $("[id^=" + me.pre + "tt_ssbond]").attr('style', style);
};

iCn3DUI.prototype.setAnnoViewAndDisplay = function(view) { var me = this;
    if(view === 'detailed view') {
        me.setAnnoView('detailed view');

        var style = 'display:block;'
        $("[id^=" + me.pre + "dt_giseq]").attr('style', style);
        $("[id^=" + me.pre + "dt_custom]").attr('style', style);
        $("[id^=" + me.pre + "dt_site]").attr('style', style);
        $("[id^=" + me.pre + "dt_snp]").attr('style', style);
        $("[id^=" + me.pre + "dt_clinvar]").attr('style', style);
        $("[id^=" + me.pre + "dt_cdd]").attr('style', style);
        $("[id^=" + me.pre + "dt_domain]").attr('style', style);
        $("[id^=" + me.pre + "dt_interaction]").attr('style', style);
        $("[id^=" + me.pre + "dt_ssbond]").attr('style', style);

        $("#" + me.pre + "seqguide_wrapper").attr('style', style);

        style = 'display:none;'
        $("[id^=" + me.pre + "ov_giseq]").attr('style', style);
        $("[id^=" + me.pre + "ov_custom]").attr('style', style);
        $("[id^=" + me.pre + "ov_site]").attr('style', style);
        $("[id^=" + me.pre + "ov_snp]").attr('style', style);
        $("[id^=" + me.pre + "ov_clinvar]").attr('style', style);
        $("[id^=" + me.pre + "ov_cdd]").attr('style', style);
        $("[id^=" + me.pre + "ov_domain]").attr('style', style);
        $("[id^=" + me.pre + "ov_interaction]").attr('style', style);
        $("[id^=" + me.pre + "ov_ssbond]").attr('style', style);
    }
    else { // overview
        me.setAnnoView('overview');

        me.hideFixedTitle();

        var style = 'display:none;'
        $("[id^=" + me.pre + "dt_giseq]").attr('style', style);
        $("[id^=" + me.pre + "dt_custom]").attr('style', style);
        $("[id^=" + me.pre + "dt_site]").attr('style', style);
        $("[id^=" + me.pre + "dt_snp]").attr('style', style);
        $("[id^=" + me.pre + "dt_clinvar]").attr('style', style);
        $("[id^=" + me.pre + "dt_cdd]").attr('style', style);
        $("[id^=" + me.pre + "dt_domain]").attr('style', style);
        $("[id^=" + me.pre + "dt_interaction]").attr('style', style);
        $("[id^=" + me.pre + "dt_ssbond]").attr('style', style);

        $("#" + me.pre + "seqguide_wrapper").attr('style', style);

        style = 'display:block;'
        $("[id^=" + me.pre + "ov_giseq]").attr('style', style);
        $("[id^=" + me.pre + "ov_custom]").attr('style', style);
        $("[id^=" + me.pre + "ov_site]").attr('style', style);
        $("[id^=" + me.pre + "ov_snp]").attr('style', style);
        $("[id^=" + me.pre + "ov_clinvar]").attr('style', style);
        $("[id^=" + me.pre + "ov_cdd]").attr('style', style);
        $("[id^=" + me.pre + "ov_domain]").attr('style', style);
        $("[id^=" + me.pre + "ov_interaction]").attr('style', style);
        $("[id^=" + me.pre + "ov_ssbond]").attr('style', style);
    }
};


/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3DUI.prototype.clickAddTrack = function() { var me = this;
    $(document).on('click', ".icn3d-addtrack", function(e) {
      e.stopImmediatePropagation();

      $("#" + me.pre + "anno_custom")[0].checked = true;
      $("[id^=" + me.pre + "custom]").show();

      //e.preventDefault();
      var chainid = $(this).attr('chainid');
      $("#" + me.pre + "track_chainid").val(chainid);
      me.openDialog(me.pre + 'dl_addtrack', 'Add track for Chain: ' + chainid);
      $( "#" + me.pre + "track_gi" ).focus();
    });
};

iCn3DUI.prototype.clickDefineHelix = function() { var me = this;
    $(document).on('click', ".icn3d-helixsets", function(e) {
      e.stopImmediatePropagation();

      //e.preventDefault();
      var chainid = $(this).attr('chainid');

      me.defineSecondary(chainid, 'helix');

      me.setLogCmd('define helix sets | chain ' + chainid, true);
    });
};

iCn3DUI.prototype.clickDefineSheet = function() { var me = this;
    $(document).on('click', ".icn3d-sheetsets", function(e) {
      e.stopImmediatePropagation();

      //e.preventDefault();
      var chainid = $(this).attr('chainid');

      me.defineSecondary(chainid, 'sheet');

      me.setLogCmd('define sheet sets | chain ' + chainid, true);
    });
};

iCn3DUI.prototype.clickDefineCoil = function() { var me = this;
    $(document).on('click', ".icn3d-coilsets", function(e) {
      e.stopImmediatePropagation();

      //e.preventDefault();
      var chainid = $(this).attr('chainid');

      me.defineSecondary(chainid, 'coil');

      me.setLogCmd('define coil sets | chain ' + chainid, true);
    });
};

iCn3DUI.prototype.clickDeleteSets = function() { var me = this;
    $("#" + me.pre + "deletesets").click(function(e) {
         me.deleteSelectedSets();
         me.setLogCmd("delete selected sets", true);
    });
};

iCn3DUI.prototype.defineSecondary = function(chainid, type) { var me = this;
    if(!$('#' + me.pre + 'dl_definedsets').hasClass('ui-dialog-content') || !$('#' + me.pre + 'dl_definedsets').dialog( 'isOpen' )) {
        me.openDialog(me.pre + 'dl_definedsets', 'Select sets');
    }

    var selectedResidues = {};
    var bUnion = false, bUpdateHighlight = true;

    // order of secondary structures
    var index = 1;

    var helixCnt = 0, sheetCnt = 0, bFirstSS = true;
    var zero = '0';
    //var prevName = chainid + zero + index + '_L(N', currName, setName;
    var prevName = chainid + '_C(Nterm', currName, setName;

    // clear selection
    me.icn3d.hAtoms = {};

    //for(var i = 0, il = me.giSeq[chainid].length; i < il; ++i) {
      //var currResi = (i >= me.matchedPos[chainid] && i - me.matchedPos[chainid] < me.icn3d.chainsSeq[chainid].length) ? me.icn3d.chainsSeq[chainid][i - me.matchedPos[chainid]].resi : me.baseResi[chainid] + 1 + i;
    for(var i = 0, il = me.icn3d.chainsSeq[chainid].length; i < il; ++i) {
      var currResi = me.icn3d.chainsSeq[chainid][i].resi;

      // name of secondary structures
      var residueid = chainid + '_' + currResi;

      if( me.icn3d.residues.hasOwnProperty(residueid) ) {
        var atom = me.icn3d.getFirstCalphaAtomObj(me.icn3d.residues[residueid]);
        currSS = me.icn3d.secondaries[residueid];

        if(currSS == 'H') {
            if(atom.ssbegin) {
                ++helixCnt;

                if(Object.keys(selectedResidues).length > 0) {
                    setName = currName + 'H' + helixCnt + ')';
                    if(type == 'coil') {
                        me.selectResidueList(selectedResidues, setName, setName, bUnion, bUpdateHighlight);
                        if(!bUnion) bUnion = true;
                    }
                    selectedResidues = {};
                    ++index;
                }
            }

            //zero = (index < 10) ? '0' : '';
            //currName = chainid + zero + index + '_H' + helixCnt;
            currName = chainid + '_H' + helixCnt;
            selectedResidues[residueid] = 1;

            if(atom.ssend) {
                //zero = (index < 9) ? '0' : '';
                //prevName = chainid + zero + (index+1) + '_L(H' + helixCnt;
                prevName = chainid + '_C(H' + helixCnt;
                if(type == 'helix') {
                    me.selectResidueList(selectedResidues, currName, currName, bUnion, bUpdateHighlight);
                    if(!bUnion) bUnion = true;
                }
                selectedResidues = {};
                ++index;
            }
        }
        else if(currSS == 'E') {
            if(atom.ssbegin) {
                ++sheetCnt;

                if(Object.keys(selectedResidues).length > 0) {
                    setName = currName + 'S' + sheetCnt + ')';
                    if(type == 'coil') {
                        me.selectResidueList(selectedResidues, setName, setName, bUnion, bUpdateHighlight);
                        if(!bUnion) bUnion = true;
                    }
                    selectedResidues = {};
                    ++index;
                }
            }

            //zero = (index < 10) ? '0' : '';
            //currName = chainid + zero + index + '_S' + sheetCnt;
            currName = chainid + '_S' + sheetCnt;
            selectedResidues[residueid] = 1;

            if(atom.ssend) {
                //zero = (index < 9) ? '0' : '';
                //prevName = chainid + zero + (index+1) + '_L(S' + sheetCnt;
                prevName = chainid + '_C(S' + sheetCnt;
                if(type == 'sheet') {
                    me.selectResidueList(selectedResidues, currName, currName, bUnion, bUpdateHighlight);
                    if(!bUnion) bUnion = true;
                }
                selectedResidues = {};
                ++index;
            }
        }
        else {
            currName = prevName + '-';
            selectedResidues[residueid] = 1;
        }
      } // end if( me.icn3d.residues.hasOwnProperty(residueid) ) {
    } // for loop

    if(Object.keys(selectedResidues).length > 0) {
        setName = currName + 'Cterm)';
        if(type == 'coil') {
            me.selectResidueList(selectedResidues, setName, setName, bUnion, bUpdateHighlight);
        }
    }
};

iCn3DUI.prototype.simplifyText = function(text) { var me = this;
    var out = ''; // 1-based text positions
    var bFoundText = false;

    var i, prevEmptyPos = -1;
    for(i = 0, il = text.length; i < il; ++i) {
        if(text[i] == '-' || text[i] == ' ') {
            if(bFoundText && i !== prevEmptyPos) {
                if(prevEmptyPos+1 == i-1) {
                    out += (prevEmptyPos+1 + 1).toString() + ' ' + text.substr(prevEmptyPos+1, i - 1 - prevEmptyPos) + ', ';
               }
                else {
                    out += (prevEmptyPos+1 + 1).toString() + '-' + (i-1 + 1).toString() + ' ' + text.substr(prevEmptyPos+1, i - 1 - prevEmptyPos) + ', ';
                }
                bFoundText = false;
            }

            prevEmptyPos = i;
        }
        else {
            bFoundText = true;
        }
    }

    if(bFoundText && i == il) {
        if(prevEmptyPos+1 == i-1) {
            out += (prevEmptyPos+1 + 1).toString() + ' ' + text.substr(prevEmptyPos+1, i - 1 - prevEmptyPos) + ', ';
        }
        else {
            out += (prevEmptyPos+1 + 1).toString() + '-' + (i-1 + 1).toString() + ' ' + text.substr(prevEmptyPos+1, i - 1 - prevEmptyPos) + ', ';
        }
    }

    return out;
};

iCn3DUI.prototype.alignSequenceToStructure = function(chainid, data, title) { var me = this;
  var query, target;

  if(data.data !== undefined) {
      query = data.data[0].query;
      target = data.data[0].targets[chainid.replace(/_/g, '')];

      target = target.hsps[0];
  }

  var text = '';

  if(query !== undefined && target !== undefined) {
      var evalue = target.scores.e_value.toPrecision(2);
      if(evalue > 1e-200) evalue = parseFloat(evalue).toExponential();

      var bitscore = target.scores.bit_score;

      var targetSeq = data.targets[chainid.replace(/_/g, '')].seqdata;
      var querySeq = query.seqdata;

      var segArray = target.segs;
      var target2queryHash = {};
      for(var i = 0, il = segArray.length; i < il; ++i) {
          var seg = segArray[i];
          for(var j = 0; j <= seg.orito - seg.orifrom; ++j) {
              target2queryHash[j + seg.orifrom] = j + seg.from;
          }
      }

      // the missing residuesatthe end ofthe seq will be filled up in the API showNewTrack()
      for(var i = 0, il = targetSeq.length; i < il; ++i) {
          if(target2queryHash.hasOwnProperty(i)) {
              text += querySeq[target2queryHash[i]];
          }
          else {
              text += '-';
          }
      }

      title += ', E: ' + evalue;
  }
  else {
      text += "cannot be aligned";
  }

  me.showNewTrack(chainid, title, text, undefined, target2queryHash);

  me.setLogCmd("add track | chainid " + chainid + " | title " + title + " | text " + me.simplifyText(text), true);
};

iCn3DUI.prototype.clickAddTrackButton = function() { var me = this;
    // ncbi gi/accession
    $(document).on('click', "#" + me.pre + "addtrack_button1", function(e) {
       e.stopImmediatePropagation();

       //e.preventDefault();
       dialog.dialog( "close" );

       var chainid = $("#" + me.pre + "track_chainid").val();

       //var gi = $("#" + me.pre + "track_gi").val().toUpperCase();
       var gi = $("#" + me.pre + "track_gi").val();
       var title = (isNaN(gi)) ? 'Acc ' + gi : 'gi ' + gi;

       //var text = $("#" + me.pre + "track_text").val();
       var url = 'https://www.ncbi.nlm.nih.gov/Structure/pwaln/pwaln.fcgi?from=track';

       $.ajax({
          url: url,
          type: 'POST',
          data : {'targets': chainid, 'queries': gi},
          dataType: 'jsonp',
          //dataType: 'json',
          tryCount : 0,
          retryLimit : 1,
          success: function(data) {
              me.alignSequenceToStructure(chainid, data, title);
          },
          error : function(xhr, textStatus, errorThrown ) {
            this.tryCount++;
            if (this.tryCount <= this.retryLimit) {
                //try again
                $.ajax(this);
                return;
            }
            return;
          }
        });
    });

    // FASTA
    $(document).on('click', "#" + me.pre + "addtrack_button2", function(e) {
       e.stopImmediatePropagation();
       //e.preventDefault();
       dialog.dialog( "close" );

       var chainid = $("#" + me.pre + "track_chainid").val();

       var fasta = $("#" + me.pre + "track_fasta").val();
       var title = 'fasta ' + fasta.substr(0, 5);

       //var text = $("#" + me.pre + "track_text").val();
       var url = 'https://www.ncbi.nlm.nih.gov/Structure/pwaln/pwaln.fcgi?from=track';
       $.ajax({
          url: url,
          type: 'POST',
          data : {'targets': chainid, 'queries': fasta},
          dataType: 'jsonp',
          //dataType: 'json',
          tryCount : 0,
          retryLimit : 1,
          success: function(data) {
              me.alignSequenceToStructure(chainid, data, title);
          },
          error : function(xhr, textStatus, errorThrown ) {
            this.tryCount++;
            if (this.tryCount <= this.retryLimit) {
                //try again
                $.ajax(this);
                return;
            }
            return;
          }
        });
    });

    // BED file
    $(document).on('click', "#" + me.pre + "addtrack_button3", function(e) {
       e.stopImmediatePropagation();
       //e.preventDefault();
       dialog.dialog( "close" );

       var chainid = $("#" + me.pre + "track_chainid").val();


       var file = $("#" + me.pre + "track_bed")[0].files[0];

       if(!file) {
         alert("Please select a file...");
       }
       else {
         if (!window.File || !window.FileReader || !window.FileList || !window.Blob) {
            alert('The File APIs are not fully supported in this browser.');
         }

         var reader = new FileReader();
         reader.onload = function (e) {
           var dataStr = e.target.result; // or = reader.result;

           var lineArray = dataStr.split('\n');

           var bItemRgb = false, bColorByStrand = false;
           var strandRgbArray;
           for(var i = 0, il = lineArray.length; i < il; ++i) {
               if(lineArray[i].substr(0, 7) == 'browser') continue;

               if(lineArray[i].substr(0, 5) == 'track') {
                   if(lineArray[i].toLowerCase().indexOf('itemrgb') != -1) bItemRgb = true;
                   if(lineArray[i].toLowerCase().indexOf('colorbystrand=') != -1) {
                       bColorByStrand = true;

                       //e.g., colorByStrand="255,0,0 0,0,255"
                       var pos = lineArray[i].toLowerCase().indexOf('colorbystrand=');
                       var restStr = lineArray[i].substr(pos);
                       var quotePos = restStr.indexOf('"');
                       if(quotePos != -1) {
                         var quoteStr = restStr.substr(quotePos + 1);
                         var quotePos2 = quoteStr.indexOf('"');
                         if(quotePos != -1) {
                           var colorList = quoteStr.substr(0, quotePos2);
                           strandRgbArray = colorList.split(' ');
                         }
                       }

                   }
               }
               else { // tracks
                      if(lineArray[i] == '') continue;
                      var fieldArray = lineArray[i].replace(/\s+/g, ' ').split(' ');

                      if(fieldArray.length > 8 || fieldArray.length < 6) bColorByStrand = false;
                      if(fieldArray.length < 9) bItemRgb = false;

                      //https://genome.ucsc.edu/FAQ/FAQformat.html#format1
                      var chromName = fieldArray[0];
                      var chromStart = fieldArray[1];
                      var chromEnd = fieldArray[2];
                      var trackName = fieldArray[3];

                      if(fieldArray.length > 4) var score = fieldArray[4];
                      if(fieldArray.length > 5) var strand = fieldArray[5]; // ., +, or -
                      if(fieldArray.length > 6) var thickStart = fieldArray[6];
                      if(fieldArray.length > 7) var thickEnd = fieldArray[7];
                      if(fieldArray.length > 8) var itemRgb = fieldArray[8];
                      if(fieldArray.length > 9) var blockCount = fieldArray[9];
                      if(fieldArray.length > 10) var blockSizes = fieldArray[10];
                      if(fieldArray.length > 11) var blockStarts = fieldArray[11];

                   var title = trackName;

                   var rgbColor = '51,51,51';
                   if(bItemRgb) {
                       rgbColor = itemRgb;
                   }
                   else if(bColorByStrand) {
                       if(strand == '+' && strandRgbArray.length > 0) {
                           rgbColor = strandRgbArray[0];
                       }
                       else if(strand == '-' && strandRgbArray.length > 1) {
                           rgbColor = strandRgbArray[1];
                       }
                       else if(strand == '.' && strandRgbArray.length > 2) {
                           rgbColor = strandRgbArray[2];
                       }
                   }

                   var text = '';
                   var cssColorArray = [];
                   for(var j = 0, jl = chromEnd; j < jl; ++j) {
                       if(j < chromStart) {
                           text += '-';
                           cssColorArray.push('');
                       }
                       else {
                           text += me.giSeq[chainid][j];
                           cssColorArray.push('rgb(' + rgbColor + ')');
                       }
                   }

                   me.showNewTrack(chainid, title, text, cssColorArray);

                   me.setLogCmd("add track | chainid " + chainid + " | title " + title + " | text " + me.simplifyText(text), true);
               }
           }
         };

         reader.readAsText(file);
       }
    });

    // custom
    $(document).on('click', "#" + me.pre + "addtrack_button4", function(e) {
       e.stopImmediatePropagation();
       //e.preventDefault();
       dialog.dialog( "close" );

       var chainid = $("#" + me.pre + "track_chainid").val();
       var title = $("#" + me.pre + "track_title").val();
       var text = $("#" + me.pre + "track_text").val(); // input simplifyText

       //me.showNewTrack(chainid, title, text);
       //me.setLogCmd("add track | chainid " + chainid + " | title " + title + " | text " + me.simplifyText(text), true);

       me.showNewTrack(chainid, title,  me.getFullText(text));
       me.setLogCmd("add track | chainid " + chainid + " | title " + title + " | text " + text, true);
    });

    // current selection
    $(document).on('click', "#" + me.pre + "addtrack_button5", function(e) {
       e.stopImmediatePropagation();
       //e.preventDefault();
       dialog.dialog( "close" );

       var chainid = $("#" + me.pre + "track_chainid").val();
       var title = $("#" + me.pre + "track_selection").val();
       var text = '';

       var selectedAtoms = me.icn3d.intHash(me.icn3d.hAtoms, me.icn3d.chains[chainid]);

       var residueHash = me.icn3d.getResiduesFromCalphaAtoms(selectedAtoms);

       var cssColorArray = [];
       for(var i = 0, il = me.giSeq[chainid].length; i < il; ++i) {
          var cFull = me.giSeq[chainid][i];

          var c = cFull;
          if(cFull.length > 1) {
              //c = cFull[0] + '..';
              c = cFull[0]; // one letter for each residue
          }

          var pos = (i >= me.matchedPos[chainid] && i - me.matchedPos[chainid] < me.icn3d.chainsSeq[chainid].length) ? me.icn3d.chainsSeq[chainid][i - me.matchedPos[chainid]].resi : me.baseResi[chainid] + 1 + i;

          if( residueHash.hasOwnProperty(chainid + '_' + pos) ) {
              var atom = me.icn3d.getFirstCalphaAtomObj(me.icn3d.residues[chainid + '_' + pos]);
              var color = atom.color.getHexString();

              text += c;
              cssColorArray.push('#' + color);
          }
          else {
              text += '-';
              cssColorArray.push('');
          }
       }

       me.showNewTrack(chainid, title, text, cssColorArray);

       me.setLogCmd("add track | chainid " + chainid + " | title " + title + " | text " + me.simplifyText(text), true);
    });

};

iCn3DUI.prototype.showNewTrack = function(chnid, title, text, cssColorArray, target2queryHash) {  var me = this;
    //if(me.customTracks[chnid] === undefined) {
    //    me.customTracks[chnid] = {};
    //}

    var bErrorMess = false;
    if(text == 'cannot be aligned') {
        bErrorMess = true;
    }

    var textForCnt = text.replace(/-/g, '');
    var resCnt = textForCnt.length;
    if(resCnt > me.giSeq[chnid].length) {
        resCnt = me.giSeq[chnid].length;
    }

    if(text.length > me.giSeq[chnid].length) {
        text = text.substr(0, me.giSeq[chnid].length);
    }
    else if(text.length < me.giSeq[chnid].length && !bErrorMess) {
        // .fill is not supported in IE
        //var extra = Array(me.giSeq[chnid].length - text.length).fill(' ').join('');
        var extra = '';
        for(var i = 0, il = me.giSeq[chnid].length - text.length; i < il; ++i) {
            extra += '-';
        }

        text += extra;
    }

    var simpTitle = title.replace(/\s/g, '_').replace(/\./g, 'dot').replace(/\W/g, '');
    if(simpTitle.length > 20) simpTitle = simpTitle.substr(0, 20);

    //me.customTracks[chnid][simpTitle] = text;

    var divLength = me.RESIDUE_WIDTH * text.length + 200;

    $("#" + me.pre + "dt_custom_" + chnid).append("<div id='" + me.pre + "dt_custom_" + chnid + "_" + simpTitle + "'></div>");
    $("#" + me.pre + "dt_custom_" + chnid + "_" + simpTitle).width(divLength);

    $("#" + me.pre + "ov_custom_" + chnid).append("<div id='" + me.pre + "ov_custom_" + chnid + "_" + simpTitle + "'></div>");
    $("#" + me.pre + "ov_custom_" + chnid + "_" + simpTitle).width(divLength);

    $("#" + me.pre + "tt_custom_" + chnid).append("<div id='" + me.pre + "tt_custom_" + chnid + "_" + simpTitle + "'></div>");
    $("#" + me.pre + "tt_custom_" + chnid + "_" + simpTitle).width(divLength);

    var html = '<div id="' + me.pre + 'giseq_sequence" class="icn3d-dl_sequence">';
    var html2 = html;
    var html3 = html;

    //var htmlTmp2 = '<div class="icn3d-seqTitle icn3d-link icn3d-blue" gi="' + chnid + '" anno="sequence" chain="' + chnid + '"><span style="white-space:nowrap;">' + title + '</span></div>';
    var htmlTmp2 = '<div class="icn3d-seqTitle" gi="' + chnid + '" anno="sequence" chain="' + chnid + '"><span style="white-space:nowrap;">' + title + '</span></div>';
    var htmlTmp3 = '<span class="icn3d-residueNum" title="residue count">' + resCnt.toString() + ' Pos</span>';

    html3 += htmlTmp2 + htmlTmp3 + '<br>';

    var htmlTmp = '<span class="icn3d-seqLine">';

    html += htmlTmp2 + htmlTmp3 + htmlTmp;
    html2 += htmlTmp2 + htmlTmp3 + htmlTmp;

    //var pre ='cst' + me.customTracks[chnid].length;
    var posTmp = chnid.indexOf('_');
    var pre ='cst' + chnid.substr(posTmp);

    var prevEmptyWidth = 0;
    var prevLineWidth = 0;
    var widthPerRes = 1;

    for(var i = 0, il = text.length; i < il; ++i) {
      html += me.insertGap(chnid, i, '-');

      var c = text.charAt(i);

      if(c != ' ' && c != '-') {
          //var pos = me.icn3d.chainsSeq[chnid][i - me.matchedPos[chnid] ].resi;
          var pos = me.icn3d.chainsSeq[chnid][i].resi - me.matchedPos[chnid];

          if(target2queryHash !== undefined) pos = target2queryHash[i] + 1; // 0-based

          if(cssColorArray !== undefined && cssColorArray[i] != '') {
              html += '<span id="' + pre + '_' + me.pre + chnid + '_' + pos + '" title="' + c + pos + '" class="icn3d-residue" style="color:' + cssColorArray[i] + '">' + c + '</span>';
          }
          else {
              html += '<span id="' + pre + '_' + me.pre + chnid + '_' + pos + '" title="' + c + pos + '" class="icn3d-residue">' + c + '</span>';
          }

          html2 += me.insertGapOverview(chnid, i);

          var emptyWidth = (me.cfg.blast_rep_id == chnid) ? Math.round(me.seqAnnWidth * i / (me.maxAnnoLength + me.nTotalGap) - prevEmptyWidth - prevLineWidth) : Math.round(me.seqAnnWidth * i / me.maxAnnoLength - prevEmptyWidth - prevLineWidth);
          if(emptyWidth < 0) emptyWidth = 0;

          html2 += '<div style="display:inline-block; width:' + emptyWidth + 'px;">&nbsp;</div>';
          if(cssColorArray !== undefined && cssColorArray[i] != '') {
              html2 += '<div style="display:inline-block; background-color:' + cssColorArray[i] + '; width:' + widthPerRes + 'px;" title="' + c + (i+1).toString() + '">&nbsp;</div>';
          }
          else {
              html2 += '<div style="display:inline-block; background-color:#333; width:' + widthPerRes + 'px;" title="' + c + (i+1).toString() + '">&nbsp;</div>';
          }

          prevEmptyWidth += emptyWidth;
          prevLineWidth += widthPerRes;
      }
      else {
          if(bErrorMess) {
              html += '<span>' + c + '</span>';
          }
          else {
            html += '<span>-</span>';
          }
      }
    }
    var htmlTmp = '<span class="icn3d-residueNum" title="residue count">' + resCnt.toString() + ' Pos</span>';
    htmlTmp += '</span>';
    htmlTmp += '<br>';

    htmlTmp += '</div>';

    html += htmlTmp;
    html2 += htmlTmp;

    html3 += '</div>';

    $("#" + me.pre + "dt_custom_" + chnid + "_" + simpTitle).html(html);
    $("#" + me.pre + "ov_custom_" + chnid + "_" + simpTitle).html(html2);
    $("#" + me.pre + "tt_custom_" + chnid + "_" + simpTitle).html(html3);
};

iCn3DUI.prototype.checkGiSeq = function (chainid, title, text, index) { var me = this;
    if(index > 20) return false;

    if(me.giSeq !== undefined && me.giSeq[chainid] !== undefined) {
        text = me.getFullText(text);
        me.showNewTrack(chainid, title, text);
        return false;
    }

    // wait for me.giSeq to be available
    setTimeout(function(){ me.checkGiSeq(chainid, title, text, index + 1); }, 100);
};

iCn3DUI.prototype.getFullText = function (text) { var me = this;
    var out = '';

    var textArray = text.split(',');
    var lastTextPos = -1;
    for(var i = 0, il = textArray.length; i < il; ++i) {
        var eachText = textArray[i].trim();
        if(eachText.length == 0) continue;

        var range_text = eachText.split(' ');
        if(range_text.length !== 2) continue;

        var rangeText = range_text[1];
        var start_end = range_text[0].split('-');

        var start, end;
        if(start_end.length == 2) {
            start = start_end[0] - 1; // 1-based
            end = start_end[1] - 1;
        }
        else if(start_end.length == 1) {
            start = start_end[0] - 1;
            end = start;
        }
        else {
            continue;
        }

        // previous empty text
        for(var j = 0; j < start - lastTextPos - 1; ++j) {
            out += '-';
        }

        var range = end - start + 1;

        if(rangeText.length > range) {
             out += rangeText.substr(0, range);
        }
        else {
             out += rangeText;
        }

        // fill up rangeText
        for(var j = 0; j < range - rangeText.length; ++j) {
            out += '-';
        }

        lastTextPos = end;
    }

    return out;
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3DUI.prototype.clickShow_selected = function() { var me = this;
    $("#" + me.pre + "show_selected").add("#" + me.pre + "mn2_show_selected").click(function(e) {
       //me.setLogCmd("show selection", true);

       me.showSelection();
       me.setLogCmd("show selection", true);
    });
};

iCn3DUI.prototype.showSelection = function (id) { var me = this;
    me.icn3d.dAtoms = {};

    me.icn3d.dAtoms = me.icn3d.cloneHash(me.icn3d.hAtoms);

    var centerAtomsResults = me.icn3d.centerAtoms(me.icn3d.hash2Atoms(me.icn3d.dAtoms));
    me.icn3d.maxD = centerAtomsResults.maxD;
    if (me.icn3d.maxD < 5) me.icn3d.maxD = 5;

    //show selected rotationcenter
    me.icn3d.opts['rotationcenter'] = 'display center';

    // clear hbonds and ssbonds?
    //me.icn3d.opts['hbonds'] = 'no';
    //me.icn3d.opts['ssbonds'] = 'no';

    //me.icn3d.lines['hbond'] = [];
    //me.icn3d.lines['ssbond'] = [];

    me.saveSelectionIfSelected();

    me.icn3d.draw();

    me.update2DdgmContent();
    me.updateHl2D();

    // show selected chains in annotation window
    me.showAnnoSelectedChains();
};

iCn3DUI.prototype.clickModeswitch = function() { var me = this;
    $("#" + me.pre + "modeswitch").click(function (e) {
        if($("#" + me.pre + "modeswitch")[0].checked) { // mode: selection
            me.setModeAndDisplay('selection');
        }
        else { // mode: all
            me.setModeAndDisplay('all');
        }
    });

    $("#" + me.pre + "mn6_modeall").click(function (e) {
        me.setModeAndDisplay('all');
    });

    $("#" + me.pre + "mn6_modeselection").click(function (e) {
        me.setModeAndDisplay('selection');
    });
};

iCn3DUI.prototype.selectAll = function() { var me = this;
    me.icn3d.hAtoms = {};

    for(var i in me.icn3d.chains) {
       me.icn3d.hAtoms = me.icn3d.unionHash(me.icn3d.hAtoms, me.icn3d.chains[i]);
       me.icn3d.dAtoms = me.icn3d.unionHash(me.icn3d.dAtoms, me.icn3d.chains[i]);
    }

    me.icn3d.removeHlObjects();
    me.removeHl2D();
    me.removeHlMenus();

    me.bSelectResidue = false;
    me.bSelectAlignResidue = false;

    me.removeSeqResidueBkgd();
    me.update2DdgmContent();

    // show annotations for all protein chains
    $("#" + me.pre + "dl_annotations > .icn3d-annotation").show();

    me.setMode('all');
};

iCn3DUI.prototype.setModeAndDisplay = function(mode) { var me = this;
    if(mode === 'all') { // mode all
        me.setMode('all');

        // remember previous selection
        me.icn3d.prevHighlightAtoms = me.icn3d.cloneHash(me.icn3d.hAtoms);

       // select all
       me.setLogCmd("set mode all", true);

       me.selectAll();

       me.icn3d.draw();
    }
    else { // mode selection
        me.setMode('selection');

        // get the previous hAtoms
        if(me.icn3d.prevHighlightAtoms !== undefined) {
            me.icn3d.hAtoms = me.icn3d.cloneHash(me.icn3d.prevHighlightAtoms);
        }
        else {
            me.selectAll();
        }

        me.setLogCmd("set mode selection", true);

        me.updateHlAll();
    }
};

iCn3DUI.prototype.setMode = function(mode) { var me = this;
    if(mode === 'all') { // mode all
        // set text
        $("#" + me.pre + "modeall").show();
        $("#" + me.pre + "modeselection").hide();

        $("#" + me.pre + "modeswitch")[0].checked = false;

        if($("#" + me.pre + "style").hasClass('icn3d-modeselection')) $("#" + me.pre + "style").removeClass('icn3d-modeselection');
        if($("#" + me.pre + "color").hasClass('icn3d-modeselection')) $("#" + me.pre + "color").removeClass('icn3d-modeselection');
        //if($("#" + me.pre + "surface").hasClass('icn3d-modeselection')) $("#" + me.pre + "surface").removeClass('icn3d-modeselection');
    }
    else { // mode selection
        //if(Object.keys(me.icn3d.hAtoms).length < Object.keys(me.icn3d.atoms).length) {
            // set text
            $("#" + me.pre + "modeall").hide();
            $("#" + me.pre + "modeselection").show();

            $("#" + me.pre + "modeswitch")[0].checked = true;

            if(!$("#" + me.pre + "style").hasClass('icn3d-modeselection')) $("#" + me.pre + "style").addClass('icn3d-modeselection');
            if(!$("#" + me.pre + "color").hasClass('icn3d-modeselection')) $("#" + me.pre + "color").addClass('icn3d-modeselection');
            //if(!$("#" + me.pre + "surface").hasClass('icn3d-modeselection')) $("#" + me.pre + "surface").addClass('icn3d-modeselection');

            // show selected chains in annotation window
            //me.showAnnoSelectedChains();
        //}
    }
};

iCn3DUI.prototype.saveSelection = function(name, description) { var me = this;
    me.selectedResidues = {};

    //for(var i in me.icn3d.hAtoms) {
    //  if(me.icn3d.hAtoms[i] !== undefined) {
    //    var residueid = me.icn3d.atoms[i].structure + '_' + me.icn3d.atoms[i].chain + '_' + me.icn3d.atoms[i].resi;
    //    me.selectedResidues[residueid] = 1;
    //  }
    //}

    me.selectedResidues = me.icn3d.getResiduesFromCalphaAtoms(me.icn3d.hAtoms);

    if(Object.keys(me.selectedResidues).length > 0) {
        me.selectResidueList(me.selectedResidues, name, description);
        //me.updateHlAll();

        me.updateSelectionNameDesc();

        //me.setLogCmd('select ' + me.residueids2spec(Object.keys(me.selectedResidues)) + ' | name ' + name + ' | description ' + description, true);
        me.setLogCmd('select ' + me.residueids2spec(Object.keys(me.selectedResidues)) + ' | name ' + name, true);
    }
};

iCn3DUI.prototype.removeSelection = function() { var me = this;
    if(!me.bAnnotations) {
        me.removeSeqChainBkgd();
    }
    //else {
    //    me.removeSeqChainBkgd();
    //}

    if(!me.icn3d.bCtrl && !me.icn3d.bShift) {
        me.removeSeqResidueBkgd();

        me.removeSeqChainBkgd();
    }

//      me.removeSeqChainBkgd();
//      me.removeSeqResidueBkgd();

      me.selectedResidues = {};
      me.bSelectResidue = false;

      me.icn3d.hAtoms = {};

      me.icn3d.removeHlObjects();

      me.removeHl2D();
};

iCn3DUI.prototype.updateSelectionNameDesc = function() { var me = this;
    var numDef = Object.keys(me.icn3d.defNames2Residues).length + Object.keys(me.icn3d.defNames2Atoms).length;

    $("#" + me.pre + "seq_command_name").val("seq_" + numDef);
    //$("#" + me.pre + "seq_command_desc").val("seq_desc_" + numDef);

    $("#" + me.pre + "seq_command_name2").val("seq_" + numDef);
    //$("#" + me.pre + "seq_command_desc2").val("seq_desc_" + numDef);

    $("#" + me.pre + "alignseq_command_name").val("alseq_" + numDef);
    //$("#" + me.pre + "alignseq_command_desc").val("alseq_desc_" + numDef);
};

iCn3DUI.prototype.selectAChain = function (chainid, commandname, bAlign, bUnion) { var me = this;
    var commandname = commandname.replace(/\s/g, '');
    var command = (bAlign !== undefined || bAlign) ? 'select alignChain ' + chainid : 'select chain ' + chainid;

    //var residueHash = {}, chainHash = {};

    if(bUnion === undefined || !bUnion) {
        me.icn3d.hAtoms = {};
        me.menuHlHash = {};
    }
    else {
        me.icn3d.hAtoms = me.icn3d.unionHash(me.icn3d.hAtoms, me.icn3d.chains[chainid]);

        if(me.menuHlHash === undefined) me.menuHlHash = {};
    }

    me.menuHlHash[chainid] = 1;

    //chainHash[chainid] = 1;

    var chnsSeq = (bAlign) ? me.icn3d.alnChainsSeq[chainid] : me.icn3d.chainsSeq[chainid];

    var oriResidueHash = {};
    for(var i = 0, il = chnsSeq.length; i < il; ++i) { // get residue number
        var resObj = chnsSeq[i];
        var residueid = chainid + "_" + resObj.resi;

        var value = resObj.name;

        if(value !== '' && value !== '-') {
          oriResidueHash[residueid] = 1;
          for(var j in me.icn3d.residues[residueid]) {
            me.icn3d.hAtoms[j] = 1;
          }
        }
    }

    if((me.icn3d.defNames2Atoms === undefined || !me.icn3d.defNames2Atoms.hasOwnProperty(chainid)) && (me.icn3d.defNames2Residues === undefined || !me.icn3d.defNames2Residues.hasOwnProperty(chainid)) ) {
        me.addCustomSelection(Object.keys(oriResidueHash), commandname, commandname, command, true);
    }

    var bForceHighlight = true;

    if(bAlign) {
        me.updateHlAll(undefined, undefined, bUnion, bForceHighlight);
    }
    else {
        me.updateHlAll(Object.keys(me.menuHlHash), undefined, bUnion, bForceHighlight);
    }

//        me.icn3d.addHlObjects();
//        me.updateHl2D(Object.keys(chainHash));
};

iCn3DUI.prototype.selectResidueList = function (residueHash, commandname, commanddescr, bUnion, bUpdateHighlight) { var me = this;
  if(Object.keys(residueHash).length > 0) {
    var chainHash = {};
    if(bUnion === undefined || !bUnion) {
        me.icn3d.hAtoms = {};
        me.menuHlHash = {};
    }
    else {
        if(me.menuHlHash === undefined) me.menuHlHash = {};
    }

    for(var i in residueHash) {
        for(var j in me.icn3d.residues[i]) {
          me.icn3d.hAtoms[j] = 1;
        }
    }

    var commandname = commandname.replace(/\s/g, '');

    me.menuHlHash[commandname] = 1;

    var select = "select " + me.residueids2spec(Object.keys(residueHash));

    var oriResidueArray = Object.keys(residueHash);

    //if( (me.icn3d.defNames2Atoms === undefined || !me.icn3d.defNames2Atoms.hasOwnProperty(commandname)) && (me.icn3d.defNames2Residues === undefined || !me.icn3d.defNames2Residues.hasOwnProperty(commandname)) ) {
        me.addCustomSelection(oriResidueArray, commandname, commanddescr, select, true);
    //}

    if(bUpdateHighlight === undefined || bUpdateHighlight) me.updateHlAll(Object.keys(me.menuHlHash), undefined, bUnion);
  }
};

iCn3DUI.prototype.addCustomSelection = function (residueAtomArray, commandname, commanddesc, select, bSelectResidues) { var me = this;
    if(bSelectResidues) {
        me.icn3d.defNames2Residues[commandname] = residueAtomArray;
    }
    else {
        me.icn3d.defNames2Atoms[commandname] = residueAtomArray;
    }

    me.icn3d.defNames2Command[commandname] = select;
    me.icn3d.defNames2Descr[commandname] = commanddesc;

    me.updateHlMenus([commandname]);
};

iCn3DUI.prototype.selectSideChains = function () { var me = this;
    var currHAtoms = me.icn3d.cloneHash(me.icn3d.hAtoms);

    me.icn3d.hAtoms = {};
    for(var i in currHAtoms) {
        if(me.icn3d.proteins.hasOwnProperty(i) && me.icn3d.atoms[i].name !== 'CA') {
            me.icn3d.hAtoms[i] = 1;
        }
    }

    me.showHighlight();
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3DUI.prototype.clickCommand_apply = function() { var me = this;
    $("#" + me.pre + "command_apply").click(function(e) {
       e.preventDefault();

       var select = $("#" + me.pre + "command").val();

       var commandname = $("#" + me.pre + "command_name").val().replace(/;/g, '_').replace(/\s+/g, '_');
       //var commanddesc = $("#" + me.pre + "command_desc").val().replace(/;/g, '_').replace(/\s+/g, '_');

       me.selectByCommand(select, commandname, commandname);
       //me.setLogCmd('select ' + select + ' | name ' + commandname + ' | description ' + commanddesc, true);
       me.setLogCmd('select ' + select + ' | name ' + commandname, true);
    });

    $("#" + me.pre + "command_apply2").click(function(e) {
       e.preventDefault();

       var select = $("#" + me.pre + "command2").val();

       var commandname = $("#" + me.pre + "command_name2").val().replace(/;/g, '_').replace(/\s+/g, '_');
       //var commanddesc = $("#" + me.pre + "command_desc").val().replace(/;/g, '_').replace(/\s+/g, '_');

       me.selectByCommand(select, commandname, commandname);
       //me.setLogCmd('select ' + select + ' | name ' + commandname + ' | description ' + commanddesc, true);
       me.setLogCmd('select ' + select + ' | name ' + commandname, true);
    });

};

iCn3DUI.prototype.selectCombinedSets = function(strSets, commandname) { var me = this;
    var idArray = strSets.split(' ');

    var orArray = [], andArray = [], notArray = [];
    var prevLabel = 'or';

    for(var i = 0, il = idArray.length; i < il; ++i) {
        if(idArray[i] === 'or' || idArray[i] === 'and' || idArray[i] === 'not') {
            prevLabel = idArray[i];
            continue;
        }
        else {
            if(prevLabel === 'or') {
                orArray.push(idArray[i]);
            }
            else if(prevLabel === 'and') {
                andArray.push(idArray[i]);
            }
            else if(prevLabel === 'not') {
                notArray.push(idArray[i]);
            }
        }
    }

    if(idArray !== null) me.combineSets(orArray, andArray, notArray, commandname);
};

iCn3DUI.prototype.selectByCommand = function (select, commandname, commanddesc) { var me = this;
       if(select.indexOf('saved atoms') === 0) {
            var pos = 12; // 'saved atoms '
            var strSets = select.substr(pos);

            me.selectCombinedSets(strSets, commandname);
       }
       else {
           var selectTmp = select.replace(/ AND /g, ' and ').replace(/ OR /g, ' or ').replace(/ or and /g, ' and ').replace(/ and /g, ' or and ').replace(/ or not /g, ' not ').replace(/ not /g, ' or not ');

           var commandStr = (selectTmp.trim().substr(0, 6) === 'select') ? selectTmp.trim().substr(7) : selectTmp.trim();

           // each select command may have several commands separated by ' or '
           var commandArray = commandStr.split(' or ');
           var allHighlightAtoms = {};

           for(var i = 0, il = commandArray.length; i < il; ++i) {
               var command = commandArray[i].trim().replace(/\s+/g, ' ');
               var pos = command.indexOf(' ');

               me.icn3d.hAtoms = {};

               if(command.substr(0, pos).toLowerCase() === 'and') { // intersection
                       me.applyCommand('select ' + command.substr(pos + 1));

                       allHighlightAtoms = me.icn3d.intHash(allHighlightAtoms, me.icn3d.hAtoms);
               }
               else if(command.substr(0, pos).toLowerCase() === 'not') { // negation
                       me.applyCommand('select ' + command.substr(pos + 1));

                       allHighlightAtoms = me.icn3d.exclHash(allHighlightAtoms, me.icn3d.hAtoms);
               }
               else { // union
                       me.applyCommand('select ' + command);

                       allHighlightAtoms = me.icn3d.unionHash(allHighlightAtoms, me.icn3d.hAtoms);
               }
           }

           me.icn3d.hAtoms = me.icn3d.cloneHash(allHighlightAtoms);

           var atomArray = Object.keys(me.icn3d.hAtoms);
           var residueArray = undefined;

           if(commandname !== "") {
               me.addCustomSelection(atomArray, commandname, commanddesc, select, false);

               var nameArray = [commandname];
               //me.changeCustomResidues(nameArray);

               me.changeCustomAtoms(nameArray);
           }
       }
};

iCn3DUI.prototype.selectBySpec = function (select, commandname, commanddesc, bDisplay) { var me = this;
   select = (select.trim().substr(0, 6) === 'select') ? select.trim().substr(7) : select.trim();

   me.icn3d.hAtoms = {};

   // selection definition is similar to Chimera: https://www.cgl.ucsf.edu/chimera/docs/UsersGuide/midas/frameatom_spec.html
   // There will be no ' or ' in the spec. It's already separated in selectByCommand()
   // There could be ' and ' in the spec.
   var commandArray = select.replace(/\s+/g, ' ').replace(/ AND /g, ' and ').split(' and ');

   var residueHash = {};
   var atomHash = {};

   var bSelectResidues = true;
   for(var i = 0, il=commandArray.length; i < il; ++i) {
       //$1,2,3.A,B,C:5-10,LYS,chemicals@CA,C
       // $1,2,3: Structure
       // .A,B,C: chain
       // :5-10,LYS,chemicals: residues, could be 'proteins', 'nucleotides', 'chemicals', 'ions', and 'water'
       // @CA,C: atoms
       // wild card * can be used to select all
       //var currHighlightAtoms = {};

       var dollarPos = commandArray[i].indexOf('$');
       var periodPos = commandArray[i].indexOf('.');
       var colonPos = commandArray[i].indexOf(':');
       var atPos = commandArray[i].indexOf('@');

       var moleculeStr, chainStr, residueStr, atomStr;
       var testStr = commandArray[i];

       if(atPos === -1) {
         atomStr = "*";
       }
       else {
         atomStr = testStr.substr(atPos + 1);
         testStr = testStr.substr(0, atPos);
       }

       if(colonPos === -1) {
         residueStr = "*";
       }
       else {
         residueStr = testStr.substr(colonPos + 1);
         testStr = testStr.substr(0, colonPos);
       }

       if(periodPos === -1) {
         chainStr = "*";
       }
       else {
         chainStr = testStr.substr(periodPos + 1);
         testStr = testStr.substr(0, periodPos);
       }

       if(dollarPos === -1) {
         moleculeStr = "*";
       }
       else {
         moleculeStr = testStr.substr(dollarPos + 1);
         testStr = testStr.substr(0, dollarPos);
       }

       if(atomStr !== '*') {
         bSelectResidues = false; // selected atoms
       }

       var molecule, chain, molecule_chain, moleculeArray=[], Molecule_ChainArray=[], start, end;

       if(moleculeStr === '*') {
         moleculeArray = Object.keys(me.icn3d.structures);
       }
       else {
         moleculeArray = moleculeStr.split(",")
       }

       if(chainStr === '*') {
         var tmpArray = Object.keys(me.icn3d.chains);  // 1_A (molecule_chain)

         for(var j = 0, jl = tmpArray.length; j < jl; ++j) {
           molecule_chain = tmpArray[j];

           molecule = molecule_chain.substr(0, molecule_chain.indexOf('_'));
           if(moleculeArray.toString().toLowerCase().indexOf(molecule.toLowerCase()) !== -1) {
             Molecule_ChainArray.push(molecule_chain);
           }
         }
       }
       else {
         for(var j = 0, jl = moleculeArray.length; j < jl; ++j) {
           molecule = moleculeArray[j];

           var chainArray = chainStr.split(",");
           for(var k in chainArray) {
             Molecule_ChainArray.push(molecule + '_' + chainArray[k]);
           }
         }
       }

       var residueStrArray = residueStr.split(',');
       for(var j = 0, jl = residueStrArray.length; j < jl; ++j) {
           var bResidueId = false;

           var hyphenPos = residueStrArray[j].indexOf('-');

           var oneLetterResidueStr;
           var bAllResidues = false;
           var bResidueArray = false;

           if(hyphenPos !== -1) {
             start = residueStrArray[j].substr(0, hyphenPos);
             end = residueStrArray[j].substr(hyphenPos+1);
             bResidueId = true;
           }
           else {
             if(residueStrArray[j] !== '' && !isNaN(residueStrArray[j])) { // residue id
               start = residueStrArray[j];
               end = start;
               bResidueId = true;
             }
             else if(residueStrArray[j] === '*') { // all resiues
               bAllResidues = true;
             }
             else if(residueStrArray[j] !== 'proteins' && residueStrArray[j] !== 'nucleotides' && residueStrArray[j] !== 'chemicals' && residueStrArray[j] !== 'ions' && residueStrArray[j] !== 'water') { // residue name
               var tmpStr = residueStrArray[j].toUpperCase();
               //oneLetterResidue = (residueStrArray[j].length === 1) ? tmpStr : me.icn3d.residueName2Abbr(tmpStr);
               oneLetterResidueStr = tmpStr;
               bResidueArray = true;
             }
           }

           for(var mc = 0, mcl = Molecule_ChainArray.length; mc < mcl; ++mc) {
             molecule_chain = Molecule_ChainArray[mc];

             if(bResidueId) {
               for(var k = parseInt(start); k <= parseInt(end); ++k) {
                 var residueId = molecule_chain + '_' + k;
                 if(i === 0) {
                      residueHash[residueId] = 1;
                 }
                 else {
                     // if not exit previously, "and" operation will remove this one
                     //if(!residueHash.hasOwnProperty(residueId)) residueHash[residueId] = undefined;
                     if(!residueHash.hasOwnProperty(residueId)) delete residueHash[residueId];
                 }

                 for(var m in me.icn3d.residues[residueId]) {
                   if(atomStr === '*' || atomStr === me.icn3d.atoms[m].name) {
                     if(i === 0) {
                         //currHighlightAtoms[m] = 1;
                         atomHash[m] = 1;
                     }
                     else {
                         //if(!currHighlightAtoms.hasOwnProperty(m)) currHighlightAtoms[m] = undefined;
                         //if(!atomHash.hasOwnProperty(m)) atomHash[m] = undefined;
                         if(!atomHash.hasOwnProperty(m)) delete atomHash[m];
                     }
                   }
                 }
               }
             }
             else {
               if(molecule_chain in me.icn3d.chains) {
                 var chainAtomHash = me.icn3d.chains[molecule_chain];
                 for(var m in chainAtomHash) {
                   // residue could also be 'proteins', 'nucleotides', 'chemicals', 'ions', and 'water'
                   var tmpStr = me.icn3d.atoms[m].resn.substr(0,3).toUpperCase();
                   if(bAllResidues
                       //|| me.icn3d.residueName2Abbr(tmpStr) === oneLetterResidue
                       || (residueStrArray[j] === 'proteins' && m in me.icn3d.proteins)
                       || (residueStrArray[j] === 'nucleotides' && m in me.icn3d.nucleotides)
                       || (residueStrArray[j] === 'chemicals' && m in me.icn3d.chemicals)
                       || (residueStrArray[j] === 'ions' && m in me.icn3d.ions)
                       || (residueStrArray[j] === 'water' && m in me.icn3d.water)
                       ) {
                     // many duplicates
                     if(i === 0) {
                         residueHash[molecule_chain + '_' + me.icn3d.atoms[m].resi] = 1;
                     }
                     else {
                         var residTmp = molecule_chain + '_' + me.icn3d.atoms[m].resi;
                         //if(!residueHash.hasOwnProperty(residTmp)) residueHash[residTmp] = undefined;
                         if(!residueHash.hasOwnProperty(residTmp)) delete residueHash[residTmp];
                     }

                     if(atomStr === '*' || atomStr === me.icn3d.atoms[m].name) {
                         if(i === 0) {
                             //currHighlightAtoms[m] = 1;
                             atomHash[m] = 1;
                         }
                         else {
                             //if(!currHighlightAtoms.hasOwnProperty(m)) currHighlightAtoms[m] = undefined;
                             //if(!atomHash.hasOwnProperty(m)) atomHash[m] = undefined;
                             if(!atomHash.hasOwnProperty(m)) delete atomHash[m];
                         }
                     }

                   }
                 } // end for(var m in atomHash) {

                 if(bResidueArray) {
                   //oneLetterResidueStr.length;
                   var chainSeq = '', resiArray = [];
                   for(var s = 0, sl = me.icn3d.chainsSeq[molecule_chain].length; s < sl;  ++s) {
                       chainSeq += (me.icn3d.chainsSeq[molecule_chain][s].name.length == 1) ? me.icn3d.chainsSeq[molecule_chain][s].name : me.icn3d.chainsSeq[molecule_chain][s].name.substr(0, 1);
                       resiArray.push(me.icn3d.chainsSeq[molecule_chain][s].resi);
                   }

                   chainSeq = chainSeq.toUpperCase();

                   var seqReg = oneLetterResidueStr.replace(/x/gi, ".");
                   var posArray = [];

                   var searchReg = new RegExp(seqReg, 'i');

                   var targetStr = chainSeq;
                   var pos = targetStr.search(searchReg);
                   var sumPos = pos;
                   while(pos !== -1) {
                       posArray.push(sumPos);
                       targetStr = targetStr.substr(pos + 1);
                       pos = targetStr.search(searchReg);
                       sumPos += pos + 1;
                   }

                   for(var s = 0, sl = posArray.length; s < sl; ++s) {
                       var pos = posArray[s];

                       for(var t = 0, tl = oneLetterResidueStr.length; t < tl;  ++t) {
                         var residueId = molecule_chain + '_' + resiArray[t + pos];
                         if(i === 0) {
                             residueHash[residueId] = 1;
                         }
                         else {
                             //if(!residueHash.hasOwnProperty(residueId)) residueHash[residueId] = undefined;
                             if(!residueHash.hasOwnProperty(residueId)) delete residueHash[residueId];
                         }

                         for(var m in me.icn3d.residues[residueId]) {
                           if(atomStr === '*' || atomStr === me.icn3d.atoms[m].name) {
                             if(i === 0) {
                                 //currHighlightAtoms[m] = 1;
                                 atomHash[m] = 1;
                             }
                             else {
                                 //if(!currHighlightAtoms.hasOwnProperty(m)) currHighlightAtoms[m] = undefined;
                                 //if(!atomHash.hasOwnProperty(m)) atomHash[m] = undefined;
                                 if(!atomHash.hasOwnProperty(m)) delete atomHash[m];
                             }
                           }
                         }
                       } // for
                   } // end for(s = 0
                 }
               } // end if(molecule_chain
             } // end else
           } // end for(var mc = 0
       } // for (j
/*
       if(i === 0) {
           me.icn3d.hAtoms = me.icn3d.cloneHash(currHighlightAtoms);
       }
       else {
           me.icn3d.hAtoms = me.icn3d.intHash(me.icn3d.hAtoms, currHighlightAtoms);
       }
*/
   }  // for (i

   me.icn3d.hAtoms = me.icn3d.cloneHash(atomHash);

   if(bDisplay === undefined || bDisplay) me.updateHlAll();

   var residueAtomArray;
   if(bSelectResidues) {
       residueAtomArray = Object.keys(residueHash);
   }
   else {
       residueAtomArray = Object.keys(atomHash);
   }

//   if(commandname == "") commandname = "tmp_" + select;

   if(commandname != "") {
       me.addCustomSelection(residueAtomArray, commandname, commanddesc, select, bSelectResidues);

       var nameArray = [commandname];
       me.changeCustomAtoms(nameArray);
   }
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3DUI.prototype.showSets = function() { var me = this;
    me.openDialog(me.pre + 'dl_definedsets', 'Select sets');
    $("#" + me.pre + "dl_setsmenu").show();
    $("#" + me.pre + "dl_setoperations").show();
    $("#" + me.pre + "dl_command").hide();

    $("#" + me.pre + "atomsCustom").resizable();

    if(me.bSetChainsAdvancedMenu === undefined || !me.bSetChainsAdvancedMenu) {
       me.setPredefinedInMenu();

       me.bSetChainsAdvancedMenu = true;
    }

    me.updateHlMenus();
};

iCn3DUI.prototype.clickCustomAtoms = function() { var me = this;
    $("#" + me.pre + "atomsCustom").change(function(e) {
       var nameArray = $(this).val();

       if(nameArray !== null) {
         // log the selection
         //me.setLogCmd('select saved atoms ' + nameArray.toString(), true);

         var bUpdateHlMenus = false;
         me.changeCustomAtoms(nameArray, bUpdateHlMenus);
         me.setLogCmd('select saved atoms ' + nameArray.join(' ' + me.setOperation + ' '), true);

         me.bSelectResidue = false;
       }
    });

    $("#" + me.pre + "atomsCustom").focus(function(e) {
       if(me.isMobile()) $("#" + me.pre + "atomsCustom").val("");
    });
};

iCn3DUI.prototype.deleteSelectedSets = function() { var me = this;
   var nameArray = $("#" + me.pre + "atomsCustom").val();

   for(var i = 0; i < nameArray.length; ++i) {
     var selectedSet = nameArray[i];

     if((me.icn3d.defNames2Atoms === undefined || !me.icn3d.defNames2Atoms.hasOwnProperty(selectedSet)) && (me.icn3d.defNames2Residues === undefined || !me.icn3d.defNames2Residues.hasOwnProperty(selectedSet)) ) continue;

     if(me.icn3d.defNames2Atoms !== undefined && me.icn3d.defNames2Atoms.hasOwnProperty(selectedSet)) {
         delete me.icn3d.defNames2Atoms[selectedSet];
     }

     if(me.icn3d.defNames2Residues !== undefined && me.icn3d.defNames2Residues.hasOwnProperty(selectedSet)) {
         delete me.icn3d.defNames2Residues[selectedSet];
     }
   } // outer for

   me.updateHlMenus();
};

iCn3DUI.prototype.changeCustomAtoms = function (nameArray, bUpdateHlMenus) { var me = this;
   me.icn3d.hAtoms = {};

   for(var i = 0; i < nameArray.length; ++i) {
     var selectedSet = nameArray[i];

     if((me.icn3d.defNames2Atoms === undefined || !me.icn3d.defNames2Atoms.hasOwnProperty(selectedSet)) && (me.icn3d.defNames2Residues === undefined || !me.icn3d.defNames2Residues.hasOwnProperty(selectedSet)) ) continue;

     if(me.icn3d.defNames2Atoms !== undefined && me.icn3d.defNames2Atoms.hasOwnProperty(selectedSet)) {
         var atomArray = me.icn3d.defNames2Atoms[selectedSet];

         for(var j = 0, jl = atomArray.length; j < jl; ++j) {
             me.icn3d.hAtoms[atomArray[j]] = 1;
         }
     }

     if(me.icn3d.defNames2Residues !== undefined && me.icn3d.defNames2Residues.hasOwnProperty(selectedSet)) {
         var residueArrayTmp = me.icn3d.defNames2Residues[selectedSet];

         var atomHash = {};
         for(var j = 0, jl = residueArrayTmp.length; j < jl; ++j) {
             atomHash = me.icn3d.unionHash(atomHash, me.icn3d.residues[residueArrayTmp[j]]);
         }

         me.icn3d.hAtoms = me.icn3d.unionHash(me.icn3d.hAtoms, atomHash);
     }
   } // outer for

   me.updateHlAll(nameArray, bUpdateHlMenus);

   // show selected chains in annotation window
   me.showAnnoSelectedChains();

   // clear commmand
   $("#" + me.pre + "command").val("");
   $("#" + me.pre + "command_name").val("");
   //$("#" + me.pre + "command_desc").val("");

   // update the commands in the dialog
   for(var i = 0, il = nameArray.length; i < il; ++i) {
       var atomArray = me.icn3d.defNames2Atoms[nameArray[i]];
       var residueArray = me.icn3d.defNames2Residues[nameArray[i]];
       var atomTitle = me.icn3d.defNames2Descr[nameArray[i]];

       if(i === 0) {
         //$("#" + me.pre + "command").val(atomCommand);
         $("#" + me.pre + "command").val('saved atoms ' + nameArray[i]);
         $("#" + me.pre + "command_name").val(nameArray[i]);
       }
       else {
         var prevValue = $("#" + me.pre + "command").val();
         $("#" + me.pre + "command").val(prevValue + ' ' + me.setOperation + ' ' + nameArray[i]);

         var prevValue = $("#" + me.pre + "command_name").val();
         $("#" + me.pre + "command_name").val(prevValue + ' ' + me.setOperation + ' ' + nameArray[i]);
       }
   } // outer for
};

iCn3DUI.prototype.setHAtomsFromSets = function (nameArray, type) { var me = this;
   for(var i = 0; i < nameArray.length; ++i) {
     var selectedSet = nameArray[i];

     if((me.icn3d.defNames2Atoms === undefined || !me.icn3d.defNames2Atoms.hasOwnProperty(selectedSet)) && (me.icn3d.defNames2Residues === undefined || !me.icn3d.defNames2Residues.hasOwnProperty(selectedSet)) ) continue;

     if(me.icn3d.defNames2Atoms !== undefined && me.icn3d.defNames2Atoms.hasOwnProperty(selectedSet)) {
         var atomArray = me.icn3d.defNames2Atoms[selectedSet];

         if(type === 'or') {
             for(var j = 0, jl = atomArray.length; j < jl; ++j) {
                 me.icn3d.hAtoms[atomArray[j]] = 1;
             }
         }
         else if(type === 'and') {
             var atomHash = {};
             for(var j = 0, jl = atomArray.length; j < jl; ++j) {
                 atomHash[atomArray[j]] = 1;
             }

             me.icn3d.hAtoms = me.icn3d.intHash(me.icn3d.hAtoms, atomHash);
         }
         else if(type === 'not') {
             for(var j = 0, jl = atomArray.length; j < jl; ++j) {
                 me.icn3d.hAtoms[atomArray[j]] = undefined;
             }
         }
     }

     if(me.icn3d.defNames2Residues !== undefined && me.icn3d.defNames2Residues.hasOwnProperty(selectedSet)) {
         var residueArrayTmp = me.icn3d.defNames2Residues[selectedSet];

         var atomHash = {};
         for(var j = 0, jl = residueArrayTmp.length; j < jl; ++j) {
             atomHash = me.icn3d.unionHash(atomHash, me.icn3d.residues[residueArrayTmp[j]]);
         }

         if(type === 'or') {
             me.icn3d.hAtoms = me.icn3d.unionHash(me.icn3d.hAtoms, atomHash);
         }
         else if(type === 'and') {
             me.icn3d.hAtoms = me.icn3d.intHash(me.icn3d.hAtoms, atomHash);
         }
         else if(type === 'not') {
             me.icn3d.hAtoms = me.icn3d.exclHash(me.icn3d.hAtoms, atomHash);
         }
     }
   } // outer for
};

iCn3DUI.prototype.updateAdvancedCommands = function (nameArray, type) { var me = this;
   // update the commands in the dialog
   var separator = ' ' + type + ' ';
   for(var i = 0, il = nameArray.length; i < il; ++i) {
       if(i === 0 && type == 'or') {
         $("#" + me.pre + "command").val('saved atoms ' + nameArray[i]);
         $("#" + me.pre + "command_name").val(nameArray[i]);
       }
       else {
         var prevValue = $("#" + me.pre + "command").val();
         $("#" + me.pre + "command").val(prevValue + separator + nameArray[i]);

         var prevValue = $("#" + me.pre + "command_name").val();
         $("#" + me.pre + "command_name").val(prevValue + separator + nameArray[i]);
       }
   } // outer for
};

iCn3DUI.prototype.combineSets = function (orArray, andArray, notArray, commandname) { var me = this;
   me.icn3d.hAtoms = {};
   me.setHAtomsFromSets(orArray, 'or');

   if(Object.keys(me.icn3d.hAtoms).length == 0) me.icn3d.hAtoms = me.icn3d.cloneHash(me.icn3d.atoms);
   me.setHAtomsFromSets(andArray, 'and');

   me.setHAtomsFromSets(notArray, 'not');

   me.updateHlAll();

   // show selected chains in annotation window
   me.showAnnoSelectedChains();

   // clear commmand
   $("#" + me.pre + "command").val("");
   $("#" + me.pre + "command_name").val("");

   me.updateAdvancedCommands(orArray, 'or');
   me.updateAdvancedCommands(andArray, 'and');
   me.updateAdvancedCommands(notArray, 'not');

   if(commandname !== undefined) {
       var select = "select " + $("#" + me.pre + "command").val();

       $("#" + me.pre + "command_name").val(commandname);
       me.addCustomSelection(Object.keys(me.icn3d.hAtoms), commandname, commandname, select, false);
   }
};

iCn3DUI.prototype.setProtNuclLigInMenu = function () { var me = this;
    for(var chain in me.icn3d.chains) {
          // Initially, add proteins, nucleotides, chemicals, ions, water into the menu "custom selections"
          if(Object.keys(me.icn3d.proteins).length > 0) {
              //me.icn3d.defNames2Atoms['proteins'] = Object.keys(me.icn3d.proteins);
              me.icn3d.defNames2Residues['proteins'] = Object.keys(me.icn3d.getResiduesFromAtoms(me.icn3d.proteins));
              me.icn3d.defNames2Descr['proteins'] = 'proteins';
              me.icn3d.defNames2Command['proteins'] = 'select :proteins';
          }

          if(Object.keys(me.icn3d.nucleotides).length > 0) {
              //me.icn3d.defNames2Atoms['nucleotides'] = Object.keys(me.icn3d.nucleotides);
              me.icn3d.defNames2Residues['nucleotides'] = Object.keys(me.icn3d.getResiduesFromAtoms(me.icn3d.nucleotides));
              me.icn3d.defNames2Descr['nucleotides'] = 'nucleotides';
              me.icn3d.defNames2Command['nucleotides'] = 'select :nucleotides';
          }

          if(Object.keys(me.icn3d.chemicals).length > 0) {
              //me.icn3d.defNames2Atoms['chemicals'] = Object.keys(me.icn3d.chemicals);
              me.icn3d.defNames2Residues['chemicals'] = Object.keys(me.icn3d.getResiduesFromAtoms(me.icn3d.chemicals));
              me.icn3d.defNames2Descr['chemicals'] = 'chemicals';
              me.icn3d.defNames2Command['chemicals'] = 'select :chemicals';
          }

          if(Object.keys(me.icn3d.ions).length > 0) {
              //me.icn3d.defNames2Atoms['ions'] = Object.keys(me.icn3d.ions);
              me.icn3d.defNames2Residues['ions'] = Object.keys(me.icn3d.getResiduesFromAtoms(me.icn3d.ions));
              me.icn3d.defNames2Descr['ions'] = 'ions';
              me.icn3d.defNames2Command['ions'] = 'select :ions';
          }

          if(Object.keys(me.icn3d.water).length > 0) {
              //me.icn3d.defNames2Atoms['water'] = Object.keys(me.icn3d.water);
              me.icn3d.defNames2Residues['water'] = Object.keys(me.icn3d.getResiduesFromAtoms(me.icn3d.water));
              me.icn3d.defNames2Descr['water'] = 'water';
              me.icn3d.defNames2Command['water'] = 'select :water';
          }
    }
};

iCn3DUI.prototype.setChainsInMenu = function () { var me = this;
    for(var chainid in me.icn3d.chains) {
        // skip chains with one residue/chemical
        if(me.icn3d.chainsSeq[chainid].length > 1) {
          //me.icn3d.defNames2Atoms[chainid] = Object.keys(me.icn3d.chains[chainid]);
          me.icn3d.defNames2Residues[chainid] = Object.keys(me.icn3d.getResiduesFromAtoms(me.icn3d.chains[chainid]));
          me.icn3d.defNames2Descr[chainid] = chainid;

          var pos = chainid.indexOf('_');
          var structure = chainid.substr(0, pos);
          var chain = chainid.substr(pos + 1);

          me.icn3d.defNames2Command[chainid] = 'select $' + structure + '.' + chain;
        }
    }
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3DUI.prototype.loadScript = function (dataStr, bStatefile) { var me = this;
  // allow the "loading structure..." message to be shown while loading script
  me.bCommandLoad = true;

  me.icn3d.bRender = false;
  me.icn3d.bStopRotate = true;

  // firebase dynamic links replace " " with "+". So convert it back
  dataStr = dataStr.replace(/\+/g, ' ').replace(/;/g, '\n');

  var preCommands = [];
  if(me.icn3d.commands.length > 0) preCommands[0] = me.icn3d.commands[0];

  me.icn3d.commands = dataStr.trim().split('\n');
  me.STATENUMBER = me.icn3d.commands.length;

  me.icn3d.commands = preCommands.concat(me.icn3d.commands);
  me.STATENUMBER = me.icn3d.commands.length;

  if(bStatefile !== undefined && bStatefile) {
      me.execCommands(0, me.STATENUMBER-1, me.STATENUMBER);
  }
  else {
      // skip the first loading step
      me.execCommands(1, me.STATENUMBER-1, me.STATENUMBER);
  }
};

iCn3DUI.prototype.loadSelection = function (dataStr) { var me = this;
  var nameCommandArray = dataStr.trim().split('\n');

  for(var i = 0, il = nameCommandArray.length; i < il; ++i) {
      var nameCommand = nameCommandArray[i].split('\t');
      var name = nameCommand[0];
      var command = nameCommand[1];

      var pos = command.indexOf(' '); // select ...

      me.selectByCommand(command.substr(pos + 1), name, name, false);
  }
};

iCn3DUI.prototype.execCommands = function (start, end, steps) { var me = this;
    me.icn3d.bRender = false;

    // initialize icn3dui
//    me.init();
//    me.icn3d.init();

    // fresh start
    me.icn3d.reinitAfterLoad();

    me.icn3d.opts = me.icn3d.cloneHash(me.opts);

    //me.execCommandsBase(0, steps-1, steps);
    me.execCommandsBase(start, end, steps);
};

iCn3DUI.prototype.execCommandsBase = function (start, end, steps) { var me = this;
  for(var i=start; i <= end; ++i) {
      var bFinalStep = (i === steps - 1) ? true : false;

      if(me.icn3d.commands[i].indexOf('load') !== -1) {
          if(end === 0 && start === end) {
              if(me.bNotLoadStructure) {
                    me.icn3d.hAtoms = me.icn3d.cloneHash(me.icn3d.atoms);
                    //me.icn3d.bRender = true;

                    // end of all commands
                    if(1 === me.icn3d.commands.length) me.bAddCommands = true;
                    if(bFinalStep) me.renderFinalStep(steps);                  }
              else {
                  $.when(me.applyCommandLoad(me.icn3d.commands[i])).then(function() {
                   // me.icn3d.bRender = true;

                    // end of all commands
                    if(1 === me.icn3d.commands.length) me.bAddCommands = true;
                    if(bFinalStep) me.renderFinalStep(steps);
                  });
              }
              return;
          }
          else {
              if(me.bNotLoadStructure) {
                  me.icn3d.hAtoms = me.icn3d.cloneHash(me.icn3d.atoms);

                  // undo/redo requires render the first step
                  if(me.backForward !== undefined && me.backForward) me.renderFinalStep(1);

                  me.execCommandsBase(i + 1, end, steps);
              }
              else {
                  $.when(me.applyCommandLoad(me.icn3d.commands[i])).then(function() {
                      // undo/redo requires render the first step
                      if(me.backForward !== undefined && me.backForward) me.renderFinalStep(1);

                      me.execCommandsBase(i + 1, end, steps);
                  });
              }

              return;
          }
      }
      else if(me.icn3d.commands[i].trim().indexOf('set map') == 0 && me.icn3d.commands[i].trim().indexOf('set map wireframe') == -1) {
          //set map 2fofc sigma 1.5
          var str = me.icn3d.commands[i].trim().substr(8);
          var paraArray = str.split(" ");

          if(paraArray.length == 3 && paraArray[1] == 'sigma') {
            var sigma = paraArray[2];
            var type = paraArray[0];

            if( (type == '2fofc' && (me.bAjax2fofc === undefined || !me.bAjax2fofc))
              || (type == 'fofc' && (me.bAjaxfofc === undefined || !me.bAjaxfofc)) ) {
                $.when(me.applyCommandMap(me.icn3d.commands[i].trim())).then(function() {
                    me.execCommandsBase(i + 1, end, steps);
                });
            }
            else {
                me.applyCommandMap(me.icn3d.commands[i].trim());
                me.execCommandsBase(i + 1, end, steps);
            }

            return;
          }
      }
      else if(me.icn3d.commands[i].trim().indexOf('set emmap') == 0 && me.icn3d.commands[i].trim().indexOf('set emmap wireframe') == -1) {
          //set emmap percentage 70
          var str = me.icn3d.commands[i].trim().substr(10);
          var paraArray = str.split(" ");

          if(paraArray.length == 2 && paraArray[0] == 'percentage') {
            var percentage = paraArray[1];

            if(me.bAjaxEm === undefined || !me.bAjaxEm) {
                $.when(me.applyCommandEmmap(me.icn3d.commands[i].trim())).then(function() {
                    me.execCommandsBase(i + 1, end, steps);
                });
            }
            else {
                me.applyCommandEmmap(me.icn3d.commands[i].trim());
                me.execCommandsBase(i + 1, end, steps);
            }

            return;
          }
      }
      else if(me.icn3d.commands[i].trim().indexOf('view annotations') == 0
        //|| me.icn3d.commands[i].trim().indexOf('set annotation cdd') == 0
        //|| me.icn3d.commands[i].trim().indexOf('set annotation site') == 0
        ) { // the command may have "|||{"factor"...
          var strArray = me.icn3d.commands[i].split("|||");
          if(Object.keys(me.icn3d.proteins).length > 0 && (me.bAjaxCddSite === undefined || !me.bAjaxCddSite) ) {
              $.when(me.applyCommandAnnotationsAndCddSite(strArray[0].trim())).then(function() {
                  me.execCommandsBase(i + 1, end, steps);
              });
          }
          else {
              if(Object.keys(me.icn3d.proteins).length > 0) {
                  me.applyCommandAnnotationsAndCddSiteBase(strArray[0].trim());
              }

              me.execCommandsBase(i + 1, end, steps);
          }

          return;
      }
      else if(me.icn3d.commands[i].trim().indexOf('set annotation clinvar') == 0
        || me.icn3d.commands[i].trim().indexOf('set annotation snp') == 0) { // the command may have "|||{"factor"...
          var strArray = me.icn3d.commands[i].split("|||");

          if(Object.keys(me.icn3d.proteins).length > 0 && (me.bAjaxSnpClinvar === undefined || !me.bAjaxSnpClinvar) ) {
              $.when(me.applyCommandSnpClinvar(strArray[0].trim())).then(function() {
                  me.execCommandsBase(i + 1, end, steps);
              });
          }
          else {
              if(Object.keys(me.icn3d.proteins).length > 0) {
                  me.applyCommandSnpClinvar(strArray[0].trim());
              }

              me.execCommandsBase(i + 1, end, steps);
          }

          return;
      }
      else if(me.icn3d.commands[i].trim().indexOf('set annotation 3ddomain') == 0) { // the command may have "|||{"factor"...
          var strArray = me.icn3d.commands[i].split("|||");

          if(Object.keys(me.icn3d.proteins).length > 0 && me.mmdb_data === undefined && (me.bAjax3ddomain === undefined || !me.bAjax3ddomain)) {
              $.when(me.applyCommand3ddomain(strArray[0].trim())).then(function() {
                  me.execCommandsBase(i + 1, end, steps);
              });
          }
          else {
              if(Object.keys(me.icn3d.proteins).length > 0) {
                  me.applyCommand3ddomain(strArray[0].trim());
              }

              me.execCommandsBase(i + 1, end, steps);
          }

          return;
      }
      else if(me.icn3d.commands[i].trim().indexOf('set annotation all') == 0) { // the command may have "|||{"factor"...
          var strArray = me.icn3d.commands[i].split("|||");
          //$.when(me.applyCommandAnnotationsAndCddSite(strArray[0].trim()))
          //  .then(me.applyCommandSnpClinvar(strArray[0].trim()))

          if( Object.keys(me.icn3d.proteins).length > 0 && (me.bAjaxSnpClinvar === undefined || !me.bAjaxSnpClinvar)
            && (me.bAjax3ddomain === undefined || !me.bAjax3ddomain || me.mmdb_data === undefined) ) {
              $.when(me.applyCommandSnpClinvar(strArray[0].trim()))
                .then(me.applyCommand3ddomain(strArray[0].trim()))
                .then(function() {
                  me.setAnnoTabAll();

                  me.execCommandsBase(i + 1, end, steps);
              });
          }
          else if(Object.keys(me.icn3d.proteins).length > 0 && (me.bAjaxSnpClinvar === undefined || !me.bAjaxSnpClinvar) ) {
              $.when(me.applyCommandSnpClinvar(strArray[0].trim()))
                .then(function() {
                  me.setAnnoTabAll();

                  me.execCommandsBase(i + 1, end, steps);
              });
          }
          else if(Object.keys(me.icn3d.proteins).length > 0 && (me.bAjax3ddomain === undefined || !me.bAjax3ddomain || me.mmdb_data === undefined) ) {
              $.when(me.applyCommand3ddomain(strArray[0].trim()))
                .then(function() {
                  me.setAnnoTabAll();

                  me.execCommandsBase(i + 1, end, steps);
              });
          }
          else {
              if(Object.keys(me.icn3d.proteins).length > 0) {
                  if((me.bAjaxSnpClinvar === undefined || !me.bAjaxSnpClinvar)
                    && (me.bAjax3ddomain === undefined || !me.bAjax3ddomain || me.mmdb_data === undefined)) {
                      me.applyCommandSnpClinvarBase(strArray[0].trim());
                      me.applyCommand3ddomainBase(strArray[0].trim());
                  }
                  else if(me.bAjaxSnpClinvar === undefined || !me.bAjaxSnpClinvar) {
                      me.applyCommandSnpClinvarBase(strArray[0].trim());
                  }
                  else if(me.bAjax3ddomain === undefined || !me.bAjax3ddomain || me.mmdb_data === undefined) {
                      me.applyCommand3ddomainBase(strArray[0].trim());
                  }
              }

              me.setAnnoTabAll();

              me.execCommandsBase(i + 1, end, steps);
          }

          return;
      }
      else if(me.icn3d.commands[i].trim().indexOf('view interactions') == 0 && me.cfg.align !== undefined) { // the command may have "|||{"factor"...
          var strArray = me.icn3d.commands[i].split("|||");

          if(me.b2DShown === undefined || !me.b2DShown) {
              $.when(me.applyCommandViewinteraction(strArray[0].trim())).then(function() {
                  me.execCommandsBase(i + 1, end, steps);
              });
          }
          else {
              me.execCommandsBase(i + 1, end, steps);
          }

          return;
      }
      else {
          me.applyCommand(me.icn3d.commands[i]);
      }
  }

  //if(i === steps - 1) {
  if(i === steps) {
      // enable me.hideLoading
      me.bCommandLoad = false;

      // hide "loading ..."
      me.hideLoading();

      //me.icn3d.bRender = true;

      // end of all commands
      if(i + 1 === me.icn3d.commands.length) me.bAddCommands = true;

      me.renderFinalStep(steps);
  }
};

iCn3DUI.prototype.renderFinalStep = function(steps) { var me = this;
    me.icn3d.bRender = true;

    var commandTransformation = me.icn3d.commands[steps-1].split('|||');

    if(commandTransformation.length == 2) {
        var transformation = JSON.parse(commandTransformation[1]);

        me.icn3d._zoomFactor = transformation.factor;

        me.icn3d.mouseChange.x = transformation.mouseChange.x;
        me.icn3d.mouseChange.y = transformation.mouseChange.y;

        me.icn3d.quaternion._x = transformation.quaternion._x;
        me.icn3d.quaternion._y = transformation.quaternion._y;
        me.icn3d.quaternion._z = transformation.quaternion._z;
        me.icn3d.quaternion._w = transformation.quaternion._w;
    }

    // simple if all atoms are modified
    //if( me.cfg.command === undefined && (steps === 1 || (Object.keys(me.icn3d.hAtoms).length === Object.keys(me.icn3d.atoms).length) || (me.icn3d.optsHistory[steps - 1] !== undefined && me.icn3d.optsHistory[steps - 1].hasOwnProperty('hlatomcount') && me.icn3d.optsHistory[steps - 1].hlatomcount === Object.keys(me.icn3d.atoms).length) ) ) {
    if(steps === 1
      || (Object.keys(me.icn3d.hAtoms).length === Object.keys(me.icn3d.atoms).length)
      || (me.icn3d.optsHistory[steps - 1] !== undefined && me.icn3d.optsHistory[steps - 1].hasOwnProperty('hlatomcount') && me.icn3d.optsHistory[steps - 1].hlatomcount === Object.keys(me.icn3d.atoms).length) ) {
        if(steps === 1) {
            // assign styles and color using the options at that stage
            me.icn3d.setAtomStyleByOptions(me.icn3d.optsHistory[steps - 1]);
            me.icn3d.setColorByOptions(me.icn3d.optsHistory[steps - 1], me.icn3d.hAtoms);
        }

        if(me.icn3d.optsHistory.length >= steps) {
            var pkOption = me.icn3d.optsHistory[steps - 1].pk;
            if(pkOption === 'no') {
                me.icn3d.pk = 0;
            }
            else if(pkOption === 'atom') {
                me.icn3d.pk = 1;
            }
            else if(pkOption === 'residue') {
                me.icn3d.pk = 2;
            }
            else if(pkOption === 'strand') {
                me.icn3d.pk = 3;
            }

            if(steps === 1) {
                me.icn3d.applyOriginalColor();
            }

            me.updateHlAll();

            jQuery.extend(me.icn3d.opts, me.icn3d.optsHistory[steps - 1]);
            me.icn3d.draw();
        }
        else {
            me.updateHlAll();

            me.icn3d.draw();
        }
    }
    else { // more complicated if partial atoms are modified
        me.icn3d.draw();
    }
};

iCn3DUI.prototype.applyCommandLoad = function (commandStr) { var me = this;
  //me.bCommandLoad = true;

  // chain functions together
  me.deferred2 = $.Deferred(function() {
  me.bAddCommands = false;
  var commandTransformation = commandStr.split('|||');

  var commandOri = commandTransformation[0].replace(/\s\s/g, ' ').trim();
  var command = commandOri.toLowerCase();

  if(command.indexOf('load') !== -1) { // 'load pdb [pdbid]'
    var load_parameters = command.split(' | ');

    var loadStr = load_parameters[0];
    if(load_parameters.length > 1) {
        var firstSpacePos = load_parameters[load_parameters.length - 1].indexOf(' ');
        me.cfg.inpara = load_parameters[load_parameters.length - 1].substr(firstSpacePos + 1);
        if(me.cfg.inpara === 'undefined') {
            me.cfg.inpara = '';
        }
    }

    // load pdb, mmcif, mmdb, cid
    var id = loadStr.substr(loadStr.lastIndexOf(' ') + 1);
    me.inputid = id;
    if(command.indexOf('load mmtf') !== -1) {
      me.cfg.mmtfid = id;
      me.downloadMmtf(id);
    }
    else if(command.indexOf('load pdb') !== -1) {
      me.cfg.pdbid = id;
      me.downloadPdb(id);
    }
    else if(command.indexOf('load mmcif') !== -1) {
      me.cfg.mmcifid = id;
      me.downloadMmcif(id);
    }
    else if(command.indexOf('load mmdb') !== -1) {
      me.cfg.mmdbid = id;
      me.downloadMmdb(id);
    }
    else if(command.indexOf('load gi') !== -1) {
      me.cfg.gi = id;
      me.downloadGi(id);
    }
    else if(command.indexOf('load seq_struc_ids') !== -1) {
      me.downloadBlast_rep_id(id);
    }
    else if(command.indexOf('load cid') !== -1) {
      me.cfg.cid = id;
      me.downloadCid(id);
    }
    else if(command.indexOf('load align') !== -1) {
      me.cfg.align = id;
      me.downloadAlignment(id);
    }
    else if(command.indexOf('load url') !== -1) {
        var typeStr = load_parameters[1]; // type pdb
        var pos = (typeStr !== undefined) ? typeStr.indexOf('type ') : -1;
        var type = 'pdb';

        if(pos !== -1) {
            type = typeStr.substr(pos + 5);
        }

        me.cfg.url = id;
        me.downloadUrl(id, type);
    }
  }

  me.bAddCommands = true;
  }); // end of me.deferred = $.Deferred(function() {

  return me.deferred2.promise();
};

iCn3DUI.prototype.applyCommandMap = function (command) { var me = this;
  // chain functions together
  me.deferredMap = $.Deferred(function() {
      var str = command.substr(8);
      var paraArray = str.split(" ");

      if(paraArray.length == 3 && paraArray[1] == 'sigma') {
          var sigma = paraArray[2];
          var type = paraArray[0];

          me.Dsn6Parser(me.inputid, type, sigma);
      }
  }); // end of me.deferred = $.Deferred(function() {

  return me.deferredMap.promise();
};

iCn3DUI.prototype.applyCommandEmmap = function (command) { var me = this;
  // chain functions together
  me.deferredEmmap = $.Deferred(function() {
      var str = command.substr(10);
      var paraArray = str.split(" ");

      if(paraArray.length == 2 && paraArray[0] == 'percentage') {
          var percentage = paraArray[1];
          var type = 'em';

          me.DensityCifParser(me.inputid, type, percentage, me.icn3d.emd);
      }
  }); // end of me.deferred = $.Deferred(function() {

  return me.deferredEmmap.promise();
};

iCn3DUI.prototype.applyCommandAnnotationsAndCddSiteBase = function (command) { var me = this;
  // chain functions together
      if(command == "view annotations") {
          if(me.cfg.showanno === undefined || !me.cfg.showanno) {
              me.showAnnotations();
          }
      }
};

iCn3DUI.prototype.applyCommandAnnotationsAndCddSite = function (command) { var me = this;
  // chain functions together
  me.deferredAnnoCddSite = $.Deferred(function() {
      me.applyCommandAnnotationsAndCddSiteBase(command);
  }); // end of me.deferred = $.Deferred(function() {

  return me.deferredAnnoCddSite.promise();
};

iCn3DUI.prototype.applyCommandSnpClinvarBase = function (command) { var me = this;
  // chain functions together
      var pos = command.lastIndexOf(' '); // set annotation clinvar
      var type = command.substr(pos + 1);

      if(type == 'clinvar') {
          me.setAnnoTabClinvar();
      }
      else if(type == 'snp') {
          me.setAnnoTabSnp();
      }
      else if(type == 'all') {
          me.setAnnoTabClinvar();
          me.setAnnoTabSnp();
      }
};

iCn3DUI.prototype.applyCommandSnpClinvar = function (command) { var me = this;
  // chain functions together
  me.deferredSnpClinvar = $.Deferred(function() {
      me.applyCommandSnpClinvarBase(command);
  }); // end of me.deferred = $.Deferred(function() {

  return me.deferredSnpClinvar.promise();
};

iCn3DUI.prototype.applyCommand3ddomainBase = function (command) { var me = this;
  // chain functions together
      var pos = command.lastIndexOf(' ');
      var type = command.substr(pos + 1);

      if(type == '3ddomain' || type == 'all') {
          me.setAnnoTab3ddomain();
      }
};

iCn3DUI.prototype.applyCommand3ddomain = function (command) { var me = this;
  // chain functions together
  me.deferred3ddomain = $.Deferred(function() {
      me.applyCommand3ddomainBase(command);
  }); // end of me.deferred = $.Deferred(function() {

  return me.deferred3ddomain.promise();
};

iCn3DUI.prototype.applyCommandViewinteractionBase = function (command) { var me = this;
  // chain functions together
     if(me.cfg.align !== undefined) {
         var structureArray = Object.keys(me.icn3d.structures);
         me.set2DDiagramsForAlign(structureArray[0].toUpperCase(), structureArray[1].toUpperCase());
     }
};

iCn3DUI.prototype.applyCommandViewinteraction = function (command) { var me = this;
  // chain functions together
  me.deferredViewinteraction = $.Deferred(function() {
     me.applyCommandViewinteractionBase(command);
  }); // end of me.deferred = $.Deferred(function() {

  return me.deferredViewinteraction.promise();
};

iCn3DUI.prototype.applyCommand = function (commandStr) { var me = this;
  me.bAddCommands = false;

  var commandTransformation = commandStr.split('|||');

  var commandOri = commandTransformation[0].replace(/\s+/g, ' ').trim();
  var command = commandOri.toLowerCase();

  var bShowLog = true;

// exact match =============

  var file_pref = (me.inputid) ? me.inputid : "custom";

  if(command == 'export state file') { // last step to update transformation
    // the last transformation will be applied
  }
  else if(command == 'export canvas') {
    setTimeout(function(){
           me.saveFile(file_pref + '_icn3d_loadable.png', 'png');
        }, 500);
  }
  else if(command == 'export interactions') {
    me.exportInteractions();
  }
  else if(command == 'export stl file') {
    setTimeout(function(){
           //me.hideStabilizer();

           var text = me.saveStlFile();
           me.saveFile(file_pref + '.stl', 'binary', text);
           text = '';
        }, 500);
  }
  else if(command == 'export vrml file') {
    setTimeout(function(){
           //me.hideStabilizer();

           var text = me.saveVrmlFile();
           me.saveFile(file_pref + '.wrl', 'text', text);
           text = '';
        }, 500);
  }
  else if(command == 'export stl stabilizer file') {
    setTimeout(function(){
           //me.icn3d.bRender = false;

           me.hideStabilizer();
           me.resetAfter3Dprint();
           me.addStabilizer();

           var text = me.saveStlFile();

           //me.hideStabilizer();
           //me.icn3d.bRender = true;
           //me.icn3d.draw();

           me.saveFile(file_pref + '_stab.stl', 'binary', text);
           text = '';
        }, 500);
  }
  else if(command == 'export vrml stabilizer file') {
    setTimeout(function(){
           //me.icn3d.bRender = false;

           me.hideStabilizer();
           me.resetAfter3Dprint();
           me.addStabilizer();

           var text = me.saveVrmlFile();

           //me.hideStabilizer();
           //me.icn3d.bRender = true;
           //me.icn3d.draw();

           me.saveFile(file_pref + '_stab.wrl', 'text', text);
           text = '';
        }, 500);
  }
  else if(command == 'select all') {
     me.selectAll();
     //me.icn3d.addHlObjects();
  }
  else if(command == 'select complement') {
     me.selectComplement();
  }
  else if(command == 'set pk atom') {
    me.icn3d.pk = 1;
    me.icn3d.opts['pk'] = 'atom';
  }
  else if(command == 'set pk off') {
    me.icn3d.pk = 0;
    me.icn3d.opts['pk'] = 'no';
    me.icn3d.draw();
    me.icn3d.removeHlObjects();
  }
  else if(command == 'set pk residue') {
    me.icn3d.pk = 2;
    me.icn3d.opts['pk'] = 'residue';
  }
  else if(command == 'set pk strand') {
    me.icn3d.pk = 3;
    me.icn3d.opts['pk'] = 'strand';
  }
  else if(command == 'set pk chain') {
    me.icn3d.pk = 4;
    me.icn3d.opts['pk'] = 'chain';
  }
  else if(command == 'set surface wireframe on') {
    me.icn3d.opts['wireframe'] = 'yes';
    me.icn3d.applySurfaceOptions();
  }
  else if(command == 'set surface wireframe off') {
    me.icn3d.opts['wireframe'] = 'no';
    me.icn3d.applySurfaceOptions();
  }
  else if(command == 'set map wireframe on') {
    me.icn3d.opts['mapwireframe'] = 'yes';
    me.icn3d.applyMapOptions();
  }
  else if(command == 'set map wireframe off') {
    me.icn3d.opts['mapwireframe'] = 'no';
    me.icn3d.applyMapOptions();
  }
  else if(command == 'set emmap wireframe on') {
    me.icn3d.opts['emmapwireframe'] = 'yes';
    me.icn3d.applyMapOptions();
  }
  else if(command == 'set emmap wireframe off') {
    me.icn3d.opts['emmapwireframe'] = 'no';
    me.icn3d.applyMapOptions();
  }
  else if(command == 'set surface neighbors on') {
    me.icn3d.bConsiderNeighbors = true;
    me.icn3d.applySurfaceOptions();
  }
  else if(command == 'set surface neighbors off') {
    me.icn3d.bConsiderNeighbors = false;
    me.icn3d.applySurfaceOptions();
  }
  else if(command == 'set axis on') {
    me.icn3d.opts['axis'] = 'yes';
  }
  else if(command == 'set axis off') {
    me.icn3d.opts['axis'] = 'no';
  }
  else if(command == 'set fog on') {
    me.icn3d.opts['fog'] = 'yes';
  }
  else if(command == 'set fog off') {
    me.icn3d.opts['fog'] = 'no';
  }
  else if(command == 'set slab on') {
    me.icn3d.opts['slab'] = 'yes';
  }
  else if(command == 'set slab off') {
    me.icn3d.opts['slab'] = 'no';
  }
  else if(command == 'set assembly on') {
    me.icn3d.bAssembly = true;
  }
  else if(command == 'set assembly off') {
    me.icn3d.bAssembly = false;
  }
  else if(command == 'set chemicalbinding show') {
    me.setOption('chemicalbinding', 'show');
  }
  else if(command == 'set chemicalbinding hide') {
    me.setOption('chemicalbinding', 'hide');
  }
  else if(command == 'set hbonds off') {
    me.icn3d.hideHbonds();
    me.icn3d.draw();
  }
  else if(command == 'set stabilizer off') {
    me.hideStabilizer();
    me.icn3d.draw();
  }
  else if(command == 'set disulfide bonds off') {
    me.icn3d.opts["ssbonds"] = "no";
    me.icn3d.draw();
  }
  else if(command == 'set cross linkage off') {
    me.icn3d.bShowCrossResidueBond = false;
    //me.opts['proteins'] = 'ribbon';
    //me.icn3d.draw();
    me.setStyle('proteins', 'ribbon')
  }
  else if(command == 'set lines off') {
    me.icn3d.labels['distance'] = [];
    me.icn3d.lines['distance'] = [];

    me.icn3d.draw();
  }
  else if(command == 'set labels off') {
    //me.icn3d.labels['residue'] = [];
    //me.icn3d.labels['custom'] = [];

    for(var name in me.icn3d.labels) {
       //if(name === 'residue' || name === 'custom') {
           me.icn3d.labels[name] = [];
       //}
    }

    me.icn3d.draw();
  }
  else if(command == 'set mode all') {
     me.setModeAndDisplay('all');
  }
  else if(command == 'set mode selection') {
     me.setModeAndDisplay('selection');
  }
  else if(command == 'set view detailed view') {
     me.setAnnoViewAndDisplay('detailed view');
  }
  else if(command == 'set view overview') {
     me.setAnnoViewAndDisplay('overview');
  }
/*
  else if(command.indexOf('set annotation') == 0) {
      var pos = command.lastIndexOf(' ');
      var type = command.substr(pos + 1);

      if(type == 'all') {
          me.setAnnoTabAll();
      }
      else if(type == 'custom') {
          me.setAnnoTabCustom();
      }
      else if(type == 'clinvar') {
          me.setAnnoTabClinvar();
      }
      else if(type == 'snp') {
          me.setAnnoTabSnp();
      }
      else if(type == 'cdd') {
          me.setAnnoTabCdd();
      }
      else if(type == '3ddomain') {
          me.setAnnoTab3ddomain();
      }
      else if(type == 'site') {
          me.setAnnoTabSite();
      }
      else if(type == 'interaction') {
          me.setAnnoTabInteraction();
      }
  }
*/
  else if(command == 'set annotation custom') {
      me.setAnnoTabCustom();
  }
  else if(command == 'set annotation interaction') {
      me.setAnnoTabInteraction();
  }
  else if(command == 'set annotation cdd') {
      me.setAnnoTabCdd();
  }
  else if(command == 'set annotation site') {
      me.setAnnoTabSite();
  }
  else if(command == 'set annotation ssbond') {
      me.setAnnoTabSsbond();
  }
  else if(command == 'highlight level up') {
      me.switchHighlightLevelUp();
  }
  else if(command == 'highlight level down') {
      me.switchHighlightLevelDown();
  }
  else if(command.indexOf('hide annotation') == 0) {
      var pos = command.lastIndexOf(' ');
      var type = command.substr(pos + 1);

      if(type == 'all') {
          me.hideAnnoTabAll();
      }
      else if(type == 'custom') {
          me.hideAnnoTabCustom();
      }
      else if(type == 'clinvar') {
          me.hideAnnoTabClinvar();
      }
      else if(type == 'snp') {
          me.hideAnnoTabSnp();
      }
      else if(type == 'cdd') {
          me.hideAnnoTabCdd();
      }
      else if(type == '3ddomain') {
          me.hideAnnoTab3ddomain();
      }
      else if(type == 'site') {
          me.hideAnnoTabSite();
      }
      else if(type == 'interaction') {
          me.hideAnnoTabInteraction();
      }
      else if(type == 'ssbond') {
          me.hideAnnoTabSsbond();
      }
  }
  else if(command == 'add residue labels') {
    me.icn3d.addResiudeLabels(me.icn3d.hAtoms);

    me.icn3d.draw();
  }
  else if(command == 'add chain labels') {
    me.addChainLabels(me.icn3d.hAtoms);

    me.icn3d.draw();
  }
  else if(command == 'add terminal labels') {
    me.addTerminiLabels(me.icn3d.hAtoms);

    me.icn3d.draw();
  }
  else if(command == 'rotate left') {
     me.icn3d.bStopRotate = false;
     me.ROT_DIR = 'left';

     me.rotStruc('left');
  }
  else if(command == 'rotate right') {
     me.icn3d.bStopRotate = false;
     me.ROT_DIR = 'right';

     me.rotStruc('right');
  }
  else if(command == 'rotate up') {
     me.icn3d.bStopRotate = false;
     me.ROT_DIR = 'up';

     me.rotStruc('up');
  }
  else if(command == 'rotate down') {
     me.icn3d.bStopRotate = false;
     me.ROT_DIR = 'down';

     me.rotStruc('down');
  }
  else if(command === 'reset') {
    //location.reload();
    me.icn3d.reinitAfterLoad();
    me.renderFinalStep(1);

    // need to render
    me.icn3d.render();
  }
  else if(command === 'reset orientation') {
    me.icn3d.resetOrientation();
    me.icn3d.draw();
  }
  else if(command == 'reset thickness') {
    me.resetAfter3Dprint();
    me.icn3d.draw();
  }
  else if(command == 'clear selection') {
    //if(me.icn3d.prevHighlightObjects.length > 0) { // remove
        me.icn3d.removeHlObjects();
        me.removeHl2D();
        me.icn3d.bShowHighlight = false;

        me.bSelectResidue = false;
    //}
  }
  else if(command == 'zoom selection') {
    me.icn3d.zoominSelection();
    me.icn3d.draw();
  }
  else if(command == 'center selection') {
    me.icn3d.centerSelection();
    me.icn3d.draw();
  }
  else if(command == 'show selection') {
    me.showSelection();
  }
  else if(command == 'output selection') {
      me.outputSelection();
  }
  else if(command == 'toggle selection') {
     me.toggleSelection();
  }
  else if(command == 'toggle highlight') {
    if(me.icn3d.prevHighlightObjects.length > 0) { // remove
        me.icn3d.removeHlObjects();
        me.icn3d.bShowHighlight = false;
    }
    else { // add
        me.icn3d.addHlObjects();
        me.icn3d.bShowHighlight = true;
    }
  }
  else if(command == 'stabilizer') {
    me.addStabilizer();

    me.prepareFor3Dprint();
    //me.icn3d.draw();
  }
  else if(command == 'disulfide bonds') {
    me.showSsbonds();
  }
  else if(command == 'cross linkage') {
    me.icn3d.bShowCrossResidueBond = true;

    me.setStyle('proteins', 'lines')
  }
  else if(command == 'back') {
     me.back();
  }
  else if(command == 'forward') {
     me.forward();
  }
  else if(command == 'clear all') {
     me.selectAll();
  }
  else if(command == 'defined sets') {
     me.showSets();
  }
  else if(command == 'delete selected sets') {
     me.deleteSelectedSets();
  }
  else if(command == 'view interactions') {
     if(me.cfg.mmdbid !== undefined || me.cfg.gi !== undefined) {
         me.set2DDiagrams(me.inputid);
     }
     //else if(me.cfg.align !== undefined) {
     //    var structureArray = Object.keys(me.icn3d.structures);
     //    me.set2DDiagramsForAlign(structureArray[0].toUpperCase(), structureArray[1].toUpperCase());
     //}
  }
//      else if(command == 'view annotations') {
//          if(me.cfg.showanno === undefined || !me.cfg.showanno) { // previously done the following call
//              me.showAnnotations();
//          }
//      }
  else if(command == 'show annotations all chains') {
     me.showAnnoAllChains();
  }

  else if(command == 'save color') {
     me.saveColor();
  }
  else if(command == 'apply saved color') {
     me.applySavedColor();
  }
  else if(command == 'save style') {
     me.saveStyle();
  }
  else if(command == 'apply saved style') {
     me.applySavedStyle();
  }
  else if(command == 'select side chains') {
     me.selectSideChains();
  }

// start with =================
  else if(commandOri.indexOf('define helix sets') == 0) {
     var chainStr = commandOri.split(' | ')[1];
     var chainid = chainStr.split(' ')[1];

     me.defineSecondary(chainid, 'helix');
  }
  else if(commandOri.indexOf('define sheet sets') == 0) {
     var chainStr = commandOri.split(' | ')[1];
     var chainid = chainStr.split(' ')[1];

     me.defineSecondary(chainid, 'sheet');
  }
  else if(commandOri.indexOf('define coil sets') == 0) {
     var chainStr = commandOri.split(' | ')[1];
     var chainid = chainStr.split(' ')[1];

     me.defineSecondary(chainid, 'coil');
  }
  else if(commandOri.indexOf('select interaction') == 0) {
    var idArray = commandOri.substr(commandOri.lastIndexOf(' ') + 1).split(',');
    if(idArray !== null) {
        var mmdbid = idArray[0].split('_')[0];
        if(!me.b2DShown) me.download2Ddgm(mmdbid.toUpperCase());

        me.selectInteraction(idArray[0], idArray[1]);
    }
  }

  else if(commandOri.indexOf('select saved atoms') == 0) {
    var paraArray = commandOri.split(' | '); // atom names might be case-sensitive

    var select = paraArray[0].replace(/,/g, ' or ');

//    var commandname;
//    if(paraArray.length == 2) commandname = paraArray[1].substr(5); // 'name ...'

    var pos = 19; // 'select saved atoms '
    var strSets = select.substr(pos);

    var commandname = strSets;

    me.selectCombinedSets(strSets, commandname);
  }
  else if(commandOri.indexOf('select chain') !== -1) {
    var idArray = commandOri.substr(commandOri.lastIndexOf(' ') + 1).split(',');

    //if(idArray !== null) me.changeChainid(idArray);
    for(var i = 0, il = idArray.length; i < il; ++i) {
        me.selectAChain(idArray[i], idArray[i], false);
    }
  }
  else if(commandOri.indexOf('select alignChain') !== -1) {
    var idArray = commandOri.substr(commandOri.lastIndexOf(' ') + 1).split(',');

    //if(idArray !== null) me.changeChainid(idArray);
    for(var i = 0, il = idArray.length; i < il; ++i) {
        me.selectAChain(idArray[i], 'align_' + idArray[i], true);
    }
  }
  else if(command.indexOf('select zone cutoff') == 0) {
    var radius = parseFloat(command.substr(command.lastIndexOf(' ') + 1));

    me.pickCustomSphere(radius);
  }
  else if(command.indexOf('set surface opacity') == 0) {
    var value = command.substr(command.lastIndexOf(' ') + 1);
    me.icn3d.opts['opacity'] = value;
    me.icn3d.applySurfaceOptions();
  }
  else if(command.indexOf('set surface') == 0) {
    var value = command.substr(12);

    me.icn3d.opts['surface'] = value;
    me.icn3d.applySurfaceOptions();
  }
//  else if(command.indexOf('set map') == 0) {
//    var value = command.substr(8);

//    me.icn3d.opts['map'] = value;
//    me.icn3d.applyMapOptions();
//  }
  else if(command.indexOf('set camera') == 0) {
    var value = command.substr(command.lastIndexOf(' ') + 1);
    me.icn3d.opts['camera'] = value;
  }
  else if(command.indexOf('set background') == 0) {
    var value = command.substr(command.lastIndexOf(' ') + 1);
    me.icn3d.opts['background'] = value;
  }
  else if(commandOri.indexOf('set thickness') == 0) {
    var paraArray = command.split(' | ');

    me.bSetThickness = true;

    for(var i = 1, il = paraArray.length; i < il; ++i) {
        var p1Array = paraArray[i].split(' ');

        var para = p1Array[0];
        var value = parseFloat(p1Array[1]);

        if(para == 'linerad') me.icn3d.lineRadius = value;
        if(para == 'coilrad') me.icn3d.coilWidth = value;
        if(para == 'stickrad') me.icn3d.cylinderRadius = value;
        if(para == 'tracerad') me.icn3d.traceRadius = value;
        if(para == 'ballscale') me.icn3d.dotSphereScale = value;

        if(para == 'ribbonthick') me.icn3d.ribbonthickness = value;
        if(para == 'proteinwidth') me.icn3d.helixSheetWidth = value;
        if(para == 'nucleotidewidth') me.icn3d.nucleicAcidWidth = value;

        me.icn3d.draw();
    }
  }
  else if(command.indexOf('set highlight color') == 0) {
       var color = command.substr(20);
       if(color === 'yellow') {
           me.icn3d.hColor = new THREE.Color(0xFFFF00);
           me.icn3d.matShader = me.icn3d.setOutlineColor('yellow');
       }
       else if(color === 'green') {
           me.icn3d.hColor = new THREE.Color(0x00FF00);
           me.icn3d.matShader = me.icn3d.setOutlineColor('green');
       }
       else if(color === 'red') {
           me.icn3d.hColor = new THREE.Color(0xFF0000);
           me.icn3d.matShader = me.icn3d.setOutlineColor('red');
       }
       me.icn3d.draw(); // required to make it work properly
  }
  else if(command.indexOf('set highlight style') == 0) {
        var style = command.substr(20);

       if(style === 'outline') {
           me.icn3d.bHighlight = 1;
       }
       else if(style === '3d') {
           me.icn3d.bHighlight = 2;
       }

       me.icn3d.draw();
  }
  else if(command.indexOf('add line') == 0) {
    var paraArray = command.split(' | ');
    var p1Array = paraArray[1].split(' ');
    var p2Array = paraArray[2].split(' ');
    var color = paraArray[3].substr(paraArray[3].lastIndexOf(' ') + 1);
    var dashed = paraArray[4].substr(paraArray[4].lastIndexOf(' ') + 1) === 'true' ? true : false;
    var type = paraArray[5].substr(paraArray[5].lastIndexOf(' ') + 1);

    me.addLine(parseFloat(p1Array[1]), parseFloat(p1Array[3]), parseFloat(p1Array[5]), parseFloat(p2Array[1]), parseFloat(p2Array[3]), parseFloat(p2Array[5]), color, dashed, type);
    me.icn3d.draw();
  }
  else if(commandOri.indexOf('add label') == 0) {
    var paraArray = commandOri.split(' | ');
    var text = paraArray[0].substr(('add label').length + 1);

    // add label Text | x 40.45 y 24.465000000000003 z 53.48 | size 40 | color #ffff00 | background #cccccc | type custom
    var x,y,z, size, color, background, type;
    var bPosition = false;
    for(var i = 1, il = paraArray.length; i < il; ++i) {
        var wordArray = paraArray[i].split(' ');

        if(wordArray[0] == 'x') {
            bPosition = true;
            x = wordArray[1];
            y = wordArray[3];
            z = wordArray[5];
        }
        else if(wordArray[0] == 'size') {
            size = paraArray[i].substr(paraArray[i].lastIndexOf(' ') + 1);
        }
        else if(wordArray[0] == 'color') {
            color = paraArray[i].substr(paraArray[i].lastIndexOf(' ') + 1);
        }
        else if(wordArray[0] == 'background') {
            background = paraArray[i].substr(paraArray[i].lastIndexOf(' ') + 1);
        }
        else if(wordArray[0] == 'type') {
            type = paraArray[i].substr(paraArray[i].lastIndexOf(' ') + 1);
        }
    }

    if(!bPosition) {
      var position = me.icn3d.centerAtoms(me.icn3d.hash2Atoms(me.icn3d.hAtoms));
      x = position.center.x;
      y = position.center.y;
      z = position.center.z;
    }

    me.addLabel(text, x,y,z, size, color, background, type);
    me.icn3d.draw();
  }
  else if(commandOri.indexOf('add track') == 0) {
      //"add track | chainid " + chainid + " | title " + title + " | text " + text
      var paraArray = commandOri.split(' | ');

      //var chainid = paraArray[1].substr(8).toUpperCase();
      var chainid = paraArray[1].substr(8);
      var title = paraArray[2].substr(6);
      var text = paraArray[3].substr(5);

      $("#" + me.pre + "anno_custom")[0].checked = true;
      $("[id^=" + me.pre + "custom]").show();

      me.checkGiSeq(chainid, title, text, 0);
  }
  else if(command.indexOf('remove one stabilizer') == 0) {
    var paraArray = command.split(' | ');
    var p1Array = paraArray[1].split(' ');

    var rmLineArray = [];
    rmLineArray.push(parseInt(p1Array[0]));
    rmLineArray.push(parseInt(p1Array[1]));

    me.removeOneStabilizer(rmLineArray);

    //me.updateStabilizer();

    me.icn3d.draw();
  }
  else if(command.indexOf('add one stabilizer') == 0) {
    var paraArray = command.split(' | ');
    var p1Array = paraArray[1].split(' ');

     if(me.icn3d.pairArray === undefined) me.icn3d.pairArray = [];
     me.icn3d.pairArray.push(parseInt(p1Array[0]));
     me.icn3d.pairArray.push(parseInt(p1Array[1]));

     //me.updateStabilizer();

     me.icn3d.draw();
  }

// start with, single word =============
  else if(command.indexOf('pickatom') == 0) {
    var atomid = parseInt(command.substr(command.lastIndexOf(' ') + 1));

    me.icn3d.pAtom = me.icn3d.atoms[atomid];

    me.icn3d.showPicking(me.icn3d.pAtom);
  }
  else if(command.indexOf('hbonds') == 0) {
    var threshold = parseFloat(command.substr(command.indexOf(' ') + 1));

    if(!isNaN(threshold)) me.showHbonds(threshold);
  }
  else if(command.indexOf('color') == 0) {
    var color = command.substr(command.indexOf(' ') + 1);
    me.icn3d.opts['color'] = color;

    me.icn3d.setColorByOptions(me.icn3d.opts, me.icn3d.hAtoms);

    me.updateHlAll();
  }
  else if(command.indexOf('style') == 0) {
    var secondPart = command.substr(command.indexOf(' ') + 1);

    var selectionType = secondPart.substr(0, secondPart.indexOf(' '));
    var style = secondPart.substr(secondPart.indexOf(' ') + 1);

    me.setStyle(selectionType, style);
  }

// special, select ==========

  else if(command.indexOf('select') == 0 && command.indexOf('name') !== -1) {
    var paraArray = commandOri.split(' | '); // atom names might be case-sensitive

    var select = '', commandname = '', commanddesc = '';
    for (var i = 0, il = paraArray.length; i < il; ++i) {
        var para = paraArray[i];

        if(para.indexOf('select') !== -1) {
            select = para.substr(para.indexOf(' ') + 1);
        }
        else if(para.indexOf('name') !== -1) {
            commandname = para.substr(para.indexOf(' ') + 1);
        }
//        else if(para.indexOf('description') !== -1) {
//            commanddesc = para.substr(para.indexOf(' ') + 1);
//        }
    }

//    if(paraArray.length < 3) commanddesc = commandname;
    commanddesc = commandname;

    me.selectByCommand(select, commandname, commanddesc);
  }
  else if(command.indexOf('select $') !== -1 || command.indexOf('select .') !== -1 || command.indexOf('select :') !== -1 || command.indexOf('select @') !== -1) {
    var paraArray = commandOri.split(' | '); // atom names might be case-sensitive

    var select = paraArray[0].substr(paraArray[0].indexOf(' ') + 1);
    var commandname = '', commanddesc = '';

    if(paraArray.length > 1) {
        commandname = paraArray[1].substr(paraArray[1].indexOf(' ') + 1);
    }

    if(paraArray.length > 2) {
        commanddesc = paraArray[2].substr(paraArray[2].indexOf(' ') + 1);
    }

    if(select.indexOf(' or ') !== -1) { // "select " command without " | name"
        me.selectByCommand(select, commandname, commanddesc);
    }
    else { // only single query from selectByCommand()
        me.selectBySpec(select, commandname, commanddesc);
    }
  }

  if(bShowLog) {
      me.setLogCmd(commandOri, false);
  }

  me.bAddCommands = true;
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3DUI.prototype.selectResidues = function(id, that) { var me = this;
  if(id !== undefined && id !== '') {
    // add "align_" in front of id so that full sequence and aligned sequence will not conflict
    //if(id.substr(0, 5) === 'align') id = id.substr(5);

    // seq_div0_1TSR_A_1, align_div0..., giseq_div0..., snp_div0..., interaction_div0..., cddsite_div0..., domain_div0...
    id = id.substr(id.indexOf('_') + 1);

    me.bSelectResidue = true;

    $(that).toggleClass('icn3d-highlightSeq');

    var residueid = id.substr(id.indexOf('_') + 1);

    if(me.icn3d.residues.hasOwnProperty(residueid)) {
        if($(that).hasClass('icn3d-highlightSeq')) {
          for(var j in me.icn3d.residues[residueid]) {
            me.icn3d.hAtoms[j] = 1;
          }
          me.selectedResidues[residueid] = 1;

          if(me.bAnnotations && $(that).attr('disease') !== undefined) {
              var label = $(that).attr('disease');

              var position = me.icn3d.centerAtoms(me.icn3d.hash2Atoms(me.icn3d.residues[residueid]));
              //position.center.add(new THREE.Vector3(3.0, 3.0, 3.0)); // shift a little bit

              var maxlen = 15;
              if(label.length > maxlen) label = label.substr(0, maxlen) + '...';

              //var size = parseInt(me.icn3d.LABELSIZE * 10 / label.length);
              var size = me.icn3d.LABELSIZE;
              var color = me.GREYD;
              me.addLabel(label, position.center.x, position.center.y, position.center.z, size, color, undefined, 'custom');
          }
        }
        else {
            for (var i in me.icn3d.residues[residueid]) {
              //me.icn3d.hAtoms[i] = undefined;
              delete me.icn3d.hAtoms[i];
            }
            //me.selectedResidues[residueid] = undefined;
            delete me.selectedResidues[residueid];

            me.icn3d.removeHlObjects();
        }
    }
  }
};

iCn3DUI.prototype.selectTitle = function(that) { var me = this;
  if($(that).hasClass('icn3d-seqTitle')) {
    var chainid = $(that).attr('chain');

    if(me.bAlignSeq) {
        me.bSelectAlignResidue = false;
    }
    else {
        me.bSelectResidue = false;
    }

    if(!me.bAnnotations) {
        me.removeSeqChainBkgd(chainid);
    }
    //else {
    //    me.removeSeqChainBkgd();
    //}

    if(!me.icn3d.bCtrl && !me.icn3d.bShift) {
        me.removeSeqResidueBkgd();

        me.removeSeqChainBkgd();
    }

    $(that).toggleClass('icn3d-highlightSeq');

    var commandname, commanddescr, position;
    if(!me.bAnnotations) {
        if(me.bAlignSeq) {
            commandname = "align_" + chainid;
        }
        else {
            commandname = chainid;
        }
    }
    else {
        commandname = $(that).attr('setname');
        commanddescr = $(that).attr('title');
    }

    if($(that).hasClass('icn3d-highlightSeq')) {
        if(!me.bAnnotations) {
            if(me.bAlignSeq) {
                if(me.icn3d.bCtrl || me.icn3d.bShift) {
                    me.selectAChain(chainid, commandname, true, true);
                }
                else {
                    me.selectAChain(chainid, commandname, true);
                }

                me.setLogCmd('select alignChain ' + chainid, true);
            }
            else {
                if(me.icn3d.bCtrl || me.icn3d.bShift) {
                    me.selectAChain(chainid, commandname, false, true);
                }
                else {
                    me.selectAChain(chainid, commandname, false);
                }

                me.setLogCmd('select chain ' + chainid, true);
            }
        }
        else {
            if($(that).hasClass('icn3d-highlightSeq')) {
                me.removeHl2D();

                if($(that).attr('gi') !== undefined) {
                    if(me.icn3d.bCtrl || me.icn3d.bShift) {
                        me.selectAChain(chainid, chainid, false, true);
                    }
                    else {
                        me.selectAChain(chainid, chainid, false);
                    }

                    me.setLogCmd('select chain ' + chainid, true);
                }
                else {
                    var residueidHash = {};
                    if($(that).attr('domain') !== undefined || $(that).attr('3ddomain') !== undefined) {
                        me.hlSummaryDomain3ddomain(that);

                        var fromArray = $(that).attr('from').split(',');
                        var toArray = $(that).attr('to').split(',');

                        //me.icn3d.hAtoms = {};

                        //removeAllLabels();

                        // protein chains
                        //var atomHash = {}, residueidHash = {};
                        var residueid;
                        for(var i = 0, il = fromArray.length; i < il; ++i) {
                            var from = parseInt(fromArray[i]);
                            var to = parseInt(toArray[i]);

                            for(var j = from; j <= to; ++j) {
                                residueid = chainid + '_' + (j+1).toString();
                                residueidHash[residueid] = 1;

                                //atomHash = me.icn3d.unionHash(atomHash, me.icn3d.residues[residueid]);
                            }
                        }

                        if(me.icn3d.bCtrl || me.icn3d.bShift) {
                            me.selectResidueList(residueidHash, commandname, commanddescr, true);
                        }
                        else {
                            me.selectResidueList(residueidHash, commandname, commanddescr, false);
                        }

                        //me.updateHlAll();

                        residueid = chainid + '_' + parseInt((from + to)/2).toString();
                        //residueid = chainid + '_' + from.toString();
                        position = me.icn3d.centerAtoms(me.icn3d.hash2Atoms(me.icn3d.residues[residueid]));
                    }
                    //else if($(that).attr('site') !== undefined || $(that).attr('clinvar') !== undefined) {
                    else {
                        var posArray = $(that).attr('posarray').split(',');

                        //me.icn3d.hAtoms = {};

                        //removeAllLabels();

                        //var  atomHash = {}, residueidHash = {};
                        var residueid;
                        for(var i = 0, il = posArray.length; i < il; ++i) {
                            if($(that).attr('site') !== undefined) {
                                residueid = chainid + '_' + (parseInt(posArray[i])+1).toString();
                            }
                            //else if($(that).attr('clinvar') !== undefined) {
                            else {
                                residueid = chainid + '_' + posArray[i];
                            }

                            residueidHash[residueid] = 1;
                            //atomHash = me.icn3d.unionHash(atomHash, me.icn3d.residues[residueid]);
                        }

                        if(me.icn3d.bCtrl || me.icn3d.bShift) {
                            me.selectResidueList(residueidHash, commandname, commanddescr, true);
                        }
                        else {
                            me.selectResidueList(residueidHash, commandname, commanddescr, false);
                        }

                        //me.updateHlAll();

                        residueid = chainid + '_' + posArray[parseInt((0 + posArray.length)/2)].toString();
                        //residueid = chainid + '_' + posArray[0].toString();
                        position = me.icn3d.centerAtoms(me.icn3d.hash2Atoms(me.icn3d.residues[residueid]));
                    }

                    //removeAllLabels
                    for(var name in me.icn3d.labels) {
                        //if(name === 'residue' || name === 'custom' || name === 'clinvar') {
                        if(name !== 'schematic' && name !== 'distance') {
                           me.icn3d.labels[name] = [];
                        }
                    }

                    //var size = parseInt(me.icn3d.LABELSIZE * 10 / commandname.length);
                    var size = me.icn3d.LABELSIZE;
                    var color = "FFFF00";
                    me.addLabel(commanddescr, position.center.x, position.center.y, position.center.z, size, color, undefined, 'custom');

//                        me.icn3d.addHlObjects();
//                        me.updateHl2D([chainid]);

                    me.icn3d.draw();

                    //me.setLogCmd('select ' + commandname, true);
                    //me.setLogCmd('select ' + me.residueids2spec(Object.keys(residueidHash)) + ' | name ' + commandname + ' | description ' + commanddescr, true);
                    me.setLogCmd('select ' + me.residueids2spec(Object.keys(residueidHash)) + ' | name ' + commandname, true);
                } // if($(that).attr('gi') !== undefined) {
            } // if($(that).hasClass('icn3d-highlightSeq')) {
        } // if(!me.bAnnotations) {
    } // if($(that).hasClass('icn3d-highlightSeq')) {
    else {
        me.icn3d.removeHlObjects();
        me.removeHl2D();

        //me.icn3d.hAtoms = {};

       $("#" + me.pre + "atomsCustom").val("");
    }

  }
};

iCn3DUI.prototype.selectSequenceNonMobile = function() { var me = this;
  //$("#" + me.pre + "dl_sequence").add("#" + me.pre + "dl_sequence2").add("#" + me.pre + "dl_annotations").selectable({
  $("#" + me.pre + "dl_sequence2").add("[id^=" + me.pre + "dt_giseq]").add("[id^=" + me.pre + "dt_site]").add("[id^=" + me.pre + "dt_snp]").add("[id^=" + me.pre + "dt_clinvar]").add("[id^=" + me.pre + "dt_cdd]").add("[id^=" + me.pre + "dt_domain]").add("[id^=" + me.pre + "dt_interaction]").add("[id^=" + me.pre + "dt_ssbond]")
  .add("[id^=" + me.pre + "tt_giseq]").add("[id^=" + me.pre + "tt_site]").add("[id^=" + me.pre + "tt_snp]").add("[id^=" + me.pre + "tt_clinvar]").add("[id^=" + me.pre + "tt_cdd]").add("[id^=" + me.pre + "tt_domain]").add("[id^=" + me.pre + "tt_interaction]").add("[id^=" + me.pre + "tt_ssbond]")
  .selectable({
  //$(".icn3d-dl_sequence").selectable({
      stop: function() {
          if($(this).attr('id') === me.pre + "dl_sequence2") {
              me.bAlignSeq = true;
              me.bAnnotations = false;
          }
          //else if($(this).attr('id') === me.pre + "dl_annotations") {
          else {
              me.bAlignSeq = false;
              me.bAnnotations = true;
          }

          if(me.bSelectResidue === false && !me.icn3d.bShift && !me.icn3d.bCtrl) {
              me.removeSelection();
          }

          // select residues
          $("span.ui-selected", this).each(function() {
              var id = $(this).attr('id');

              if(id !== undefined) {
                 me.selectResidues(id, this);
             }
          });

/*
          if(me.bAnnotations) {
              me.icn3d.addResiudeLabels(me.icn3d.hAtoms);

              me.icn3d.draw();
          }
          else {
              me.icn3d.addHlObjects();  // render() is called
          }
*/

          //me.icn3d.addResiudeLabels(me.icn3d.hAtoms, false, 0.5);
          me.icn3d.addHlObjects();  // render() is called

          // get all chainid in the selected residues
          var chainHash = {};
          for(var residueid in me.selectedResidues) {
              var pos = residueid.lastIndexOf('_');
              var chainid = residueid.substr(0, pos);

              chainHash[chainid] = 1;
          }

          // highlight the nodes
          var chainArray2d = Object.keys(chainHash);
          me.updateHl2D(chainArray2d);

          // select annotation title
          $("div.ui-selected", this).each(function() {
              if($(this).attr('chain') !== undefined) {

                  me.selectTitle(this);
              }
          });
      }
  });

  $("[id^=" + me.pre + "ov_giseq]").add("[id^=" + me.pre + "ov_site]").add("[id^=" + me.pre + "ov_snp]").add("[id^=" + me.pre + "ov_clinvar]").add("[id^=" + me.pre + "ov_cdd]").add("[id^=" + me.pre + "ov_domain]").add("[id^=" + me.pre + "ov_interaction]").add("[id^=" + me.pre + "ov_ssbond]")
  .add("[id^=" + me.pre + "tt_giseq]").add("[id^=" + me.pre + "tt_site]").add("[id^=" + me.pre + "tt_snp]").add("[id^=" + me.pre + "tt_clinvar]").add("[id^=" + me.pre + "tt_cdd]").add("[id^=" + me.pre + "tt_domain]").add("[id^=" + me.pre + "tt_interaction]").add("[id^=" + me.pre + "tt_ssbond]")
  .on('click', '.icn3d-seqTitle', function(e) {
      e.stopImmediatePropagation();

      me.bAlignSeq = false;
      me.bAnnotations = true;

      // select annotation title
      //$("div .ui-selected", this).each(function() {
          me.selectTitle(this);

          me.hlSummaryDomain3ddomain(this);
       //});
  });
};

iCn3DUI.prototype.hlSummaryDomain3ddomain = function(that) { var me = this;
  if($(that).attr('domain') !== undefined) { // domain
    var index = $(that).attr('index');
    var chainid = $(that).attr('chain');

    if($("[id^=" + chainid + "_domain_" + index + "]").length !== 0) {
        $("[id^=" + chainid + "_domain_" + index + "]").addClass('icn3d-highlightSeqBox');
    }
  }

  if($(that).attr('3ddomain') !== undefined) { // 3d domain
    var index = $(that).attr('index');
    var chainid = $(that).attr('chain');

    if($("[id^=" + chainid + "_3d_domain_" + index + "]").length !== 0) {
        $("[id^=" + chainid + "_3d_domain_" + index + "]").addClass('icn3d-highlightSeqBox');
    }
  }
};

iCn3DUI.prototype.selectSequenceMobile = function() { var me = this;
  $("#" + me.pre + "dl_sequence2").add("[id^=" + me.pre + "giseq]").add("[id^=" + me.pre + "site]").add("[id^=" + me.pre + "clinvar]").add("[id^=" + me.pre + "snp]").add("[id^=" + me.pre + "cdd]").add("[id^=" + me.pre + "domain]").add("[id^=" + me.pre + "interaction]").add("[id^=" + me.pre + "ssbond]").on('click', '.icn3d-residue', function(e) {
  //$(".icn3d-dl_sequence").on('click', '.icn3d-residue', function(e) {
      e.stopImmediatePropagation();

      if($(this).attr('id') === me.pre + "dl_sequence2") {
          me.bAlignSeq = true;
          me.bAnnotations = false;
      }
      //else if($(this).attr('id') === me.pre + "dl_annotations") {
      else {
          me.bAlignSeq = false;
          me.bAnnotations = true;
      }

      // select residues
      //$("span.ui-selected", this).each(function() {
          var id = $(this).attr('id');

          if(id !== undefined) {
               me.selectResidues(id, this);
         }
      //});

/*
      if(me.bAnnotations) {
          me.icn3d.addResiudeLabels(me.icn3d.hAtoms);

          me.icn3d.draw();
      }
      else {
          me.icn3d.addHlObjects();  // render() is called
      }
*/

      //me.icn3d.addResiudeLabels(me.icn3d.hAtoms, false, 0.5);
       me.icn3d.addHlObjects();  // render() is called

      // get all chainid in the selected residues
      var chainHash = {};
      for(var residueid in me.selectedResidues) {
          var pos = residueid.lastIndexOf('_');
          var chainid = residueid.substr(0, pos);

          chainHash[chainid] = 1;
      }

      // clear nodes in 2d dgm
      me.removeHl2D();

      // highlight the nodes
      var chainArray2d = Object.keys(chainHash);
      me.updateHl2D(chainArray2d);
  });
};

iCn3DUI.prototype.selectChainMobile = function() { var me = this;
  $("#" + me.pre + "dl_sequence2").add("[id^=" + me.pre + "giseq]").add("[id^=" + me.pre + "site]").add("[id^=" + me.pre + "clinvar]").add("[id^=" + me.pre + "snp]").add("[id^=" + me.pre + "cdd]").add("[id^=" + me.pre + "domain]").add("[id^=" + me.pre + "interaction]").add("[id^=" + me.pre + "ssbond]").on('click', '.icn3d-seqTitle', function(e) {
  //$(".icn3d-dl_sequence").on('click', '.icn3d-seqTitle', function(e) {
      e.stopImmediatePropagation();

      if($(this).attr('id') === me.pre + "dl_sequence2") {
          me.bAlignSeq = true;
          me.bAnnotations = false;
      }
      //else if($(this).attr('id') === me.pre + "dl_annotations") {
      else {
          me.bAlignSeq = false;
          me.bAnnotations = true;
      }

      // select annotation title
      //$("div.ui-selected", this).each(function() {
          me.selectTitle(this);

          me.hlSummaryDomain3ddomain(this);
      //});
  });
};

// remove highlight of chains
iCn3DUI.prototype.removeSeqChainBkgd = function(currChain) {
  if(currChain === undefined) {
    $( ".icn3d-seqTitle" ).each(function( index ) {
      $( this ).removeClass('icn3d-highlightSeq');
      $( this ).removeClass('icn3d-highlightSeqBox');
    });
  }
  else {
    $( ".icn3d-seqTitle" ).each(function( index ) {
      if($(this).attr('chain') !== currChain) {
          $( this ).removeClass('icn3d-highlightSeq');
          $( this ).removeClass('icn3d-highlightSeqBox');
      }
    });
  }
};

// remove all highlighted residue color
iCn3DUI.prototype.removeSeqResidueBkgd = function() {
    $( ".icn3d-residue" ).each(function( index ) {
      $( this ).removeClass('icn3d-highlightSeq');
    });
};


/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3DUI.prototype.update2DdgmContent = function () { var me = this;
   // update 2D diagram to show just the displayed parts
   var html2ddgm = '';
   if(me.cfg.mmdbid !== undefined || me.cfg.gi !== undefined) {
      html2ddgm += me.draw2Ddgm(me.interactionData, me.inputid, undefined, true);
      html2ddgm += me.set2DdgmNote();

      $("#" + me.pre + "dl_2ddgm").html(html2ddgm);
   }
   else if(me.cfg.align !== undefined) {
      html2ddgm += me.draw2Ddgm(me.interactionData1, me.mmdbidArray[0].toUpperCase(), 0, true);
      html2ddgm += me.draw2Ddgm(me.interactionData2, me.mmdbidArray[1].toUpperCase(), 1, true);
      html2ddgm += me.set2DdgmNote(true);

      $("#" + me.pre + "dl_2ddgm").html(html2ddgm);
   }
};

iCn3DUI.prototype.changeSeqColor = function(residueArray) { var me = this;
   for(var i = 0, il = residueArray.length; i < il; ++i) {
       var pickedResidue = residueArray[i];
       if($("[id$=" + me.pre + pickedResidue + "]").length !== 0) {
         var atom = me.icn3d.getFirstCalphaAtomObj(me.icn3d.residues[pickedResidue]);
         var color = (atom.color !== undefined) ? "#" + atom.color.getHexString() : me.icn3d.defaultAtomColor;
         //$("[id$=" + me.pre + pickedResidue + "]").attr('style', 'color:' + color);
         // annotations will have their own color, only the chain will have the changed color
         $("[id=giseq_" + me.pre + pickedResidue + "]").attr('style', 'color:' + color);
         if(me.cfg.align !== undefined) $("[id=align_" + me.pre + pickedResidue + "]").attr('style', 'color:' + color);
       }
   }
};

iCn3DUI.prototype.removeHlAll = function() { var me = this;
       me.removeHlObjects();
       me.removeHlSeq();
       me.removeHl2D();
       me.removeHlMenus();
};

iCn3DUI.prototype.removeHlObjects = function() { var me = this;
       me.icn3d.removeHlObjects();
};

// remove highlight in sequence
iCn3DUI.prototype.removeHlSeq = function() { var me = this;
//       me.removeSeqChainBkgd();
       me.removeSeqResidueBkgd();
};

// remove highlight in 2D window
iCn3DUI.prototype.removeHl2D = function() { var me = this;
      // clear nodes in 2d dgm
      $("#" + me.pre + "dl_2ddgm rect").attr('stroke', '#000000');
      $("#" + me.pre + "dl_2ddgm circle").attr('stroke', '#000000');
      $("#" + me.pre + "dl_2ddgm polygon").attr('stroke', '#000000');

      $("#" + me.pre + "dl_2ddgm svg line").attr('stroke', '#000000');

      $("#" + me.pre + "dl_2ddgm rect").attr('stroke-width', 1);
      $("#" + me.pre + "dl_2ddgm circle").attr('stroke-width', 1);
      $("#" + me.pre + "dl_2ddgm polygon").attr('stroke-width', 1);

      $("#" + me.pre + "dl_2ddgm line").attr('stroke-width', 1);
};

// remove highlight in the menu of defined sets
iCn3DUI.prototype.removeHlMenus = function() { var me = this;
    $("#" + me.pre + "atomsCustom").val("");
};

iCn3DUI.prototype.updateHlAll = function(commandnameArray, bSetMenu, bUnion, bForceHighlight) { var me = this;
       me.updateHlObjects(bForceHighlight);

       if(commandnameArray !== undefined) {
           me.updateHlSeqInChain(commandnameArray, bUnion);
       }
       else {
           me.updateHlSeq(undefined, undefined, bUnion);
       }

       me.updateHl2D();
       if(bSetMenu === undefined || bSetMenu) me.updateHlMenus(commandnameArray);

       //me.showAnnoSelectedChains();
};

iCn3DUI.prototype.updateHlObjects = function(bForceHighlight) { var me = this;
       me.icn3d.removeHlObjects();

       if(Object.keys(me.icn3d.hAtoms).length < Object.keys(me.icn3d.atoms).length || bForceHighlight) {
           me.icn3d.addHlObjects();
       }
};

// update highlight in sequence, slow if sequence is long
iCn3DUI.prototype.updateHlSeq = function(bShowHighlight, residueHash, bUnion) { var me = this;
       if(bUnion === undefined || !bUnion) {
           me.removeHlSeq();
       }

       if(residueHash === undefined) residueHash = me.icn3d.getResiduesFromCalphaAtoms(me.icn3d.hAtoms);

       if(Object.keys(me.icn3d.hAtoms).length < Object.keys(me.icn3d.atoms).length) me.hlSeq(Object.keys(residueHash));
       me.changeSeqColor(Object.keys(residueHash));
};

iCn3DUI.prototype.updateHlSeqInChain = function(commandnameArray, bUnion) { var me = this;
       if(bUnion === undefined || !bUnion) {
           me.removeHlSeq();
       }
       //if(residueHash === undefined) residueHash = me.icn3d.getResiduesFromCalphaAtoms(me.icn3d.hAtoms);

       if(Object.keys(me.icn3d.hAtoms).length == Object.keys(me.icn3d.atoms).length) return;

       //me.hlSeq(Object.keys(residueHash));
       // speed up with chain highlight
       for(var i = 0, il = commandnameArray.length; i < il; ++i) {
           var commandname = commandnameArray[i];
           if(Object.keys(me.icn3d.chains).indexOf(commandname) !== -1) {
               me.hlSeqInChain(commandname);
           }
           else {
               var residueArray = [];

               if(me.icn3d.defNames2Residues[commandname] !== undefined && me.icn3d.defNames2Residues[commandname].length > 0) {
                   residueArray = me.icn3d.defNames2Residues[commandname];
               }

               var residueHash = {};
               if(me.icn3d.defNames2Atoms[commandname] !== undefined && me.icn3d.defNames2Atoms[commandname].length > 0) {
                   for(var j = 0, jl = me.icn3d.defNames2Atoms[commandname].length; j < jl; ++j) {
                       var serial = me.icn3d.defNames2Atoms[commandname][j];
                       var atom = me.icn3d.atoms[serial];
                       var resid = atom.structure + '_' + atom.chain + '_' + atom.resi;

                       residueHash[resid] = 1;
                   }

                   residueArray = residueArray.concat(Object.keys(residueHash));
               }

               me.hlSeq(residueArray);
           }
       }

       //me.changeSeqColor(Object.keys(residueHash));
};

// update highlight in 2D window
iCn3DUI.prototype.updateHl2D = function(chainArray2d) { var me = this;
  me.removeHl2D();

  if(Object.keys(me.icn3d.hAtoms).length == Object.keys(me.icn3d.atoms).length) return;

  if(chainArray2d === undefined) {
      var chainHash = me.icn3d.getChainsFromAtoms(me.icn3d.hAtoms);
      chainArray2d = Object.keys(chainHash);
  }

  if(chainArray2d !== undefined) {
      for(var i = 0, il = chainArray2d.length; i < il; ++i) {
          var hlatoms = me.icn3d.intHash(me.icn3d.chains[chainArray2d[i]], me.icn3d.hAtoms);
          var ratio = 1.0 * Object.keys(hlatoms).length / Object.keys(me.icn3d.chains[chainArray2d[i]]).length;

          var firstAtom = me.icn3d.getFirstCalphaAtomObj(hlatoms);
          if(me.icn3d.alnChains[chainArray2d[i]] !== undefined) {
                var alignedAtoms = me.icn3d.intHash(me.icn3d.alnChains[chainArray2d[i]], hlatoms);
                if(Object.keys(alignedAtoms).length > 0) firstAtom = me.icn3d.getFirstCalphaAtomObj(alignedAtoms);
            }
          var color = (firstAtom !== undefined && firstAtom.color !== undefined) ? '#' + firstAtom.color.getHexString() : '#FFFFFF';

          var target = $("#" + me.pre + "dl_2ddgm g[chainid=" + chainArray2d[i] + "] rect[class='icn3d-hlnode']");
          var base = $("#" + me.pre + "dl_2ddgm g[chainid=" + chainArray2d[i] + "] rect[class='icn3d-basenode']");
          if(target !== undefined) {
              me.highlightNode('rect', target, base, ratio);
              $(target).attr('fill', color);
          }

          target = $("#" + me.pre + "dl_2ddgm g[chainid=" + chainArray2d[i] + "] circle[class='icn3d-hlnode']");
          base = $("#" + me.pre + "dl_2ddgm g[chainid=" + chainArray2d[i] + "] circle[class='icn3d-basenode']");
          if(target !== undefined) {
                me.highlightNode('circle', target, base, ratio);
                $(target).attr('fill', color);
          }

          target = $("#" + me.pre + "dl_2ddgm g[chainid=" + chainArray2d[i] + "] polygon[class='icn3d-hlnode']");
          base = $("#" + me.pre + "dl_2ddgm g[chainid=" + chainArray2d[i] + "] polygon[class='icn3d-basenode']");

          if(target !== undefined) {
              me.highlightNode('polygon', target, base, ratio);
              $(target).attr('fill', color);
          }
      }
  }

  if(me.lineArray2d !== undefined) {
      for(var i = 0, il = me.lineArray2d.length; i < il; i += 2) {
          $("#" + me.pre + "dl_2ddgm g[chainid1=" + me.lineArray2d[i] + "][chainid2=" + me.lineArray2d[i + 1] + "] line").attr('stroke', me.ORANGE);
      }
  }

  // update the previously highlisghted atoms for switching between all and selection
  me.icn3d.prevHighlightAtoms = me.icn3d.cloneHash(me.icn3d.hAtoms);

  me.setMode('selection');
};

// update highlight in the menu of defined sets
iCn3DUI.prototype.updateHlMenus = function(commandnameArray) { var me = this;
    if(commandnameArray === undefined) commandnameArray = [];

    var definedAtomsHtml = me.setAtomMenu(commandnameArray);

    if($("#" + me.pre + "atomsCustom").length) {
        $("#" + me.pre + "atomsCustom").html(definedAtomsHtml);
    }
};

iCn3DUI.prototype.setAtomMenu = function (commandnameArray) { var me = this;
  var html = "";

  var nameArray1 = (me.icn3d.defNames2Residues !== undefined) ? Object.keys(me.icn3d.defNames2Residues) : [];
  var nameArray2 = (me.icn3d.defNames2Atoms !== undefined) ? Object.keys(me.icn3d.defNames2Atoms) : [];

  var nameArray = nameArray1.concat(nameArray2).sort();

  //for(var i in me.icn3d.defNames2Atoms) {
  for(var i = 0, il = nameArray.length; i < il; ++i) {
      var name = nameArray[i];

      var atom, atomHash;
      if(me.icn3d.defNames2Atoms !== undefined && me.icn3d.defNames2Atoms.hasOwnProperty(name)) {
          var atomArray = me.icn3d.defNames2Atoms[name];

          if(atomArray.length > 0) atom = me.icn3d.atoms[atomArray[0]];
      }
      else if(me.icn3d.defNames2Residues !== undefined && me.icn3d.defNames2Residues.hasOwnProperty(name)) {
          var residueArray = me.icn3d.defNames2Residues[name];
          if(residueArray.length > 0) {
              atomHash = me.icn3d.residues[residueArray[0]]
              if(atomHash) {
                  atom = me.icn3d.atoms[Object.keys(atomHash)[0]];
              }
          }
      }

      var color = (atom !== undefined) ? atom.color.getHexString() : '000000';

      if(commandnameArray.indexOf(name) != -1) {
        html += "<option value='" + name + "' style='color:#" + color + "' selected='selected'>" + name + "</option>";
      }
      else {
        html += "<option value='" + name + "' style='color:#" + color + "'>" + name + "</option>";
      }
  }

  return html;
};

iCn3DUI.prototype.setPredefinedInMenu = function() { var me = this;
      // predefined sets: all chains
      me.setChainsInMenu();

      // predefined sets: proteins,nucleotides, chemicals
      me.setProtNuclLigInMenu();

      if(me.cfg.align !== undefined && me.bFullUi) {
        me.selectResidueList(me.consHash1, me.conservedName1, me.conservedName1, false, false);
        me.selectResidueList(me.consHash2, me.conservedName2, me.conservedName2, false, false);

        me.selectResidueList(me.nconsHash1, me.nonConservedName1, me.nonConservedName1, false, false);
        me.selectResidueList(me.nconsHash2, me.nonConservedName2, me.nonConservedName2, false, false);

        me.selectResidueList(me.nalignHash1, me.notAlignedName1, me.notAlignedName1, false, false);
        me.selectResidueList(me.nalignHash2, me.notAlignedName2, me.notAlignedName2, false, false);

        // for alignment, show aligned residues, chemicals, and ions
        var dAtoms = {};
        for(var alignChain in me.icn3d.alnChains) {
            dAtoms = me.icn3d.unionHash(dAtoms, me.icn3d.alnChains[alignChain]);
        }

        var residuesHash = {}, chains = {};
        for(var i in dAtoms) {
            var atom = me.icn3d.atoms[i];

            var chainid = atom.structure + '_' + atom.chain;
            var resid = chainid + '_' + atom.resi;
            residuesHash[resid] = 1;
            chains[chainid] = 1;
        }

        var commandname = 'aligned_protein';
        var commanddescr = 'aligned protein and nucleotides';
        var select = "select " + me.residueids2spec(Object.keys(residuesHash));

        //me.addCustomSelection(Object.keys(residuesHash), Object.keys(dAtoms), commandname, commanddescr, select, true);
        me.addCustomSelection(Object.keys(residuesHash), commandname, commanddescr, select, true);
      }
};

iCn3DUI.prototype.hlSeq = function(residueArray) { var me = this;
   // update annotation windows and alignment sequences
   var chainHash = {};
   for(var i = 0, il = residueArray.length; i < il; ++i) {
       var pickedResidue = residueArray[i];
       if($("[id$=" + me.pre + pickedResidue + "]").length !== 0) {
         $("[id$=" + me.pre + pickedResidue + "]").addClass('icn3d-highlightSeq');
       }

       var pos = pickedResidue.lastIndexOf('_');
       var chainid = pickedResidue.substr(0, pos);

       chainHash[chainid] = 1;
   }

   for(var chainid in chainHash) {
       if($("#giseq_summary_" + me.pre + chainid).length !== 0) {
         $("#giseq_summary_" + me.pre + chainid).addClass('icn3d-highlightSeqBox');
       }
   }
};

iCn3DUI.prototype.hlSeqInChain = function(chainid) { var me = this;
   // update annotation windows and alignment sequences
   for(var i = 0, il = me.icn3d.chainsSeq[chainid].length; i < il; ++i) {
       var resi = me.icn3d.chainsSeq[chainid][i].resi;
       var pickedResidue = chainid + '_' + resi;

       //if($("[id$=" + me.pre + pickedResidue + "]").length !== 0) {
       //  $("[id$=" + me.pre + pickedResidue + "]").addClass('icn3d-highlightSeq');
       //}
       // too expensive to highlight all annotations
       if($("#giseq_" + me.pre + pickedResidue).length !== 0) {
         $("#giseq_" + me.pre + pickedResidue).addClass('icn3d-highlightSeq');
       }
   }

   if($("#giseq_summary_" + me.pre + chainid).length !== 0) {
     $("#giseq_summary_" + me.pre + chainid).addClass('icn3d-highlightSeqBox');
   }
};

iCn3DUI.prototype.toggleHighlight = function() { var me = this;
    //me.setLogCmd("toggle highlight", true);

    if(me.icn3d.prevHighlightObjects.length > 0 || me.icn3d.prevHighlightObjects_ghost.length > 0) { // remove
        me.clearHighlight();
    }
    else { // add
        me.showHighlight();
    }

    me.setLogCmd("toggle highlight", true);
};

iCn3DUI.prototype.clearHighlight = function() { var me = this;
    me.icn3d.labels['picking']=[];
    me.icn3d.draw();

    me.icn3d.removeHlObjects();
    me.removeHl2D();
    me.icn3d.render();

    me.removeSeqChainBkgd();
    me.removeSeqResidueBkgd();

    me.bSelectResidue = false;
};

iCn3DUI.prototype.showHighlight = function() { var me = this;
    me.icn3d.addHlObjects();
    me.updateHlAll();
    //me.bSelectResidue = true;
};

iCn3DUI.prototype.highlightChains = function(chainArray) { var me = this;
    me.icn3d.removeHlObjects();
    me.removeHl2D();

    me.icn3d.addHlObjects();
    me.updateHl2D(chainArray);

    var residueHash = {};
    for(var c = 0, cl = chainArray.length; c < cl; ++c) {
        var chainid = chainArray[c];
        for(var i in me.icn3d.chainsSeq[chainid]) { // get residue number
            var resObj = me.icn3d.chainsSeq[chainid][i];
            var residueid = chainid + "_" + resObj.resi;

            if(resObj.name !== '' && resObj.name !== '-') {
              residueHash[residueid] = 1;
            }
        }
    }

    me.hlSeq(Object.keys(residueHash));
};


/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3DUI.prototype.setTools = function() { var me = this;
    var html = "";

    html += "  <div id='" + me.pre + "selection' style='display:none;'><div style='position:absolute; z-index:555; float:left; display:table-row; margin: 32px 0px 0px 3px;'>";
    html += "    <table style='margin-top: 3px; width:100px;'><tr valign='center'>";

    html += me.setTools_base();

    // add custom buttons here
    // ...

    html += "    </tr></table>";
    html += "  </div></div>";

    return html;
};

iCn3DUI.prototype.setButton = function(buttonStyle, id, title, text) { var me = this;
    var bkgdColor = me.isMobile() ? ' background-color:#DDDDDD;' : '';
    return "<div style='margin:3px 0px 0px 10px;'><button style='-webkit-appearance:" + buttonStyle + "; height:36px;" + bkgdColor + "' id='" + me.pre + id + "'><span style='white-space:nowrap' class='icn3d-commandTitle' title='" + title + "'>" + text + "</span></button></div>";
};

iCn3DUI.prototype.setTools_base = function() { var me = this;
    // second row
    var html = "";

    var buttonStyle = me.isMobile() ? 'none' : 'button';

    html += "      <td valign='top'>" + me.setButton(buttonStyle, 'saveimage', 'Save iCn3D PNG Image', 'Save iCn3D<br/>PNG Image') + "</td>";

    if(me.cfg.cid === undefined) {
        //html += "      <td valign='top'>" + me.setButton(buttonStyle, 'definedSets', 'Select defined structure, chain, and custom sets', 'Defined <br/>Sets') + "</td>";
        html += "      <td valign='top'>" + me.setButton(buttonStyle, 'definedsets', 'Defined Sets', 'Defined<br/>Sets') + "</td>";

        html += "      <td valign='top'>" + me.setButton(buttonStyle, 'show_annotations', 'View sequences and annotations for each chain', 'View Sequences<br/>& Annotations') + "</td>";

        if(me.cfg.align !== undefined) {
            html += "      <td valign='top'>" + me.setButton(buttonStyle, 'show_alignsequences', 'View the sequences of the aligned structures', 'Aligned<br/>Sequences') + "</td>";
        }

        if(me.cfg.mmdbid !== undefined || me.cfg.gi !== undefined || me.cfg.blast_rep_id !== undefined || me.cfg.align !== undefined) {
            html += "      <td valign='top'>" + me.setButton(buttonStyle, 'show_2ddgm', 'View the interactions of the structure', 'View<br/>Interactions') + "</td>";
        }

        html += "      <td valign='top'>" + me.setButton(buttonStyle, 'chemicalbindingshow', 'View Chemical Binding', 'View Chemical<br/>Binding') + "</td>";

        html += "      <td valign='top'>" + me.setButton(buttonStyle, 'alternate', 'Alternate the structures', 'Alternate<br/>(Key \"a\")') + "</td>";
    }

    html += "      <td valign='top'>" + me.setButton(buttonStyle, 'show_selected', 'View ONLY the selected atoms', 'View Only<br/>Selection') + "</td>";

    html += "      <td valign='top'>" + me.setButton(buttonStyle, 'toggleHighlight', 'Turn on and off the 3D highlight in the viewer', 'Toggle<br/>Highlight') + "</td>";

    if(me.cfg.cid === undefined) {
        html += "      <td valign='top'>" + me.setButton(buttonStyle, 'removeLabels', 'Remove Labels', 'Remove<br/>Labels') + "</td>";
    }

    return html;
};

iCn3DUI.prototype.setTopMenusHtml = function (id) { var me = this;
    var html = "";

    html += "<div style='position:relative;'>";

    html += "<div id='" + me.pre + "popup' class='icn3d-text icn3d-popup'></div>";

    html += "  <!--https://forum.jquery.com/topic/looking-for-a-jquery-horizontal-menu-bar-->";
    html += "  <div id='" + me.pre + "mnlist' style='position:absolute; z-index:999; float:left; display:table-row; margin-top: -2px;'>";
    html += "    <table border='0' cellpadding='0' cellspacing='0' width='100'><tr>";

    html += "    <td valign='top'>" + me.setMenu1() + "</td>";
    html += "    <td valign='top'>" + me.setMenu2() + "</td>";
    html += "    <td valign='top'>" + me.setMenu2b() + "</td>";
    html += "    <td valign='top'>" + me.setMenu3() + "</td>";
    html += "    <td valign='top'>" + me.setMenu4() + "</td>";
    html += "    <td valign='top'>" + me.setMenu5() + "</td>";
    //html += "    <td valign='top'>" + me.setMenu5b() + "</td>";
    html += "    <td valign='top'>" + me.setMenu6() + "</td>";

    html += "    <td valign='top'><div style='position:relative; margin-left:6px;'><label class='icn3d-switch'><input id='" + me.pre + "modeswitch' type='checkbox'><div class='icn3d-slider icn3d-round' style='width:34px; height:18px; margin: 6px 0px 0px 3px;' title='Left (\"All atoms\"): Style and color menu options will be applied to all atoms in the structure&#13;Right (\"Selection\"): Style and color menu options will be applied only to selected atoms'></div></label>";
    html += "    <div class='icn3d-commandTitle' style='min-width:40px; margin-top: 3px; white-space: nowrap;'><span id='" + me.pre + "modeall' title='Style and color menu options will be applied to all atoms in the structure'>All atoms&nbsp;&nbsp;</span><span id='" + me.pre + "modeselection' class='icn3d-modeselection' style='display:none;' title='Style and color menu options will be applied only to selected atoms'>Selection&nbsp;&nbsp;</span></div></div></td>";

    //html += '    <td valign="top"><div class="icn3d-commandTitle" style="white-space:nowrap; margin-top:10px;"><div style="width:20px; display:inline-block; margin-left:6px;"><span id="' + me.pre +  'selection_expand" class="ui-icon ui-icon-plus icn3d-link" style="width:15px;" title="Expand"></span><span id="' + me.pre +  'selection_shrink" class="ui-icon ui-icon-minus icn3d-link" style="display:none; width:15px;" title="Shrink"></span></div> Tools</div></td>';

    //html += '    <td valign="top"><div class="icn3d-commandTitle" style="white-space:nowrap; margin-top:10px;"><span id="' + me.pre +  'selection_expand" class="icn3d-expand icn3d-link" title="Expand"><span class="ui-icon ui-icon-plus"></span> Show Tools</span><span id="' + me.pre +  'selection_shrink" class="icn3d-shrink icn3d-link" style="display:none;" title="Shrink"><span class="ui-icon ui-icon-minus"></span> Hide Tools</span></div></td>';
    html += '    <td valign="top"><div class="icn3d-commandTitle" style="white-space:nowrap; margin-top:10px; border-left:solid 1px #888888"><span id="' + me.pre +  'selection_expand" class="icn3d-expand icn3d-link" title="Expand">&nbsp;&nbsp;Show Toolbar&nbsp;&nbsp;</span><span id="' + me.pre +  'selection_shrink" class="icn3d-shrink icn3d-link" style="display:none;" title="Shrink">&nbsp;&nbsp;Hide Toolbar&nbsp;&nbsp;</span></div></td>';

    html += '    <td valign="top"><div class="icn3d-commandTitle" style="white-space:nowrap; margin-top:8px; border-left:solid 1px #888888">&nbsp;&nbsp;<input type="text" id="' + me.pre + 'search_seq" size="10" placeholder="one-letter seq."> <button style="white-space:nowrap;" id="' + me.pre + 'search_seq_button">Search Seq.</button> <a href="https://www.ncbi.nlm.nih.gov/Structure/icn3d/icn3d.html#selectb" target="_blank" title="Specification tips">?</a></div></td>';

    html += "  </tr>";
    html += "  </table>";
    html += "  </div>";

    html += me.setTools();

    // show title at the top left corner
    html += "  <div id='" + me.pre + "title' class='icn3d-commandTitle' style='font-size:1.2em; font-weight:normal; position:absolute; z-index:1; float:left; display:table-row; margin: 85px 0px 0px 5px; color: " + me.GREYD + "'></div>";
    html += "  <div id='" + me.pre + "viewer' style='position:relative; width:100%; height:100%; background-color: " + me.GREYD + ";'>";
    html += "   <div id='" + me.pre + "mnLogSection'>";
    html += "    <div style='height: " + me.MENU_HEIGHT + "px;'></div>";
//        html += "    <div style='height: " + me.MENU_HEIGHT + "px;'></div>";

    html += "   </div>";

    //$("#" + me.divid).css('background-color', me.GREYD);

    if(me.cfg.mmtfid === undefined) {
        if(me.realHeight < 300) {
            html += "    <div id='" + me.pre + "wait' style='position:absolute; top:100px; left:50px; font-size: 1.2em; color: #444444;'>Loading data...</div>";
        }
        else {
            html += "    <div id='" + me.pre + "wait' style='position:absolute; top:180px; left:50px; font-size: 1.8em; color: #444444;'>Loading data...</div>";
        }
    }
    html += "    <canvas id='" + me.pre + "canvas' style='width:100%; height: 100%; background-color: #000;'>Your browser does not support WebGL.</canvas>";

    // separate for the log box
    if(me.cfg.showcommand === undefined || me.cfg.showcommand) {
        html += me.setLogWindow();
    }

    html += "  </div>";

    html += "</div>";

    html += me.setDialogs();

    html += me.setCustomDialogs();

    $( "#" + id).html(html);

    // mn display
    $("accordion").accordion({ collapsible: true, active: false, heightStyle: "content"});
    $("accordion div").removeClass("ui-accordion-content ui-corner-all ui-corner-bottom ui-widget-content");

    $(".icn3d-mn").menu({position: { my: "left top", at: "right top" }});
    $(".icn3d-mn").hover(function(){},function(){$("accordion").accordion( "option", "active", "none");});

    $("#" + me.pre + "accordion1").hover( function(){ $("#" + me.pre + "accordion1 div").css("display", "block"); }, function(){ $("#" + me.pre + "accordion1 div").css("display", "none"); } );

    $("#" + me.pre + "accordion2").hover( function(){ $("#" + me.pre + "accordion2 div").css("display", "block"); }, function(){ $("#" + me.pre + "accordion2 div").css("display", "none"); } );

    $("#" + me.pre + "accordion2b").hover( function(){ $("#" + me.pre + "accordion2b div").css("display", "block"); }, function(){ $("#" + me.pre + "accordion2b div").css("display", "none"); } );

    $("#" + me.pre + "accordion3").hover( function(){ $("#" + me.pre + "accordion3 div").css("display", "block"); }, function(){ $("#" + me.pre + "accordion3 div").css("display", "none"); } );

    $("#" + me.pre + "accordion4").hover( function(){ $("#" + me.pre + "accordion4 div").css("display", "block"); }, function(){ $("#" + me.pre + "accordion4 div").css("display", "none"); } );

    $("#" + me.pre + "accordion5").hover( function(){ $("#" + me.pre + "accordion5 div").css("display", "block"); }, function(){ $("#" + me.pre + "accordion5 div").css("display", "none"); } );

    //$("#" + me.pre + "accordion5b").hover( function(){ $("#" + me.pre + "accordion5b div").css("display", "block"); }, function(){ $("#" + me.pre + "accordion5b div").css("display", "none"); } );

    $("#" + me.pre + "accordion6").hover( function(){ $("#" + me.pre + "accordion6 div").css("display", "block"); }, function(){ $("#" + me.pre + "accordion6 div").css("display", "none"); } );
};

iCn3DUI.prototype.getLink = function(id, text) { var me = this;
    return "<li><span id='" + me.pre + id + "' class='icn3d-link'>" + text + "</span></li>";
};

iCn3DUI.prototype.getLinkWrapper = function(id, text, wrapper) { var me = this;
    return "<li id='" + me.pre + wrapper + "'><span id='" + me.pre + id + "' class='icn3d-link'>" + text + "</span></li>";
};

iCn3DUI.prototype.getRadio = function(radioid, id, text, bChecked) { var me = this;
    var checkedStr = (bChecked !== undefined && bChecked) ? ' checked' : '';
    //return "<li><input type='radio' name='" + me.pre + radioid + "' id='" + me.pre + id + "'" + checkedStr + "><label for='" + me.pre + id + "'>" + text + "</label></li>";

    //https://stackoverflow.com/questions/17541614/use-images-instead-of-radio-buttons/17541916
    return "<li><label for='" + me.pre + id + "' class='icn3d-rad'><input type='radio' name='" + me.pre + radioid + "' id='" + me.pre + id + "'" + checkedStr + "><span class='ui-icon ui-icon-blank'></span> <span class='icn3d-rad-text'>" + text + "</span></label></li>";
};

iCn3DUI.prototype.setMenu1 = function() { var me = this;
    var html = "";

    html += "    <div class='icn3d-menu'>";
    html += "          <accordion id='" + me.pre + "accordion1'>";
    html += "<h3>File</h3>";
    html += "<div>";
    html += "<ul class='icn3d-mn'>";
    html += "  <li><span>Retrieve by ID</span>";
    html += "    <ul>";
    html += me.getLink('mn1_mmdbid', 'MMDB ID');
    html += me.getLink('mn1_mmtfid', 'MMTF ID');
    html += me.getLink('mn1_pdbid', 'PDB ID');
    html += me.getLink('mn1_mmcifid', 'mmCIF ID');
    html += me.getLink('mn1_gi', 'NCBI gi');
    html += me.getLink('mn1_cid', 'PubChem CID');
    html += "    </ul>";
    html += "  </li>";
    html += "  <li><span>Open File</span>";
    html += "    <ul>";
    html += me.getLink('mn1_pdbfile', 'PDB File');
    html += me.getLink('mn1_mmciffile', 'mmCIF File');
    html += me.getLink('mn1_mol2file', 'Mol2 File');
    html += me.getLink('mn1_sdffile', 'SDF File');
    html += me.getLink('mn1_xyzfile', 'XYZ File');
    html += me.getLink('mn1_urlfile', 'Url (Same Host) ');
    html += "      <li>-</li>";
    html += me.getLink('mn1_pngimage', 'iCn3D PNG Image');
    html += me.getLink('mn1_state', 'State/Script File');
    html += me.getLink('mn1_selection', 'Selection File');
    html += "    </ul>";
    html += "  </li>";
    html += "  <li><span>Align</span>";
    html += "    <ul>";
    html += me.getLink('mn1_blast_rep_id', 'Sequence to Structure');
    html += me.getLink('mn1_align', 'Structure to Structure');
    html += "    </ul>";
    html += "  </li>";
    html += "  <li><span>3D Printing</span>";
    html += "    <ul>";
    if(me.cfg.cid === undefined) {
        html += me.getLink('mn1_exportVrmlStab', 'VRML (Color, W/  Stabilizers)');
        html += me.getLink('mn1_exportStlStab', 'STL (W/  Stabilizers)');
        html += "      <li>-</li>";
        html += me.getLink('mn1_exportVrml', 'VRML (Color)');
        html += me.getLink('mn1_exportStl', 'STL');
        html += "      <li>-</li>";
        html += me.getLink('mn1_stabilizerYes', 'Add All  Stabilizers');
        html += me.getLink('mn1_stabilizerNo', 'Remove All  Stabilizers');
        html += "      <li>-</li>";
        html += me.getLink('mn1_stabilizerOne', 'Add One  Stabilizer');
        html += me.getLink('mn1_stabilizerRmOne', 'Remove One  Stabilizer');
        html += "      <li>-</li>";
        html += me.getLink('mn1_thicknessSet', 'Set Thickness');
        html += me.getLink('mn1_thicknessReset', 'Reset Thickness');
    }
    else {
        html += me.getLink('mn1_exportVrml', 'VRML (Color)');
        html += me.getLink('mn1_exportStl', 'STL');
    }

    html += "    </ul>";
    html += "  </li>";

    html += "  <li><span>Save Files</span>";
    html += "    <ul>";
    html += me.getLink('mn1_exportCanvas', 'iCn3D PNG Image');
    html += me.getLink('mn1_exportState', 'State File');
    html += me.getLink('mn1_exportSelections', 'Selection File');
    html += me.getLink('mn1_exportCounts', 'Residue Counts');
    if(me.cfg.mmdbid !== undefined) {
     html += me.getLink('mn6_exportInteraction', 'Interaction List');
    }

    html += "    </ul>";
    html += "  </li>";

    html += me.getLink('mn1_sharelink', 'Share Link');

    html += "</ul>";
    html += "</div>";
    html += "          </accordion>";
    html += "    </div>";

    return html;
};

iCn3DUI.prototype.setMenu2 = function() { var me = this;
    var html = "";

    html += "    <div class='icn3d-menu'>";
    html += "          <accordion id='" + me.pre + "accordion2'>";
    html += "<h3>Select</h3>";
    html += "<div>";
    html += "<ul class='icn3d-mn'>";

    html += me.getLink('mn2_definedsets', 'Defined Sets');
    html += me.getLink('mn2_selectall', 'All');
//        if(me.cfg.cid === undefined) {
//            html += me.getRadio('mn2_select', 'mn2_select_chain', 'Defined Sets');
//        }
    html += me.getLink('mn2_aroundsphere', 'by Distance');
    html += me.getLink('mn2_selectcomplement', 'Inverse');
    html += me.getLink('mn2_selectsidechains', 'Side Chains');
    html += me.getLink('mn2_command', 'Advanced');


    //html += "  <li><span>Selection Mode</span>";
    //html += "    <ul>";
    //html += me.getLink('mn6_modeall', 'Apply style, color,</span><br/><span>surface to all atoms');
    //html += me.getLink('mn6_modeselection', 'Apply style, color,</span><br/><span>surface only to selection');
    //html += "    </ul>";
    //html += "  </li>";


    if(me.cfg.cid === undefined) {
        html += "  <li><span>Select on 3D</span>";
        html += "    <ul>";

        html += "  <li>\"Alt\"+Click: start selection</li>";
        html += "  <li>\"Ctrl\"+Click: union selection</li>";
        html += "  <li>\"Shift\"+Click: range Selection</li>";
        html += "  <li>-</li>";
        html += me.getRadio('mn2_pk', 'mn2_pkChain', 'Chain');
        html += me.getRadio('mn2_pk', 'mn2_pkStrand', 'Strand/Helix');
        html += me.getRadio('mn2_pk', 'mn2_pkResidue', 'Residue', true);
        html += me.getRadio('mn2_pk', 'mn2_pkYes', 'Atom');
        html += "    </ul>";
        html += "  </li>";
    }
    else {
        if(me.isMobile()) {
            html += "  <li><span>Touch to pick</span>";
        }
        else {
            html += "  <li><span>Picking with<br>\"Alt\" + Click</span>";
        }
    }

    html += "  <li>-</li>";

    html += me.getLink('mn2_saveselection', 'Save Selection');
    html += me.getLink('clearall', 'Clear Selection');

    html += "  <li>-</li>";

    html += "      <li><span>Highlight Color</span>";
    html += "        <ul>";
    html += me.getRadio('mn2_hl_clr', 'mn2_hl_clrYellow', 'Yellow', true);
    html += me.getRadio('mn2_hl_clr', 'mn2_hl_clrGreen', 'Green');
    html += me.getRadio('mn2_hl_clr', 'mn2_hl_clrRed', 'Red');
    html += "        </ul>";
    html += "      </li>";
    html += "      <li><span>Highlight Style</span>";
    html += "        <ul>";

    html += me.getRadio('mn2_hl_style', 'mn2_hl_styleOutline', 'Outline', true);
    html += me.getRadio('mn2_hl_style', 'mn2_hl_styleObject', '3D Objects');
    html += me.getRadio('mn2_hl_style', 'mn2_hl_styleNone', 'No Highlight');

    html += "        </ul>";
    html += "      </li>";

    //html += me.getLink('toggleHighlight2', 'Toggle Highlight');

    html += "  <li><br/></li>";

    html += "</ul>";
    html += "</div>";
    html += "          </accordion>";
    html += "    </div>";

    return html;
};

iCn3DUI.prototype.setMenu2b = function() { var me = this;
    var html = "";

    html += "    <div class='icn3d-menu'>";
    html += "          <accordion id='" + me.pre + "accordion2b'>";
    html += "<h3>View</h3>";
    html += "<div>";
    html += "<ul class='icn3d-mn'>";

    html += me.getLink('mn2_show_selected', 'View Only <br>Selection');
    html += me.getLink('mn2_selectedcenter', 'Zoom in <br>Selection');
    html += me.getLink('mn6_center', 'Center on <br>Selection');
    if(me.cfg.align !== undefined) {
        html += me.getLink('mn2_alternate', 'Alternate (Key \"a\")');
    }

    html += "  <li>-</li>";

    if(me.cfg.cid === undefined) {
        html += "  <li><span>Chem. Binding</span>";
        html += "    <ul>";
        html += me.getRadio('mn6_chemicalbinding', 'mn6_chemicalbindingshow', 'Show');
        html += me.getRadio('mn6_chemicalbinding', 'mn6_chemicalbindinghide', 'Hide', true);
        html += "    </ul>";
        html += "  </li>";

        html += "  <li><span>H-Bonds to</span><br/><span>Selection</span>";
        html += "    <ul>";
        html += me.getRadio('mn6_hbonds', 'mn6_hbondsYes', 'Show');
        html += me.getRadio('mn6_hbonds', 'mn6_hbondsNo', 'Hide', true);
        html += "    </ul>";
        html += "  </li>";

        html += "  <li><span>Disulfide Bonds</span>";
        html += "    <ul>";
        html += me.getRadio('mn6_ssbonds', 'mn6_ssbondsYes', 'Show', true);
        html += me.getRadio('mn6_ssbonds', 'mn6_ssbondsNo', 'Hide');
        html += "    </ul>";
        html += "  </li>";

        html += "  <li><span>Cross-Linkages</span>";
        html += "    <ul>";
        html += me.getRadio('mn6_clbonds', 'mn6_clbondsYes', 'Show');
        html += me.getRadio('mn6_clbonds', 'mn6_clbondsNo', 'Hide', true);
        html += "    </ul>";
        html += "  </li>";

        if(me.cfg.mmtfid !== undefined || me.cfg.pdbid !== undefined || me.cfg.mmcifid !== undefined || me.cfg.mmdbid !== undefined || me.cfg.gi !== undefined || me.cfg.blast_rep_id !== undefined) {
          html += "  <li id='" + me.pre + "assemblyWrapper'><span>Assembly</span>";
          html += "    <ul>";

          html += me.getRadio('mn6_assembly', 'mn6_assemblyYes', 'Biological Assembly', true);
          html += me.getRadio('mn6_assembly', 'mn6_assemblyNo', 'Asymmetric Unit');

          html += "    </ul>";
          html += "  </li>";
        }
    }

    html += "  <li><span>Distance</span>";
    html += "    <ul>";
    html += me.getRadio('mn6_distance', 'mn6_distanceYes', 'Measure');
    html += me.getRadio('mn6_distance', 'mn6_distanceNo', 'Hide', true);
    html += "    </ul>";
    html += "  </li>";

    html += "  <li><span>Label</span>";
    html += "    <ul>";
    html += me.getRadio('mn6_addlabel', 'mn6_addlabelYes', 'by Picking Atoms');
    html += me.getRadio('mn6_addlabel', 'mn6_addlabelSelection', 'per Selection');
    if(me.cfg.cid === undefined) {
        html += me.getRadio('mn6_addlabel', 'mn6_addlabelResidues', 'per Residue');
        html += me.getRadio('mn6_addlabel', 'mn6_addlabelChains', 'per Chain');
        html += me.getRadio('mn6_addlabel', 'mn6_addlabelTermini', 'N- & C-Termini');
    }
    html += me.getRadio('mn6_addlabel', 'mn6_addlabelNo', 'Remove', true);
    html += "    </ul>";
    html += "  </li>";

    html += "  <li>-</li>";

    html += "  <li><span>Reset</span>";
    html += "    <ul>";
    html += me.getRadio('mn6_reset', 'reset', 'All');
    html += me.getRadio('mn6_reset', 'mn6_resetOrientation', 'Orientation');
    html += "    </ul>";
    html += "  </li>";

    html += "  <li><span>Transform Hints</span>";
    html += "    <ul>";
    html += "      <li><span>Rotate</span>";
    html += "          <ul>";
    html += "<li>Left Mouse</li>";
    html += "<li>Key L: Left</li>";
    html += "<li>Key J: Right</li>";
    html += "<li>Key I: Up</li>";
    html += "<li>Key M: Down</li>";
    html += "          </ul>";
    html += "      </li>";
    html += "      <li><span>Zoom</span>";
    html += "          <ul>";
    html += "<li>Middle Mouse</li>";
    html += "<li>Key Z: Zoom in</li>";
    html += "<li>Key X: Zoom out</li>";
    html += "          </ul>";
    html += "      </li>";
    html += "      <li><span>Translate</span>";
    html += "          <ul>";
    html += "<li>Right Mouse</li>";
    html += "          </ul>";
    html += "      </li>";
    html += "    </ul>";
    html += "  </li>";

    html += "  <li><span>Auto Rotation</span>";
    html += "    <ul>";
    html += me.getRadio('mn6_rotate', 'mn6_rotateleft', 'Rotate Left');
    html += me.getRadio('mn6_rotate', 'mn6_rotateright', 'Rotate Right');
    html += me.getRadio('mn6_rotate', 'mn6_rotateup', 'Rotate Up');
    html += me.getRadio('mn6_rotate', 'mn6_rotatedown', 'Rotate Down');
    html += "    </ul>";
    html += "  </li>";
    html += "  <li><span>Camera</span>";
    html += "    <ul>";
    html += me.getRadio('mn6_camera', 'mn6_cameraPers', 'Perspective', true);
    html += me.getRadio('mn6_camera', 'mn6_cameraOrth', 'Orthographic');
    html += "    </ul>";
    html += "  </li>";
    html += "  <li><span>Fog</span>";
    html += "    <ul>";
    html += me.getRadio('mn6_showfog', 'mn6_showfogYes', 'On');
    html += me.getRadio('mn6_showfog', 'mn6_showfogNo', 'Off', true);
    html += "    </ul>";
    html += "  </li>";
    html += "  <li><span>Slab</span>";
    html += "    <ul>";
    html += me.getRadio('mn6_showslab', 'mn6_showslabYes', 'On');
    html += me.getRadio('mn6_showslab', 'mn6_showslabNo', 'Off', true);
    html += "    </ul>";
    html += "  </li>";
    html += "  <li><span>XYZ-axes</span>";
    html += "    <ul>";
    html += me.getRadio('mn6_showaxis', 'mn6_showaxisYes', 'Show');
    html += me.getRadio('mn6_showaxis', 'mn6_showaxisNo', 'Hide', true);
    html += "    </ul>";
    html += "  </li>";

    html += me.getLink('mn6_back', 'Undo');
    html += me.getLink('mn6_forward', 'Redo');

    html += "  <li><br/></li>";

    html += "</ul>";
    html += "</div>";
    html += "          </accordion>";
    html += "    </div>";

    return html;
};

iCn3DUI.prototype.setMenu3 = function() { var me = this;
    var html = "";

    html += "    <div class='icn3d-menu'>";
    html += "          <accordion id='" + me.pre + "accordion3'>";
    html += "<h3 id='" + me.pre + "style'>Style</h3>";
    html += "<div>";
    html += "<ul class='icn3d-mn'>";

    if(me.cfg.cid === undefined) {
        html += "  <li><span>Proteins</span>";
        html += "    <ul>";
        if(me.cfg.align !== undefined) {
            html += me.getRadio('mn3_proteins', 'mn3_proteinsRibbon', 'Ribbon');
        }
        else {
            html += me.getRadio('mn3_proteins', 'mn3_proteinsRibbon', 'Ribbon', true);
        }

        html += me.getRadio('mn3_proteins', 'mn3_proteinsStrand', 'Strand');
        html += me.getRadio('mn3_proteins', 'mn3_proteinsCylinder', 'Cylinder and Plate');
        html += me.getRadio('mn3_proteins', 'mn3_proteinsSchematic', 'Schematic');

        if(me.cfg.align !== undefined) {
            html += me.getRadio('mn3_proteins', 'mn3_proteinsCalpha', 'C Alpha Trace', true);
        }
        else {
            html += me.getRadio('mn3_proteins', 'mn3_proteinsCalpha', 'C Alpha Trace');
        }

        html += me.getRadio('mn3_proteins', 'mn3_proteinsBfactor', 'B-factor Tube');
        html += me.getRadio('mn3_proteins', 'mn3_proteinsLines', 'Lines');
        html += me.getRadio('mn3_proteins', 'mn3_proteinsStick', 'Stick');
        html += me.getRadio('mn3_proteins', 'mn3_proteinsBallstick', 'Ball and Stick');
        html += me.getRadio('mn3_proteins', 'mn3_proteinsSphere', 'Sphere');
        html += me.getRadio('mn3_proteins', 'mn3_proteinsNo', 'Hide');
        html += "    </ul>";
        html += "  </li>";

        html += "  <li><span>Side Chains</span>";
        html += "    <ul>";

        html += me.getRadio('mn3_sidec', 'mn3_sidecLines', 'Lines');
        html += me.getRadio('mn3_sidec', 'mn3_sidecStick', 'Stick');
        html += me.getRadio('mn3_sidec', 'mn3_sidecBallstick', 'Ball and Stick');
        html += me.getRadio('mn3_sidec', 'mn3_sidecSphere', 'Sphere');
        html += me.getRadio('mn3_sidec', 'mn3_sidecNo', 'Hide', true);
        html += "    </ul>";
        html += "  </li>";

        html += "  <li><span>Nucleotides</span>";
        html += "    <ul>";
        html += me.getRadio('mn3_nucl', 'mn3_nuclCartoon', 'Cartoon', true);
        html += me.getRadio('mn3_nucl', 'mn3_nuclPhos', "O3' Trace");
        html += me.getRadio('mn3_nucl', 'mn3_nuclSchematic', 'Schematic')
        html += me.getRadio('mn3_nucl', 'mn3_nuclLines', 'Lines');
        html += me.getRadio('mn3_nucl', 'mn3_nuclStick', 'Stick');
        html += me.getRadio('mn3_nucl', 'mn3_nuclBallstick', 'Ball and Stick');
        html += me.getRadio('mn3_nucl', 'mn3_nuclSphere', 'Sphere');
        html += me.getRadio('mn3_nucl', 'mn3_nuclNo', 'Hide');
        html += "    </ul>";
        html += "  </li>";
    }

    html += "  <li><span>Chemicals</span>";
    html += "    <ul>";
    html += me.getRadio('mn3_lig', 'mn3_ligLines', 'Lines');
    if(me.cfg.cid === undefined) {
        html += me.getRadio('mn3_lig', 'mn3_ligStick', 'Stick', true);
        html += me.getRadio('mn3_lig', 'mn3_ligBallstick', 'Ball and Stick');
    }
    else {
        html += me.getRadio('mn3_lig', 'mn3_ligStick', 'Stick');
        html += me.getRadio('mn3_lig', 'mn3_ligBallstick', 'Ball and Stick', true);
    }
    html += me.getRadio('mn3_lig', 'mn3_ligSchematic', 'Schematic');
    html += me.getRadio('mn3_lig', 'mn3_ligSphere', 'Sphere');
    html += me.getRadio('mn3_lig', 'mn3_ligNo', 'Hide');
    html += "    </ul>";
    html += "  </li>";


    html += "  <li><span>Ions</span>";
    html += "    <ul>";
    html += me.getRadio('mn3_ions', 'mn3_ionsSphere', 'Sphere', true);
    html += me.getRadio('mn3_ions', 'mn3_ionsDot', 'Dot');
    html += me.getRadio('mn3_ions', 'mn3_ionsNo', 'Hide');
    html += "    </ul>";
    html += "  </li>";

    html += "  <li><span>Water</span>";
    html += "    <ul>";
    html += me.getRadio('mn3_water', 'mn3_waterSphere', 'Sphere');
    html += me.getRadio('mn3_water', 'mn3_waterDot', 'Dot');
    html += me.getRadio('mn3_water', 'mn3_waterNo', 'Hide', true);
    html += "    </ul>";
    html += "  </li>";

    html += me.getLink('mn3_setThickness', 'Set Thickness');

    html += "  <li>-</li>";

    html += me.getLink('mn3_styleSave', 'Save Style');
    html += me.getLink('mn3_styleApplySave', 'Apply Saved Style');

    html += "  <li>-</li>";

    html += "  <li><span>Surface Type</span>";
    html += "    <ul>";
    html += me.getRadio('mn5_surface', 'mn5_surfaceVDW', 'Van der Waals');
    html += me.getRadio('mn5_surface', 'mn5_surfaceVDWContext', 'VDW with Context');
    html += me.getRadio('mn5_surface', 'mn5_surfaceMolecular', 'Molecular Surface');
    html += me.getRadio('mn5_surface', 'mn5_surfaceMolecularContext', 'MS with Context');
    html += me.getRadio('mn5_surface', 'mn5_surfaceSAS', 'Solvent Accessible');
    html += me.getRadio('mn5_surface', 'mn5_surfaceSASContext', 'SA with Context');
    html += "    </ul>";
    html += "  </li>";

    html += me.getLink('mn5_surfaceNo', 'Remove Surface');

    html += "  <li><span>Surface Opacity</span>";
    html += "    <ul>";
    html += me.getRadio('mn5_opacity', 'mn5_opacity10', '1.0', true);
    html += me.getRadio('mn5_opacity', 'mn5_opacity09', '0.9');
    html += me.getRadio('mn5_opacity', 'mn5_opacity08', '0.8');
    html += me.getRadio('mn5_opacity', 'mn5_opacity07', '0.7');
    html += me.getRadio('mn5_opacity', 'mn5_opacity06', '0.6');
    html += me.getRadio('mn5_opacity', 'mn5_opacity05', '0.5');
    html += me.getRadio('mn5_opacity', 'mn5_opacity04', '0.4');
    html += me.getRadio('mn5_opacity', 'mn5_opacity03', '0.3');
    html += me.getRadio('mn5_opacity', 'mn5_opacity02', '0.2');
    html += me.getRadio('mn5_opacity', 'mn5_opacity01', '0.1');
    html += "    </ul>";
    html += "  </li>";
    html += "  <li><span>Surface <br>Wireframe</span>";
    html += "    <ul>";
    html += me.getRadio('mn5_wireframe', 'mn5_wireframeYes', 'Yes');
    html += me.getRadio('mn5_wireframe', 'mn5_wireframeNo', 'No', true);
    html += "    </ul>";
    html += "  </li>";

    if(me.cfg.cid === undefined) {
        html += "  <li>-</li>";

        html += "  <li id='" + me.pre + "mapWrapper1'><span>Electron Density</span>";
        html += "    <ul>";
        html += me.getRadio('mn5_elecmap', 'mn5_elecmap2fofc', '2Fo-Fc Map');
        html += me.getRadio('mn5_elecmap', 'mn5_elecmapfofc', 'Fo-Fc Map');
        html += "    </ul>";
        html += "  </li>";

        html += me.getLinkWrapper('mn5_elecmapNo', 'Remove Map', 'mapWrapper2');

        html += "  <li id='" + me.pre + "mapWrapper3'><span>Map <br>Wireframe</span>";
        html += "    <ul>";
        html += me.getRadio('mn5_mapwireframe', 'mn5_mapwireframeYes', 'Yes', true);
        html += me.getRadio('mn5_mapwireframe', 'mn5_mapwireframeNo', 'No');
        html += "    </ul>";
        html += "  </li>";

        if(me.cfg.mmtfid === undefined) {
            //html += "  <li>-</li>";

            html += me.getLinkWrapper('mn5_emmap', 'EM Density Map', 'emmapWrapper1');
            html += me.getLinkWrapper('mn5_emmapNo', 'Remove EM Map', 'emmapWrapper2');

            html += "  <li id='" + me.pre + "emmapWrapper3'><span>EM Map <br>Wireframe</span>";
            html += "    <ul>";
            html += me.getRadio('mn5_emmapwireframe', 'mn5_emmapwireframeYes', 'Yes', true);
            html += me.getRadio('mn5_emmapwireframe', 'mn5_emmapwireframeNo', 'No');
            html += "    </ul>";
            html += "  </li>";
        }
    }

    html += "  <li>-</li>";

    html += "  <li><span>Background</span>";
    html += "    <ul>";
    html += me.getRadio('mn6_bkgd', 'mn6_bkgdTransparent', 'Transparent', true);
    html += me.getRadio('mn6_bkgd', 'mn6_bkgdBlack', 'Black');
    html += me.getRadio('mn6_bkgd', 'mn6_bkgdGrey', 'Grey');
    html += me.getRadio('mn6_bkgd', 'mn6_bkgdWhite', 'White');
    html += "    </ul>";
    html += "  </li>";

    html += "  <li><br/></li>";

    html += "</ul>";
    html += "</div>";
    html += "          </accordion>";
    html += "    </div>";

    return html;
};

iCn3DUI.prototype.setMenu4 = function() { var me = this;
    var html = "";

    html += "    <div class='icn3d-menu'>";
    html += "          <accordion id='" + me.pre + "accordion4'>";
    html += "<h3 id='" + me.pre + "color'>Color</h3>";
    html += "<div>";
    html += "<ul class='icn3d-mn'>";

    if(me.cfg.cid === undefined) {
        html += me.getRadio('mn4_clr', 'mn4_clrSpectrum', 'Spectrum');
        html += "  <li><span style='padding-left:2em;'>Secondary</span>";
        html += "    <ul>";
        html += me.getRadio('mn4_clr', 'mn4_clrSSGreen', 'Sheet in Green');
        html += me.getRadio('mn4_clr', 'mn4_clrSSYellow', 'Sheet in Yellow');
        html += "    </ul>";

        html += me.getRadio('mn4_clr', 'mn4_clrCharge', 'Charge');
        html += me.getRadio('mn4_clr', 'mn4_clrHydrophobic', 'Hydrophobic');

        if(me.cfg.align !== undefined || me.cfg.blast_rep_id !== undefined) {
          html += me.getRadio('mn4_clr', 'mn4_clrChain', 'Chain');
        }
        else {
          html += me.getRadio('mn4_clr', 'mn4_clrChain', 'Chain', true);
        }

        html += me.getRadio('mn4_clr', 'mn4_clrResidue', 'Residue');
        html += me.getRadio('mn4_clr', 'mn4_clrAtom', 'Atom');
        html += "  <li><span style='padding-left:2em;'>B-factor</span>";
        html += "    <ul>";
        html += me.getRadio('mn4_clr', 'mn4_clrBfactor', 'Original');
        html += me.getRadio('mn4_clr', 'mn4_clrBfactorNorm', 'Percentile');
        html += "    </ul>";

        if(me.cfg.align !== undefined) {
          html += me.getRadio('mn4_clr', 'mn4_clrIdentity', 'Identity', true);
          html += me.getRadio('mn4_clr', 'mn4_clrConserved', 'Conservation');
        }
        else if(me.cfg.blast_rep_id !== undefined) {
          html += me.getRadio('mn4_clr', 'mn4_clrIdentity', 'Identity');
          html += me.getRadio('mn4_clr', 'mn4_clrConserved', 'Conservation', true);
        }
    }
    else {
        html += me.getRadio('mn4_clr', 'mn4_clrAtom', 'Atom', true);
    }

    html += "  <li>-</li>";
    html += "  <li><span style='padding-left:2em;'>Unicolor</span>";
    html += "    <ul>";
    html += me.getRadio('mn4_clr', 'mn4_clrRed', 'Red');
    html += me.getRadio('mn4_clr', 'mn4_clrGreen', 'Green');
    html += me.getRadio('mn4_clr', 'mn4_clrBlue', 'Blue');
    html += me.getRadio('mn4_clr', 'mn4_clrMagenta', 'Magenta');
    html += me.getRadio('mn4_clr', 'mn4_clrYellow', 'Yellow');
    html += me.getRadio('mn4_clr', 'mn4_clrCyan', 'Cyan');
    html += me.getRadio('mn4_clr', 'mn4_clrWhite', 'White');
    html += me.getRadio('mn4_clr', 'mn4_clrGrey', 'Grey');
    html += "    </ul>";
    html += me.getRadio('mn4_clr', 'mn4_clrCustom', 'Color Picker');
    html += "  <li>-</li>";
    html += me.getLink('mn4_clrSave', 'Save Color');
    html += me.getLink('mn4_clrApplySave', 'Apply Saved Color');
    html += "  <li><br/></li>";
    html += "</ul>";
    html += "</div>";
    html += "          </accordion>";
    html += "    </div>";

    return html;
};

iCn3DUI.prototype.setMenu5 = function() { var me = this;
    var html = "";

    html += "    <div class='icn3d-menu'>";
    html += "          <accordion id='" + me.pre + "accordion5'>";
    html += "<h3 id='" + me.pre + "windows' style='font-size:1.2em'>&nbsp;Windows</h3>";
    html += "<div>";
    html += "<ul class='icn3d-mn'>";

    if(me.cfg.cid === undefined) {
        html += me.getLink('mn6_selectannotations', 'View Sequences<br>& Annotations');

        if(me.cfg.align !== undefined) {
            html += me.getLink('mn2_alignment', 'View Aligned<br>Sequences');
        }

        //html += me.getLink('mn2_selectresidues', 'View Sequences');
        if(me.cfg.mmdbid !== undefined || me.cfg.gi !== undefined || me.cfg.blast_rep_id !== undefined || me.cfg.align !== undefined) {
          html += me.getLink('mn2_2ddgm', 'View Interactions');
        }
    }

    if(me.cfg.cid !== undefined) {
        html += "  <li><span>Links</span>";
        html += "    <ul>";
        html += me.getLink('mn1_link_structure', 'Compound Summary');
        html += me.getLink('mn1_link_vast', 'Similar Compounds');
        html += me.getLink('mn1_link_bind', 'Structures Bound');
        html += "    </ul>";
        html += "  </li>";
    }
    else {
        html += "  <li><span>Links</span>";
        html += "    <ul>";
        html += me.getLink('mn1_link_structure', 'Structure Summary');
        html += me.getLink('mn1_link_vast', 'Similar Structures');
        html += me.getLink('mn1_link_pubmed', 'Literature');
        html += me.getLink('mn1_link_protein', 'Protein');
        //html += me.getLink('mn1_link_gene', 'Gene');
        //html += me.getLink('mn1_link_chemicals', 'Chemicals');
        html += "    </ul>";
        html += "  </li>";
    }

    html += "  <li><br/></li>";

    html += "</ul>";
    html += "</div>";
    html += "          </accordion>";
    html += "    </div>";

    return html;
};

iCn3DUI.prototype.setMenu6 = function() { var me = this;
    var html = "";

    html += "    <div class='icn3d-menu'>";
    html += "          <accordion id='" + me.pre + "accordion6'>";
    html += "<h3>Help</h3>";
    html += "<div>";
    html += "<ul class='icn3d-mn'>";

    html += "  <li><a href='https://www.ncbi.nlm.nih.gov/Structure/icn3d/docs/icn3d_about.html' target='_blank'>About iCn3D<span style='font-size:0.9em'> " + me.REVISION + "</span></a></li>";

    html += "  <li><a href='https://www.ncbi.nlm.nih.gov/Structure/icn3d/docs/icn3d_help.html' target='_blank'>Help Doc</a></li>";

    html += "  <li><span>Web APIs</span>";
    html += "    <ul>";

    html += "<li><a href='https://www.ncbi.nlm.nih.gov/Structure/icn3d/icn3d.html#HowToUse' target='_blank'>How to Use</a></li>";
    html += "<li><a href='https://www.ncbi.nlm.nih.gov/Structure/icn3d/icn3d.html#parameters' target='_blank'>URL Parameters</a></li>";
    html += "<li><a href='https://www.ncbi.nlm.nih.gov/Structure/icn3d/icn3d.html#commands' target='_blank'>Commands</a></li>";
    html += "    </ul>";
    html += "  </li>";

    html += "  <li><a href='https://github.com/ncbi/icn3d' target='_blank'>Source Code</a></li>";

    html += "  <li>-</li>";

    html += "  <li><span>Transform Hints</span>";
    html += "    <ul>";
    html += "      <li><span>Rotate</span>";
    html += "          <ul>";
    html += "<li>Left Mouse</li>";
    html += "<li>Key L: Left</li>";
    html += "<li>Key J: Right</li>";
    html += "<li>Key I: Up</li>";
    html += "<li>Key M: Down</li>";
    html += "          </ul>";
    html += "      </li>";
    html += "      <li><span>Zoom</span>";
    html += "          <ul>";
    html += "<li>Middle Mouse</li>";
    html += "<li>Key Z: Zoom in</li>";
    html += "<li>Key X: Zoom out</li>";
    html += "          </ul>";
    html += "      </li>";
    html += "      <li><span>Translate</span>";
    html += "          <ul>";
    html += "<li>Right Mouse</li>";
    html += "          </ul>";
    html += "      </li>";
    html += "    </ul>";
    html += "  </li>";

    html += "  <li><a href='https://www.ncbi.nlm.nih.gov/Structure/icn3d/icn3d.html#HowToUseStep5' target='_blank'>Selection Hints</a></li>";

    html += "  <li><br/></li>";
    html += "</ul>";
    html += "</div>";
    html += "          </accordion>";
    html += "    </div>";

    return html;
};

iCn3DUI.prototype.setLogWindow = function() { var me = this;
    var html = "";

    html += "  <div id='" + me.pre + "cmdlog' style='float:left; margin-top: -5px; width: 100%;'>";

    html += "    <textarea id='" + me.pre + "logtext' rows='2' style='width: 100%; height: " + me.CMD_HEIGHT + "px; padding: 0px; border: 0px; background-color: " + me.GREYD + ";'></textarea>";
    html += "  </div>";

    return html;
};

iCn3DUI.prototype.setAdvanced = function(index) { var me = this;
    var indexStr = (index === undefined) ? '' : index;

    var html = "<div id='" + me.pre + "dl_advanced" + indexStr + "'>";

    html += "      <table width='500'><tr><td valign='top'><table cellspacing='0'>";
    html += "    <tr><td><b>Select:</b></td><td><input type='text' id='" + me.pre + "command" + indexStr + "' placeholder='$[structures].[chains]:[residues]@[atoms]' size='60'></td></tr>";
    html += "    <tr><td><b>Name:</b></td><td><input type='text' id='" + me.pre + "command_name" + indexStr + "' placeholder='my_selection' size='60'></td></tr>";
    //html += "<tr><td align='right'><b>Description:</b></td><td><input type='text' id='" + me.pre + "command_desc' placeholder='description about my selection' size='30'></td></tr>";
    html += "    <tr><td colspan='2' align='left'>&nbsp;&nbsp;&nbsp;<button id='" + me.pre + "command_apply" + indexStr + "'><b>Save Selection</b></button></td></tr>";
    html += "      </table></td>";

    html += "      </tr>";

    html += "      <tr><td>";

    html += 'Specification Tips: <div style="width:20px; margin-top:6px; display:inline-block;"><span id="' + me.pre + 'specguide' + indexStr + '_expand" class="ui-icon ui-icon-plus icn3d-expand icn3d-link" style="width:15px;" title="Expand"></span><span id="' + me.pre + 'specguide' + indexStr + '_shrink" class="ui-icon ui-icon-minus icn3d-shrink icn3d-link" style="display:none; width:15px;" title="Shrink"></span></div><br>';

    html += "<div id='" + me.pre + "specguide" + indexStr + "' style='display:none; width:500px' class='icn3d-box'>";

    html += "  <b>Specification:</b> In the selection \"$1HHO,4N7N.A,B,C:5-10,KRDE,chemicals@CA,C\":";
    html += "  <ul><li>\"$1HHO,4N7N\" uses \"$\" to indicate structure selection.<br/>";
    html += "  <li>\".A,B,C\" uses \".\" to indicate chain selection.<br/>";
    html += "  <li>\":5-10,KRDE,chemicals\" uses \":\" to indicate residue selection. Residue selection could be residue number (5-10), one-letter sequence (KRDE), or predefined names: \"proteins\", \"nucleotides\", \"chemicals\", \"ions\", and \"water\".<br/>";
    html += "  <li>\"@CA,C\" uses \"@\" to indicate atom selection.<br/>";
    html += "  <li>Partial definition is allowed, e.g., \":1-10\" selects all residue IDs 1-10 in all chains.<br/>";
    html += "  <li>Different selections can be unioned (with \"<b>or</b>\", default), intersected (with \"<b>and</b>\"), or negated (with \"<b>not</b>\"). For example, \":1-10 or :K\" selects all residues 1-10 and all Lys residues. \":1-10 and :K\" selects all Lys residues in the range of residue number 1-10. \":1-10 or not :K\" selects all residues 1-10, which are not Lys residues.</ul>";
    html += "  <b>Set Operation:</b>";
    html += "  <ul><li>Users can select multiple sets in the menu \"Select > Defined Sets\".<br/>";
    html += "  <li>Different sets can be unioned (with \"<b>or</b>\", default), intersected (with \"<b>and</b>\"), or negated (with \"<b>not</b>\"). For example, if the \"Defined Sets\" menu has four sets \":1-10\", \":11-20\", \":5-15\", and \":7-8\", the command \"saved atoms :1-10 or :11-20 and :5-15 not :7-8\" unions all residues 1-10 and 11-20 to get the residues 1-20, then intersects with the residues 5-15 to get the residues 5-15, then exclude the residues 7-8 to get the final residues 5-6 and 9-15.</ul>";
    html += "  <b>Full commands in url or command window:</b>";
    html += "  <ul><li>Select without saving the set: select $1HHO,4N7N.A,B,C:5-10,KRDE,chemicals@CA,C<br/>";
    //html += "  <li>Select and save: select $1HHO,4N7N.A,B,C:5-10,KRDE,chemicals@CA,C | name my_name | description my_description</ul>";
    html += "  <li>Select and save: select $1HHO,4N7N.A,B,C:5-10,KRDE,chemicals@CA,C | name my_name</ul>";

    html += "</div>";

    html += "      </td></tr></table>";
    html += "</div>";

    return html;
};

iCn3DUI.prototype.setDialogs = function() { var me = this;
    var html = "";

    html += "<!-- dialog will not be part of the form -->";

    html += "<div id='" + me.pre + "alldialogs' class='icn3d-hidden icn3d-dialog'>";

    // filter for large structure
    //html += "<div id='" + me.pre + "dl_filter' style='overflow:auto; position:relative;'>";
    //html += "  <div style='text-align:center; margin-bottom:10px;'><button id='" + me.pre + "filter'><span style='white-space:nowrap'><b>Show Structure</b></span></button>";
    //html += "<button id='" + me.pre + "highlight_3d_dgm' style='margin-left:10px;'><span style='white-space:nowrap'><b>Highlight</b></span></button></div>";
    //html += "  <div id='" + me.pre + "dl_filter_table' class='icn3d-box'>";
    //html += "  </div>";
    //html += "</div>";

    html += "<div id='" + me.pre + "dl_2ddgm' class='icn3d-dl_2ddgm'>";
    html += "</div>";

    if(me.cfg.align !== undefined) {
      html += "<div id='" + me.pre + "dl_alignment' style='background-color:white;'>";
      html += "  <div id='" + me.pre + "dl_sequence2' class='icn3d-dl_sequence'>";
      html += "  </div>";
      html += "</div>";
    }

    html += "<div id='" + me.pre + "dl_definedsets'>";
    html += "    <div id='" + me.pre + "dl_setsmenu'>";
    html += "        <b>Defined Sets:</b> <br/>";
    html += "        <select id='" + me.pre + "atomsCustom' multiple size='6' style='min-width:130px;'>";
    html += "        </select>";
    html += "        <div style='margin: 6px 0 6px 0;'><button id='" + me.pre + "deletesets'><b>Delete Selected Sets</b></button></div>";
    html += '        <b>Set Operations</b>: <div style="width:20px; margin-top:6px; display:inline-block;"><span id="' + me.pre + 'dl_command_expand" class="ui-icon ui-icon-plus icn3d-expand icn3d-link" style="width:15px;" title="Expand"></span><span id="' + me.pre + 'dl_command_shrink" class="ui-icon ui-icon-minus icn3d-shrink icn3d-link" style="display:none; width:15px;" title="Shrink"></span></div><br>';
    html += "    </div>";

    html += "    <div id='" + me.pre + "dl_command' style='display:none;'>";
    html += "      <div id='" + me.pre + "dl_setoperations'>";
    html += "        <label for='" + me.pre + "setOr'><input type='radio' name='" + me.pre + "setOperation' id='" + me.pre + "setOr' checked> Union (or) </label><br/>";
    html += "        <label for='" + me.pre + "setAnd'><input type='radio' name='" + me.pre + "setOperation' id='" + me.pre + "setAnd'> Intersection (and) </label><br/>";
    html += "        <label for='" + me.pre + "setNot'><input type='radio' name='" + me.pre + "setOperation' id='" + me.pre + "setNot'> Exclusion (not) </label>";
    html += "      </div><br>";

    html += me.setAdvanced();

    html += "    </div>";
    html += "</div>";

    html += me.setAdvanced(2);

    html += "<div id='" + me.pre + "dl_mmtfid'>";
    html += "MMTF ID: <input type='text' id='" + me.pre + "mmtfid' value='1TUP' size=8> ";
    html += "<button id='" + me.pre + "reload_mmtf'>Load</button>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_pdbid'>";
    html += "PDB ID: <input type='text' id='" + me.pre + "pdbid' value='1TUP' size=8> ";
    html += "<button id='" + me.pre + "reload_pdb'>Load</button>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_pdbfile'>";
    html += "PDB File: <input type='file' id='" + me.pre + "pdbfile' size=8> ";
    html += "<button id='" + me.pre + "reload_pdbfile'>Load</button>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_align'>";
    html += "Enter the PDB IDs or MMDB IDs of two structures that have been found to be similar by <A HREF=' https://www.ncbi.nlm.nih.gov/Structure/vastplus/vastplus.cgi'>VAST+</A> : <br/><br/>ID1: <input type='text' id='" + me.pre + "alignid1' value='1HHO' size=8>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ID2: <input type='text' id='" + me.pre + "alignid2' value='4N7N' size=8><br/><br/>";
    html += "<button id='" + me.pre + "reload_align_ori'>All Matching Molecules Superposed</button>&nbsp;&nbsp;&nbsp;<button id='" + me.pre + "reload_align_refined'>Invariant Substructure Superposed</button>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_mol2file'>";
    html += "Mol2 File: <input type='file' id='" + me.pre + "mol2file' size=8> ";
    html += "<button id='" + me.pre + "reload_mol2file'>Load</button>";
    html += "</div>";
    html += "<div id='" + me.pre + "dl_sdffile'>";
    html += "SDF File: <input type='file' id='" + me.pre + "sdffile' size=8> ";
    html += "<button id='" + me.pre + "reload_sdffile'>Load</button>";
    html += "</div>";
    html += "<div id='" + me.pre + "dl_xyzfile'>";
    html += "XYZ File: <input type='file' id='" + me.pre + "xyzfile' size=8> ";
    html += "<button id='" + me.pre + "reload_xyzfile'>Load</button>";
    html += "</div>";
    html += "<div id='" + me.pre + "dl_urlfile'>";
    html += "File type: ";
    html += "<select id='" + me.pre + "filetype'>";
    html += "<option value='pdb' selected>pdb</option>";
    html += "<option value='mol2'>mol2</option>";
    html += "<option value='sdf'>sdf</option>";
    html += "<option value='xyz'>xyz</option>";
    html += "</select><br/>";
    html += "URL in the same host: <input type='text' id='" + me.pre + "urlfile' size=20><br/> ";
    html += "<button id='" + me.pre + "reload_urlfile'>Load</button>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_mmciffile'>";
    html += "mmCIF File: <input type='file' id='" + me.pre + "mmciffile' value='1TUP' size=8> ";
    html += "<button id='" + me.pre + "reload_mmciffile'>Load</button>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_mmcifid'>";
    html += "mmCIF ID: <input type='text' id='" + me.pre + "mmcifid' value='1TUP' size=8> ";
    html += "<button id='" + me.pre + "reload_mmcif'>Load</button>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_mmdbid'>";
    html += "MMDB ID: <input type='text' id='" + me.pre + "mmdbid' value='1TUP' size=8> ";
    html += "<button id='" + me.pre + "reload_mmdb'>Load</button>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_blast_rep_id' style='max-width:500px;'>";
    html += "Enter a Sequence ID (or FASTA sequence) and the aligned Structure ID, which can be found using the <a href='https://blast.ncbi.nlm.nih.gov/Blast.cgi?PROGRAM=blastp&PAGE_TYPE=BlastSearch&DATABASE=pdb' target='_blank'>BLAST</a> search against the pdb database with the Sequence ID or FASTA sequence as input.<br><br> ";
    html += "<b>Sequence ID</b> (NCBI protein accession of a sequence): <input type='text' id='" + me.pre + "query_id' value='NP_001108451.1' size=8><br> ";
    html += "or FASTA sequence: <br><textarea id='" + me.pre + "query_fasta' rows='5' style='width: 100%; height: " + (me.MENU_HEIGHT) + "px; padding: 0px; border: 0px;'></textarea><br><br>";
    html += "<b>Structure ID</b> (NCBI protein accession of a chain of a 3D structure): <input type='text' id='" + me.pre + "blast_rep_id' value='1TSR_A' size=8><br> ";
    html += "<button id='" + me.pre + "reload_blast_rep_id'>Load</button>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_gi'>";
    html += "Protein gi: <input type='text' id='" + me.pre + "gi' value='1310960' size=8> ";
    html += "<button id='" + me.pre + "reload_gi'>Load</button>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_cid'>";
    html += "PubChem CID: <input type='text' id='" + me.pre + "cid' value='2244' size=8> ";
    html += "<button id='" + me.pre + "reload_cid'>Load</button>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_pngimage'>";
    html += "iCn3D PNG image: <input type='file' id='" + me.pre + "pngimage'><br/>";
    html += "<button id='" + me.pre + "reload_pngimage' style='margin-top: 6px;'>Load</button>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_state'>";
    html += "State file: <input type='file' id='" + me.pre + "state'><br/>";
    html += "<button id='" + me.pre + "reload_state' style='margin-top: 6px;'>Load</button>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_selection'>";
    html += "Selection file: <input type='file' id='" + me.pre + "selectionfile'><br/>";
    html += "<button id='" + me.pre + "reload_selectionfile' style='margin-top: 6px;'>Load</button>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_clr'>";
    html += "Click in the input box to use the color picker:<br><br> ";
    html += "Custom Color: <input type='text' id='" + me.pre + "colorcustom' value='FF0000' size=8> ";
    html += "<button id='" + me.pre + "applycustomcolor'>Apply</button>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_hbonds'>";
    html += "<div style='width:400px;'>To show hydrogen bonds between other residues and the current selection, please select the threshold of H-bonds.</div><br/>";
    html += "  <span style='white-space:nowrap;font-weight:bold;'>Threshold: <select id='" + me.pre + "hbondthreshold'>";
    html += "  <option value='3.2'>3.2</option>";
    html += "  <option value='3.3'>3.3</option>";
    html += "  <option value='3.4'>3.4</option>";
    html += "  <option value='3.5' selected>3.5</option>";
    html += "  <option value='3.6'>3.6</option>";
    html += "  <option value='3.7'>3.7</option>";
    html += "  <option value='3.8'>3.8</option>";
    html += "  <option value='3.9'>3.9</option>";
    html += "  <option value='4.0'>4.0</option>";
    html += "  </select> &#197;</span> <span style='white-space:nowrap; margin-left:30px;'><button id='" + me.pre + "applyhbonds'>Display</button></span>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_elecmap2fofc'>";
    html += "  <span style='white-space:nowrap;font-weight:bold;'>Contour at: <select id='" + me.pre + "sigma2fofc'>";
    html += "  <option value='0'>0</option>";
    html += "  <option value='0.5'>0.5</option>";
    html += "  <option value='1'>1</option>";
    html += "  <option value='1.5' selected>1.5</option>";
    html += "  <option value='2'>2</option>";
    html += "  <option value='3'>3</option>";
    html += "  <option value='4'>4</option>";
    html += "  <option value='5'>5</option>";
    html += "  <option value='6'>6</option>";
    html += "  <option value='7'>7</option>";
    html += "  <option value='8'>8</option>";
    html += "  <option value='9'>9</option>";
    html += "  <option value='10'>10</option>";
    html += "  </select> &sigma;</span> <span style='white-space:nowrap; margin-left:30px;'><button id='" + me.pre + "applymap2fofc'>Display</button></span> <span style='white-space:nowrap; margin-left:30px;'><button id='" + me.pre + "elecmapNo2'>Remove Map</button></span>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_elecmapfofc'>";
    html += "  <span style='white-space:nowrap;font-weight:bold;'>Contour at: <select id='" + me.pre + "sigmafofc'>";
    html += "  <option value='0'>0</option>";
    html += "  <option value='0.5'>0.5</option>";
    html += "  <option value='1'>1</option>";
    html += "  <option value='1.5'>1.5</option>";
    html += "  <option value='2'>2</option>";
    html += "  <option value='3' selected>3</option>";
    html += "  <option value='4'>4</option>";
    html += "  <option value='5'>5</option>";
    html += "  <option value='6'>6</option>";
    html += "  <option value='7'>7</option>";
    html += "  <option value='8'>8</option>";
    html += "  <option value='9'>9</option>";
    html += "  <option value='10'>10</option>";
    html += "  </select> &sigma;</span> <span style='white-space:nowrap; margin-left:30px;'><button id='" + me.pre + "applymapfofc'>Display</button></span> <span style='white-space:nowrap; margin-left:30px;'><button id='" + me.pre + "elecmapNo3'>Remove Map</button></span>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_emmap'>";
    html += "  <span style='white-space:nowrap;font-weight:bold;'>Contour at: <select id='" + me.pre + "empercentage'>";
    html += "  <option value='0'>0</option>";
    html += "  <option value='10'>10</option>";
    html += "  <option value='20'>20</option>";
    html += "  <option value='30' selected>30</option>";
    html += "  <option value='40'>40</option>";
    html += "  <option value='50'>50</option>";
    html += "  <option value='60'>60</option>";
    html += "  <option value='70'>70</option>";
    html += "  <option value='80'>80</option>";
    html += "  <option value='90'>90</option>";
    html += "  <option value='100'>100</option>";
    html += "  </select> % of maximum EM values</span><br><span style='white-space:nowrap; margin-left:30px;'><button id='" + me.pre + "applyemmap'>Display</button></span> <span style='white-space:nowrap; margin-left:30px;'><button id='" + me.pre + "emmapNo2'>Remove EM Map</button></span>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_aroundsphere'>";
    html += "  <span style='white-space:nowrap'>1. Sphere with a radius: <input type='text' id='" + me.pre + "radius_aroundsphere' value='4' size='2'> &#197;</span><br/>";
    html += "  <span style='white-space:nowrap'>2. <button id='" + me.pre + "applypick_aroundsphere'>Display</button> the sphere around currently selected atoms</span>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_addlabel'>";
    html += "1. Text: <input type='text' id='" + me.pre + "labeltext' value='Text' size=4><br/>";
    html += "2. Size: <input type='text' id='" + me.pre + "labelsize' value='18' size=4 maxlength=2><br/>";
    html += "3. Color: <input type='text' id='" + me.pre + "labelcolor' value='ffff00' size=4><br/>";
    html += "4. Background: <input type='text' id='" + me.pre + "labelbkgd' value='cccccc' size=4><br/>";
    if(me.isMobile()) {
        html += "  <span style='white-space:nowrap'>5. Touch TWO atoms</span><br/>";
    }
    else {
        html += "  <span style='white-space:nowrap'>5. Pick TWO atoms while holding \"Alt\" key</span><br/>";
    }
    html += "<span style='white-space:nowrap'>6. <button id='" + me.pre + "applypick_labels'>Display</button></span>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_addlabelselection'>";
    html += "1. Text: <input type='text' id='" + me.pre + "labeltext2' value='Text' size=4><br/>";
    html += "2. Size: <input type='text' id='" + me.pre + "labelsize2' value='18' size=4 maxlength=2><br/>";
    html += "3. Color: <input type='text' id='" + me.pre + "labelcolor2' value='ffff00' size=4><br/>";
    html += "4. Background: <input type='text' id='" + me.pre + "labelbkgd2' value='cccccc' size=4><br/>";
    html += "<span style='white-space:nowrap'>5. <button id='" + me.pre + "applyselection_labels'>Display</button></span>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_distance'>";
    if(me.isMobile()) {
        html += "  <span style='white-space:nowrap'>1. Touch TWO atoms</span><br/>";
    }
    else {
        html += "  <span style='white-space:nowrap'>1. Pick TWO atoms while holding \"Alt\" key</span><br/>";
    }
    html += "  <span style='white-space:nowrap'>2. Color: <input type='text' id='" + me.pre + "distancecolor' value='ffff00' size=4><br/>";
    html += "  <span style='white-space:nowrap'>3. <button id='" + me.pre + "applypick_measuredistance'>Display</button></span>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_stabilizer'>";
    if(me.isMobile()) {
        html += "  <span style='white-space:nowrap'>1. Touch TWO atoms</span><br/>";
    }
    else {
        html += "  <span style='white-space:nowrap'>1. Pick TWO atoms while holding \"Alt\" key</span><br/>";
    }
    html += "  <span style='white-space:nowrap'>2. Color: <input type='text' id='" + me.pre + "stabilizercolor' value='ffffff' size=4><br/>";
    html += "  <span style='white-space:nowrap'>3. <button id='" + me.pre + "applypick_stabilizer'>Add</button></span>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_stabilizer_rm'>";
    if(me.isMobile()) {
        html += "  <span style='white-space:nowrap'>1. Touch TWO atoms</span><br/>";
    }
    else {
        html += "  <span style='white-space:nowrap'>1. Pick TWO atoms while holding \"Alt\" key</span><br/>";
    }
    html += "  <span style='white-space:nowrap'>2. <button id='" + me.pre + "applypick_stabilizer_rm'>Remove</button></span>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_thickness'>";
    html += me.setThicknessHtml('3dprint');
    html += "</div>";

    html += "<div id='" + me.pre + "dl_thickness2'>";
    html += me.setThicknessHtml('style');
    html += "</div>";

    html += "<div id='" + me.pre + "dl_addtrack'>";
    html += "     <input type='hidden' id='" + me.pre + "track_chainid' value=''>";

    html += "    <div id='" + me.pre + "dl_addtrack_tabs' style='border:0px;'>";
    html += "      <ul>";
    html += "        <li><a href='#" + me.pre + "tracktab1'>NCBI gi/Accession</a></li>";
    html += "        <li><a href='#" + me.pre + "tracktab2'>FASTA</a></li>";
    html += "        <li><a href='#" + me.pre + "tracktab3'>BED File</a></li>";
    html += "        <li><a href='#" + me.pre + "tracktab4'>Custom</a></li>";
    html += "        <li><a href='#" + me.pre + "tracktab5'>Current Selection</a></li>";
    html += "      </ul>";
    html += "      <div id='" + me.pre + "tracktab1'>";
    html += "NCBI gi/Accession: <input type='text' id='" + me.pre + "track_gi' placeholder='gi' size=16> <br><br>";
    html += "<button id='" + me.pre + "addtrack_button1'>Add Track</button>";
    html += "      </div>";
    html += "      <div id='" + me.pre + "tracktab2'>";
    html += "FASTA sequence: <br><textarea id='" + me.pre + "track_fasta' rows='5' style='width: 100%; height: " + (2*me.MENU_HEIGHT) + "px; padding: 0px; border: 0px;'></textarea><br><br>";
    html += "<button id='" + me.pre + "addtrack_button2'>Add Track</button>";
    html += "      </div>";
    html += "      <div id='" + me.pre + "tracktab3'>";
    html += "BED file: <input type='file' id='" + me.pre + "track_bed' size=16> <br><br>";
    html += "<button id='" + me.pre + "addtrack_button3'>Add Track</button>";
    html += "      </div>";
    html += "      <div id='" + me.pre + "tracktab4'>";
    html += "Track Title: <input type='text' id='" + me.pre + "track_title' placeholder='track title' size=16> <br><br>";
    html += "Track Text (e.g., \"152 G, 155-156 RR\" defines a character \"G\" at the position 152 and two continuous characters \"RR\" at positions from 155 to 156. The starting position is 1): <br>";
    html += "<textarea id='" + me.pre + "track_text' rows='5' style='width: 100%; height: " + (2*me.MENU_HEIGHT) + "px; padding: 0px; border: 0px;'></textarea><br><br>";
    html += "<button id='" + me.pre + "addtrack_button4'>Add Track</button>";
    html += "      </div>";
    html += "      <div id='" + me.pre + "tracktab5'>";
    html += "Track Title: <input type='text' id='" + me.pre + "track_selection' placeholder='track title' size=16> <br><br>";
    html += "<button id='" + me.pre + "addtrack_button5'>Add Track</button>";
    html += "      </div>";

    html += "    </div>";

    html += "</div>";

    html += "<div id='" + me.pre + "dl_saveselection'>";
    var index = (me.icn3d) ? Object.keys(me.icn3d.defNames2Atoms).length : 1;
    var suffix = '';
    html += "Name: <input type='text' id='" + me.pre + "seq_command_name" + suffix + "' value='seq_" + index + "' size='5'> <br>";
    //html += "Description: <input type='text' id='" + me.pre + "seq_command_desc" + suffix + "' value='seq_desc_" + index + "' size='10'> <br>";
    html += "<button style='white-space:nowrap;' id='" + me.pre + "seq_saveselection" + suffix + "'>Save</button> <button style='white-space:nowrap; margin-left:20px;' id='" + me.pre + "seq_clearselection" + suffix + "'>Clear</button><br/><br/>";
    html += "</div>";


    html += "<div id='" + me.pre + "dl_copyurl'>";
    html += "Please copy one of the URLs below. They work the same way.<br><br>";
    html += "Original URL with commands: <br><textarea id='" + me.pre + "ori_url' rows='4' style='width:100%'></textarea><br><br>";
    html += "Short URL: <br><input type='text' id='" + me.pre + "short_url' value='' style='width:100%'><br><br>";
    html += "</div>";

    html += "<div id='" + me.pre + "dl_selectannotations' class='icn3d-annotation' style='background-color:white;'>";

    html += "    <div id='" + me.pre + "dl_annotations_tabs'>";

/*
    html += "    <table border=0><tr>";
    html += "    <td valign='top' width='100'>";
    html += "        <div style='margin-top:28px; white-space: nowrap;'><span id='" + me.pre + "viewdetail' style='display:none;' title='Expand the width of the annotation window to view the residue details'><b>Detailed View</b></span><span id='" + me.pre + "overview' class='icn3d-viewselection' title='Shrink the width of the annotaion window to overview'><b>Overview</b></span></div>";
    html += "        <label class='icn3d-switch'><input id='" + me.pre + "viewswitch' type='checkbox'><div class='icn3d-slider icn3d-round' style='width:34px; height:18px; margin: 16px 0px 0px 30px;' title='Left (\"Detailed View\")&#13;Right (\"Overview\")'></div></label>";
    html += "    </td>";
    html += "    <td>";
    html += "        <div style='border-left:1px solid #ccc; width:1px; height:40px;'></div>";
    html += "    </td>";
    html += "    <td>";
*/

/*
    html += "        <div style='white-space: nowrap;'><span id='" + me.pre + "viewdetail' class='icn3d-large'><b>Sequence Details</b></span>";
    html += "        <label class='icn3d-switch'><input id='" + me.pre + "viewswitch' type='checkbox'><div class='icn3d-slider icn3d-round' style='width:34px; height:18px; display:inline-block; margin: 6px 0px 0px 145px;' title='Left (\"Detailed View\")&#13;Right (\"Overview\")'></div></label>";
    html += "        <span id='" + me.pre + "overview' style='margin-left:50px;' class='icn3d-viewselection icn3d-large'><b>Graphic Summary</b></span>";

    html += "<button style='white-space:nowrap; margin-left:50px' id='" + me.pre + "showallchains'>Show All Chains</button></div>";
*/

    html += "<div id='" + me.pre + "dl_anno_view_tabs' style='border:0px; height:33px;'>";
    html += "      <ul>";
    html += "        <li><a href='#" + me.pre + "anno_tmp1' id='" + me.pre + "anno_summary'>Summary</a></li>";
    html += "        <li><a href='#" + me.pre + "anno_tmp2' id='" + me.pre + "anno_details'>Details</a></li>";
    html += "      </ul>";
    html += "      <div id='" + me.pre + "anno_tmp1'>";
    html += "      </div>";
    html += "      <div id='" + me.pre + "anno_tmp2'>";
    html += "      </div>";
    html += "</div>";

    html += "      <div class='icn3d-box' style='width:520px;'><b>Annotations:&nbsp;</b><br><table border=0><tr>";
    html += "        <td style='min-width:60px;'><input type='checkbox' id='" + me.pre + "anno_all'>All&nbsp;&nbsp;</td>";
    html += "        <td style='min-width:130px;'><input type='checkbox' id='" + me.pre + "anno_cdd' checked>Conserved Domains&nbsp;&nbsp;</td>";
    html += "        <td style='min-width:60px;'><input type='checkbox' id='" + me.pre + "anno_clinvar'>ClinVar&nbsp;&nbsp;</td>";
    html += "        <td style='min-width:110px;'><input type='checkbox' id='" + me.pre + "anno_binding'>Functional Sites&nbsp;&nbsp;</td>";
    html += "        <td style='min-width:110px;'><input type='checkbox' id='" + me.pre + "anno_ssbond'>Disulfide Bonds&nbsp;&nbsp;</td>";
    html += "      </tr><tr>";
    html += "        <td style='min-width:60px;'><input type='checkbox' id='" + me.pre + "anno_custom'>Custom&nbsp;&nbsp;</td>";
    html += "        <td style='min-width:130px;'><input type='checkbox' id='" + me.pre + "anno_3dd'>3D Domains&nbsp;&nbsp;</td>";
    html += "        <td style='min-width:60px;'><input type='checkbox' id='" + me.pre + "anno_snp'>SNPs&nbsp;&nbsp;</td>";
    html += "        <td style='min-width:110px;'><input type='checkbox' id='" + me.pre + "anno_interact'>Interactions&nbsp;&nbsp;</td>";
    html += "        <td></td>";
    html += "      </tr></table></div>";

    html += "<button style='white-space:nowrap; margin-left:5px;' id='" + me.pre + "showallchains'>Show All Chains</button><br>";
//    html += "    </td>";
//    html += "    </tr></table>";

    html += "    <div id='" + me.pre + "seqguide_wrapper' style='display:none'><br>" + me.setSequenceGuide("2") + "</div>";

    // add note about assembly
    //html = "     <div id='" + me.pre + "assembly_note' class='icn3d-annoLargeTitle'><br>Only the asymmetric unit is shown in the sequence window.</div>";

    html += "    </div><br/><hr><br>";

    html += "    <div id='" + me.pre + "dl_annotations'>";
    html += "    </div>";
    html += "</div>";

    html += "</div>";
    html += "<!--/form-->";

    return html;
};

iCn3DUI.prototype.setThicknessHtml = function (type) { var me = this;
    var html = '';

    // type == '3dprint' or 'style'
    var linerad = (type == '3dprint') ? '1' : '0.1';
    var coilrad = (type == '3dprint') ? '1.2' : '0.3';
    var stickrad = (type == '3dprint') ? '0.8' : '0.4';
    var tracerad = (type == '3dprint') ? '1' : '0.2';
    var ribbonthick = (type == '3dprint') ? '1' : '0.2';
    var prtribbonwidth = (type == '3dprint') ? '2' : '1.3';
    var nucleotideribbonwidth = (type == '3dprint') ? '1.4' : '0.8';
    var ballscale = (type == '3dprint') ? '0.6' : '0.3';

    html += "<b>Line Radius</b>: <input type='text' id='" + me.pre + "linerad_" + type + "' value='" + linerad + "' size=4>&nbsp;&nbsp;&nbsp;(for stabilizers, hydrogen bonds, distance lines, default 0.1)<br/>";
    html += "<b>Coil Radius</b>: <input type='text' id='" + me.pre + "coilrad_" + type + "' value='" + coilrad + "' size=4>&nbsp;&nbsp;&nbsp;(for coils, default 0.3)<br/>";
    html += "<b>Stick Radius</b>: <input type='text' id='" + me.pre + "stickrad_" + type + "' value='" + stickrad + "' size=4>&nbsp;&nbsp;&nbsp;(for sticks, default 0.4)<br/>";
    html += "<b>Trace Radius</b>: <input type='text' id='" + me.pre + "tracerad_" + type + "' value='" + tracerad + "' size=4>&nbsp;&nbsp;&nbsp;(for C alpha trace, O3' trace, default 0.2)<br/>";

    html += "<b>Ribbon Thickness</b>: <input type='text' id='" + me.pre + "ribbonthick_" + type + "' value='" + ribbonthick + "' size=4>&nbsp;&nbsp;&nbsp;(for helix and sheet ribbons, nucleotide ribbons, default 0.2)<br/>";
    html += "<b>Protein Ribbon Width</b>: <input type='text' id='" + me.pre + "prtribbonwidth_" + type + "' value='" + prtribbonwidth + "' size=4>&nbsp;&nbsp;&nbsp;(for helix and sheet ribbons, default 1.3)<br/>";
    html += "<b>Nucleotide Ribbon Width</b>: <input type='text' id='" + me.pre + "nucleotideribbonwidth_" + type + "' value='" + nucleotideribbonwidth + "' size=4>&nbsp;&nbsp;&nbsp;(for nucleotide ribbons, default 0.8)<br/>";

    html += "<b>Ball Scale</b>: <input type='text' id='" + me.pre + "ballscale_" + type + "' value='" + ballscale + "' size=4>&nbsp;&nbsp;&nbsp;(for styles 'Ball and Stick' and 'Dot', default 0.3)<br/>";

    html += "<span style='white-space:nowrap'><button id='" + me.pre + "apply_thickness_" + type + "'>Preview</button></span>";

    return html;
};

iCn3DUI.prototype.setSequenceGuide = function (suffix, bShown) { var me = this;
  var sequencesHtml = '';

  var index = (me.icn3d) ? Object.keys(me.icn3d.defNames2Atoms).length : 1;

  if(bShown) {
     sequencesHtml += "<div id='" + me.pre + "seqguide" + suffix + "'>";
 }
 else {
     sequencesHtml += '<div style="width:20px; margin-left:3px; display:inline-block;"><span id="' + me.pre + 'seqguide' + suffix + '_expand" class="ui-icon ui-icon-plus icn3d-expand icn3d-link" style="width:15px;" title="Expand"></span><span id="' + me.pre + 'seqguide' + suffix + '_shrink" class="ui-icon ui-icon-minus icn3d-shrink icn3d-link" style="display:none; width:15px;" title="Shrink"></span></div> ';

     //sequencesHtml += "<div style='min-width:200px; display:inline-block;'><b>Selection:</b> Name: <input type='text' id='" + me.pre + "seq_command_name" + suffix + "' value='seq_" + index + "' size='5'> &nbsp;&nbsp;Description: <input type='text' id='" + me.pre + "seq_command_desc" + suffix + "' value='seq_desc_" + index + "' size='10'> &nbsp;&nbsp;<button style='white-space:nowrap;' id='" + me.pre + "seq_saveselection" + suffix + "'>Save</button> <button style='white-space:nowrap; margin-left:20px;' id='" + me.pre + "seq_clearselection" + suffix + "'>Clear</button></div><br/>";
     sequencesHtml += "<div style='min-width:200px; display:inline-block;'><b>Selection:</b> Name: <input type='text' id='" + me.pre + "seq_command_name" + suffix + "' value='seq_" + index + "' size='5'> &nbsp;&nbsp;<button style='white-space:nowrap;' id='" + me.pre + "seq_saveselection" + suffix + "'>Save</button> <button style='white-space:nowrap; margin-left:20px;' id='" + me.pre + "seq_clearselection" + suffix + "'>Clear</button></div><br/>";

     sequencesHtml += "<div id='" + me.pre + "seqguide" + suffix + "' style='display:none; white-space:normal;' class='icn3d-box'>";
 }

  if(!me.isMobile()) {
      sequencesHtml += "<b>Select on 1D sequences:</b> drag to select, drag again to deselect, multiple selection is allowed without Ctrl key, click \"Save Selection\" to save the current selection.<br/><br/>";

      sequencesHtml += "<b>Select on 2D interaction diagram:</b> click on the nodes or lines. The nodes are chains and can be united with the Ctrl key. The lines are interactions and can NOT be united. Each click on the lines selects half of the lines, i.e., select the interacting residues in one of the two chains. The selected residues are saved in the \"Select -> Advanced\" menu.<br/><br/>";

      var tmpStr = me.isMobile() ? 'use finger to pick' : 'hold "Alt" and use mouse to pick';
      sequencesHtml += "<b>Select on 3D structures:</b> " + tmpStr + ", click the second time to deselect, hold \"Ctrl\" to union selection, hold \"Shift\" to select a range, press the up/down arrow to switch among atom/residue/strand/chain/structure, click \"Save Selection\" to save the current selection.<br/><br/>";

      sequencesHtml += "<b>Save the current selection</b> (either on 3D structure, 2D interactions, or 1D sequence): open the menu \"Select -> Save Selection\", specify the name and description for the selection, and click \"Save\".<br/><br/>";
  }
  else {
        sequencesHtml += "<b>Select Sequences:</b> touch to select, touch again to deselect, multiple selection is allowed without Ctrl key, click \"Save Selection\" to save the current selection.<br/><br/>";
  }

  var resCategories = "<b>Residue labeling:</b> standard residue with coordinates: UPPER case letter; nonstandard residue with coordinates: the first UPPER case letter plus a period except that water residue uses the letter 'O'; residue missing coordinates: lower case letter.";
  var scroll = (me.isMac() && !me.isMobile()) ? "<br/><br/><b>Turn on scroll bar:</b> System preferences -> General -> show scroll bars -> check Always" : "";

  sequencesHtml += resCategories + scroll + "<br/></div>";

  return sequencesHtml;
};

iCn3DUI.prototype.getAlignSequencesAnnotations = function (alignChainArray, bUpdateHighlightAtoms, residueArray, bShowHighlight) { var me = this;
  var resCategories = "<b>Residue labeling:</b> aligned residue with coordinates: UPPER case letter; non-aligned residue with coordinates: lower case letter which can be highlighted; residue missing coordinates: lower case letter which can NOT be highlighted.";
  var scroll = (me.isMac() && !me.isMobile()) ? "<br/><b>Turn on scroll bar:</b> System preferences -> General -> show scroll bars -> check Always" : "";

  var sequencesHtml;

  if(!me.isMobile()) {
      sequencesHtml = "<b>Select on 1D sequences:</b> drag to select, drag again to deselect, multiple selection is allowed without Ctrl key, click \"Save Selection\" to save the current selection.<br/>";

      sequencesHtml += "<b>Select on 2D interaction diagram:</b> click on the nodes or lines. The nodes are chains and can be united with the Ctrl key. The lines are interactions and can NOT be united. Each click on the lines selects half of the lines, i.e., select the interacting residues in one of the two chains. The selected residues are saved in the \"Select -> Advanced\" menu.<br/><br/>";

      var tmpStr = me.isMobile() ? 'use finger to pick' : 'hold "Alt" and use mouse to pick';
      sequencesHtml += "<b>Select on 3D structures:</b> " + tmpStr + ", click the second time to deselect, hold \"Ctrl\" to union selection, hold \"Shift\" to select a range, press the up/down arrow to switch among atom/residue/strand/chain/structure, click \"Save Selection\" to save the current selection.<br/>";

      sequencesHtml += "<b>Save the current selection</b> (either on 3D structure, 2D interactions, or 1D sequence): open the menu \"Select -> Save Selection\", specify the name and description for the selection, and click \"Save\".<br/><br/>";
  }
  else {
        sequencesHtml = "<b>Select Aligned Sequences:</b> touch to select, touch again to deselect, multiple selection is allowed without Ctrl key, click \"Save Selection\" to save the current selection.<br/>";
  }

  //sequencesHtml += "<div style='min-width:200px;'><b>Selection:</b> Name: <input type='text' id='" + me.pre + "alignseq_command_name' value='alseq_" + Object.keys(me.icn3d.defNames2Atoms).length + "' size='10'> &nbsp;&nbsp;Description: <input type='text' id='" + me.pre + "alignseq_command_desc' value='alseq_desc_" + Object.keys(me.icn3d.defNames2Atoms).length + "' size='20'> <button style='white-space:nowrap;' id='" + me.pre + "alignseq_saveselection'>Save</button> <button style='white-space:nowrap; margin-left:20px;' id='" + me.pre + "alignseq_clearselection'>Clear</button></div><br/>";
  sequencesHtml += "<div style='min-width:200px;'><b>Selection:</b> Name: <input type='text' id='" + me.pre + "alignseq_command_name' value='alseq_" + Object.keys(me.icn3d.defNames2Atoms).length + "' size='10'> &nbsp;&nbsp;<button style='white-space:nowrap;' id='" + me.pre + "alignseq_saveselection'>Save</button> <button style='white-space:nowrap; margin-left:20px;' id='" + me.pre + "alignseq_clearselection'>Clear</button></div><br/>";

  sequencesHtml += resCategories + scroll + "<br/>";

  var maxSeqCnt = 0;

  var chainHash = {};
  if(alignChainArray !== undefined) {
      for(var i = 0, il = alignChainArray.length; i < il; ++i) {
          chainHash[alignChainArray[i]] = 1;
      }
  }

  var bModifyHAtoms = Object.keys(me.icn3d.hAtoms).length == Object.keys(me.icn3d.atoms).length && bHighlightChain && (bUpdateHighlightAtoms === undefined || bUpdateHighlightAtoms);

  if(bModifyHAtoms) {
      me.icn3d.hAtoms = {};
  }

  for(var i in me.icn3d.alnChains) {
      var bHighlightChain = (alignChainArray !== undefined && chainHash.hasOwnProperty(i)) ? true : false;

      //if( bHighlightChain && (bUpdateHighlightAtoms === undefined || bUpdateHighlightAtoms) ) {
      // do not update isa subset is selected already
      if( bModifyHAtoms ) {
          me.icn3d.hAtoms = me.icn3d.unionHash(me.icn3d.hAtoms, me.icn3d.alnChains[i]);
      }

      var resiHtmlArray = [], seqHtml = "";
      var seqLength = (me.icn3d.alnChainsSeq[i] !== undefined) ? me.icn3d.alnChainsSeq[i].length : 0;

      if(seqLength > maxSeqCnt) maxSeqCnt = seqLength;

      var dashPos = i.indexOf('_');
      var structure = i.substr(0, dashPos);
      var chain = i.substr(dashPos + 1);

      seqHtml += "<span class='icn3d-residueNum' title='starting residue number'>" + me.icn3d.alnChainsSeq[i][0].resi + "</span>";
      var bHighlightChain = (alignChainArray !== undefined && chainHash.hasOwnProperty(i)) ? true : false;

      for(var k=0, kl=seqLength; k < kl; ++k) {
        // resiId is empty if it's gap
        var resiId = 'N/A', resIdFull = '', color = '#000';
        if(me.icn3d.alnChainsSeq[i][k].resi !== '' && !isNaN(me.icn3d.alnChainsSeq[i][k].resi)) {
            resiId = me.icn3d.alnChainsSeq[i][k].resi;
            resIdFull = structure + "_" + chain + "_" + resiId;
            color = me.icn3d.alnChainsSeq[i][k].color;
        }

        var classForAlign = "class='icn3d-residue"; // used to identify a residue when clicking a residue in sequence

        //if( (bShowHighlight === undefined || bShowHighlight) && (bHighlightChain || (me.icn3d.alnChainsSeq[i][k].aligned === 2 && residueArray !== undefined && resIdFull !== '' && residueArray.indexOf(resIdFull) !== -1) ) ) {
        if( (bShowHighlight === undefined || bShowHighlight) && (bHighlightChain || (residueArray !== undefined && resIdFull !== '' && residueArray.indexOf(resIdFull) !== -1) ) ) {
            classForAlign = "class='icn3d-residue icn3d-highlightSeq";
        }

        // class for alignment: cons, ncons, nalign
        if(resIdFull === '') {
            classForAlign += "'";
        }
        else {
            classForAlign += " " + me.icn3d.alnChainsSeq[i][k].class + "'";
        }

        var colorRes;
        if(!me.icn3d.residues.hasOwnProperty(resIdFull)) {
            colorRes = '#000000;';
        }
        else {
            var firstAtom = me.icn3d.getFirstCalphaAtomObj(me.icn3d.residues[resIdFull]);
            colorRes = (firstAtom.color !== undefined) ? '#' + firstAtom.color.getHexString() + ';' : '#000000;';
        }

        if(colorRes.toUpperCase() === '#FFFFFF;') colorRes = me.GREYD;

        var bWithCoord = (resIdFull !== '') ? true : false;

        if(bWithCoord) {
            if(me.icn3d.alnChainsSeq[i][k].resi != -1) {
                // add "align" in front of id so that full sequence and aligned sequence will not conflict
                seqHtml += "<span id='align_" + me.pre + resIdFull + "' " + classForAlign + " style='color:" + colorRes + "' title='" + me.icn3d.alnChainsSeq[i][k].resn + me.icn3d.alnChainsSeq[i][k].resi + "'>" + me.icn3d.alnChainsSeq[i][k].resn + "</span>";
            }
            else {
                seqHtml += "<span>" + me.icn3d.alnChainsSeq[i][k].resn + "</span>";
            }
        }
        else {
            seqHtml += "<span title='" + me.icn3d.alnChainsSeq[i][k].resn + me.icn3d.alnChainsSeq[i][k].resi + "'>" + me.icn3d.alnChainsSeq[i][k].resn + "</span>";
        }

      }
      seqHtml += "<span class='icn3d-residueNum' title='ending residue number'>" + me.icn3d.alnChainsSeq[i][seqLength-1].resi + "</span>";

      // the first chain stores all annotations
      var annoLength = (me.icn3d.alnChainsAnno[i] !== undefined) ? me.icn3d.alnChainsAnno[i].length : 0;

      for(var j=0, jl=annoLength; j < jl; ++j) {
        resiHtmlArray[j] = "";

        var chainid = (j == 0) ? me.icn3d.alnChainsAnTtl[i][4][0] : i; // bottom secondary, j == 0: chain2,  next secondary, j == 1: chain1,

        resiHtmlArray[j] += "<span class='icn3d-residueNum'></span>"; // a spot corresponding to the starting and ending residue number
        for(var k=0, kl=me.icn3d.alnChainsAnno[i][j].length; k < kl; ++k) {
          var text = me.icn3d.alnChainsAnno[i][j][k];

          if(text == 'H' || text == 'E' || text == 'c' || text == 'o') {

            if(text == 'H') {
                if(k % 2 == 0) {
                    resiHtmlArray[j] += '<span class="icn3d-helix">&nbsp;</span>';
                }
                else {
                    resiHtmlArray[j] += '<span class="icn3d-helix2">&nbsp;</span>';
                }
            }
            else if(text == 'E') {
                if(me.icn3d.alnChainsSeq[chainid][k] !== undefined) {
                    //var resiId = me.icn3d.alnChainsSeq[i][k].resi;
                    var resiId = me.icn3d.alnChainsSeq[chainid][k].resi;
                    var resIdFull = chainid + "_" + resiId;

                    if(me.icn3d.residues.hasOwnProperty(resIdFull)) {
                        var atom = me.icn3d.getFirstCalphaAtomObj(me.icn3d.residues[resIdFull]);

                        if(atom.ssend) {
                            resiHtmlArray[j] += '<span class="icn3d-sheet2">&nbsp;</span>';
                        }
                        else {
                            resiHtmlArray[j] += '<span class="icn3d-sheet">&nbsp;</span>';
                        }
                    }
                }
            }
            else if(text == 'c') {
                resiHtmlArray[j] += '<span class="icn3d-coil">&nbsp;</span>';
            }
            else if(text == 'o') {
                resiHtmlArray[j] += '<span class="icn3d-other">&nbsp;</span>';
            }
            else {
                resiHtmlArray[j] += "<span></span>";
            }
          }
          else {
              resiHtmlArray[j] += "<span>" + text + "</span>";
          }
          //resiHtmlArray[j] += "<span>" + me.icn3d.alnChainsAnno[i][j][k] + "</span>";
        }
        resiHtmlArray[j] += "<span class='icn3d-residueNum'></span>"; // a spot corresponding to the starting and ending residue number
      }

      var chainidTmp = i, title = (me.icn3d.pdbid_chain2title !== undefined) ? me.icn3d.pdbid_chain2title[i] : '';

      // add markers and residue numbers
      for(var j=annoLength-1; j >= 0; --j) {
        var annotitle = me.icn3d.alnChainsAnTtl[i][j][0];
        if(annotitle == 'SS') annotitle = '';
        //sequencesHtml += "<div class='icn3d-residueLine' style='white-space:nowrap;'><div class='icn3d-seqTitle' chain='" + i + "' anno='" + j + "'>" + annotitle + "</div>" + resiHtmlArray[j] + "<br/></div>";
        sequencesHtml += "<div class='icn3d-residueLine' style='white-space:nowrap;'><div class='icn3d-seqTitle' anno='" + j + "'>" + annotitle + "</div>" + resiHtmlArray[j] + "<br/></div>";
      }

      sequencesHtml += '<div class="icn3d-seqTitle icn3d-link icn3d-blue" chain="' + i + '" anno="sequence" title="' + title + '">' + chainidTmp + ' </div><span class="icn3d-seqLine">' + seqHtml + '</span><br/>';
  }

  return {"sequencesHtml": sequencesHtml, "maxSeqCnt":maxSeqCnt};
};


/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

iCn3DUI.prototype.openDialogHalfWindow = function (id, title, dialogWidth, bForceResize) {  var me = this;
    var twoddgmWidth = 170;

    me.resizeCanvas(me.WIDTH - dialogWidth - me.LESSWIDTH, me.HEIGHT - me.LESSHEIGHT - me.EXTRAHEIGHT, bForceResize);

    height = me.HEIGHT - me.LESSHEIGHT - me.EXTRAHEIGHT;
    width = dialogWidth;

    var position;
    if(me.cfg.showmenu) {
        //position ={ my: "left top", at: "right top+80", of: "#" + me.pre + "viewer", collision: "none" };
        position ={ my: "left top", at: "right top+40", of: "#" + me.pre + "viewer", collision: "none" };
    }
    else {
        position ={ my: "left top", at: "right top", of: "#" + me.pre + "viewer", collision: "none" };
    }

    // disable resize
    me.cfg.resize = false;

    window.dialog = $( "#" + id ).dialog({
      autoOpen: true,
      title: title,
      height: height,
      width: width,
      modal: false,
      position: position,
      close: function(e) {
            // determine whether dialogs initilaized
            var bSelectannotationsInit = $('#' + me.pre + 'dl_selectannotations').hasClass('ui-dialog-content'); // initialized
            var bAlignmentInit = $('#' + me.pre + 'dl_alignment').hasClass('ui-dialog-content'); // initialized
            var bTwoddgmInit = $('#' + me.pre + 'dl_2ddgm').hasClass('ui-dialog-content'); // initialized
            var bSetsInit = $('#' + me.pre + 'dl_definedsets').hasClass('ui-dialog-content'); // initialized

            var bSelectannotationsInit2 = false, bAlignmentInit2 = false, bTwoddgmInit2 = false, bSetsInit2 = false;
            if(bSelectannotationsInit) bSelectannotationsInit2 = $('#' + me.pre + 'dl_selectannotations').dialog( 'isOpen' );
            if(bAlignmentInit) bAlignmentInit2 = $('#' + me.pre + 'dl_alignment').dialog( 'isOpen' );
            if(bTwoddgmInit) bTwoddgmInit2 = $('#' + me.pre + 'dl_2ddgm').dialog( 'isOpen' );
            if(bSetsInit) bSetsInit2 = $('#' + me.pre + 'dl_definedsets').dialog( 'isOpen' );

          if((id === me.pre + 'dl_selectannotations' && (!bAlignmentInit2) )
            || (id === me.pre + 'dl_alignment' && (!bSelectannotationsInit2) )
            ) {
              if(bTwoddgmInit2 || bSetsInit2) {
                  me.resizeCanvas(me.WIDTH - me.LESSWIDTH - twoddgmWidth, me.HEIGHT - me.LESSHEIGHT - me.EXTRAHEIGHT, true);

                  if(bTwoddgmInit2) me.openDialog2Ddgm(me.pre + 'dl_2ddgm', undefined, bSetsInit2);
                  if(bSetsInit2) me.openDialog2Ddgm(me.pre + 'dl_definedsets');
              }
              else {
                  me.resizeCanvas(me.WIDTH - me.LESSWIDTH, me.HEIGHT - me.LESSHEIGHT - me.EXTRAHEIGHT, true);
              }
          }
      },
      resize: function(e) {
          if(id == me.pre + 'dl_selectannotations') {
              me.hideFixedTitle();
          }
      }
    });
};

iCn3DUI.prototype.openDialog2Ddgm = function (id, inHeight, bDefinedSets) {  var me = this;
    var twoddgmWidth = 170;
    var at, title;
    if(id === me.pre + 'dl_definedsets') {
        at = "right top";
        title = 'Select sets';
    }
    else if(id === me.pre + 'dl_2ddgm') {
        if(bDefinedSets !== undefined && bDefinedSets) {
            at = "right top+240";
        }
        else {
            at = "right top";
        }

        title = 'Interactions';
    }

    //var position ={ my: "left top", at: at, of: "#" + me.pre + "canvas", collision: "none" };
    var position ={ my: "left top+" + me.MENU_HEIGHT, at: at, of: "#" + me.pre + "viewer", collision: "none" };

    var height = 'auto';

    window.dialog = $( '#' + id ).dialog({
      autoOpen: true,
      title: title,
      height: height,
      width: twoddgmWidth,
      modal: false,
      position: position,
      close: function(e) {
            // determine whether dialogs initilaized
            var bSelectannotationsInit = $('#' + me.pre + 'dl_selectannotations').hasClass('ui-dialog-content'); // initialized
            var bAlignmentInit = $('#' + me.pre + 'dl_alignment').hasClass('ui-dialog-content'); // initialized
            var bTwoddgmInit = $('#' + me.pre + 'dl_2ddgm').hasClass('ui-dialog-content'); // initialized
            var bSetsInit = $('#' + me.pre + 'dl_definedsets').hasClass('ui-dialog-content'); // initialized

            var bSelectannotationsInit2 = false, bAlignmentInit2 = false, bTwoddgmInit2 = false, bSetsInit2 = false;
            if(bSelectannotationsInit) bSelectannotationsInit2 = $('#' + me.pre + 'dl_selectannotations').dialog( 'isOpen' );
            if(bAlignmentInit) bAlignmentInit2 = $('#' + me.pre + 'dl_alignment').dialog( 'isOpen' );
            if(bTwoddgmInit) bTwoddgmInit2 = $('#' + me.pre + 'dl_2ddgm').dialog( 'isOpen' );
            if(bSetsInit) bSetsInit2 = $('#' + me.pre + 'dl_definedsets').dialog( 'isOpen' );

          if( (!bSelectannotationsInit2) && (!bAlignmentInit2) ) {
                me.resizeCanvas(me.WIDTH - me.LESSWIDTH, me.HEIGHT - me.LESSHEIGHT - me.EXTRAHEIGHT, true);
          }
      }
    });
};

iCn3DUI.prototype.openDialog = function (id, title) {  var me = this;
    var width = 400, height = 150;
    var twoddgmWidth = 170;

    var bSelectannotationsInit = $('#' + me.pre + 'dl_selectannotations').hasClass('ui-dialog-content'); // initialized
    var bAlignmentInit = $('#' + me.pre + 'dl_alignment').hasClass('ui-dialog-content'); // initialized
    var bTwoddgmInit = $('#' + me.pre + 'dl_2ddgm').hasClass('ui-dialog-content'); // initialized
    var bSetsInit = $('#' + me.pre + 'dl_definedsets').hasClass('ui-dialog-content'); // initialized

    var bSelectannotationsInit2 = false, bAlignmentInit2 = false, bTwoddgmInit2 = false, bSetsInit2 = false;
    if(bSelectannotationsInit) bSelectannotationsInit2 = $('#' + me.pre + 'dl_selectannotations').dialog( 'isOpen' );
    if(bAlignmentInit) bAlignmentInit2 = $('#' + me.pre + 'dl_alignment').dialog( 'isOpen' );
    if(bTwoddgmInit) bTwoddgmInit2 = $('#' + me.pre + 'dl_2ddgm').dialog( 'isOpen' );
    if(bSetsInit) bSetsInit2 = $('#' + me.pre + 'dl_definedsets').dialog( 'isOpen' );

    if(id === me.pre + 'dl_selectannotations' || id === me.pre + 'dl_alignment') {
        var dialogWidth = 0.5 * (me.WIDTH - me.LESSWIDTH) - twoddgmWidth * 0.5;

        if(me.WIDTH - me.LESSWIDTH >= me.HEIGHT - me.LESSHEIGHT - me.EXTRAHEIGHT) {
            me.openDialogHalfWindow(id, title, dialogWidth, true);

            if(bTwoddgmInit2 || bSetsInit2) {
                me.resizeCanvas(me.WIDTH - me.LESSWIDTH - dialogWidth - twoddgmWidth, me.HEIGHT - me.LESSHEIGHT - me.EXTRAHEIGHT, true);

                if(bTwoddgmInit2) me.openDialog2Ddgm(me.pre + 'dl_2ddgm', undefined, bSetsInit2);
                if(bSetsInit2) me.openDialog2Ddgm(me.pre + 'dl_definedsets');
            }
        }
        else {
            me.resizeCanvas(me.WIDTH - me.LESSWIDTH, (me.HEIGHT - me.LESSHEIGHT - me.EXTRAHEIGHT) * 0.5, true);

            height = (me.HEIGHT - me.LESSHEIGHT - me.EXTRAHEIGHT) * 0.5;

            width = me.WIDTH - me.LESSWIDTH;

            var position ={ my: "left top", at: "left bottom+32", of: "#" + me.pre + "canvas", collision: "none" };

            window.dialog = $( "#" + id ).dialog({
              autoOpen: true,
              title: title,
              height: height,
              width: width,
              modal: false,
              position: position,
              close: function(e) {
/*
                    // determine whether dialogs initilaized
                    var bSelectannotationsInit = $('#' + me.pre + 'dl_selectannotations').hasClass('ui-dialog-content'); // initialized
                    var bAlignmentInit = $('#' + me.pre + 'dl_alignment').hasClass('ui-dialog-content'); // initialized
                    var bTwoddgmInit = $('#' + me.pre + 'dl_2ddgm').hasClass('ui-dialog-content'); // initialized
                    var bSetsInit = $('#' + me.pre + 'dl_definedsets').hasClass('ui-dialog-content'); // initialized

                    var bSelectannotationsInit2 = false, bAlignmentInit2 = false, bTwoddgmInit2 = false, bSetsInit2 = false;
                    if(bSelectannotationsInit) bSelectannotationsInit2 = $('#' + me.pre + 'dl_selectannotations').dialog( 'isOpen' );
                    if(bAlignmentInit) bAlignmentInit2 = $('#' + me.pre + 'dl_alignment').dialog( 'isOpen' );
                    if(bTwoddgmInit) bTwoddgmInit2 = $('#' + me.pre + 'dl_2ddgm').dialog( 'isOpen' );
                    if(bSetsInit) bSetsInit2 = $('#' + me.pre + 'dl_definedsets').dialog( 'isOpen' );
*/

                  if((id === me.pre + 'dl_selectannotations' && (!bAlignmentInit2) )
                    || (id === me.pre + 'dl_alignment' &&(!bSelectannotationsInit2) )
                    ) {
                      if(bTwoddgmInit2 || bSetsInit2) {
                          me.resizeCanvas(me.WIDTH - me.LESSWIDTH - twoddgmWidth, me.HEIGHT - me.LESSHEIGHT - me.EXTRAHEIGHT, true);

                          if(bTwoddgmInit2) me.openDialog2Ddgm(me.pre + 'dl_2ddgm', undefined, bSetsInit2);
                          if(bSetsInit2) me.openDialog2Ddgm(me.pre + 'dl_definedsets');
                      }
                      else {
                          me.resizeCanvas(me.WIDTH - me.LESSWIDTH, me.HEIGHT - me.LESSHEIGHT - me.EXTRAHEIGHT, true);
                      }
                  }
              },
              resize: function(e) {
                  if(id == me.pre + 'dl_selectannotations') {
                      me.hideFixedTitle();
                  }
              }
            });
        }
    }
    else if(id === me.pre + 'dl_2ddgm') {
        var tmpWidth = 0;

        if(me.WIDTH - me.LESSWIDTH >= me.HEIGHT - me.LESSHEIGHT - me.EXTRAHEIGHT) {
            if(bSelectannotationsInit2 || bAlignmentInit2) {
                tmpWidth = 0.5 * (me.WIDTH - me.LESSWIDTH) - twoddgmWidth * 0.5;
            }
            me.resizeCanvas(me.WIDTH - me.LESSWIDTH - tmpWidth - twoddgmWidth, me.HEIGHT - me.LESSHEIGHT - me.EXTRAHEIGHT, true);

            me.openDialog2Ddgm(id, undefined, bSetsInit2);
        }
        else {
            me.resizeCanvas(me.WIDTH - me.LESSWIDTH - tmpWidth - twoddgmWidth, (me.HEIGHT - me.LESSHEIGHT - me.EXTRAHEIGHT)*0.5, true);
            me.openDialog2Ddgm(id, (me.HEIGHT - me.LESSHEIGHT - me.EXTRAHEIGHT)*0.5);

            me.openDialog2Ddgm(id, (me.HEIGHT - me.LESSHEIGHT - me.EXTRAHEIGHT)*0.5, bSetsInit2);
        }
    }
    else {
        height = 'auto';
        width = 'auto';

        if(id === me.pre + 'dl_addtrack') {
            width='50%';
        }

        var position;

        if(id === me.pre + 'dl_definedsets') {
            var tmpWidth = 0;

            if(me.WIDTH - me.LESSWIDTH >= me.HEIGHT - me.LESSHEIGHT - me.EXTRAHEIGHT) {
                if(bSelectannotationsInit2 || bAlignmentInit2) {
                    tmpWidth = 0.5 * (me.WIDTH - me.LESSWIDTH) - twoddgmWidth * 0.5;
                }
                me.resizeCanvas(me.WIDTH - me.LESSWIDTH - tmpWidth - twoddgmWidth, me.HEIGHT - me.LESSHEIGHT - me.EXTRAHEIGHT, true);
                me.openDialog2Ddgm(id);

                if(bTwoddgmInit2) me.openDialog2Ddgm(me.pre + 'dl_2ddgm', undefined, true);
            }
            else {
                me.resizeCanvas(me.WIDTH - me.LESSWIDTH - tmpWidth - twoddgmWidth, (me.HEIGHT - me.LESSHEIGHT - me.EXTRAHEIGHT)*0.5, true);
                me.openDialog2Ddgm(id, (me.HEIGHT - me.LESSHEIGHT - me.EXTRAHEIGHT)*0.5);

                if(bTwoddgmInit2) me.openDialog2Ddgm(me.pre + 'dl_2ddgm', (me.HEIGHT - me.LESSHEIGHT - me.EXTRAHEIGHT)*0.5, true);
            }
        }
        else {
            if(me.isMobile()) {
                position ={ my: "left top", at: "left bottom-50", of: "#" + me.pre + "canvas", collision: "none" };
            }
            else {
                position ={ my: "left top", at: "left top+50", of: "#" + me.pre + "canvas", collision: "none" };
            }

            window.dialog = $( "#" + id ).dialog({
              autoOpen: true,
              title: title,
              height: height,
              width: width,
              modal: false,
              position: position
            });
        }
    }

    $(".ui-dialog .ui-button span")
      .removeClass("ui-icon-closethick")
      .addClass("ui-icon-close");
};

/**
 * @author Jiyao Wang <wangjiy@ncbi.nlm.nih.gov> / https://github.com/ncbi/icn3d
 */

// draw 2D dgm for MMDB ID
// Used as a reference the work at 2016 ISMB hackathon: https://github.com/NCBI-Hackathons/3D_2D_Rep_Structure
// bUpdate: redraw 2Ddiagramfor the displayed structure
iCn3DUI.prototype.draw2Ddgm = function(data, mmdbid, structureIndex, bUpdate) { var me = this;
    // only show the 2D diagrams for displayed structures

    // reduce the size from 300 to 150
    var factor = 0.5;

    // set molid2chain
    var molid2chain = {}, molid2color = {}, molid2name = {}, chainid2molid = {};
    var chainNameHash = {};

    if(data === undefined) return '';

    for(var molid in data.moleculeInfor) {
          var color = '#' + ( '000000' + data.moleculeInfor[molid].color.toString( 16 ) ).slice( - 6 );
          var chainName = data.moleculeInfor[molid].chain.trim();
          if(chainNameHash[chainName] === undefined) {
              chainNameHash[chainName] = 1;
          }
          else {
              ++chainNameHash[chainName];
          }

          var chainNameFinal = (chainNameHash[chainName] === 1) ? chainName : chainName + chainNameHash[chainName].toString();
          var chainid = mmdbid + '_' + chainNameFinal;

          molid2chain[molid] = chainid;
          molid2color[molid] = color;
          molid2name[molid] = data.moleculeInfor[molid].name;

          chainid2molid[chainid] = molid;
    }

    // save the interacting residues
    if(bUpdate === undefined || !bUpdate) {
        for(var i = 0, il = data['intracResidues'].length; i < il; ++i) {
            var pair = data['intracResidues'][i];

            var index = 0;
            var chainid1, chainid2;

            for(var molid in pair) {
                //molid = parseInt(molid);

                var chainid;

                chainid = molid2chain[molid];
                if(index === 0) {
                    chainid1 = chainid;
                }
                else {
                    chainid2 = chainid;
                }

                ++index;
            }

            if(chainid1 === undefined || chainid2 === undefined) continue;

            index = 0;
            for(var molid in pair) {
                var resArray = pair[molid];

                var fisrtChainid, secondChainid;
                if(index === 0) {
                    fisrtChainid = chainid1;
                    secondChainid = chainid2;
                }
                else {
                    fisrtChainid = chainid2;
                    secondChainid = chainid1;
                }

                if(me.chainids2resids[fisrtChainid] === undefined) {
                    me.chainids2resids[fisrtChainid] = {};
                }

                if(me.chainids2resids[fisrtChainid][secondChainid] === undefined) {
                    me.chainids2resids[fisrtChainid][secondChainid] = [];
                }

                for(var j = 0, jl = resArray.length; j < jl; ++j) {
                    var res = resArray[j];
                    var resid = me.mmdbMolidResid2mmdbChainResi[mmdbid.toUpperCase() + '_' + molid + '_' + res];

                    me.chainids2resids[fisrtChainid][secondChainid].push(resid);
                }

                // update me.chainname2residues
                if(me.chainname2residues === undefined) me.chainname2residues = {};

                var chainid2 = secondChainid;

                var atom2 = me.icn3d.getFirstCalphaAtomObj(me.icn3d.chains[chainid2]);
                //if(me.chainname2residues[chainid2] === undefined) me.chainname2residues[chainid2] = {};

                var type2;
                if(me.icn3d.chemicals.hasOwnProperty(atom2.serial)) { // 1. chemical interacting with proteins
                    type2 = 'chemical';
                }
                else if(me.icn3d.nucleotides.hasOwnProperty(atom2.serial)) { // 2. DNA interacting with proteins
                    type2 = 'nucleotide';
                }
                else if(me.icn3d.ions.hasOwnProperty(atom2.serial)) { // 3. ions interacting with proteins
                    type2 = 'ion';
                }
                else if(me.icn3d.proteins.hasOwnProperty(atom2.serial)) { // 4. protein interacting with proteins
                    type2 = 'protein';
                }
                else if(me.icn3d.water.hasOwnProperty(atom2.serial)) { // 5. water interacting with proteins
                    type2 = 'water';
                }

                var name = chainid2.substr(chainid2.indexOf('_') + 1) + " (" + type2 + ")";

                if(me.chainname2residues[fisrtChainid] === undefined) me.chainname2residues[fisrtChainid] = {};

                me.chainname2residues[fisrtChainid][name] = me.chainids2resids[fisrtChainid][secondChainid];


                ++index;
            }
        }
    }

    var html = "<div id='#" + me.pre + mmdbid + "'>";

    html += "<b>" + mmdbid.toUpperCase() + "</b><br/>";

    html += "<svg viewBox='0,0,150,150'>";
    var strokecolor = '#000000';
    var strokewidth = '1';
    var linestrokewidth = '2';
    var textcolor = '#000000';
    var fontsize = '10';
    var smallfontsize = '8';
    var adjustx = 0, adjusty = 4, smalladjustx = 1, smalladjusty = 2, halfLetHigh = 6;

    var posHash = {};
    var lines = [];

    var nodeHtml = "", chemNodeHtml = "";

    var alignedAtomArray = [];

    var displayedMolids = {};
    if(bUpdate !== undefined && bUpdate) {
        // get all displayed chains
        for(var i in me.icn3d.dAtoms) {
            var atom = me.icn3d.atoms[i];
            var chainid = atom.structure + '_' + atom.chain;
            var molid = chainid2molid[chainid];

            displayedMolids[molid] = 1;
        }
    }

    var allMolidArray = Object.keys(data.moleculeInfor);
    var intracMolidArray = Object.keys(data.intrac);

    var missingMolidArray = [];
    for(var i = 0, il = allMolidArray.length; i < il; ++i) {
        if(intracMolidArray.indexOf(allMolidArray[i]) === -1) missingMolidArray.push(allMolidArray[i]);
    }

    var missingMolid2intrac = {}; // biopolymer

    if(missingMolidArray.length > 0) {
        for(var molid in data.intrac) {
            var dgm = data.intrac[molid];
            for(var i = 0, il = dgm.intrac.length; i < il; ++i) {
                var intracMolid = dgm.intrac[i].toString();
                if(missingMolidArray.indexOf(intracMolid) !== -1) {
                    if(missingMolid2intrac[intracMolid] === undefined) missingMolid2intrac[intracMolid] = [];
                    missingMolid2intrac[intracMolid].push(molid);
                    lines.push([intracMolid, molid]);
                }
            }

            if(dgm.shape === 'rect') {
                var x = dgm.coords[0] * factor;
                var y = dgm.coords[1] * factor;
                var width = dgm.coords[2] * factor - x;
                var height = dgm.coords[3] * factor - y;

                posHash[molid] = [x + width/2, y + height/2];
            }
            else if(dgm.shape === 'circle') {
                var x = dgm.coords[0] * factor;
                var y = dgm.coords[1] * factor;
                var r = dgm.coords[2] * factor;

                posHash[molid] = [x, y];
            }
            else if(dgm.shape === 'poly') {
                var x0 = dgm.coords[0] * factor;
                var y0 = dgm.coords[1] * factor;
                var x1 = dgm.coords[2] * factor;
                var y1 = dgm.coords[3] * factor;
                var x2 = dgm.coords[4] * factor;
                var y2 = dgm.coords[5] * factor;
                var x3 = dgm.coords[6] * factor;
                var y3 = dgm.coords[7] * factor;

                var x = x0, y = y1;

                posHash[molid] = [x0, y1];
            }
        }
    }

    var cntNointeraction = 0;
    //for(var molid in data.intrac) {
    for(var index = 0, indexl = allMolidArray.length; index < indexl; ++index) {
        var molid = allMolidArray[index];

        // if redraw2d diagram and the molid is not displayed, skip
        if(bUpdate !== undefined && bUpdate && !displayedMolids.hasOwnProperty(molid)) continue;

        var dgm = data.intrac[molid];
        var color = "#FFFFFF";
        var oricolor = molid2color[molid];
        var alignNum = "";
        if(structureIndex !== undefined && structureIndex === 0) {
            if(me.alignmolid2color !== undefined && me.alignmolid2color[0].hasOwnProperty(molid)) {
                //color = me.alignmolid2color[0][molid];
                alignNum = me.alignmolid2color[0][molid];
                oricolor = "#FF0000";
            }
            else {
                oricolor = "#FFFFFF";
            }
        }
        else if(structureIndex !== undefined && structureIndex === 1) {
            if(me.alignmolid2color !== undefined && me.alignmolid2color[1].hasOwnProperty(molid)) {
                //color = me.alignmolid2color[1][molid];
                alignNum = me.alignmolid2color[1][molid];
                oricolor = "#FF0000";
            }
            else {
                oricolor = "#FFFFFF";
            }
        }

        var chainid;

        chainid = molid2chain[molid];

        var chainname = molid2name[molid];

        var chain = ' ', oriChain = ' ';
        if(chainid !== undefined) {
            var pos = chainid.indexOf('_');
            oriChain = chainid.substr(pos + 1);

            if(oriChain.length > 1) {
                chain = oriChain.substr(0, 1) + '..';
            }
            else {
                chain = oriChain;
            }
        }
        else {
            chainid = 'Misc';
        }

        if(oricolor === undefined) {
            oricolor = '#FFFFFF';
        }

        var ratio = 1.0;
        if(me.icn3d.alnChains[chainid] !== undefined) {
            //ratio = 1.0 * Object.keys(me.icn3d.alnChains[chainid]).length / Object.keys(me.icn3d.chains[chainid]).length;
            var alignedAtomCnt = 0;
            for(var i in me.icn3d.alnChains[chainid]) {
                var colorStr = me.icn3d.atoms[i].color.getHexString().toUpperCase();
                if(colorStr === 'FF0000' || colorStr === '00FF00') {
                    ++alignedAtomCnt;
                }
            }
            ratio = 1.0 * alignedAtomCnt / Object.keys(me.icn3d.chains[chainid]).length;
        }
        if(ratio < 0.2) ratio = 0.2;

        if(missingMolidArray.indexOf(molid) === -1) {
            for(var i = 0, il = dgm.intrac.length; i < il; ++i) {
                // show the interactin line once
                if(parseInt(molid) < parseInt(dgm.intrac[i])) lines.push([molid, dgm.intrac[i] ]);
            }

            if(dgm.shape === 'rect') {
                var x = dgm.coords[0] * factor;
                var y = dgm.coords[1] * factor;
                var width = dgm.coords[2] * factor - x;
                var height = dgm.coords[3] * factor - y;

                nodeHtml += me.draw2DNucleotide(x + 0.5 * width, y + 0.5 * height, chainid, oriChain, chain, chainname, alignNum, color, oricolor, factor, ratio);

                posHash[molid] = [x + width/2, y + height/2];
            }
            else if(dgm.shape === 'circle') {
                var x = dgm.coords[0] * factor;
                var y = dgm.coords[1] * factor;

                nodeHtml += me.draw2DProtein(x, y, chainid, oriChain, chain, chainname, alignNum, color, oricolor, factor, ratio);

                posHash[molid] = [x, y];
            }
            else if(dgm.shape === 'poly') {
              var x0 = dgm.coords[0] * factor;
              var y0 = dgm.coords[1] * factor;
              var x1 = dgm.coords[2] * factor;
              var y1 = dgm.coords[3] * factor;
              var x2 = dgm.coords[4] * factor;
              var y2 = dgm.coords[5] * factor;
              var x3 = dgm.coords[6] * factor;
              var y3 = dgm.coords[7] * factor;

              var x = x0, y = y1;

              var atom = me.icn3d.getFirstAtomObj(me.icn3d.chains[chainid]);

              //if(me.icn3d.proteins.hasOwnProperty(atom.serial)) {
              //    chemNodeHtml += me.draw2DProtein(x, y, chainid, oriChain, chain, chainname, alignNum, color, oricolor, factor, ratio);
              //}
              //else if(me.icn3d.nucleotides.hasOwnProperty(atom.serial)) {
              //    chemNodeHtml += me.draw2DNucleotide(x, y, chainid, oriChain, chain, chainname, alignNum, color, oricolor, factor, ratio);
              //}
              //else {
              //    chemNodeHtml += me.draw2DChemical(x, y, chainid, oriChain, chain, chainname, alignNum, color, oricolor, factor, ratio);
              //}

              chemNodeHtml += me.draw2DChemical(x, y, chainid, oriChain, chain, chainname, alignNum, color, oricolor, factor, ratio);

              posHash[molid] = [x0, y1];
            }
        }
        else { // missing biopolymer
            // max x and y value: 300
            var maxSize = 300;
            var step = 50;

            var xCenter, yCenter;
            if(missingMolid2intrac[molid] !== undefined && missingMolid2intrac[molid].length > 1) { // has interactions
                // find its position
                var xSum = 0, ySum = 0;

                for(var j = 0, jl = missingMolid2intrac[molid].length; j < jl; ++j) {
                    var intracMolid = missingMolid2intrac[molid][j];
                    if(posHash.hasOwnProperty(intracMolid)) {
                        var node = posHash[intracMolid];
                        xSum += node[0];
                        ySum += node[1];
                    }
                }

                xCenter = xSum / missingMolid2intrac[molid].length;
                yCenter = ySum / missingMolid2intrac[molid].length;
            }
            else { // has NO interactions or just one interaction
                var nSteps = maxSize / step;

                if(cntNointeraction < nSteps - 1) {
                    xCenter = (cntNointeraction + 1) * step * factor;
                    yCenter = 0.1 * maxSize * factor;
                }
                else if(cntNointeraction - (nSteps - 1) < nSteps - 1) {
                    xCenter = 0.1 * maxSize * factor;
                    yCenter = (cntNointeraction - (nSteps - 1) + 1) * step * factor;
                }
                else {
                    xCenter = 0.25 * maxSize * factor;
                    yCenter = xCenter;
                }

                ++cntNointeraction;

            }

            var x = xCenter, y = yCenter;

            var atom = me.icn3d.getFirstAtomObj(me.icn3d.chains[chainid]);

            //if(me.icn3d.proteins.hasOwnProperty(atom.serial)) {
            //  chemNodeHtml += me.draw2DProtein(x, y, chainid, oriChain, chain, chainname, alignNum, color, oricolor, factor, ratio);
            //}
            //else if(me.icn3d.nucleotides.hasOwnProperty(atom.serial)) {
            //  chemNodeHtml += me.draw2DNucleotide(x, y, chainid, oriChain, chain, chainname, alignNum, color, oricolor, factor, ratio);
            //}
            //else {
            //  chemNodeHtml += me.draw2DChemical(x, y, chainid, oriChain, chain, chainname, alignNum, color, oricolor, factor, ratio);
            //}

            var bBiopolymer = true;
            chemNodeHtml += me.draw2DChemical(x, y, chainid, oriChain, chain, chainname, alignNum, color, oricolor, factor, ratio, bBiopolymer);

            posHash[molid] = [x, y];
        }
    }

    for(var i = 0, il = lines.length; i < il; ++i) {
        var pair = lines[i];

        // if redraw2d diagram and the molid is not displayed, skip
        if(bUpdate !== undefined && bUpdate && (!displayedMolids.hasOwnProperty(pair[0]) || !displayedMolids.hasOwnProperty(pair[1])) ) continue;

        var node1 = posHash[parseInt(pair[0])];
        var node2 = posHash[parseInt(pair[1])];

        if(node1 === undefined || node2 === undefined) continue;

        var chainid1, chainid2;

        chainid1 = molid2chain[pair[0]];
        chainid2 = molid2chain[pair[1]];

        var pos1 = chainid1.indexOf('_');
        var pos2 = chainid2.indexOf('_');

        var chain1 = chainid1.substr(pos1 + 1);
        var chain2 = chainid2.substr(pos2 + 1);

        var x1 = node1[0], y1 = node1[1], x2 = node2[0], y2 = node2[1], xMiddle = (x1 + x2) * 0.5, yMiddle = (y1 + y2) * 0.5;

        //if(me.icn3d.bSSOnly) { // the condensed view with only secondary structure information
        //    html += "<g chainid1='" + chainid1 + "' chainid2='" + chainid2 + "' >";
        //    html += "<title>Interactions NOT shown in the condensed view</title>";
        //    html += "<line x1='" + x1 + "' y1='" + y1 + "' x2='" + x2 + "' y2='" + y2 + "' stroke='" + strokecolor + "' stroke-width='" + linestrokewidth + "' /></g>";
        //}
        //else {
            html += "<g class='icn3d-interaction' chainid1='" + chainid1 + "' chainid2='" + chainid2 + "' >";
            html += "<title>Interaction of chain " + chain1 + " with chain " + chain2 + "</title>";
            html += "<line x1='" + x1 + "' y1='" + y1 + "' x2='" + xMiddle + "' y2='" + yMiddle + "' stroke='" + strokecolor + "' stroke-width='" + linestrokewidth + "' /></g>";

            html += "<g class='icn3d-interaction' chainid1='" + chainid2 + "' chainid2='" + chainid1 + "' >";
            html += "<title>Interaction of chain " + chain2 + " with chain " + chain1 + "</title>";
            html += "<line x1='" + xMiddle + "' y1='" + yMiddle + "' x2='" + x2 + "' y2='" + y2 + "' stroke='" + strokecolor + "' stroke-width='" + linestrokewidth + "' /></g>";
        //}
    }

    html += chemNodeHtml + nodeHtml; // draw chemicals at the bottom layer

    html += "</svg>";
    html += "</div>";

    me.html2ddgm += html;

    $("#" + me.pre + "dl_2ddgm").html(me.html2ddgm);

    return html;
};

iCn3DUI.prototype.set2DdgmNote = function(bAlign) { var me = this;
    var html = "<div style='width:150px'><b>Nodes</b>:<br>";
    //html += "<span style='margin-right:18px;'>&#9711;</span>Protein<br>";
    //html += "<span style='margin-right:18px;'>&#9633;</span>Nucleotide<br>";
    //html += "<span style='margin-right:18px;'>&#9674;</span>Chemical<br>";


    if(me.isMac()) {
        html += "<span style='margin-right:18px;'>&#9711;</span>Protein<br>";
        html += "<span style='margin-right:18px;'>&#9634;</span>Nucleotide<br>";
        html += "<span style='margin-right:18px;'>&#9826;</span>Chemical<br>";
        html += "<span style='margin-right:18px;display: inline-block;transform: skew(-25deg);'>&#9634;</span>Biopolymer<br>";
    }
    else {
        html += "<span style='margin-right:18px;'>O</span>Protein<br>";
        html += "<span style='margin-right:18px;'>&#9634;</span>Nucleotide<br>";
        html += "<span style='margin-right:18px;'>&#9671;</span>Chemical<br>";
        html += "<span style='margin-right:18px;display: inline-block;transform: skew(-25deg);'>&#9634;</span>Biopolymer<br>";
    }

    html += "<br><b>Lines</b>:<br> Interactions at 4 &#197;<br>"
    if(bAlign !== undefined && bAlign) html += "<b>Numbers in red</b>:<br> Aligned chains"
    html += "</div><br/>";

    return html;
};

iCn3DUI.prototype.highlightNode = function(type, highlight, base, ratio) { var me = this;
    if(ratio < 0.2) ratio = 0.2;
    var strokeWidth = 3; // default 1

    if(type === 'rect') {
        $(highlight).attr('stroke', me.ORANGE);
        $(highlight).attr('stroke-width', strokeWidth);

        var x = Number($(base).attr('x'));
        var y = Number($(base).attr('y'));
        var width = Number($(base).attr('width'));
        var height = Number($(base).attr('height'));
        $(highlight).attr('x', x + width / 2.0 * (1 - ratio));
        $(highlight).attr('y', y + height / 2.0 * (1 - ratio));
        $(highlight).attr('width', width * ratio);
        $(highlight).attr('height', height * ratio);
    }
    else if(type === 'circle') {
        $(highlight).attr('stroke', me.ORANGE);
        $(highlight).attr('stroke-width', strokeWidth);

        $(highlight).attr('r', Number($(base).attr('r')) * ratio);
    }
    else if(type === 'polygon') {
        $(highlight).attr('stroke', me.ORANGE);
        $(highlight).attr('stroke-width', strokeWidth);

        var x = Number($(base).attr('x'));
        var y = Number($(base).attr('y'));

        var x0diff = Number($(base).attr('x0d'));
        var y0diff = Number($(base).attr('y0d'));
        var x1diff = Number($(base).attr('x1d'));
        var y1diff = Number($(base).attr('y1d'));
        var x2diff = Number($(base).attr('x2d'));
        var y2diff = Number($(base).attr('y2d'));
        var x3diff = Number($(base).attr('x3d'));
        var y3diff = Number($(base).attr('y3d'));

        $(highlight).attr('points', (x+x0diff*ratio).toString() + ", " + (y+y0diff*ratio).toString() + ", " + (x+x1diff*ratio).toString() + ", " + (y+y1diff*ratio).toString() + ", " + (x+x2diff*ratio).toString() + ", " + (y+y2diff*ratio).toString() + ", " + (x+x3diff*ratio).toString() + ", " + (y+y3diff*ratio).toString());
    }
};

iCn3DUI.prototype.click2Ddgm = function() { var me = this;
    $("#" + me.pre + "dl_2ddgm").on("click", ".icn3d-node", function(e) {
          e.stopImmediatePropagation();
        if(Object.keys(me.icn3d.hAtoms).length < Object.keys(me.icn3d.atoms).length) me.setMode('selection');

        me.bClickInteraction = false;

        var chainid = $(this).attr('chainid');

        // clear all nodes
        if(!me.icn3d.bCtrl && !me.icn3d.bShift) {
            me.removeSelection();

            // me.lineArray2d is used to highlight lines in 2D diagram
            me.lineArray2d = [];
        }

        //$(this).find('rect').attr('stroke', me.ORANGE);
        //$(this).find('circle').attr('stroke', me.ORANGE);
        //$(this).find('polygon').attr('stroke', me.ORANGE);

        var ratio = 1.0;
        if(me.icn3d.alnChains[chainid] !== undefined) ratio = 1.0 * Object.keys(me.icn3d.alnChains[chainid]).length / Object.keys(me.icn3d.chains[chainid]).length;

        var target = $(this).find("rect[class='icn3d-hlnode']");
        var base = $(this).find("rect[class='icn3d-basenode']");
        me.highlightNode('rect', target, base, ratio);

        target = $(this).find("circle[class='icn3d-hlnode']");
        base = $(this).find("circle[class='icn3d-basenode']");
        me.highlightNode('circle', target, base, ratio);

        target = $(this).find("polygon[class='icn3d-hlnode']");
        base = $(this).find("polygon[class='icn3d-basenode']");
        me.highlightNode('polygon', target, base, ratio);

        if(!me.icn3d.bCtrl && !me.icn3d.bShift) {
            me.icn3d.hAtoms = me.icn3d.cloneHash(me.icn3d.chains[chainid]);
        }
        else {
            me.icn3d.hAtoms = me.icn3d.unionHash(me.icn3d.hAtoms, me.icn3d.chains[chainid]);
        }

/*
        // highlight on 3D structure
        me.icn3d.removeHlObjects();

        me.icn3d.addHlObjects();

        // highlight on 2D diagram
        if(!me.icn3d.bCtrl && !me.icn3d.bShift) {
            me.chainArray2d = [chainid];
        }
        else {
            if(me.chainArray2d === undefined) me.chainArray2d = [];
            me.chainArray2d.push(chainid);
        }

        // highlight residues in annotation window and alignment window
        var residueArray = [];
        for(var i = 0, il = me.chainArray2d.length; i < il; ++i) {
            var chainid = me.chainArray2d[i];
            for(var j = 0, jl = me.icn3d.chainsSeq[chainid].length; j < jl; ++j) {
                residueArray.push(chainid + '_' + me.icn3d.chainsSeq[chainid][j].resi);
            }
        }

        me.hlSeq(residueArray);
*/

        // get the name array
        if(!me.icn3d.bCtrl && !me.icn3d.bShift) {
            me.chainArray2d = [chainid];
        }
        else {
            if(me.chainArray2d === undefined) me.chainArray2d = [];
            me.chainArray2d.push(chainid);
        }

        me.updateHlAll(me.chainArray2d);

        // show selected chains in annotation window
        me.showAnnoSelectedChains();

        var select = "select chain " + chainid;
        me.setLogCmd(select, true);

        me.bSelectResidue = false;
    });

    $("#" + me.pre + "dl_2ddgm").on("click", ".icn3d-interaction", function(e) {
          e.stopImmediatePropagation();
        if(Object.keys(me.icn3d.hAtoms).length < Object.keys(me.icn3d.atoms).length) me.setMode('selection');

        // clear all nodes
        //if(!me.icn3d.bCtrl && !me.icn3d.bShift) {
        //    me.removeSelection();
        //}

        me.bClickInteraction = true;

        var chainid1 = $(this).attr('chainid1');
        var chainid2 = $(this).attr('chainid2');

        $(this).find('line').attr('stroke', me.ORANGE);

        // interaction of chain1 with chain2, only show the part of chain1 interacting with chain2
        me.selectInteraction(chainid1, chainid2);

        // show selected chains in annotation window
        me.showAnnoSelectedChains();

        var select = "select interaction " + chainid1 + "," + chainid2;
        me.setLogCmd(select, true);

        me.bClickInteraction = false;
    });
};

iCn3DUI.prototype.selectInteraction = function (chainid1, chainid2) {   var me = this;
        me.removeHl2D();
        me.icn3d.removeHlObjects();

        if(!me.icn3d.bCtrl && !me.icn3d.bShift) {
            // me.lineArray2d is used to highlight lines in 2D diagram
            me.lineArray2d = [chainid1, chainid2];
        }
        else {
            if(me.lineArray2d === undefined) me.lineArray2d = [];
            me.lineArray2d.push(chainid1);
            me.lineArray2d.push(chainid2);
        }

        me.selectInteractionAtoms(chainid1, chainid2);

        me.icn3d.addHlObjects();

        me.updateHlAll();
};

iCn3DUI.prototype.selectInteractionAtoms = function (chainid1, chainid2) {   var me = this; // me.icn3d.pAtom is set already
    var radius = 4;

    // method 2. Retrieved from the cgi (This previously had problems in sharelink where the data from ajax is async. Now the data is from the same cgi as the atom data and there is no problem.)
    var residueArray = me.chainids2resids[chainid1][chainid2];

    if(!me.icn3d.bCtrl && !me.icn3d.bShift) me.icn3d.hAtoms = {};

    for(var i = 0, il = residueArray.length; i < il; ++i) {
        me.icn3d.hAtoms = me.icn3d.unionHash(me.icn3d.hAtoms, me.icn3d.residues[residueArray[i]]);
    }

    var commandname, commanddesc;
    if(Object.keys(me.icn3d.structures).length > 1) {
        commandname = "inter_" + chainid1 + "_" + chainid2;
    }
    else {
        var pos1 = chainid1.indexOf('_');
        var pos2 = chainid2.indexOf('_');

        commandname = "inter_" + chainid1.substr(pos1 + 1) + "_" + chainid2.substr(pos2 + 1);
    }

    commanddesc = "select the atoms in chain " + chainid1 + " interacting with chain " + chainid2 + " in a distance of " + radius + " angstrom";

    var select = "select interaction " + chainid1 + "," + chainid2;

    me.addCustomSelection(residueArray, commandname, commanddesc, select, true);

    var nameArray = [commandname];
};

iCn3DUI.prototype.draw2DProtein = function(x, y, chainid, oriChain, chain, chainname, alignNum, color, oricolor, factor, ratio) { var me = this;
    var strokecolor = '#000000';
    var strokewidth = '1';
    var linestrokewidth = '2';
    var textcolor = '#000000';
    var fontsize = '10';
    var smallfontsize = '8';
    var adjustx = 0, adjusty = 4, smalladjustx = 1, smalladjusty = 2, halfLetHigh = 6;

    var r = 20 * factor;

    html = "<g class='icn3d-node' chainid='" + chainid + "' >";
    html += "<title>Chain " + oriChain + ": " + chainname + "</title>";
    html += "<circle class='icn3d-basenode' cx='" + x + "' cy='" + y + "' r='" + r + "' fill='" + color + "' stroke-width='" + strokewidth + "' stroke='" + strokecolor + "' class='icn3d-node' chainid='" + chainid + "' />";

    html += "<circle class='icn3d-hlnode' cx='" + x + "' cy='" + y + "' r='" + (r * ratio).toString() + "' fill='" + oricolor + "' stroke-width='" + strokewidth + "' stroke='" + strokecolor + "' />";

    html += "<text x='" + (x - adjustx).toString() + "' y='" + (y + adjusty).toString() + "' style='fill:" + textcolor + "; font-size:" + fontsize + "; text-anchor:middle' >" + chain + "</text>";

    if(alignNum !== "") html += "<text x='" + (x - adjustx).toString() + "' y='" + (y + r + adjusty + halfLetHigh).toString() + "' style='fill:" + oricolor + "; font-size:" + smallfontsize + "; font-weight:bold; text-anchor:middle' >" + alignNum + "</text>";

    html += "</g>";

    return html;
};

iCn3DUI.prototype.draw2DNucleotide = function(x, y, chainid, oriChain, chain, chainname, alignNum, color, oricolor, factor, ratio) { var me = this;
    var strokecolor = '#000000';
    var strokewidth = '1';
    var linestrokewidth = '2';
    var textcolor = '#000000';
    var fontsize = '10';
    var smallfontsize = '8';
    var adjustx = 0, adjusty = 4, smalladjustx = 1, smalladjusty = 2, halfLetHigh = 6;

    var width = 30 * factor;
    var height = 30 * factor;

    x -= 0.5 * width;
    y -= 0.5 * height;

    html = "<g class='icn3d-node' chainid='" + chainid + "' >";
    html += "<title>Chain " + oriChain + ": " + chainname + "</title>";
    // place holder
    html += "<rect class='icn3d-basenode' x='" + x + "' y='" + y + "' width='" + width + "' height='" + height + "' fill='" + color + "' stroke-width='" + strokewidth + "' stroke='" + strokecolor + "' />";
    // highlight
    html += "<rect class='icn3d-hlnode' x='" + (x + width / 2.0 * (1 - ratio)).toString() + "' y='" + (y + height / 2.0 * (1 - ratio)).toString() + "' width='" + (width * ratio).toString() + "' height='" + (height * ratio).toString() + "' fill='" + oricolor + "' stroke-width='" + strokewidth + "' stroke='" + strokecolor + "' />";

    html += "<text x='" + (x + width / 2 - adjustx).toString() + "' y='" + (y + height / 2 + adjusty).toString() + "' style='fill:" + textcolor + "; font-size:" + fontsize + "; text-anchor:middle' >" + chain + "</text>";

    if(alignNum !== "") html += "<text x='" + (x + width / 2 - adjustx).toString() + "' y='" + (y + height + adjusty + halfLetHigh).toString() + "' style='fill:" + oricolor + "; font-size:" + smallfontsize + "; font-weight:bold; text-anchor:middle' >" + alignNum + "</text>";

    html += "</g>";

    return html;
};

iCn3DUI.prototype.draw2DChemical = function(x, y, chainid, oriChain, chain, chainname, alignNum, color, oricolor, factor, ratio, bBiopolymer) { var me = this;
    var strokecolor = '#000000';
    var strokewidth = '1';
    var linestrokewidth = '2';
    var textcolor = '#000000';
    var fontsize = '10';
    var smallfontsize = '8';
    var adjustx = 0, adjusty = 4, smalladjustx = 1, smalladjusty = 2, halfLetHigh = 6;

    var bpsize = 30 * factor;

    if(bBiopolymer !== undefined && bBiopolymer) {
        // biopolymer
        var xOffset = 0.5 * bpsize / Math.sqrt(3);
        var yOffset = 0.5 * bpsize;

        var x0 = x - xOffset;
        var y0 = y - yOffset;
        var x1 = x + 3 * xOffset;
        var y1 = y - yOffset;
        var x2 = x + xOffset;
        var y2 = y + yOffset;
        var x3 = x - 3 * xOffset;
        var y3 = y + yOffset;
    }
    else {
        // diamond
        var xOffset = 0.5 * bpsize;
        var yOffset = 0.5 * bpsize;

        var x0 = x - xOffset;
        var y0 = y;
        var x1 = x;
        var y1 = y + yOffset;
        var x2 = x + xOffset;
        var y2 = y;
        var x3 = x;
        var y3 = y - yOffset;
    }

    var x0diff = x0 - x;
    var y0diff = y0 - y;
    var x1diff = x1 - x;
    var y1diff = y1 - y;
    var x2diff = x2 - x;
    var y2diff = y2 - y;
    var x3diff = x3 - x;
    var y3diff = y3 - y;

    var html = "<g class='icn3d-node' chainid='" + chainid + "' >";
    html += "<title>Chain " + oriChain + ": " + chainname + "</title>";
    html += "<polygon class='icn3d-basenode' points='" + x0 + ", " + y0 + "," + x1 + ", " + y1 + "," + x2 + ", " + y2 + "," + x3 + ", " + y3 + "' x='" + x + "' y='" + y + "' x0d='" + x0diff + "' y0d='" + y0diff + "' x1d='" + x1diff + "' y1d='" + y1diff + "' x2d='" + x2diff + "' y2d='" + y2diff + "' x3d='" + x3diff + "' y3d='" + y3diff + "' fill='" + color + "' stroke-width='" + strokewidth + "' stroke='" + strokecolor + "' />";

    html += "<polygon class='icn3d-hlnode' points='" + (x+x0diff*ratio).toString() + ", " + (y+y0diff*ratio).toString() + "," + (x+x1diff*ratio).toString() + ", " + (y+y1diff*ratio).toString() + "," + (x+x2diff*ratio).toString() + ", " + (y+y2diff*ratio).toString() + "," + (x+x3diff*ratio).toString() + ", " + (y+y3diff*ratio).toString() + "' fill='" + oricolor + "' stroke-width='" + strokewidth + "' stroke='" + strokecolor + "' />";

    html += "<text x='" + (x + smalladjustx).toString() + "' y='" + (y + smalladjusty).toString() + "' style='fill:" + textcolor + "; font-size:" + smallfontsize + "; text-anchor:middle' >" + chain + "</text>";

    if(alignNum !== "") html += "<text x='" + (x + smalladjustx).toString() + "' y='" + (y + smalladjusty + halfLetHigh).toString() + "' style='fill:" + oricolor + "; font-size:" + smallfontsize + "; font-weight:bold; text-anchor:middle' >" + alignNum + "</text>";

    html += "</g>";

    return html;
};


/*!
 * ==========================================================
 *  COLOR PICKER PLUGIN 1.3.9
 * ==========================================================
 * Author: Taufik Nurrohman <https://github.com/tovic>
 * License: MIT
 * ----------------------------------------------------------
 */

(function(win, doc, NS) {

    var instance = '__instance__',
        first = 'firstChild',
        delay = setTimeout;

    function is_set(x) {
        return typeof x !== "undefined";
    }

    function is_string(x) {
        return typeof x === "string";
    }

    function is_object(x) {
        return typeof x === "object";
    }

    function object_length(x) {
        return Object.keys(x).length;
    }

    function edge(a, b, c) {
        if (a < b) return b;
        if (a > c) return c;
        return a;
    }

    function num(i, j) {
        return parseInt(i, j || 10);
    }

    function round(i) {
        return Math.round(i);
    }

    // [h, s, v] ... 0 <= h, s, v <= 1
    function HSV2RGB(a) {
        var h = +a[0],
            s = +a[1],
            v = +a[2],
            r, g, b, i, f, p, q, t;
        i = Math.floor(h * 6);
        f = h * 6 - i;
        p = v * (1 - s);
        q = v * (1 - f * s);
        t = v * (1 - (1 - f) * s);
        i = i || 0;
        q = q || 0;
        t = t || 0;
        switch (i % 6) {
            case 0:
                r = v, g = t, b = p;
                break;
            case 1:
                r = q, g = v, b = p;
                break;
            case 2:
                r = p, g = v, b = t;
                break;
            case 3:
                r = p, g = q, b = v;
                break;
            case 4:
                r = t, g = p, b = v;
                break;
            case 5:
                r = v, g = p, b = q;
                break;
        }
        return [round(r * 255), round(g * 255), round(b * 255)];
    }

    function HSV2HEX(a) {
        return RGB2HEX(HSV2RGB(a));
    }

    // [r, g, b] ... 0 <= r, g, b <= 255
    function RGB2HSV(a) {
        var r = +a[0],
            g = +a[1],
            b = +a[2],
            max = Math.max(r, g, b),
            min = Math.min(r, g, b),
            d = max - min,
            h, s = (max === 0 ? 0 : d / max),
            v = max / 255;
        switch (max) {
            case min:
                h = 0;
                break;
            case r:
                h = (g - b) + d * (g < b ? 6 : 0);
                h /= 6 * d;
                break;
            case g:
                h = (b - r) + d * 2;
                h /= 6 * d;
                break;
            case b:
                h = (r - g) + d * 4;
                h /= 6 * d;
                break;
        }
        return [h, s, v];
    }

    function RGB2HEX(a) {
        var s = +a[2] | (+a[1] << 8) | (+a[0] << 16);
        s = '000000' + s.toString(16);
        return s.slice(-6);
    }

    // rrggbb or rgb
    function HEX2HSV(s) {
        return RGB2HSV(HEX2RGB(s));
    }

    function HEX2RGB(s) {
        if (s.length === 3) {
            s = s.replace(/./g, '$&$&');
        }
        return [num(s[0] + s[1], 16), num(s[2] + s[3], 16), num(s[4] + s[5], 16)];
    }

    // convert range from `0` to `360` and `0` to `100` in color into range from `0` to `1`
    function _2HSV_pri(a) {
        return [+a[0] / 360, +a[1] / 100, +a[2] / 100];
    }

    // convert range from `0` to `1` into `0` to `360` and `0` to `100` in color
    function _2HSV_pub(a) {
        return [round(+a[0] * 360), round(+a[1] * 100), round(+a[2] * 100)];
    }

    // convert range from `0` to `255` in color into range from `0` to `1`
    function _2RGB_pri(a) {
        return [+a[0] / 255, +a[1] / 255, +a[2] / 255];
    }

    // *
    function parse(x) {
        if (is_object(x)) return x;
        var rgb = /\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)\s*$/i.exec(x),
            hsv = /\s*hsv\s*\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)\s*$/i.exec(x),
            hex = x[0] === '#' && x.match(/^#([\da-f]{3}|[\da-f]{6})$/i);
        if (hex) {
            return HEX2HSV(x.slice(1));
        } else if (hsv) {
            return _2HSV_pri([+hsv[1], +hsv[2], +hsv[3]]);
        } else if (rgb) {
            return RGB2HSV([+rgb[1], +rgb[2], +rgb[3]]);
        }
        return [0, 1, 1]; // default is red
    }

    (function($) {

        // plugin version
        $.version = '1.3.9';

        // collect all instance(s)
        $[instance] = {};

        // plug to all instance(s)
        $.each = function(fn, t) {
            return delay(function() {
                var ins = $[instance], i;
                for (i in ins) {
                    fn(ins[i], i, ins);
                }
            }, t === 0 ? 0 : (t || 1)), $;
        };

        // static method(s)
        $.parse = parse;
        $._HSV2RGB = HSV2RGB;
        $._HSV2HEX = HSV2HEX;
        $._RGB2HSV = RGB2HSV;
        $._HEX2HSV = HEX2HSV;
        $._HEX2RGB = function(a) {
            return _2RGB_pri(HEX2RGB(a));
        };
        $.HSV2RGB = function(a) {
            return HSV2RGB(_2HSV_pri(a));
        };
        $.HSV2HEX = function(a) {
            return HSV2HEX(_2HSV_pri(a));
        };
        $.RGB2HSV = function(a) {
            return _2HSV_pub(RGB2HSV(a));
        };
        $.RGB2HEX = RGB2HEX;
        $.HEX2HSV = function(s) {
            return _2HSV_pub(HEX2HSV(s));
        };
        $.HEX2RGB = HEX2RGB;

    })(win[NS] = function(target, events, parent) {

        var b = doc.body,
            h = doc.documentElement,
            $ = this,
            $$ = win[NS],
            _ = false,
            hooks = {},
            picker = doc.createElement('div'),
            on_down = "touchstart mousedown",
            on_move = "touchmove mousemove",
            on_up = "touchend mouseup",
            on_resize = "orientationchange resize";

        // return a new instance if `CP` was called without the `new` operator
        if (!($ instanceof $$)) {
            return new $$(target, events);
        }

        // store color picker instance to `CP.__instance__`
        $$[instance][target.id || target.name || object_length($$[instance])] = $;

        // trigger color picker panel on click by default
        if (!is_set(events) || events === true) {
            events = on_down;
        }

        // add event
        function on(ev, el, fn) {
            ev = ev.split(/\s+/);
            for (var i = 0, ien = ev.length; i < ien; ++i) {
                el.addEventListener(ev[i], fn, false);
            }
        }

        // remove event
        function off(ev, el, fn) {
            ev = ev.split(/\s+/);
            for (var i = 0, ien = ev.length; i < ien; ++i) {
                el.removeEventListener(ev[i], fn);
            }
        }

        // get mouse/finger coordinate
        function point(el, e) {
            var T = 'touches',
                X = 'clientX',
                Y = 'clientY',
                x = !!e[T] ? e[T][0][X] : e[X],
                y = !!e[T] ? e[T][0][Y] : e[Y],
                o = offset(el);
            return {
                x: x - o.l,
                y: y - o.t
            };
        }

        // get position
        function offset(el) {
            var left, top, rect;
            if (el === win) {
                left = win.pageXOffset || h.scrollLeft;
                top = win.pageYOffset || h.scrollTop;
            } else {
                rect = el.getBoundingClientRect();
                left = rect.left;
                top = rect.top;
            }
            return {
                l: left,
                t: top
            };
        }

        // get closest parent
        function closest(a, b) {
            while ((a = a.parentElement) && a !== b);
            return a;
        }

        // prevent default
        function prevent(e) {
            if (e) e.preventDefault();
        }

        // get dimension
        function size(el) {
            return el === win ? {
                w: win.innerWidth,
                h: win.innerHeight
            } : {
                w: el.offsetWidth,
                h: el.offsetHeight
            };
        }

        // get color data
        function get_data(a) {
            return _ || (is_set(a) ? a : false);
        }

        // set color data
        function set_data(a) {
            _ = a;
        }

        // add hook
        function add(ev, fn, id) {
            if (!is_set(ev)) return hooks;
            if (!is_set(fn)) return hooks[ev];
            if (!is_set(hooks[ev])) hooks[ev] = {};
            if (!is_set(id)) id = object_length(hooks[ev]);
            return hooks[ev][id] = fn, $;
        }

        // remove hook
        function remove(ev, id) {
            if (!is_set(ev)) return hooks = {}, $;
            if (!is_set(id)) return hooks[ev] = {}, $;
            return delete hooks[ev][id], $;
        }

        // trigger hook
        function trigger(ev, a, id) {
            if (!is_set(hooks[ev])) return $;
            if (!is_set(id)) {
                for (var i in hooks[ev]) {
                    hooks[ev][i].apply($, a);
                }
            } else {
                if (is_set(hooks[ev][id])) {
                    hooks[ev][id].apply($, a);
                }
            }
            return $;
        }

        // initialize data ...
        set_data($$.parse(target.getAttribute('data-color') || target.value || [0, 1, 1]));

        // generate color picker pane ...
        picker.className = 'color-picker';
        picker.innerHTML = '<div class="color-picker-control"><span class="color-picker-h"><i></i></span><span class="color-picker-sv"><i></i></span></div>';
        var c = picker[first].children,
            HSV = get_data([0, 1, 1]), // default is red
            H = c[0],
            SV = c[1],
            H_point = H[first],
            SV_point = SV[first],
            start_H = 0,
            start_SV = 0,
            drag_H = 0,
            drag_SV = 0,
            left = 0,
            top = 0,
            P_W = 0,
            P_H = 0,
            v = HSV2HEX(HSV),
            set;

        // on update ...
        function trigger_(k, x) {
            if (!k || k === "h") {
                trigger("change:h", x);
            }
            if (!k || k === "sv") {
                trigger("change:sv", x);
            }
            trigger("change", x);
        }

        // is visible?
        function visible() {
            return picker.parentNode;
        }

        // create
        function create(first, bucket) {
            if (!first) {
                (parent || bucket || b).appendChild(picker), $.visible = true;
            }
            P_W = size(picker).w;
            P_H = size(picker).h;
            var SV_size = size(SV),
                SV_point_size = size(SV_point),
                H_H = size(H).h,
                SV_W = SV_size.w,
                SV_H = SV_size.h,
                H_point_H = size(H_point).h,
                SV_point_W = SV_point_size.w,
                SV_point_H = SV_point_size.h;
            if (first) {
                picker.style.left = picker.style.top = '-9999px';
                function click(e) {
                    var t = e.target,
                        is_target = t === target || closest(t, target) === target;
                    if (is_target) {
                        create();
                    } else {
                        $.exit();
                    }
                    trigger(is_target ? "enter" : "exit", [$]);
                }
                if (events !== false) {
                    on(events, target, click);
                }
                $.create = function() {
                    return create(1), trigger("create", [$]), $;
                };
                $.destroy = function() {
                    if (events !== false) {
                        off(events, target, click);
                    }
                    $.exit(), set_data(false);
                    return trigger("destroy", [$]), $;
                };
            } else {
                fit();
            }
            set = function() {
                HSV = get_data(HSV), color();
                H_point.style.top = (H_H - (H_point_H / 2) - (H_H * +HSV[0])) + 'px';
                SV_point.style.right = (SV_W - (SV_point_W / 2) - (SV_W * +HSV[1])) + 'px';
                SV_point.style.top = (SV_H - (SV_point_H / 2) - (SV_H * +HSV[2])) + 'px';
            };
            $.exit = function(e) {
                if (visible()) {
                    visible().removeChild(picker);
                    $.visible = false;
                }
                off(on_down, H, down_H);
                off(on_down, SV, down_SV);
                off(on_move, doc, move);
                off(on_up, doc, stop);
                off(on_resize, win, fit);
                return $;
            };
            function color(e) {
                var a = HSV2RGB(HSV),
                    b = HSV2RGB([HSV[0], 1, 1]);
                SV.style.backgroundColor = 'rgb(' + b.join(',') + ')';
                set_data(HSV);
                prevent(e);
            };
            set();
            function do_H(e) {
                var y = edge(point(H, e).y, 0, H_H);
                HSV[0] = (H_H - y) / H_H;
                H_point.style.top = (y - (H_point_H / 2)) + 'px';
                color(e);
            }
            function do_SV(e) {
                var o = point(SV, e),
                    x = edge(o.x, 0, SV_W),
                    y = edge(o.y, 0, SV_H);
                HSV[1] = 1 - ((SV_W - x) / SV_W);
                HSV[2] = (SV_H - y) / SV_H;
                SV_point.style.right = (SV_W - x - (SV_point_W / 2)) + 'px';
                SV_point.style.top = (y - (SV_point_H / 2)) + 'px';
                color(e);
            }
            function move(e) {
                if (drag_H) {
                    do_H(e), v = HSV2HEX(HSV);
                    if (!start_H) {
                        trigger("drag:h", [v, $]);
                        trigger("drag", [v, $]);
                        trigger_("h", [v, $]);
                    }
                }
                if (drag_SV) {
                    do_SV(e), v = HSV2HEX(HSV);
                    if (!start_SV) {
                        trigger("drag:sv", [v, $]);
                        trigger("drag", [v, $]);
                        trigger_("sv", [v, $]);
                    }
                }
                start_H = 0,
                start_SV = 0;
            }
            function stop(e) {
                var t = e.target,
                    k = drag_H ? "h" : "sv",
                    a = [HSV2HEX(HSV), $],
                    is_target = t === target || closest(t, target) === target,
                    is_picker = t === picker || closest(t, picker) === picker;
                if (!is_target && !is_picker) {
                    // click outside the target or picker element to exit
                    if (visible() && events !== false) $.exit(), trigger("exit", [$]), trigger_(0, a);
                } else {
                    if (is_picker) {
                        trigger("stop:" + k, a);
                        trigger("stop", a);
                        trigger_(k, a);
                    }
                }
                drag_H = 0,
                drag_SV = 0;
            }
            function down_H(e) {
                start_H = 1,
                drag_H = 1,
                move(e), prevent(e);
                trigger("start:h", [v, $]);
                trigger("start", [v, $]);
                trigger_("h", [v, $]);
            }
            function down_SV(e) {
                start_SV = 1,
                drag_SV = 1,
                move(e), prevent(e);
                trigger("start:sv", [v, $]);
                trigger("start", [v, $]);
                trigger_("sv", [v, $]);
            }
            if (!first) {
                on(on_down, H, down_H);
                on(on_down, SV, down_SV);
                on(on_move, doc, move);
                on(on_up, doc, stop);
                on(on_resize, win, fit);
            }
        } create(1);

        delay(function() {
            var a = [HSV2HEX(HSV), $];
            trigger("create", a);
            trigger_(0, a);
        }, 0);

        // fit to window
        $.fit = function(o) {
            var w = size(win),
                y = size(h),
                screen_w = w.w - y.w, // vertical scroll bar
                screen_h = w.h - h.clientHeight, // horizontal scroll bar
                ww = offset(win),
                to = offset(target);
            left = to.l + ww.l;
            top = to.t + ww.t + size(target).h; // drop!
            if (is_object(o)) {
                is_set(o[0]) && (left = o[0]);
                is_set(o[1]) && (top = o[1]);
            } else {
                var min_x = ww.l,
                    min_y = ww.t,
                    max_x = ww.l + w.w - P_W - screen_w,
                    max_y = ww.t + w.h - P_H - screen_h;
                left = edge(left, min_x, max_x) >> 0;
                top = edge(top, min_y, max_y) >> 0;
            }
            picker.style.left = left + 'px';
            picker.style.top = top + 'px';
            return trigger("fit", [$]), $;
        };

        // for event listener ID
        function fit() {
            return $.fit();
        }

        // set hidden color picker data
        $.set = function(a) {
            if (!is_set(a)) return get_data();
            if (is_string(a)) {
                a = $$.parse(a);
            }
            return set_data(a), set(), $;
        };

        // alias for `$.set()`
        $.get = function(a) {
            return get_data(a);
        };

        // register to global ...
        $.target = target;
        $.picker = picker;
        $.visible = false;
        $.on = add;
        $.off = remove;
        $.fire = trigger;
        $.hooks = hooks;
        $.enter = function(bucket) {
            return create(0, bucket);
        };

        // return the global object
        return $;

    });

})(window, document, 'CP');

;/*! jQuery UI - v1.12.1 - 2016-09-14
* http://jqueryui.com
* Includes: widget.js, position.js, data.js, disable-selection.js, effect.js, effects/effect-blind.js, effects/effect-bounce.js, effects/effect-clip.js, effects/effect-drop.js, effects/effect-explode.js, effects/effect-fade.js, effects/effect-fold.js, effects/effect-highlight.js, effects/effect-puff.js, effects/effect-pulsate.js, effects/effect-scale.js, effects/effect-shake.js, effects/effect-size.js, effects/effect-slide.js, effects/effect-transfer.js, focusable.js, form-reset-mixin.js, jquery-1-7.js, keycode.js, labels.js, scroll-parent.js, tabbable.js, unique-id.js, widgets/accordion.js, widgets/autocomplete.js, widgets/button.js, widgets/checkboxradio.js, widgets/controlgroup.js, widgets/datepicker.js, widgets/dialog.js, widgets/draggable.js, widgets/droppable.js, widgets/menu.js, widgets/mouse.js, widgets/progressbar.js, widgets/resizable.js, widgets/selectable.js, widgets/selectmenu.js, widgets/slider.js, widgets/sortable.js, widgets/spinner.js, widgets/tabs.js, widgets/tooltip.js
* Copyright jQuery Foundation and other contributors; Licensed MIT */

(function(t){"function"==typeof define&&define.amd?define(["jquery"],t):t(jQuery)})(function(t){function e(t){for(var e=t.css("visibility");"inherit"===e;)t=t.parent(),e=t.css("visibility");return"hidden"!==e}function i(t){for(var e,i;t.length&&t[0]!==document;){if(e=t.css("position"),("absolute"===e||"relative"===e||"fixed"===e)&&(i=parseInt(t.css("zIndex"),10),!isNaN(i)&&0!==i))return i;t=t.parent()}return 0}function s(){this._curInst=null,this._keyEvent=!1,this._disabledInputs=[],this._datepickerShowing=!1,this._inDialog=!1,this._mainDivId="ui-datepicker-div",this._inlineClass="ui-datepicker-inline",this._appendClass="ui-datepicker-append",this._triggerClass="ui-datepicker-trigger",this._dialogClass="ui-datepicker-dialog",this._disableClass="ui-datepicker-disabled",this._unselectableClass="ui-datepicker-unselectable",this._currentClass="ui-datepicker-current-day",this._dayOverClass="ui-datepicker-days-cell-over",this.regional=[],this.regional[""]={closeText:"Done",prevText:"Prev",nextText:"Next",currentText:"Today",monthNames:["January","February","March","April","May","June","July","August","September","October","November","December"],monthNamesShort:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],dayNames:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],dayNamesShort:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],dayNamesMin:["Su","Mo","Tu","We","Th","Fr","Sa"],weekHeader:"Wk",dateFormat:"mm/dd/yy",firstDay:0,isRTL:!1,showMonthAfterYear:!1,yearSuffix:""},this._defaults={showOn:"focus",showAnim:"fadeIn",showOptions:{},defaultDate:null,appendText:"",buttonText:"...",buttonImage:"",buttonImageOnly:!1,hideIfNoPrevNext:!1,navigationAsDateFormat:!1,gotoCurrent:!1,changeMonth:!1,changeYear:!1,yearRange:"c-10:c+10",showOtherMonths:!1,selectOtherMonths:!1,showWeek:!1,calculateWeek:this.iso8601Week,shortYearCutoff:"+10",minDate:null,maxDate:null,duration:"fast",beforeShowDay:null,beforeShow:null,onSelect:null,onChangeMonthYear:null,onClose:null,numberOfMonths:1,showCurrentAtPos:0,stepMonths:1,stepBigMonths:12,altField:"",altFormat:"",constrainInput:!0,showButtonPanel:!1,autoSize:!1,disabled:!1},t.extend(this._defaults,this.regional[""]),this.regional.en=t.extend(!0,{},this.regional[""]),this.regional["en-US"]=t.extend(!0,{},this.regional.en),this.dpDiv=n(t("<div id='"+this._mainDivId+"' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"))}function n(e){var i="button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";return e.on("mouseout",i,function(){t(this).removeClass("ui-state-hover"),-1!==this.className.indexOf("ui-datepicker-prev")&&t(this).removeClass("ui-datepicker-prev-hover"),-1!==this.className.indexOf("ui-datepicker-next")&&t(this).removeClass("ui-datepicker-next-hover")}).on("mouseover",i,o)}function o(){t.datepicker._isDisabledDatepicker(m.inline?m.dpDiv.parent()[0]:m.input[0])||(t(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover"),t(this).addClass("ui-state-hover"),-1!==this.className.indexOf("ui-datepicker-prev")&&t(this).addClass("ui-datepicker-prev-hover"),-1!==this.className.indexOf("ui-datepicker-next")&&t(this).addClass("ui-datepicker-next-hover"))}function a(e,i){t.extend(e,i);for(var s in i)null==i[s]&&(e[s]=i[s]);return e}function r(t){return function(){var e=this.element.val();t.apply(this,arguments),this._refresh(),e!==this.element.val()&&this._trigger("change")}}t.ui=t.ui||{},t.ui.version="1.12.1";var h=0,l=Array.prototype.slice;t.cleanData=function(e){return function(i){var s,n,o;for(o=0;null!=(n=i[o]);o++)try{s=t._data(n,"events"),s&&s.remove&&t(n).triggerHandler("remove")}catch(a){}e(i)}}(t.cleanData),t.widget=function(e,i,s){var n,o,a,r={},h=e.split(".")[0];e=e.split(".")[1];var l=h+"-"+e;return s||(s=i,i=t.Widget),t.isArray(s)&&(s=t.extend.apply(null,[{}].concat(s))),t.expr[":"][l.toLowerCase()]=function(e){return!!t.data(e,l)},t[h]=t[h]||{},n=t[h][e],o=t[h][e]=function(t,e){return this._createWidget?(arguments.length&&this._createWidget(t,e),void 0):new o(t,e)},t.extend(o,n,{version:s.version,_proto:t.extend({},s),_childConstructors:[]}),a=new i,a.options=t.widget.extend({},a.options),t.each(s,function(e,s){return t.isFunction(s)?(r[e]=function(){function t(){return i.prototype[e].apply(this,arguments)}function n(t){return i.prototype[e].apply(this,t)}return function(){var e,i=this._super,o=this._superApply;return this._super=t,this._superApply=n,e=s.apply(this,arguments),this._super=i,this._superApply=o,e}}(),void 0):(r[e]=s,void 0)}),o.prototype=t.widget.extend(a,{widgetEventPrefix:n?a.widgetEventPrefix||e:e},r,{constructor:o,namespace:h,widgetName:e,widgetFullName:l}),n?(t.each(n._childConstructors,function(e,i){var s=i.prototype;t.widget(s.namespace+"."+s.widgetName,o,i._proto)}),delete n._childConstructors):i._childConstructors.push(o),t.widget.bridge(e,o),o},t.widget.extend=function(e){for(var i,s,n=l.call(arguments,1),o=0,a=n.length;a>o;o++)for(i in n[o])s=n[o][i],n[o].hasOwnProperty(i)&&void 0!==s&&(e[i]=t.isPlainObject(s)?t.isPlainObject(e[i])?t.widget.extend({},e[i],s):t.widget.extend({},s):s);return e},t.widget.bridge=function(e,i){var s=i.prototype.widgetFullName||e;t.fn[e]=function(n){var o="string"==typeof n,a=l.call(arguments,1),r=this;return o?this.length||"instance"!==n?this.each(function(){var i,o=t.data(this,s);return"instance"===n?(r=o,!1):o?t.isFunction(o[n])&&"_"!==n.charAt(0)?(i=o[n].apply(o,a),i!==o&&void 0!==i?(r=i&&i.jquery?r.pushStack(i.get()):i,!1):void 0):t.error("no such method '"+n+"' for "+e+" widget instance"):t.error("cannot call methods on "+e+" prior to initialization; "+"attempted to call method '"+n+"'")}):r=void 0:(a.length&&(n=t.widget.extend.apply(null,[n].concat(a))),this.each(function(){var e=t.data(this,s);e?(e.option(n||{}),e._init&&e._init()):t.data(this,s,new i(n,this))})),r}},t.Widget=function(){},t.Widget._childConstructors=[],t.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",defaultElement:"<div>",options:{classes:{},disabled:!1,create:null},_createWidget:function(e,i){i=t(i||this.defaultElement||this)[0],this.element=t(i),this.uuid=h++,this.eventNamespace="."+this.widgetName+this.uuid,this.bindings=t(),this.hoverable=t(),this.focusable=t(),this.classesElementLookup={},i!==this&&(t.data(i,this.widgetFullName,this),this._on(!0,this.element,{remove:function(t){t.target===i&&this.destroy()}}),this.document=t(i.style?i.ownerDocument:i.document||i),this.window=t(this.document[0].defaultView||this.document[0].parentWindow)),this.options=t.widget.extend({},this.options,this._getCreateOptions(),e),this._create(),this.options.disabled&&this._setOptionDisabled(this.options.disabled),this._trigger("create",null,this._getCreateEventData()),this._init()},_getCreateOptions:function(){return{}},_getCreateEventData:t.noop,_create:t.noop,_init:t.noop,destroy:function(){var e=this;this._destroy(),t.each(this.classesElementLookup,function(t,i){e._removeClass(i,t)}),this.element.off(this.eventNamespace).removeData(this.widgetFullName),this.widget().off(this.eventNamespace).removeAttr("aria-disabled"),this.bindings.off(this.eventNamespace)},_destroy:t.noop,widget:function(){return this.element},option:function(e,i){var s,n,o,a=e;if(0===arguments.length)return t.widget.extend({},this.options);if("string"==typeof e)if(a={},s=e.split("."),e=s.shift(),s.length){for(n=a[e]=t.widget.extend({},this.options[e]),o=0;s.length-1>o;o++)n[s[o]]=n[s[o]]||{},n=n[s[o]];if(e=s.pop(),1===arguments.length)return void 0===n[e]?null:n[e];n[e]=i}else{if(1===arguments.length)return void 0===this.options[e]?null:this.options[e];a[e]=i}return this._setOptions(a),this},_setOptions:function(t){var e;for(e in t)this._setOption(e,t[e]);return this},_setOption:function(t,e){return"classes"===t&&this._setOptionClasses(e),this.options[t]=e,"disabled"===t&&this._setOptionDisabled(e),this},_setOptionClasses:function(e){var i,s,n;for(i in e)n=this.classesElementLookup[i],e[i]!==this.options.classes[i]&&n&&n.length&&(s=t(n.get()),this._removeClass(n,i),s.addClass(this._classes({element:s,keys:i,classes:e,add:!0})))},_setOptionDisabled:function(t){this._toggleClass(this.widget(),this.widgetFullName+"-disabled",null,!!t),t&&(this._removeClass(this.hoverable,null,"ui-state-hover"),this._removeClass(this.focusable,null,"ui-state-focus"))},enable:function(){return this._setOptions({disabled:!1})},disable:function(){return this._setOptions({disabled:!0})},_classes:function(e){function i(i,o){var a,r;for(r=0;i.length>r;r++)a=n.classesElementLookup[i[r]]||t(),a=e.add?t(t.unique(a.get().concat(e.element.get()))):t(a.not(e.element).get()),n.classesElementLookup[i[r]]=a,s.push(i[r]),o&&e.classes[i[r]]&&s.push(e.classes[i[r]])}var s=[],n=this;return e=t.extend({element:this.element,classes:this.options.classes||{}},e),this._on(e.element,{remove:"_untrackClassesElement"}),e.keys&&i(e.keys.match(/\S+/g)||[],!0),e.extra&&i(e.extra.match(/\S+/g)||[]),s.join(" ")},_untrackClassesElement:function(e){var i=this;t.each(i.classesElementLookup,function(s,n){-1!==t.inArray(e.target,n)&&(i.classesElementLookup[s]=t(n.not(e.target).get()))})},_removeClass:function(t,e,i){return this._toggleClass(t,e,i,!1)},_addClass:function(t,e,i){return this._toggleClass(t,e,i,!0)},_toggleClass:function(t,e,i,s){s="boolean"==typeof s?s:i;var n="string"==typeof t||null===t,o={extra:n?e:i,keys:n?t:e,element:n?this.element:t,add:s};return o.element.toggleClass(this._classes(o),s),this},_on:function(e,i,s){var n,o=this;"boolean"!=typeof e&&(s=i,i=e,e=!1),s?(i=n=t(i),this.bindings=this.bindings.add(i)):(s=i,i=this.element,n=this.widget()),t.each(s,function(s,a){function r(){return e||o.options.disabled!==!0&&!t(this).hasClass("ui-state-disabled")?("string"==typeof a?o[a]:a).apply(o,arguments):void 0}"string"!=typeof a&&(r.guid=a.guid=a.guid||r.guid||t.guid++);var h=s.match(/^([\w:-]*)\s*(.*)$/),l=h[1]+o.eventNamespace,c=h[2];c?n.on(l,c,r):i.on(l,r)})},_off:function(e,i){i=(i||"").split(" ").join(this.eventNamespace+" ")+this.eventNamespace,e.off(i).off(i),this.bindings=t(this.bindings.not(e).get()),this.focusable=t(this.focusable.not(e).get()),this.hoverable=t(this.hoverable.not(e).get())},_delay:function(t,e){function i(){return("string"==typeof t?s[t]:t).apply(s,arguments)}var s=this;return setTimeout(i,e||0)},_hoverable:function(e){this.hoverable=this.hoverable.add(e),this._on(e,{mouseenter:function(e){this._addClass(t(e.currentTarget),null,"ui-state-hover")},mouseleave:function(e){this._removeClass(t(e.currentTarget),null,"ui-state-hover")}})},_focusable:function(e){this.focusable=this.focusable.add(e),this._on(e,{focusin:function(e){this._addClass(t(e.currentTarget),null,"ui-state-focus")},focusout:function(e){this._removeClass(t(e.currentTarget),null,"ui-state-focus")}})},_trigger:function(e,i,s){var n,o,a=this.options[e];if(s=s||{},i=t.Event(i),i.type=(e===this.widgetEventPrefix?e:this.widgetEventPrefix+e).toLowerCase(),i.target=this.element[0],o=i.originalEvent)for(n in o)n in i||(i[n]=o[n]);return this.element.trigger(i,s),!(t.isFunction(a)&&a.apply(this.element[0],[i].concat(s))===!1||i.isDefaultPrevented())}},t.each({show:"fadeIn",hide:"fadeOut"},function(e,i){t.Widget.prototype["_"+e]=function(s,n,o){"string"==typeof n&&(n={effect:n});var a,r=n?n===!0||"number"==typeof n?i:n.effect||i:e;n=n||{},"number"==typeof n&&(n={duration:n}),a=!t.isEmptyObject(n),n.complete=o,n.delay&&s.delay(n.delay),a&&t.effects&&t.effects.effect[r]?s[e](n):r!==e&&s[r]?s[r](n.duration,n.easing,o):s.queue(function(i){t(this)[e](),o&&o.call(s[0]),i()})}}),t.widget,function(){function e(t,e,i){return[parseFloat(t[0])*(u.test(t[0])?e/100:1),parseFloat(t[1])*(u.test(t[1])?i/100:1)]}function i(e,i){return parseInt(t.css(e,i),10)||0}function s(e){var i=e[0];return 9===i.nodeType?{width:e.width(),height:e.height(),offset:{top:0,left:0}}:t.isWindow(i)?{width:e.width(),height:e.height(),offset:{top:e.scrollTop(),left:e.scrollLeft()}}:i.preventDefault?{width:0,height:0,offset:{top:i.pageY,left:i.pageX}}:{width:e.outerWidth(),height:e.outerHeight(),offset:e.offset()}}var n,o=Math.max,a=Math.abs,r=/left|center|right/,h=/top|center|bottom/,l=/[\+\-]\d+(\.[\d]+)?%?/,c=/^\w+/,u=/%$/,d=t.fn.position;t.position={scrollbarWidth:function(){if(void 0!==n)return n;var e,i,s=t("<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"),o=s.children()[0];return t("body").append(s),e=o.offsetWidth,s.css("overflow","scroll"),i=o.offsetWidth,e===i&&(i=s[0].clientWidth),s.remove(),n=e-i},getScrollInfo:function(e){var i=e.isWindow||e.isDocument?"":e.element.css("overflow-x"),s=e.isWindow||e.isDocument?"":e.element.css("overflow-y"),n="scroll"===i||"auto"===i&&e.width<e.element[0].scrollWidth,o="scroll"===s||"auto"===s&&e.height<e.element[0].scrollHeight;return{width:o?t.position.scrollbarWidth():0,height:n?t.position.scrollbarWidth():0}},getWithinInfo:function(e){var i=t(e||window),s=t.isWindow(i[0]),n=!!i[0]&&9===i[0].nodeType,o=!s&&!n;return{element:i,isWindow:s,isDocument:n,offset:o?t(e).offset():{left:0,top:0},scrollLeft:i.scrollLeft(),scrollTop:i.scrollTop(),width:i.outerWidth(),height:i.outerHeight()}}},t.fn.position=function(n){if(!n||!n.of)return d.apply(this,arguments);n=t.extend({},n);var u,p,f,g,m,_,v=t(n.of),b=t.position.getWithinInfo(n.within),y=t.position.getScrollInfo(b),w=(n.collision||"flip").split(" "),k={};return _=s(v),v[0].preventDefault&&(n.at="left top"),p=_.width,f=_.height,g=_.offset,m=t.extend({},g),t.each(["my","at"],function(){var t,e,i=(n[this]||"").split(" ");1===i.length&&(i=r.test(i[0])?i.concat(["center"]):h.test(i[0])?["center"].concat(i):["center","center"]),i[0]=r.test(i[0])?i[0]:"center",i[1]=h.test(i[1])?i[1]:"center",t=l.exec(i[0]),e=l.exec(i[1]),k[this]=[t?t[0]:0,e?e[0]:0],n[this]=[c.exec(i[0])[0],c.exec(i[1])[0]]}),1===w.length&&(w[1]=w[0]),"right"===n.at[0]?m.left+=p:"center"===n.at[0]&&(m.left+=p/2),"bottom"===n.at[1]?m.top+=f:"center"===n.at[1]&&(m.top+=f/2),u=e(k.at,p,f),m.left+=u[0],m.top+=u[1],this.each(function(){var s,r,h=t(this),l=h.outerWidth(),c=h.outerHeight(),d=i(this,"marginLeft"),_=i(this,"marginTop"),x=l+d+i(this,"marginRight")+y.width,C=c+_+i(this,"marginBottom")+y.height,D=t.extend({},m),I=e(k.my,h.outerWidth(),h.outerHeight());"right"===n.my[0]?D.left-=l:"center"===n.my[0]&&(D.left-=l/2),"bottom"===n.my[1]?D.top-=c:"center"===n.my[1]&&(D.top-=c/2),D.left+=I[0],D.top+=I[1],s={marginLeft:d,marginTop:_},t.each(["left","top"],function(e,i){t.ui.position[w[e]]&&t.ui.position[w[e]][i](D,{targetWidth:p,targetHeight:f,elemWidth:l,elemHeight:c,collisionPosition:s,collisionWidth:x,collisionHeight:C,offset:[u[0]+I[0],u[1]+I[1]],my:n.my,at:n.at,within:b,elem:h})}),n.using&&(r=function(t){var e=g.left-D.left,i=e+p-l,s=g.top-D.top,r=s+f-c,u={target:{element:v,left:g.left,top:g.top,width:p,height:f},element:{element:h,left:D.left,top:D.top,width:l,height:c},horizontal:0>i?"left":e>0?"right":"center",vertical:0>r?"top":s>0?"bottom":"middle"};l>p&&p>a(e+i)&&(u.horizontal="center"),c>f&&f>a(s+r)&&(u.vertical="middle"),u.important=o(a(e),a(i))>o(a(s),a(r))?"horizontal":"vertical",n.using.call(this,t,u)}),h.offset(t.extend(D,{using:r}))})},t.ui.position={fit:{left:function(t,e){var i,s=e.within,n=s.isWindow?s.scrollLeft:s.offset.left,a=s.width,r=t.left-e.collisionPosition.marginLeft,h=n-r,l=r+e.collisionWidth-a-n;e.collisionWidth>a?h>0&&0>=l?(i=t.left+h+e.collisionWidth-a-n,t.left+=h-i):t.left=l>0&&0>=h?n:h>l?n+a-e.collisionWidth:n:h>0?t.left+=h:l>0?t.left-=l:t.left=o(t.left-r,t.left)},top:function(t,e){var i,s=e.within,n=s.isWindow?s.scrollTop:s.offset.top,a=e.within.height,r=t.top-e.collisionPosition.marginTop,h=n-r,l=r+e.collisionHeight-a-n;e.collisionHeight>a?h>0&&0>=l?(i=t.top+h+e.collisionHeight-a-n,t.top+=h-i):t.top=l>0&&0>=h?n:h>l?n+a-e.collisionHeight:n:h>0?t.top+=h:l>0?t.top-=l:t.top=o(t.top-r,t.top)}},flip:{left:function(t,e){var i,s,n=e.within,o=n.offset.left+n.scrollLeft,r=n.width,h=n.isWindow?n.scrollLeft:n.offset.left,l=t.left-e.collisionPosition.marginLeft,c=l-h,u=l+e.collisionWidth-r-h,d="left"===e.my[0]?-e.elemWidth:"right"===e.my[0]?e.elemWidth:0,p="left"===e.at[0]?e.targetWidth:"right"===e.at[0]?-e.targetWidth:0,f=-2*e.offset[0];0>c?(i=t.left+d+p+f+e.collisionWidth-r-o,(0>i||a(c)>i)&&(t.left+=d+p+f)):u>0&&(s=t.left-e.collisionPosition.marginLeft+d+p+f-h,(s>0||u>a(s))&&(t.left+=d+p+f))},top:function(t,e){var i,s,n=e.within,o=n.offset.top+n.scrollTop,r=n.height,h=n.isWindow?n.scrollTop:n.offset.top,l=t.top-e.collisionPosition.marginTop,c=l-h,u=l+e.collisionHeight-r-h,d="top"===e.my[1],p=d?-e.elemHeight:"bottom"===e.my[1]?e.elemHeight:0,f="top"===e.at[1]?e.targetHeight:"bottom"===e.at[1]?-e.targetHeight:0,g=-2*e.offset[1];0>c?(s=t.top+p+f+g+e.collisionHeight-r-o,(0>s||a(c)>s)&&(t.top+=p+f+g)):u>0&&(i=t.top-e.collisionPosition.marginTop+p+f+g-h,(i>0||u>a(i))&&(t.top+=p+f+g))}},flipfit:{left:function(){t.ui.position.flip.left.apply(this,arguments),t.ui.position.fit.left.apply(this,arguments)},top:function(){t.ui.position.flip.top.apply(this,arguments),t.ui.position.fit.top.apply(this,arguments)}}}}(),t.ui.position,t.extend(t.expr[":"],{data:t.expr.createPseudo?t.expr.createPseudo(function(e){return function(i){return!!t.data(i,e)}}):function(e,i,s){return!!t.data(e,s[3])}}),t.fn.extend({disableSelection:function(){var t="onselectstart"in document.createElement("div")?"selectstart":"mousedown";return function(){return this.on(t+".ui-disableSelection",function(t){t.preventDefault()})}}(),enableSelection:function(){return this.off(".ui-disableSelection")}});var c="ui-effects-",u="ui-effects-style",d="ui-effects-animated",p=t;t.effects={effect:{}},function(t,e){function i(t,e,i){var s=u[e.type]||{};return null==t?i||!e.def?null:e.def:(t=s.floor?~~t:parseFloat(t),isNaN(t)?e.def:s.mod?(t+s.mod)%s.mod:0>t?0:t>s.max?s.max:t)}function s(i){var s=l(),n=s._rgba=[];return i=i.toLowerCase(),f(h,function(t,o){var a,r=o.re.exec(i),h=r&&o.parse(r),l=o.space||"rgba";return h?(a=s[l](h),s[c[l].cache]=a[c[l].cache],n=s._rgba=a._rgba,!1):e}),n.length?("0,0,0,0"===n.join()&&t.extend(n,o.transparent),s):o[i]}function n(t,e,i){return i=(i+1)%1,1>6*i?t+6*(e-t)*i:1>2*i?e:2>3*i?t+6*(e-t)*(2/3-i):t}var o,a="backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",r=/^([\-+])=\s*(\d+\.?\d*)/,h=[{re:/rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,parse:function(t){return[t[1],t[2],t[3],t[4]]}},{re:/rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,parse:function(t){return[2.55*t[1],2.55*t[2],2.55*t[3],t[4]]}},{re:/#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,parse:function(t){return[parseInt(t[1],16),parseInt(t[2],16),parseInt(t[3],16)]}},{re:/#([a-f0-9])([a-f0-9])([a-f0-9])/,parse:function(t){return[parseInt(t[1]+t[1],16),parseInt(t[2]+t[2],16),parseInt(t[3]+t[3],16)]}},{re:/hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,space:"hsla",parse:function(t){return[t[1],t[2]/100,t[3]/100,t[4]]}}],l=t.Color=function(e,i,s,n){return new t.Color.fn.parse(e,i,s,n)},c={rgba:{props:{red:{idx:0,type:"byte"},green:{idx:1,type:"byte"},blue:{idx:2,type:"byte"}}},hsla:{props:{hue:{idx:0,type:"degrees"},saturation:{idx:1,type:"percent"},lightness:{idx:2,type:"percent"}}}},u={"byte":{floor:!0,max:255},percent:{max:1},degrees:{mod:360,floor:!0}},d=l.support={},p=t("<p>")[0],f=t.each;p.style.cssText="background-color:rgba(1,1,1,.5)",d.rgba=p.style.backgroundColor.indexOf("rgba")>-1,f(c,function(t,e){e.cache="_"+t,e.props.alpha={idx:3,type:"percent",def:1}}),l.fn=t.extend(l.prototype,{parse:function(n,a,r,h){if(n===e)return this._rgba=[null,null,null,null],this;(n.jquery||n.nodeType)&&(n=t(n).css(a),a=e);var u=this,d=t.type(n),p=this._rgba=[];return a!==e&&(n=[n,a,r,h],d="array"),"string"===d?this.parse(s(n)||o._default):"array"===d?(f(c.rgba.props,function(t,e){p[e.idx]=i(n[e.idx],e)}),this):"object"===d?(n instanceof l?f(c,function(t,e){n[e.cache]&&(u[e.cache]=n[e.cache].slice())}):f(c,function(e,s){var o=s.cache;f(s.props,function(t,e){if(!u[o]&&s.to){if("alpha"===t||null==n[t])return;u[o]=s.to(u._rgba)}u[o][e.idx]=i(n[t],e,!0)}),u[o]&&0>t.inArray(null,u[o].slice(0,3))&&(u[o][3]=1,s.from&&(u._rgba=s.from(u[o])))}),this):e},is:function(t){var i=l(t),s=!0,n=this;return f(c,function(t,o){var a,r=i[o.cache];return r&&(a=n[o.cache]||o.to&&o.to(n._rgba)||[],f(o.props,function(t,i){return null!=r[i.idx]?s=r[i.idx]===a[i.idx]:e})),s}),s},_space:function(){var t=[],e=this;return f(c,function(i,s){e[s.cache]&&t.push(i)}),t.pop()},transition:function(t,e){var s=l(t),n=s._space(),o=c[n],a=0===this.alpha()?l("transparent"):this,r=a[o.cache]||o.to(a._rgba),h=r.slice();return s=s[o.cache],f(o.props,function(t,n){var o=n.idx,a=r[o],l=s[o],c=u[n.type]||{};null!==l&&(null===a?h[o]=l:(c.mod&&(l-a>c.mod/2?a+=c.mod:a-l>c.mod/2&&(a-=c.mod)),h[o]=i((l-a)*e+a,n)))}),this[n](h)},blend:function(e){if(1===this._rgba[3])return this;var i=this._rgba.slice(),s=i.pop(),n=l(e)._rgba;return l(t.map(i,function(t,e){return(1-s)*n[e]+s*t}))},toRgbaString:function(){var e="rgba(",i=t.map(this._rgba,function(t,e){return null==t?e>2?1:0:t});return 1===i[3]&&(i.pop(),e="rgb("),e+i.join()+")"},toHslaString:function(){var e="hsla(",i=t.map(this.hsla(),function(t,e){return null==t&&(t=e>2?1:0),e&&3>e&&(t=Math.round(100*t)+"%"),t});return 1===i[3]&&(i.pop(),e="hsl("),e+i.join()+")"},toHexString:function(e){var i=this._rgba.slice(),s=i.pop();return e&&i.push(~~(255*s)),"#"+t.map(i,function(t){return t=(t||0).toString(16),1===t.length?"0"+t:t}).join("")},toString:function(){return 0===this._rgba[3]?"transparent":this.toRgbaString()}}),l.fn.parse.prototype=l.fn,c.hsla.to=function(t){if(null==t[0]||null==t[1]||null==t[2])return[null,null,null,t[3]];var e,i,s=t[0]/255,n=t[1]/255,o=t[2]/255,a=t[3],r=Math.max(s,n,o),h=Math.min(s,n,o),l=r-h,c=r+h,u=.5*c;return e=h===r?0:s===r?60*(n-o)/l+360:n===r?60*(o-s)/l+120:60*(s-n)/l+240,i=0===l?0:.5>=u?l/c:l/(2-c),[Math.round(e)%360,i,u,null==a?1:a]},c.hsla.from=function(t){if(null==t[0]||null==t[1]||null==t[2])return[null,null,null,t[3]];var e=t[0]/360,i=t[1],s=t[2],o=t[3],a=.5>=s?s*(1+i):s+i-s*i,r=2*s-a;return[Math.round(255*n(r,a,e+1/3)),Math.round(255*n(r,a,e)),Math.round(255*n(r,a,e-1/3)),o]},f(c,function(s,n){var o=n.props,a=n.cache,h=n.to,c=n.from;l.fn[s]=function(s){if(h&&!this[a]&&(this[a]=h(this._rgba)),s===e)return this[a].slice();var n,r=t.type(s),u="array"===r||"object"===r?s:arguments,d=this[a].slice();return f(o,function(t,e){var s=u["object"===r?t:e.idx];null==s&&(s=d[e.idx]),d[e.idx]=i(s,e)}),c?(n=l(c(d)),n[a]=d,n):l(d)},f(o,function(e,i){l.fn[e]||(l.fn[e]=function(n){var o,a=t.type(n),h="alpha"===e?this._hsla?"hsla":"rgba":s,l=this[h](),c=l[i.idx];return"undefined"===a?c:("function"===a&&(n=n.call(this,c),a=t.type(n)),null==n&&i.empty?this:("string"===a&&(o=r.exec(n),o&&(n=c+parseFloat(o[2])*("+"===o[1]?1:-1))),l[i.idx]=n,this[h](l)))})})}),l.hook=function(e){var i=e.split(" ");f(i,function(e,i){t.cssHooks[i]={set:function(e,n){var o,a,r="";if("transparent"!==n&&("string"!==t.type(n)||(o=s(n)))){if(n=l(o||n),!d.rgba&&1!==n._rgba[3]){for(a="backgroundColor"===i?e.parentNode:e;(""===r||"transparent"===r)&&a&&a.style;)try{r=t.css(a,"backgroundColor"),a=a.parentNode}catch(h){}n=n.blend(r&&"transparent"!==r?r:"_default")}n=n.toRgbaString()}try{e.style[i]=n}catch(h){}}},t.fx.step[i]=function(e){e.colorInit||(e.start=l(e.elem,i),e.end=l(e.end),e.colorInit=!0),t.cssHooks[i].set(e.elem,e.start.transition(e.end,e.pos))}})},l.hook(a),t.cssHooks.borderColor={expand:function(t){var e={};return f(["Top","Right","Bottom","Left"],function(i,s){e["border"+s+"Color"]=t}),e}},o=t.Color.names={aqua:"#00ffff",black:"#000000",blue:"#0000ff",fuchsia:"#ff00ff",gray:"#808080",green:"#008000",lime:"#00ff00",maroon:"#800000",navy:"#000080",olive:"#808000",purple:"#800080",red:"#ff0000",silver:"#c0c0c0",teal:"#008080",white:"#ffffff",yellow:"#ffff00",transparent:[null,null,null,0],_default:"#ffffff"}}(p),function(){function e(e){var i,s,n=e.ownerDocument.defaultView?e.ownerDocument.defaultView.getComputedStyle(e,null):e.currentStyle,o={};if(n&&n.length&&n[0]&&n[n[0]])for(s=n.length;s--;)i=n[s],"string"==typeof n[i]&&(o[t.camelCase(i)]=n[i]);else for(i in n)"string"==typeof n[i]&&(o[i]=n[i]);return o}function i(e,i){var s,o,a={};for(s in i)o=i[s],e[s]!==o&&(n[s]||(t.fx.step[s]||!isNaN(parseFloat(o)))&&(a[s]=o));return a}var s=["add","remove","toggle"],n={border:1,borderBottom:1,borderColor:1,borderLeft:1,borderRight:1,borderTop:1,borderWidth:1,margin:1,padding:1};t.each(["borderLeftStyle","borderRightStyle","borderBottomStyle","borderTopStyle"],function(e,i){t.fx.step[i]=function(t){("none"!==t.end&&!t.setAttr||1===t.pos&&!t.setAttr)&&(p.style(t.elem,i,t.end),t.setAttr=!0)}}),t.fn.addBack||(t.fn.addBack=function(t){return this.add(null==t?this.prevObject:this.prevObject.filter(t))}),t.effects.animateClass=function(n,o,a,r){var h=t.speed(o,a,r);return this.queue(function(){var o,a=t(this),r=a.attr("class")||"",l=h.children?a.find("*").addBack():a;l=l.map(function(){var i=t(this);return{el:i,start:e(this)}}),o=function(){t.each(s,function(t,e){n[e]&&a[e+"Class"](n[e])})},o(),l=l.map(function(){return this.end=e(this.el[0]),this.diff=i(this.start,this.end),this}),a.attr("class",r),l=l.map(function(){var e=this,i=t.Deferred(),s=t.extend({},h,{queue:!1,complete:function(){i.resolve(e)}});return this.el.animate(this.diff,s),i.promise()}),t.when.apply(t,l.get()).done(function(){o(),t.each(arguments,function(){var e=this.el;t.each(this.diff,function(t){e.css(t,"")})}),h.complete.call(a[0])})})},t.fn.extend({addClass:function(e){return function(i,s,n,o){return s?t.effects.animateClass.call(this,{add:i},s,n,o):e.apply(this,arguments)}}(t.fn.addClass),removeClass:function(e){return function(i,s,n,o){return arguments.length>1?t.effects.animateClass.call(this,{remove:i},s,n,o):e.apply(this,arguments)}}(t.fn.removeClass),toggleClass:function(e){return function(i,s,n,o,a){return"boolean"==typeof s||void 0===s?n?t.effects.animateClass.call(this,s?{add:i}:{remove:i},n,o,a):e.apply(this,arguments):t.effects.animateClass.call(this,{toggle:i},s,n,o)}}(t.fn.toggleClass),switchClass:function(e,i,s,n,o){return t.effects.animateClass.call(this,{add:i,remove:e},s,n,o)}})}(),function(){function e(e,i,s,n){return t.isPlainObject(e)&&(i=e,e=e.effect),e={effect:e},null==i&&(i={}),t.isFunction(i)&&(n=i,s=null,i={}),("number"==typeof i||t.fx.speeds[i])&&(n=s,s=i,i={}),t.isFunction(s)&&(n=s,s=null),i&&t.extend(e,i),s=s||i.duration,e.duration=t.fx.off?0:"number"==typeof s?s:s in t.fx.speeds?t.fx.speeds[s]:t.fx.speeds._default,e.complete=n||i.complete,e}function i(e){return!e||"number"==typeof e||t.fx.speeds[e]?!0:"string"!=typeof e||t.effects.effect[e]?t.isFunction(e)?!0:"object"!=typeof e||e.effect?!1:!0:!0}function s(t,e){var i=e.outerWidth(),s=e.outerHeight(),n=/^rect\((-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto)\)$/,o=n.exec(t)||["",0,i,s,0];return{top:parseFloat(o[1])||0,right:"auto"===o[2]?i:parseFloat(o[2]),bottom:"auto"===o[3]?s:parseFloat(o[3]),left:parseFloat(o[4])||0}}t.expr&&t.expr.filters&&t.expr.filters.animated&&(t.expr.filters.animated=function(e){return function(i){return!!t(i).data(d)||e(i)}}(t.expr.filters.animated)),t.uiBackCompat!==!1&&t.extend(t.effects,{save:function(t,e){for(var i=0,s=e.length;s>i;i++)null!==e[i]&&t.data(c+e[i],t[0].style[e[i]])},restore:function(t,e){for(var i,s=0,n=e.length;n>s;s++)null!==e[s]&&(i=t.data(c+e[s]),t.css(e[s],i))},setMode:function(t,e){return"toggle"===e&&(e=t.is(":hidden")?"show":"hide"),e},createWrapper:function(e){if(e.parent().is(".ui-effects-wrapper"))return e.parent();var i={width:e.outerWidth(!0),height:e.outerHeight(!0),"float":e.css("float")},s=t("<div></div>").addClass("ui-effects-wrapper").css({fontSize:"100%",background:"transparent",border:"none",margin:0,padding:0}),n={width:e.width(),height:e.height()},o=document.activeElement;try{o.id}catch(a){o=document.body}return e.wrap(s),(e[0]===o||t.contains(e[0],o))&&t(o).trigger("focus"),s=e.parent(),"static"===e.css("position")?(s.css({position:"relative"}),e.css({position:"relative"})):(t.extend(i,{position:e.css("position"),zIndex:e.css("z-index")}),t.each(["top","left","bottom","right"],function(t,s){i[s]=e.css(s),isNaN(parseInt(i[s],10))&&(i[s]="auto")}),e.css({position:"relative",top:0,left:0,right:"auto",bottom:"auto"})),e.css(n),s.css(i).show()},removeWrapper:function(e){var i=document.activeElement;return e.parent().is(".ui-effects-wrapper")&&(e.parent().replaceWith(e),(e[0]===i||t.contains(e[0],i))&&t(i).trigger("focus")),e}}),t.extend(t.effects,{version:"1.12.1",define:function(e,i,s){return s||(s=i,i="effect"),t.effects.effect[e]=s,t.effects.effect[e].mode=i,s},scaledDimensions:function(t,e,i){if(0===e)return{height:0,width:0,outerHeight:0,outerWidth:0};var s="horizontal"!==i?(e||100)/100:1,n="vertical"!==i?(e||100)/100:1;return{height:t.height()*n,width:t.width()*s,outerHeight:t.outerHeight()*n,outerWidth:t.outerWidth()*s}},clipToBox:function(t){return{width:t.clip.right-t.clip.left,height:t.clip.bottom-t.clip.top,left:t.clip.left,top:t.clip.top}},unshift:function(t,e,i){var s=t.queue();e>1&&s.splice.apply(s,[1,0].concat(s.splice(e,i))),t.dequeue()},saveStyle:function(t){t.data(u,t[0].style.cssText)},restoreStyle:function(t){t[0].style.cssText=t.data(u)||"",t.removeData(u)},mode:function(t,e){var i=t.is(":hidden");return"toggle"===e&&(e=i?"show":"hide"),(i?"hide"===e:"show"===e)&&(e="none"),e},getBaseline:function(t,e){var i,s;switch(t[0]){case"top":i=0;break;case"middle":i=.5;break;case"bottom":i=1;break;default:i=t[0]/e.height}switch(t[1]){case"left":s=0;break;case"center":s=.5;break;case"right":s=1;break;default:s=t[1]/e.width}return{x:s,y:i}},createPlaceholder:function(e){var i,s=e.css("position"),n=e.position();return e.css({marginTop:e.css("marginTop"),marginBottom:e.css("marginBottom"),marginLeft:e.css("marginLeft"),marginRight:e.css("marginRight")}).outerWidth(e.outerWidth()).outerHeight(e.outerHeight()),/^(static|relative)/.test(s)&&(s="absolute",i=t("<"+e[0].nodeName+">").insertAfter(e).css({display:/^(inline|ruby)/.test(e.css("display"))?"inline-block":"block",visibility:"hidden",marginTop:e.css("marginTop"),marginBottom:e.css("marginBottom"),marginLeft:e.css("marginLeft"),marginRight:e.css("marginRight"),"float":e.css("float")}).outerWidth(e.outerWidth()).outerHeight(e.outerHeight()).addClass("ui-effects-placeholder"),e.data(c+"placeholder",i)),e.css({position:s,left:n.left,top:n.top}),i},removePlaceholder:function(t){var e=c+"placeholder",i=t.data(e);i&&(i.remove(),t.removeData(e))},cleanUp:function(e){t.effects.restoreStyle(e),t.effects.removePlaceholder(e)},setTransition:function(e,i,s,n){return n=n||{},t.each(i,function(t,i){var o=e.cssUnit(i);o[0]>0&&(n[i]=o[0]*s+o[1])}),n}}),t.fn.extend({effect:function(){function i(e){function i(){r.removeData(d),t.effects.cleanUp(r),"hide"===s.mode&&r.hide(),a()}function a(){t.isFunction(h)&&h.call(r[0]),t.isFunction(e)&&e()}var r=t(this);s.mode=c.shift(),t.uiBackCompat===!1||o?"none"===s.mode?(r[l](),a()):n.call(r[0],s,i):(r.is(":hidden")?"hide"===l:"show"===l)?(r[l](),a()):n.call(r[0],s,a)}var s=e.apply(this,arguments),n=t.effects.effect[s.effect],o=n.mode,a=s.queue,r=a||"fx",h=s.complete,l=s.mode,c=[],u=function(e){var i=t(this),s=t.effects.mode(i,l)||o;i.data(d,!0),c.push(s),o&&("show"===s||s===o&&"hide"===s)&&i.show(),o&&"none"===s||t.effects.saveStyle(i),t.isFunction(e)&&e()};return t.fx.off||!n?l?this[l](s.duration,h):this.each(function(){h&&h.call(this)}):a===!1?this.each(u).each(i):this.queue(r,u).queue(r,i)},show:function(t){return function(s){if(i(s))return t.apply(this,arguments);var n=e.apply(this,arguments);return n.mode="show",this.effect.call(this,n)
}}(t.fn.show),hide:function(t){return function(s){if(i(s))return t.apply(this,arguments);var n=e.apply(this,arguments);return n.mode="hide",this.effect.call(this,n)}}(t.fn.hide),toggle:function(t){return function(s){if(i(s)||"boolean"==typeof s)return t.apply(this,arguments);var n=e.apply(this,arguments);return n.mode="toggle",this.effect.call(this,n)}}(t.fn.toggle),cssUnit:function(e){var i=this.css(e),s=[];return t.each(["em","px","%","pt"],function(t,e){i.indexOf(e)>0&&(s=[parseFloat(i),e])}),s},cssClip:function(t){return t?this.css("clip","rect("+t.top+"px "+t.right+"px "+t.bottom+"px "+t.left+"px)"):s(this.css("clip"),this)},transfer:function(e,i){var s=t(this),n=t(e.to),o="fixed"===n.css("position"),a=t("body"),r=o?a.scrollTop():0,h=o?a.scrollLeft():0,l=n.offset(),c={top:l.top-r,left:l.left-h,height:n.innerHeight(),width:n.innerWidth()},u=s.offset(),d=t("<div class='ui-effects-transfer'></div>").appendTo("body").addClass(e.className).css({top:u.top-r,left:u.left-h,height:s.innerHeight(),width:s.innerWidth(),position:o?"fixed":"absolute"}).animate(c,e.duration,e.easing,function(){d.remove(),t.isFunction(i)&&i()})}}),t.fx.step.clip=function(e){e.clipInit||(e.start=t(e.elem).cssClip(),"string"==typeof e.end&&(e.end=s(e.end,e.elem)),e.clipInit=!0),t(e.elem).cssClip({top:e.pos*(e.end.top-e.start.top)+e.start.top,right:e.pos*(e.end.right-e.start.right)+e.start.right,bottom:e.pos*(e.end.bottom-e.start.bottom)+e.start.bottom,left:e.pos*(e.end.left-e.start.left)+e.start.left})}}(),function(){var e={};t.each(["Quad","Cubic","Quart","Quint","Expo"],function(t,i){e[i]=function(e){return Math.pow(e,t+2)}}),t.extend(e,{Sine:function(t){return 1-Math.cos(t*Math.PI/2)},Circ:function(t){return 1-Math.sqrt(1-t*t)},Elastic:function(t){return 0===t||1===t?t:-Math.pow(2,8*(t-1))*Math.sin((80*(t-1)-7.5)*Math.PI/15)},Back:function(t){return t*t*(3*t-2)},Bounce:function(t){for(var e,i=4;((e=Math.pow(2,--i))-1)/11>t;);return 1/Math.pow(4,3-i)-7.5625*Math.pow((3*e-2)/22-t,2)}}),t.each(e,function(e,i){t.easing["easeIn"+e]=i,t.easing["easeOut"+e]=function(t){return 1-i(1-t)},t.easing["easeInOut"+e]=function(t){return.5>t?i(2*t)/2:1-i(-2*t+2)/2}})}();var f=t.effects;t.effects.define("blind","hide",function(e,i){var s={up:["bottom","top"],vertical:["bottom","top"],down:["top","bottom"],left:["right","left"],horizontal:["right","left"],right:["left","right"]},n=t(this),o=e.direction||"up",a=n.cssClip(),r={clip:t.extend({},a)},h=t.effects.createPlaceholder(n);r.clip[s[o][0]]=r.clip[s[o][1]],"show"===e.mode&&(n.cssClip(r.clip),h&&h.css(t.effects.clipToBox(r)),r.clip=a),h&&h.animate(t.effects.clipToBox(r),e.duration,e.easing),n.animate(r,{queue:!1,duration:e.duration,easing:e.easing,complete:i})}),t.effects.define("bounce",function(e,i){var s,n,o,a=t(this),r=e.mode,h="hide"===r,l="show"===r,c=e.direction||"up",u=e.distance,d=e.times||5,p=2*d+(l||h?1:0),f=e.duration/p,g=e.easing,m="up"===c||"down"===c?"top":"left",_="up"===c||"left"===c,v=0,b=a.queue().length;for(t.effects.createPlaceholder(a),o=a.css(m),u||(u=a["top"===m?"outerHeight":"outerWidth"]()/3),l&&(n={opacity:1},n[m]=o,a.css("opacity",0).css(m,_?2*-u:2*u).animate(n,f,g)),h&&(u/=Math.pow(2,d-1)),n={},n[m]=o;d>v;v++)s={},s[m]=(_?"-=":"+=")+u,a.animate(s,f,g).animate(n,f,g),u=h?2*u:u/2;h&&(s={opacity:0},s[m]=(_?"-=":"+=")+u,a.animate(s,f,g)),a.queue(i),t.effects.unshift(a,b,p+1)}),t.effects.define("clip","hide",function(e,i){var s,n={},o=t(this),a=e.direction||"vertical",r="both"===a,h=r||"horizontal"===a,l=r||"vertical"===a;s=o.cssClip(),n.clip={top:l?(s.bottom-s.top)/2:s.top,right:h?(s.right-s.left)/2:s.right,bottom:l?(s.bottom-s.top)/2:s.bottom,left:h?(s.right-s.left)/2:s.left},t.effects.createPlaceholder(o),"show"===e.mode&&(o.cssClip(n.clip),n.clip=s),o.animate(n,{queue:!1,duration:e.duration,easing:e.easing,complete:i})}),t.effects.define("drop","hide",function(e,i){var s,n=t(this),o=e.mode,a="show"===o,r=e.direction||"left",h="up"===r||"down"===r?"top":"left",l="up"===r||"left"===r?"-=":"+=",c="+="===l?"-=":"+=",u={opacity:0};t.effects.createPlaceholder(n),s=e.distance||n["top"===h?"outerHeight":"outerWidth"](!0)/2,u[h]=l+s,a&&(n.css(u),u[h]=c+s,u.opacity=1),n.animate(u,{queue:!1,duration:e.duration,easing:e.easing,complete:i})}),t.effects.define("explode","hide",function(e,i){function s(){b.push(this),b.length===u*d&&n()}function n(){p.css({visibility:"visible"}),t(b).remove(),i()}var o,a,r,h,l,c,u=e.pieces?Math.round(Math.sqrt(e.pieces)):3,d=u,p=t(this),f=e.mode,g="show"===f,m=p.show().css("visibility","hidden").offset(),_=Math.ceil(p.outerWidth()/d),v=Math.ceil(p.outerHeight()/u),b=[];for(o=0;u>o;o++)for(h=m.top+o*v,c=o-(u-1)/2,a=0;d>a;a++)r=m.left+a*_,l=a-(d-1)/2,p.clone().appendTo("body").wrap("<div></div>").css({position:"absolute",visibility:"visible",left:-a*_,top:-o*v}).parent().addClass("ui-effects-explode").css({position:"absolute",overflow:"hidden",width:_,height:v,left:r+(g?l*_:0),top:h+(g?c*v:0),opacity:g?0:1}).animate({left:r+(g?0:l*_),top:h+(g?0:c*v),opacity:g?1:0},e.duration||500,e.easing,s)}),t.effects.define("fade","toggle",function(e,i){var s="show"===e.mode;t(this).css("opacity",s?0:1).animate({opacity:s?1:0},{queue:!1,duration:e.duration,easing:e.easing,complete:i})}),t.effects.define("fold","hide",function(e,i){var s=t(this),n=e.mode,o="show"===n,a="hide"===n,r=e.size||15,h=/([0-9]+)%/.exec(r),l=!!e.horizFirst,c=l?["right","bottom"]:["bottom","right"],u=e.duration/2,d=t.effects.createPlaceholder(s),p=s.cssClip(),f={clip:t.extend({},p)},g={clip:t.extend({},p)},m=[p[c[0]],p[c[1]]],_=s.queue().length;h&&(r=parseInt(h[1],10)/100*m[a?0:1]),f.clip[c[0]]=r,g.clip[c[0]]=r,g.clip[c[1]]=0,o&&(s.cssClip(g.clip),d&&d.css(t.effects.clipToBox(g)),g.clip=p),s.queue(function(i){d&&d.animate(t.effects.clipToBox(f),u,e.easing).animate(t.effects.clipToBox(g),u,e.easing),i()}).animate(f,u,e.easing).animate(g,u,e.easing).queue(i),t.effects.unshift(s,_,4)}),t.effects.define("highlight","show",function(e,i){var s=t(this),n={backgroundColor:s.css("backgroundColor")};"hide"===e.mode&&(n.opacity=0),t.effects.saveStyle(s),s.css({backgroundImage:"none",backgroundColor:e.color||"#ffff99"}).animate(n,{queue:!1,duration:e.duration,easing:e.easing,complete:i})}),t.effects.define("size",function(e,i){var s,n,o,a=t(this),r=["fontSize"],h=["borderTopWidth","borderBottomWidth","paddingTop","paddingBottom"],l=["borderLeftWidth","borderRightWidth","paddingLeft","paddingRight"],c=e.mode,u="effect"!==c,d=e.scale||"both",p=e.origin||["middle","center"],f=a.css("position"),g=a.position(),m=t.effects.scaledDimensions(a),_=e.from||m,v=e.to||t.effects.scaledDimensions(a,0);t.effects.createPlaceholder(a),"show"===c&&(o=_,_=v,v=o),n={from:{y:_.height/m.height,x:_.width/m.width},to:{y:v.height/m.height,x:v.width/m.width}},("box"===d||"both"===d)&&(n.from.y!==n.to.y&&(_=t.effects.setTransition(a,h,n.from.y,_),v=t.effects.setTransition(a,h,n.to.y,v)),n.from.x!==n.to.x&&(_=t.effects.setTransition(a,l,n.from.x,_),v=t.effects.setTransition(a,l,n.to.x,v))),("content"===d||"both"===d)&&n.from.y!==n.to.y&&(_=t.effects.setTransition(a,r,n.from.y,_),v=t.effects.setTransition(a,r,n.to.y,v)),p&&(s=t.effects.getBaseline(p,m),_.top=(m.outerHeight-_.outerHeight)*s.y+g.top,_.left=(m.outerWidth-_.outerWidth)*s.x+g.left,v.top=(m.outerHeight-v.outerHeight)*s.y+g.top,v.left=(m.outerWidth-v.outerWidth)*s.x+g.left),a.css(_),("content"===d||"both"===d)&&(h=h.concat(["marginTop","marginBottom"]).concat(r),l=l.concat(["marginLeft","marginRight"]),a.find("*[width]").each(function(){var i=t(this),s=t.effects.scaledDimensions(i),o={height:s.height*n.from.y,width:s.width*n.from.x,outerHeight:s.outerHeight*n.from.y,outerWidth:s.outerWidth*n.from.x},a={height:s.height*n.to.y,width:s.width*n.to.x,outerHeight:s.height*n.to.y,outerWidth:s.width*n.to.x};n.from.y!==n.to.y&&(o=t.effects.setTransition(i,h,n.from.y,o),a=t.effects.setTransition(i,h,n.to.y,a)),n.from.x!==n.to.x&&(o=t.effects.setTransition(i,l,n.from.x,o),a=t.effects.setTransition(i,l,n.to.x,a)),u&&t.effects.saveStyle(i),i.css(o),i.animate(a,e.duration,e.easing,function(){u&&t.effects.restoreStyle(i)})})),a.animate(v,{queue:!1,duration:e.duration,easing:e.easing,complete:function(){var e=a.offset();0===v.opacity&&a.css("opacity",_.opacity),u||(a.css("position","static"===f?"relative":f).offset(e),t.effects.saveStyle(a)),i()}})}),t.effects.define("scale",function(e,i){var s=t(this),n=e.mode,o=parseInt(e.percent,10)||(0===parseInt(e.percent,10)?0:"effect"!==n?0:100),a=t.extend(!0,{from:t.effects.scaledDimensions(s),to:t.effects.scaledDimensions(s,o,e.direction||"both"),origin:e.origin||["middle","center"]},e);e.fade&&(a.from.opacity=1,a.to.opacity=0),t.effects.effect.size.call(this,a,i)}),t.effects.define("puff","hide",function(e,i){var s=t.extend(!0,{},e,{fade:!0,percent:parseInt(e.percent,10)||150});t.effects.effect.scale.call(this,s,i)}),t.effects.define("pulsate","show",function(e,i){var s=t(this),n=e.mode,o="show"===n,a="hide"===n,r=o||a,h=2*(e.times||5)+(r?1:0),l=e.duration/h,c=0,u=1,d=s.queue().length;for((o||!s.is(":visible"))&&(s.css("opacity",0).show(),c=1);h>u;u++)s.animate({opacity:c},l,e.easing),c=1-c;s.animate({opacity:c},l,e.easing),s.queue(i),t.effects.unshift(s,d,h+1)}),t.effects.define("shake",function(e,i){var s=1,n=t(this),o=e.direction||"left",a=e.distance||20,r=e.times||3,h=2*r+1,l=Math.round(e.duration/h),c="up"===o||"down"===o?"top":"left",u="up"===o||"left"===o,d={},p={},f={},g=n.queue().length;for(t.effects.createPlaceholder(n),d[c]=(u?"-=":"+=")+a,p[c]=(u?"+=":"-=")+2*a,f[c]=(u?"-=":"+=")+2*a,n.animate(d,l,e.easing);r>s;s++)n.animate(p,l,e.easing).animate(f,l,e.easing);n.animate(p,l,e.easing).animate(d,l/2,e.easing).queue(i),t.effects.unshift(n,g,h+1)}),t.effects.define("slide","show",function(e,i){var s,n,o=t(this),a={up:["bottom","top"],down:["top","bottom"],left:["right","left"],right:["left","right"]},r=e.mode,h=e.direction||"left",l="up"===h||"down"===h?"top":"left",c="up"===h||"left"===h,u=e.distance||o["top"===l?"outerHeight":"outerWidth"](!0),d={};t.effects.createPlaceholder(o),s=o.cssClip(),n=o.position()[l],d[l]=(c?-1:1)*u+n,d.clip=o.cssClip(),d.clip[a[h][1]]=d.clip[a[h][0]],"show"===r&&(o.cssClip(d.clip),o.css(l,d[l]),d.clip=s,d[l]=n),o.animate(d,{queue:!1,duration:e.duration,easing:e.easing,complete:i})});var f;t.uiBackCompat!==!1&&(f=t.effects.define("transfer",function(e,i){t(this).transfer(e,i)})),t.ui.focusable=function(i,s){var n,o,a,r,h,l=i.nodeName.toLowerCase();return"area"===l?(n=i.parentNode,o=n.name,i.href&&o&&"map"===n.nodeName.toLowerCase()?(a=t("img[usemap='#"+o+"']"),a.length>0&&a.is(":visible")):!1):(/^(input|select|textarea|button|object)$/.test(l)?(r=!i.disabled,r&&(h=t(i).closest("fieldset")[0],h&&(r=!h.disabled))):r="a"===l?i.href||s:s,r&&t(i).is(":visible")&&e(t(i)))},t.extend(t.expr[":"],{focusable:function(e){return t.ui.focusable(e,null!=t.attr(e,"tabindex"))}}),t.ui.focusable,t.fn.form=function(){return"string"==typeof this[0].form?this.closest("form"):t(this[0].form)},t.ui.formResetMixin={_formResetHandler:function(){var e=t(this);setTimeout(function(){var i=e.data("ui-form-reset-instances");t.each(i,function(){this.refresh()})})},_bindFormResetHandler:function(){if(this.form=this.element.form(),this.form.length){var t=this.form.data("ui-form-reset-instances")||[];t.length||this.form.on("reset.ui-form-reset",this._formResetHandler),t.push(this),this.form.data("ui-form-reset-instances",t)}},_unbindFormResetHandler:function(){if(this.form.length){var e=this.form.data("ui-form-reset-instances");e.splice(t.inArray(this,e),1),e.length?this.form.data("ui-form-reset-instances",e):this.form.removeData("ui-form-reset-instances").off("reset.ui-form-reset")}}},"1.7"===t.fn.jquery.substring(0,3)&&(t.each(["Width","Height"],function(e,i){function s(e,i,s,o){return t.each(n,function(){i-=parseFloat(t.css(e,"padding"+this))||0,s&&(i-=parseFloat(t.css(e,"border"+this+"Width"))||0),o&&(i-=parseFloat(t.css(e,"margin"+this))||0)}),i}var n="Width"===i?["Left","Right"]:["Top","Bottom"],o=i.toLowerCase(),a={innerWidth:t.fn.innerWidth,innerHeight:t.fn.innerHeight,outerWidth:t.fn.outerWidth,outerHeight:t.fn.outerHeight};t.fn["inner"+i]=function(e){return void 0===e?a["inner"+i].call(this):this.each(function(){t(this).css(o,s(this,e)+"px")})},t.fn["outer"+i]=function(e,n){return"number"!=typeof e?a["outer"+i].call(this,e):this.each(function(){t(this).css(o,s(this,e,!0,n)+"px")})}}),t.fn.addBack=function(t){return this.add(null==t?this.prevObject:this.prevObject.filter(t))}),t.ui.keyCode={BACKSPACE:8,COMMA:188,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,LEFT:37,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SPACE:32,TAB:9,UP:38},t.ui.escapeSelector=function(){var t=/([!"#$%&'()*+,.\/:;<=>?@[\]^`{|}~])/g;return function(e){return e.replace(t,"\\$1")}}(),t.fn.labels=function(){var e,i,s,n,o;return this[0].labels&&this[0].labels.length?this.pushStack(this[0].labels):(n=this.eq(0).parents("label"),s=this.attr("id"),s&&(e=this.eq(0).parents().last(),o=e.add(e.length?e.siblings():this.siblings()),i="label[for='"+t.ui.escapeSelector(s)+"']",n=n.add(o.find(i).addBack(i))),this.pushStack(n))},t.fn.scrollParent=function(e){var i=this.css("position"),s="absolute"===i,n=e?/(auto|scroll|hidden)/:/(auto|scroll)/,o=this.parents().filter(function(){var e=t(this);return s&&"static"===e.css("position")?!1:n.test(e.css("overflow")+e.css("overflow-y")+e.css("overflow-x"))}).eq(0);return"fixed"!==i&&o.length?o:t(this[0].ownerDocument||document)},t.extend(t.expr[":"],{tabbable:function(e){var i=t.attr(e,"tabindex"),s=null!=i;return(!s||i>=0)&&t.ui.focusable(e,s)}}),t.fn.extend({uniqueId:function(){var t=0;return function(){return this.each(function(){this.id||(this.id="ui-id-"+ ++t)})}}(),removeUniqueId:function(){return this.each(function(){/^ui-id-\d+$/.test(this.id)&&t(this).removeAttr("id")})}}),t.widget("ui.accordion",{version:"1.12.1",options:{active:0,animate:{},classes:{"ui-accordion-header":"ui-corner-top","ui-accordion-header-collapsed":"ui-corner-all","ui-accordion-content":"ui-corner-bottom"},collapsible:!1,event:"click",header:"> li > :first-child, > :not(li):even",heightStyle:"auto",icons:{activeHeader:"ui-icon-triangle-1-s",header:"ui-icon-triangle-1-e"},activate:null,beforeActivate:null},hideProps:{borderTopWidth:"hide",borderBottomWidth:"hide",paddingTop:"hide",paddingBottom:"hide",height:"hide"},showProps:{borderTopWidth:"show",borderBottomWidth:"show",paddingTop:"show",paddingBottom:"show",height:"show"},_create:function(){var e=this.options;this.prevShow=this.prevHide=t(),this._addClass("ui-accordion","ui-widget ui-helper-reset"),this.element.attr("role","tablist"),e.collapsible||e.active!==!1&&null!=e.active||(e.active=0),this._processPanels(),0>e.active&&(e.active+=this.headers.length),this._refresh()},_getCreateEventData:function(){return{header:this.active,panel:this.active.length?this.active.next():t()}},_createIcons:function(){var e,i,s=this.options.icons;s&&(e=t("<span>"),this._addClass(e,"ui-accordion-header-icon","ui-icon "+s.header),e.prependTo(this.headers),i=this.active.children(".ui-accordion-header-icon"),this._removeClass(i,s.header)._addClass(i,null,s.activeHeader)._addClass(this.headers,"ui-accordion-icons"))},_destroyIcons:function(){this._removeClass(this.headers,"ui-accordion-icons"),this.headers.children(".ui-accordion-header-icon").remove()},_destroy:function(){var t;this.element.removeAttr("role"),this.headers.removeAttr("role aria-expanded aria-selected aria-controls tabIndex").removeUniqueId(),this._destroyIcons(),t=this.headers.next().css("display","").removeAttr("role aria-hidden aria-labelledby").removeUniqueId(),"content"!==this.options.heightStyle&&t.css("height","")},_setOption:function(t,e){return"active"===t?(this._activate(e),void 0):("event"===t&&(this.options.event&&this._off(this.headers,this.options.event),this._setupEvents(e)),this._super(t,e),"collapsible"!==t||e||this.options.active!==!1||this._activate(0),"icons"===t&&(this._destroyIcons(),e&&this._createIcons()),void 0)},_setOptionDisabled:function(t){this._super(t),this.element.attr("aria-disabled",t),this._toggleClass(null,"ui-state-disabled",!!t),this._toggleClass(this.headers.add(this.headers.next()),null,"ui-state-disabled",!!t)},_keydown:function(e){if(!e.altKey&&!e.ctrlKey){var i=t.ui.keyCode,s=this.headers.length,n=this.headers.index(e.target),o=!1;switch(e.keyCode){case i.RIGHT:case i.DOWN:o=this.headers[(n+1)%s];break;case i.LEFT:case i.UP:o=this.headers[(n-1+s)%s];break;case i.SPACE:case i.ENTER:this._eventHandler(e);break;case i.HOME:o=this.headers[0];break;case i.END:o=this.headers[s-1]}o&&(t(e.target).attr("tabIndex",-1),t(o).attr("tabIndex",0),t(o).trigger("focus"),e.preventDefault())}},_panelKeyDown:function(e){e.keyCode===t.ui.keyCode.UP&&e.ctrlKey&&t(e.currentTarget).prev().trigger("focus")},refresh:function(){var e=this.options;this._processPanels(),e.active===!1&&e.collapsible===!0||!this.headers.length?(e.active=!1,this.active=t()):e.active===!1?this._activate(0):this.active.length&&!t.contains(this.element[0],this.active[0])?this.headers.length===this.headers.find(".ui-state-disabled").length?(e.active=!1,this.active=t()):this._activate(Math.max(0,e.active-1)):e.active=this.headers.index(this.active),this._destroyIcons(),this._refresh()},_processPanels:function(){var t=this.headers,e=this.panels;this.headers=this.element.find(this.options.header),this._addClass(this.headers,"ui-accordion-header ui-accordion-header-collapsed","ui-state-default"),this.panels=this.headers.next().filter(":not(.ui-accordion-content-active)").hide(),this._addClass(this.panels,"ui-accordion-content","ui-helper-reset ui-widget-content"),e&&(this._off(t.not(this.headers)),this._off(e.not(this.panels)))},_refresh:function(){var e,i=this.options,s=i.heightStyle,n=this.element.parent();this.active=this._findActive(i.active),this._addClass(this.active,"ui-accordion-header-active","ui-state-active")._removeClass(this.active,"ui-accordion-header-collapsed"),this._addClass(this.active.next(),"ui-accordion-content-active"),this.active.next().show(),this.headers.attr("role","tab").each(function(){var e=t(this),i=e.uniqueId().attr("id"),s=e.next(),n=s.uniqueId().attr("id");e.attr("aria-controls",n),s.attr("aria-labelledby",i)}).next().attr("role","tabpanel"),this.headers.not(this.active).attr({"aria-selected":"false","aria-expanded":"false",tabIndex:-1}).next().attr({"aria-hidden":"true"}).hide(),this.active.length?this.active.attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0}).next().attr({"aria-hidden":"false"}):this.headers.eq(0).attr("tabIndex",0),this._createIcons(),this._setupEvents(i.event),"fill"===s?(e=n.height(),this.element.siblings(":visible").each(function(){var i=t(this),s=i.css("position");"absolute"!==s&&"fixed"!==s&&(e-=i.outerHeight(!0))}),this.headers.each(function(){e-=t(this).outerHeight(!0)}),this.headers.next().each(function(){t(this).height(Math.max(0,e-t(this).innerHeight()+t(this).height()))}).css("overflow","auto")):"auto"===s&&(e=0,this.headers.next().each(function(){var i=t(this).is(":visible");i||t(this).show(),e=Math.max(e,t(this).css("height","").height()),i||t(this).hide()}).height(e))},_activate:function(e){var i=this._findActive(e)[0];i!==this.active[0]&&(i=i||this.active[0],this._eventHandler({target:i,currentTarget:i,preventDefault:t.noop}))},_findActive:function(e){return"number"==typeof e?this.headers.eq(e):t()},_setupEvents:function(e){var i={keydown:"_keydown"};e&&t.each(e.split(" "),function(t,e){i[e]="_eventHandler"}),this._off(this.headers.add(this.headers.next())),this._on(this.headers,i),this._on(this.headers.next(),{keydown:"_panelKeyDown"}),this._hoverable(this.headers),this._focusable(this.headers)},_eventHandler:function(e){var i,s,n=this.options,o=this.active,a=t(e.currentTarget),r=a[0]===o[0],h=r&&n.collapsible,l=h?t():a.next(),c=o.next(),u={oldHeader:o,oldPanel:c,newHeader:h?t():a,newPanel:l};e.preventDefault(),r&&!n.collapsible||this._trigger("beforeActivate",e,u)===!1||(n.active=h?!1:this.headers.index(a),this.active=r?t():a,this._toggle(u),this._removeClass(o,"ui-accordion-header-active","ui-state-active"),n.icons&&(i=o.children(".ui-accordion-header-icon"),this._removeClass(i,null,n.icons.activeHeader)._addClass(i,null,n.icons.header)),r||(this._removeClass(a,"ui-accordion-header-collapsed")._addClass(a,"ui-accordion-header-active","ui-state-active"),n.icons&&(s=a.children(".ui-accordion-header-icon"),this._removeClass(s,null,n.icons.header)._addClass(s,null,n.icons.activeHeader)),this._addClass(a.next(),"ui-accordion-content-active")))},_toggle:function(e){var i=e.newPanel,s=this.prevShow.length?this.prevShow:e.oldPanel;this.prevShow.add(this.prevHide).stop(!0,!0),this.prevShow=i,this.prevHide=s,this.options.animate?this._animate(i,s,e):(s.hide(),i.show(),this._toggleComplete(e)),s.attr({"aria-hidden":"true"}),s.prev().attr({"aria-selected":"false","aria-expanded":"false"}),i.length&&s.length?s.prev().attr({tabIndex:-1,"aria-expanded":"false"}):i.length&&this.headers.filter(function(){return 0===parseInt(t(this).attr("tabIndex"),10)}).attr("tabIndex",-1),i.attr("aria-hidden","false").prev().attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0})},_animate:function(t,e,i){var s,n,o,a=this,r=0,h=t.css("box-sizing"),l=t.length&&(!e.length||t.index()<e.index()),c=this.options.animate||{},u=l&&c.down||c,d=function(){a._toggleComplete(i)};return"number"==typeof u&&(o=u),"string"==typeof u&&(n=u),n=n||u.easing||c.easing,o=o||u.duration||c.duration,e.length?t.length?(s=t.show().outerHeight(),e.animate(this.hideProps,{duration:o,easing:n,step:function(t,e){e.now=Math.round(t)}}),t.hide().animate(this.showProps,{duration:o,easing:n,complete:d,step:function(t,i){i.now=Math.round(t),"height"!==i.prop?"content-box"===h&&(r+=i.now):"content"!==a.options.heightStyle&&(i.now=Math.round(s-e.outerHeight()-r),r=0)}}),void 0):e.animate(this.hideProps,o,n,d):t.animate(this.showProps,o,n,d)},_toggleComplete:function(t){var e=t.oldPanel,i=e.prev();this._removeClass(e,"ui-accordion-content-active"),this._removeClass(i,"ui-accordion-header-active")._addClass(i,"ui-accordion-header-collapsed"),e.length&&(e.parent()[0].className=e.parent()[0].className),this._trigger("activate",null,t)}}),t.ui.safeActiveElement=function(t){var e;try{e=t.activeElement}catch(i){e=t.body}return e||(e=t.body),e.nodeName||(e=t.body),e},t.widget("ui.menu",{version:"1.12.1",defaultElement:"<ul>",delay:300,options:{icons:{submenu:"ui-icon-caret-1-e"},items:"> *",menus:"ul",position:{my:"left top",at:"right top"},role:"menu",blur:null,focus:null,select:null},_create:function(){this.activeMenu=this.element,this.mouseHandled=!1,this.element.uniqueId().attr({role:this.options.role,tabIndex:0}),this._addClass("ui-menu","ui-widget ui-widget-content"),this._on({"mousedown .ui-menu-item":function(t){t.preventDefault()},"click .ui-menu-item":function(e){var i=t(e.target),s=t(t.ui.safeActiveElement(this.document[0]));!this.mouseHandled&&i.not(".ui-state-disabled").length&&(this.select(e),e.isPropagationStopped()||(this.mouseHandled=!0),i.has(".ui-menu").length?this.expand(e):!this.element.is(":focus")&&s.closest(".ui-menu").length&&(this.element.trigger("focus",[!0]),this.active&&1===this.active.parents(".ui-menu").length&&clearTimeout(this.timer)))},"mouseenter .ui-menu-item":function(e){if(!this.previousFilter){var i=t(e.target).closest(".ui-menu-item"),s=t(e.currentTarget);i[0]===s[0]&&(this._removeClass(s.siblings().children(".ui-state-active"),null,"ui-state-active"),this.focus(e,s))}},mouseleave:"collapseAll","mouseleave .ui-menu":"collapseAll",focus:function(t,e){var i=this.active||this.element.find(this.options.items).eq(0);e||this.focus(t,i)},blur:function(e){this._delay(function(){var i=!t.contains(this.element[0],t.ui.safeActiveElement(this.document[0]));i&&this.collapseAll(e)})},keydown:"_keydown"}),this.refresh(),this._on(this.document,{click:function(t){this._closeOnDocumentClick(t)&&this.collapseAll(t),this.mouseHandled=!1}})},_destroy:function(){var e=this.element.find(".ui-menu-item").removeAttr("role aria-disabled"),i=e.children(".ui-menu-item-wrapper").removeUniqueId().removeAttr("tabIndex role aria-haspopup");this.element.removeAttr("aria-activedescendant").find(".ui-menu").addBack().removeAttr("role aria-labelledby aria-expanded aria-hidden aria-disabled tabIndex").removeUniqueId().show(),i.children().each(function(){var e=t(this);e.data("ui-menu-submenu-caret")&&e.remove()})},_keydown:function(e){var i,s,n,o,a=!0;switch(e.keyCode){case t.ui.keyCode.PAGE_UP:this.previousPage(e);break;case t.ui.keyCode.PAGE_DOWN:this.nextPage(e);break;case t.ui.keyCode.HOME:this._move("first","first",e);break;case t.ui.keyCode.END:this._move("last","last",e);break;case t.ui.keyCode.UP:this.previous(e);break;case t.ui.keyCode.DOWN:this.next(e);break;case t.ui.keyCode.LEFT:this.collapse(e);break;case t.ui.keyCode.RIGHT:this.active&&!this.active.is(".ui-state-disabled")&&this.expand(e);break;case t.ui.keyCode.ENTER:case t.ui.keyCode.SPACE:this._activate(e);break;case t.ui.keyCode.ESCAPE:this.collapse(e);break;default:a=!1,s=this.previousFilter||"",o=!1,n=e.keyCode>=96&&105>=e.keyCode?""+(e.keyCode-96):String.fromCharCode(e.keyCode),clearTimeout(this.filterTimer),n===s?o=!0:n=s+n,i=this._filterMenuItems(n),i=o&&-1!==i.index(this.active.next())?this.active.nextAll(".ui-menu-item"):i,i.length||(n=String.fromCharCode(e.keyCode),i=this._filterMenuItems(n)),i.length?(this.focus(e,i),this.previousFilter=n,this.filterTimer=this._delay(function(){delete this.previousFilter},1e3)):delete this.previousFilter}a&&e.preventDefault()},_activate:function(t){this.active&&!this.active.is(".ui-state-disabled")&&(this.active.children("[aria-haspopup='true']").length?this.expand(t):this.select(t))},refresh:function(){var e,i,s,n,o,a=this,r=this.options.icons.submenu,h=this.element.find(this.options.menus);this._toggleClass("ui-menu-icons",null,!!this.element.find(".ui-icon").length),s=h.filter(":not(.ui-menu)").hide().attr({role:this.options.role,"aria-hidden":"true","aria-expanded":"false"}).each(function(){var e=t(this),i=e.prev(),s=t("<span>").data("ui-menu-submenu-caret",!0);a._addClass(s,"ui-menu-icon","ui-icon "+r),i.attr("aria-haspopup","true").prepend(s),e.attr("aria-labelledby",i.attr("id"))}),this._addClass(s,"ui-menu","ui-widget ui-widget-content ui-front"),e=h.add(this.element),i=e.find(this.options.items),i.not(".ui-menu-item").each(function(){var e=t(this);a._isDivider(e)&&a._addClass(e,"ui-menu-divider","ui-widget-content")}),n=i.not(".ui-menu-item, .ui-menu-divider"),o=n.children().not(".ui-menu").uniqueId().attr({tabIndex:-1,role:this._itemRole()}),this._addClass(n,"ui-menu-item")._addClass(o,"ui-menu-item-wrapper"),i.filter(".ui-state-disabled").attr("aria-disabled","true"),this.active&&!t.contains(this.element[0],this.active[0])&&this.blur()},_itemRole:function(){return{menu:"menuitem",listbox:"option"}[this.options.role]},_setOption:function(t,e){if("icons"===t){var i=this.element.find(".ui-menu-icon");this._removeClass(i,null,this.options.icons.submenu)._addClass(i,null,e.submenu)}this._super(t,e)},_setOptionDisabled:function(t){this._super(t),this.element.attr("aria-disabled",t+""),this._toggleClass(null,"ui-state-disabled",!!t)},focus:function(t,e){var i,s,n;this.blur(t,t&&"focus"===t.type),this._scrollIntoView(e),this.active=e.first(),s=this.active.children(".ui-menu-item-wrapper"),this._addClass(s,null,"ui-state-active"),this.options.role&&this.element.attr("aria-activedescendant",s.attr("id")),n=this.active.parent().closest(".ui-menu-item").children(".ui-menu-item-wrapper"),this._addClass(n,null,"ui-state-active"),t&&"keydown"===t.type?this._close():this.timer=this._delay(function(){this._close()},this.delay),i=e.children(".ui-menu"),i.length&&t&&/^mouse/.test(t.type)&&this._startOpening(i),this.activeMenu=e.parent(),this._trigger("focus",t,{item:e})},_scrollIntoView:function(e){var i,s,n,o,a,r;this._hasScroll()&&(i=parseFloat(t.css(this.activeMenu[0],"borderTopWidth"))||0,s=parseFloat(t.css(this.activeMenu[0],"paddingTop"))||0,n=e.offset().top-this.activeMenu.offset().top-i-s,o=this.activeMenu.scrollTop(),a=this.activeMenu.height(),r=e.outerHeight(),0>n?this.activeMenu.scrollTop(o+n):n+r>a&&this.activeMenu.scrollTop(o+n-a+r))},blur:function(t,e){e||clearTimeout(this.timer),this.active&&(this._removeClass(this.active.children(".ui-menu-item-wrapper"),null,"ui-state-active"),this._trigger("blur",t,{item:this.active}),this.active=null)},_startOpening:function(t){clearTimeout(this.timer),"true"===t.attr("aria-hidden")&&(this.timer=this._delay(function(){this._close(),this._open(t)},this.delay))},_open:function(e){var i=t.extend({of:this.active},this.options.position);clearTimeout(this.timer),this.element.find(".ui-menu").not(e.parents(".ui-menu")).hide().attr("aria-hidden","true"),e.show().removeAttr("aria-hidden").attr("aria-expanded","true").position(i)},collapseAll:function(e,i){clearTimeout(this.timer),this.timer=this._delay(function(){var s=i?this.element:t(e&&e.target).closest(this.element.find(".ui-menu"));s.length||(s=this.element),this._close(s),this.blur(e),this._removeClass(s.find(".ui-state-active"),null,"ui-state-active"),this.activeMenu=s},this.delay)},_close:function(t){t||(t=this.active?this.active.parent():this.element),t.find(".ui-menu").hide().attr("aria-hidden","true").attr("aria-expanded","false")},_closeOnDocumentClick:function(e){return!t(e.target).closest(".ui-menu").length},_isDivider:function(t){return!/[^\-\u2014\u2013\s]/.test(t.text())},collapse:function(t){var e=this.active&&this.active.parent().closest(".ui-menu-item",this.element);e&&e.length&&(this._close(),this.focus(t,e))},expand:function(t){var e=this.active&&this.active.children(".ui-menu ").find(this.options.items).first();e&&e.length&&(this._open(e.parent()),this._delay(function(){this.focus(t,e)}))},next:function(t){this._move("next","first",t)},previous:function(t){this._move("prev","last",t)},isFirstItem:function(){return this.active&&!this.active.prevAll(".ui-menu-item").length},isLastItem:function(){return this.active&&!this.active.nextAll(".ui-menu-item").length},_move:function(t,e,i){var s;this.active&&(s="first"===t||"last"===t?this.active["first"===t?"prevAll":"nextAll"](".ui-menu-item").eq(-1):this.active[t+"All"](".ui-menu-item").eq(0)),s&&s.length&&this.active||(s=this.activeMenu.find(this.options.items)[e]()),this.focus(i,s)},nextPage:function(e){var i,s,n;return this.active?(this.isLastItem()||(this._hasScroll()?(s=this.active.offset().top,n=this.element.height(),this.active.nextAll(".ui-menu-item").each(function(){return i=t(this),0>i.offset().top-s-n}),this.focus(e,i)):this.focus(e,this.activeMenu.find(this.options.items)[this.active?"last":"first"]())),void 0):(this.next(e),void 0)},previousPage:function(e){var i,s,n;return this.active?(this.isFirstItem()||(this._hasScroll()?(s=this.active.offset().top,n=this.element.height(),this.active.prevAll(".ui-menu-item").each(function(){return i=t(this),i.offset().top-s+n>0}),this.focus(e,i)):this.focus(e,this.activeMenu.find(this.options.items).first())),void 0):(this.next(e),void 0)},_hasScroll:function(){return this.element.outerHeight()<this.element.prop("scrollHeight")},select:function(e){this.active=this.active||t(e.target).closest(".ui-menu-item");var i={item:this.active};this.active.has(".ui-menu").length||this.collapseAll(e,!0),this._trigger("select",e,i)},_filterMenuItems:function(e){var i=e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&"),s=RegExp("^"+i,"i");return this.activeMenu.find(this.options.items).filter(".ui-menu-item").filter(function(){return s.test(t.trim(t(this).children(".ui-menu-item-wrapper").text()))})}}),t.widget("ui.autocomplete",{version:"1.12.1",defaultElement:"<input>",options:{appendTo:null,autoFocus:!1,delay:300,minLength:1,position:{my:"left top",at:"left bottom",collision:"none"},source:null,change:null,close:null,focus:null,open:null,response:null,search:null,select:null},requestIndex:0,pending:0,_create:function(){var e,i,s,n=this.element[0].nodeName.toLowerCase(),o="textarea"===n,a="input"===n;
this.isMultiLine=o||!a&&this._isContentEditable(this.element),this.valueMethod=this.element[o||a?"val":"text"],this.isNewMenu=!0,this._addClass("ui-autocomplete-input"),this.element.attr("autocomplete","off"),this._on(this.element,{keydown:function(n){if(this.element.prop("readOnly"))return e=!0,s=!0,i=!0,void 0;e=!1,s=!1,i=!1;var o=t.ui.keyCode;switch(n.keyCode){case o.PAGE_UP:e=!0,this._move("previousPage",n);break;case o.PAGE_DOWN:e=!0,this._move("nextPage",n);break;case o.UP:e=!0,this._keyEvent("previous",n);break;case o.DOWN:e=!0,this._keyEvent("next",n);break;case o.ENTER:this.menu.active&&(e=!0,n.preventDefault(),this.menu.select(n));break;case o.TAB:this.menu.active&&this.menu.select(n);break;case o.ESCAPE:this.menu.element.is(":visible")&&(this.isMultiLine||this._value(this.term),this.close(n),n.preventDefault());break;default:i=!0,this._searchTimeout(n)}},keypress:function(s){if(e)return e=!1,(!this.isMultiLine||this.menu.element.is(":visible"))&&s.preventDefault(),void 0;if(!i){var n=t.ui.keyCode;switch(s.keyCode){case n.PAGE_UP:this._move("previousPage",s);break;case n.PAGE_DOWN:this._move("nextPage",s);break;case n.UP:this._keyEvent("previous",s);break;case n.DOWN:this._keyEvent("next",s)}}},input:function(t){return s?(s=!1,t.preventDefault(),void 0):(this._searchTimeout(t),void 0)},focus:function(){this.selectedItem=null,this.previous=this._value()},blur:function(t){return this.cancelBlur?(delete this.cancelBlur,void 0):(clearTimeout(this.searching),this.close(t),this._change(t),void 0)}}),this._initSource(),this.menu=t("<ul>").appendTo(this._appendTo()).menu({role:null}).hide().menu("instance"),this._addClass(this.menu.element,"ui-autocomplete","ui-front"),this._on(this.menu.element,{mousedown:function(e){e.preventDefault(),this.cancelBlur=!0,this._delay(function(){delete this.cancelBlur,this.element[0]!==t.ui.safeActiveElement(this.document[0])&&this.element.trigger("focus")})},menufocus:function(e,i){var s,n;return this.isNewMenu&&(this.isNewMenu=!1,e.originalEvent&&/^mouse/.test(e.originalEvent.type))?(this.menu.blur(),this.document.one("mousemove",function(){t(e.target).trigger(e.originalEvent)}),void 0):(n=i.item.data("ui-autocomplete-item"),!1!==this._trigger("focus",e,{item:n})&&e.originalEvent&&/^key/.test(e.originalEvent.type)&&this._value(n.value),s=i.item.attr("aria-label")||n.value,s&&t.trim(s).length&&(this.liveRegion.children().hide(),t("<div>").text(s).appendTo(this.liveRegion)),void 0)},menuselect:function(e,i){var s=i.item.data("ui-autocomplete-item"),n=this.previous;this.element[0]!==t.ui.safeActiveElement(this.document[0])&&(this.element.trigger("focus"),this.previous=n,this._delay(function(){this.previous=n,this.selectedItem=s})),!1!==this._trigger("select",e,{item:s})&&this._value(s.value),this.term=this._value(),this.close(e),this.selectedItem=s}}),this.liveRegion=t("<div>",{role:"status","aria-live":"assertive","aria-relevant":"additions"}).appendTo(this.document[0].body),this._addClass(this.liveRegion,null,"ui-helper-hidden-accessible"),this._on(this.window,{beforeunload:function(){this.element.removeAttr("autocomplete")}})},_destroy:function(){clearTimeout(this.searching),this.element.removeAttr("autocomplete"),this.menu.element.remove(),this.liveRegion.remove()},_setOption:function(t,e){this._super(t,e),"source"===t&&this._initSource(),"appendTo"===t&&this.menu.element.appendTo(this._appendTo()),"disabled"===t&&e&&this.xhr&&this.xhr.abort()},_isEventTargetInWidget:function(e){var i=this.menu.element[0];return e.target===this.element[0]||e.target===i||t.contains(i,e.target)},_closeOnClickOutside:function(t){this._isEventTargetInWidget(t)||this.close()},_appendTo:function(){var e=this.options.appendTo;return e&&(e=e.jquery||e.nodeType?t(e):this.document.find(e).eq(0)),e&&e[0]||(e=this.element.closest(".ui-front, dialog")),e.length||(e=this.document[0].body),e},_initSource:function(){var e,i,s=this;t.isArray(this.options.source)?(e=this.options.source,this.source=function(i,s){s(t.ui.autocomplete.filter(e,i.term))}):"string"==typeof this.options.source?(i=this.options.source,this.source=function(e,n){s.xhr&&s.xhr.abort(),s.xhr=t.ajax({url:i,data:e,dataType:"json",success:function(t){n(t)},error:function(){n([])}})}):this.source=this.options.source},_searchTimeout:function(t){clearTimeout(this.searching),this.searching=this._delay(function(){var e=this.term===this._value(),i=this.menu.element.is(":visible"),s=t.altKey||t.ctrlKey||t.metaKey||t.shiftKey;(!e||e&&!i&&!s)&&(this.selectedItem=null,this.search(null,t))},this.options.delay)},search:function(t,e){return t=null!=t?t:this._value(),this.term=this._value(),t.length<this.options.minLength?this.close(e):this._trigger("search",e)!==!1?this._search(t):void 0},_search:function(t){this.pending++,this._addClass("ui-autocomplete-loading"),this.cancelSearch=!1,this.source({term:t},this._response())},_response:function(){var e=++this.requestIndex;return t.proxy(function(t){e===this.requestIndex&&this.__response(t),this.pending--,this.pending||this._removeClass("ui-autocomplete-loading")},this)},__response:function(t){t&&(t=this._normalize(t)),this._trigger("response",null,{content:t}),!this.options.disabled&&t&&t.length&&!this.cancelSearch?(this._suggest(t),this._trigger("open")):this._close()},close:function(t){this.cancelSearch=!0,this._close(t)},_close:function(t){this._off(this.document,"mousedown"),this.menu.element.is(":visible")&&(this.menu.element.hide(),this.menu.blur(),this.isNewMenu=!0,this._trigger("close",t))},_change:function(t){this.previous!==this._value()&&this._trigger("change",t,{item:this.selectedItem})},_normalize:function(e){return e.length&&e[0].label&&e[0].value?e:t.map(e,function(e){return"string"==typeof e?{label:e,value:e}:t.extend({},e,{label:e.label||e.value,value:e.value||e.label})})},_suggest:function(e){var i=this.menu.element.empty();this._renderMenu(i,e),this.isNewMenu=!0,this.menu.refresh(),i.show(),this._resizeMenu(),i.position(t.extend({of:this.element},this.options.position)),this.options.autoFocus&&this.menu.next(),this._on(this.document,{mousedown:"_closeOnClickOutside"})},_resizeMenu:function(){var t=this.menu.element;t.outerWidth(Math.max(t.width("").outerWidth()+1,this.element.outerWidth()))},_renderMenu:function(e,i){var s=this;t.each(i,function(t,i){s._renderItemData(e,i)})},_renderItemData:function(t,e){return this._renderItem(t,e).data("ui-autocomplete-item",e)},_renderItem:function(e,i){return t("<li>").append(t("<div>").text(i.label)).appendTo(e)},_move:function(t,e){return this.menu.element.is(":visible")?this.menu.isFirstItem()&&/^previous/.test(t)||this.menu.isLastItem()&&/^next/.test(t)?(this.isMultiLine||this._value(this.term),this.menu.blur(),void 0):(this.menu[t](e),void 0):(this.search(null,e),void 0)},widget:function(){return this.menu.element},_value:function(){return this.valueMethod.apply(this.element,arguments)},_keyEvent:function(t,e){(!this.isMultiLine||this.menu.element.is(":visible"))&&(this._move(t,e),e.preventDefault())},_isContentEditable:function(t){if(!t.length)return!1;var e=t.prop("contentEditable");return"inherit"===e?this._isContentEditable(t.parent()):"true"===e}}),t.extend(t.ui.autocomplete,{escapeRegex:function(t){return t.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&")},filter:function(e,i){var s=RegExp(t.ui.autocomplete.escapeRegex(i),"i");return t.grep(e,function(t){return s.test(t.label||t.value||t)})}}),t.widget("ui.autocomplete",t.ui.autocomplete,{options:{messages:{noResults:"No search results.",results:function(t){return t+(t>1?" results are":" result is")+" available, use up and down arrow keys to navigate."}}},__response:function(e){var i;this._superApply(arguments),this.options.disabled||this.cancelSearch||(i=e&&e.length?this.options.messages.results(e.length):this.options.messages.noResults,this.liveRegion.children().hide(),t("<div>").text(i).appendTo(this.liveRegion))}}),t.ui.autocomplete;var g=/ui-corner-([a-z]){2,6}/g;t.widget("ui.controlgroup",{version:"1.12.1",defaultElement:"<div>",options:{direction:"horizontal",disabled:null,onlyVisible:!0,items:{button:"input[type=button], input[type=submit], input[type=reset], button, a",controlgroupLabel:".ui-controlgroup-label",checkboxradio:"input[type='checkbox'], input[type='radio']",selectmenu:"select",spinner:".ui-spinner-input"}},_create:function(){this._enhance()},_enhance:function(){this.element.attr("role","toolbar"),this.refresh()},_destroy:function(){this._callChildMethod("destroy"),this.childWidgets.removeData("ui-controlgroup-data"),this.element.removeAttr("role"),this.options.items.controlgroupLabel&&this.element.find(this.options.items.controlgroupLabel).find(".ui-controlgroup-label-contents").contents().unwrap()},_initWidgets:function(){var e=this,i=[];t.each(this.options.items,function(s,n){var o,a={};return n?"controlgroupLabel"===s?(o=e.element.find(n),o.each(function(){var e=t(this);e.children(".ui-controlgroup-label-contents").length||e.contents().wrapAll("<span class='ui-controlgroup-label-contents'></span>")}),e._addClass(o,null,"ui-widget ui-widget-content ui-state-default"),i=i.concat(o.get()),void 0):(t.fn[s]&&(a=e["_"+s+"Options"]?e["_"+s+"Options"]("middle"):{classes:{}},e.element.find(n).each(function(){var n=t(this),o=n[s]("instance"),r=t.widget.extend({},a);if("button"!==s||!n.parent(".ui-spinner").length){o||(o=n[s]()[s]("instance")),o&&(r.classes=e._resolveClassesValues(r.classes,o)),n[s](r);var h=n[s]("widget");t.data(h[0],"ui-controlgroup-data",o?o:n[s]("instance")),i.push(h[0])}})),void 0):void 0}),this.childWidgets=t(t.unique(i)),this._addClass(this.childWidgets,"ui-controlgroup-item")},_callChildMethod:function(e){this.childWidgets.each(function(){var i=t(this),s=i.data("ui-controlgroup-data");s&&s[e]&&s[e]()})},_updateCornerClass:function(t,e){var i="ui-corner-top ui-corner-bottom ui-corner-left ui-corner-right ui-corner-all",s=this._buildSimpleOptions(e,"label").classes.label;this._removeClass(t,null,i),this._addClass(t,null,s)},_buildSimpleOptions:function(t,e){var i="vertical"===this.options.direction,s={classes:{}};return s.classes[e]={middle:"",first:"ui-corner-"+(i?"top":"left"),last:"ui-corner-"+(i?"bottom":"right"),only:"ui-corner-all"}[t],s},_spinnerOptions:function(t){var e=this._buildSimpleOptions(t,"ui-spinner");return e.classes["ui-spinner-up"]="",e.classes["ui-spinner-down"]="",e},_buttonOptions:function(t){return this._buildSimpleOptions(t,"ui-button")},_checkboxradioOptions:function(t){return this._buildSimpleOptions(t,"ui-checkboxradio-label")},_selectmenuOptions:function(t){var e="vertical"===this.options.direction;return{width:e?"auto":!1,classes:{middle:{"ui-selectmenu-button-open":"","ui-selectmenu-button-closed":""},first:{"ui-selectmenu-button-open":"ui-corner-"+(e?"top":"tl"),"ui-selectmenu-button-closed":"ui-corner-"+(e?"top":"left")},last:{"ui-selectmenu-button-open":e?"":"ui-corner-tr","ui-selectmenu-button-closed":"ui-corner-"+(e?"bottom":"right")},only:{"ui-selectmenu-button-open":"ui-corner-top","ui-selectmenu-button-closed":"ui-corner-all"}}[t]}},_resolveClassesValues:function(e,i){var s={};return t.each(e,function(n){var o=i.options.classes[n]||"";o=t.trim(o.replace(g,"")),s[n]=(o+" "+e[n]).replace(/\s+/g," ")}),s},_setOption:function(t,e){return"direction"===t&&this._removeClass("ui-controlgroup-"+this.options.direction),this._super(t,e),"disabled"===t?(this._callChildMethod(e?"disable":"enable"),void 0):(this.refresh(),void 0)},refresh:function(){var e,i=this;this._addClass("ui-controlgroup ui-controlgroup-"+this.options.direction),"horizontal"===this.options.direction&&this._addClass(null,"ui-helper-clearfix"),this._initWidgets(),e=this.childWidgets,this.options.onlyVisible&&(e=e.filter(":visible")),e.length&&(t.each(["first","last"],function(t,s){var n=e[s]().data("ui-controlgroup-data");if(n&&i["_"+n.widgetName+"Options"]){var o=i["_"+n.widgetName+"Options"](1===e.length?"only":s);o.classes=i._resolveClassesValues(o.classes,n),n.element[n.widgetName](o)}else i._updateCornerClass(e[s](),s)}),this._callChildMethod("refresh"))}}),t.widget("ui.checkboxradio",[t.ui.formResetMixin,{version:"1.12.1",options:{disabled:null,label:null,icon:!0,classes:{"ui-checkboxradio-label":"ui-corner-all","ui-checkboxradio-icon":"ui-corner-all"}},_getCreateOptions:function(){var e,i,s=this,n=this._super()||{};return this._readType(),i=this.element.labels(),this.label=t(i[i.length-1]),this.label.length||t.error("No label found for checkboxradio widget"),this.originalLabel="",this.label.contents().not(this.element[0]).each(function(){s.originalLabel+=3===this.nodeType?t(this).text():this.outerHTML}),this.originalLabel&&(n.label=this.originalLabel),e=this.element[0].disabled,null!=e&&(n.disabled=e),n},_create:function(){var t=this.element[0].checked;this._bindFormResetHandler(),null==this.options.disabled&&(this.options.disabled=this.element[0].disabled),this._setOption("disabled",this.options.disabled),this._addClass("ui-checkboxradio","ui-helper-hidden-accessible"),this._addClass(this.label,"ui-checkboxradio-label","ui-button ui-widget"),"radio"===this.type&&this._addClass(this.label,"ui-checkboxradio-radio-label"),this.options.label&&this.options.label!==this.originalLabel?this._updateLabel():this.originalLabel&&(this.options.label=this.originalLabel),this._enhance(),t&&(this._addClass(this.label,"ui-checkboxradio-checked","ui-state-active"),this.icon&&this._addClass(this.icon,null,"ui-state-hover")),this._on({change:"_toggleClasses",focus:function(){this._addClass(this.label,null,"ui-state-focus ui-visual-focus")},blur:function(){this._removeClass(this.label,null,"ui-state-focus ui-visual-focus")}})},_readType:function(){var e=this.element[0].nodeName.toLowerCase();this.type=this.element[0].type,"input"===e&&/radio|checkbox/.test(this.type)||t.error("Can't create checkboxradio on element.nodeName="+e+" and element.type="+this.type)},_enhance:function(){this._updateIcon(this.element[0].checked)},widget:function(){return this.label},_getRadioGroup:function(){var e,i=this.element[0].name,s="input[name='"+t.ui.escapeSelector(i)+"']";return i?(e=this.form.length?t(this.form[0].elements).filter(s):t(s).filter(function(){return 0===t(this).form().length}),e.not(this.element)):t([])},_toggleClasses:function(){var e=this.element[0].checked;this._toggleClass(this.label,"ui-checkboxradio-checked","ui-state-active",e),this.options.icon&&"checkbox"===this.type&&this._toggleClass(this.icon,null,"ui-icon-check ui-state-checked",e)._toggleClass(this.icon,null,"ui-icon-blank",!e),"radio"===this.type&&this._getRadioGroup().each(function(){var e=t(this).checkboxradio("instance");e&&e._removeClass(e.label,"ui-checkboxradio-checked","ui-state-active")})},_destroy:function(){this._unbindFormResetHandler(),this.icon&&(this.icon.remove(),this.iconSpace.remove())},_setOption:function(t,e){return"label"!==t||e?(this._super(t,e),"disabled"===t?(this._toggleClass(this.label,null,"ui-state-disabled",e),this.element[0].disabled=e,void 0):(this.refresh(),void 0)):void 0},_updateIcon:function(e){var i="ui-icon ui-icon-background ";this.options.icon?(this.icon||(this.icon=t("<span>"),this.iconSpace=t("<span> </span>"),this._addClass(this.iconSpace,"ui-checkboxradio-icon-space")),"checkbox"===this.type?(i+=e?"ui-icon-check ui-state-checked":"ui-icon-blank",this._removeClass(this.icon,null,e?"ui-icon-blank":"ui-icon-check")):i+="ui-icon-blank",this._addClass(this.icon,"ui-checkboxradio-icon",i),e||this._removeClass(this.icon,null,"ui-icon-check ui-state-checked"),this.icon.prependTo(this.label).after(this.iconSpace)):void 0!==this.icon&&(this.icon.remove(),this.iconSpace.remove(),delete this.icon)},_updateLabel:function(){var t=this.label.contents().not(this.element[0]);this.icon&&(t=t.not(this.icon[0])),this.iconSpace&&(t=t.not(this.iconSpace[0])),t.remove(),this.label.append(this.options.label)},refresh:function(){var t=this.element[0].checked,e=this.element[0].disabled;this._updateIcon(t),this._toggleClass(this.label,"ui-checkboxradio-checked","ui-state-active",t),null!==this.options.label&&this._updateLabel(),e!==this.options.disabled&&this._setOptions({disabled:e})}}]),t.ui.checkboxradio,t.widget("ui.button",{version:"1.12.1",defaultElement:"<button>",options:{classes:{"ui-button":"ui-corner-all"},disabled:null,icon:null,iconPosition:"beginning",label:null,showLabel:!0},_getCreateOptions:function(){var t,e=this._super()||{};return this.isInput=this.element.is("input"),t=this.element[0].disabled,null!=t&&(e.disabled=t),this.originalLabel=this.isInput?this.element.val():this.element.html(),this.originalLabel&&(e.label=this.originalLabel),e},_create:function(){!this.option.showLabel&!this.options.icon&&(this.options.showLabel=!0),null==this.options.disabled&&(this.options.disabled=this.element[0].disabled||!1),this.hasTitle=!!this.element.attr("title"),this.options.label&&this.options.label!==this.originalLabel&&(this.isInput?this.element.val(this.options.label):this.element.html(this.options.label)),this._addClass("ui-button","ui-widget"),this._setOption("disabled",this.options.disabled),this._enhance(),this.element.is("a")&&this._on({keyup:function(e){e.keyCode===t.ui.keyCode.SPACE&&(e.preventDefault(),this.element[0].click?this.element[0].click():this.element.trigger("click"))}})},_enhance:function(){this.element.is("button")||this.element.attr("role","button"),this.options.icon&&(this._updateIcon("icon",this.options.icon),this._updateTooltip())},_updateTooltip:function(){this.title=this.element.attr("title"),this.options.showLabel||this.title||this.element.attr("title",this.options.label)},_updateIcon:function(e,i){var s="iconPosition"!==e,n=s?this.options.iconPosition:i,o="top"===n||"bottom"===n;this.icon?s&&this._removeClass(this.icon,null,this.options.icon):(this.icon=t("<span>"),this._addClass(this.icon,"ui-button-icon","ui-icon"),this.options.showLabel||this._addClass("ui-button-icon-only")),s&&this._addClass(this.icon,null,i),this._attachIcon(n),o?(this._addClass(this.icon,null,"ui-widget-icon-block"),this.iconSpace&&this.iconSpace.remove()):(this.iconSpace||(this.iconSpace=t("<span> </span>"),this._addClass(this.iconSpace,"ui-button-icon-space")),this._removeClass(this.icon,null,"ui-wiget-icon-block"),this._attachIconSpace(n))},_destroy:function(){this.element.removeAttr("role"),this.icon&&this.icon.remove(),this.iconSpace&&this.iconSpace.remove(),this.hasTitle||this.element.removeAttr("title")},_attachIconSpace:function(t){this.icon[/^(?:end|bottom)/.test(t)?"before":"after"](this.iconSpace)},_attachIcon:function(t){this.element[/^(?:end|bottom)/.test(t)?"append":"prepend"](this.icon)},_setOptions:function(t){var e=void 0===t.showLabel?this.options.showLabel:t.showLabel,i=void 0===t.icon?this.options.icon:t.icon;e||i||(t.showLabel=!0),this._super(t)},_setOption:function(t,e){"icon"===t&&(e?this._updateIcon(t,e):this.icon&&(this.icon.remove(),this.iconSpace&&this.iconSpace.remove())),"iconPosition"===t&&this._updateIcon(t,e),"showLabel"===t&&(this._toggleClass("ui-button-icon-only",null,!e),this._updateTooltip()),"label"===t&&(this.isInput?this.element.val(e):(this.element.html(e),this.icon&&(this._attachIcon(this.options.iconPosition),this._attachIconSpace(this.options.iconPosition)))),this._super(t,e),"disabled"===t&&(this._toggleClass(null,"ui-state-disabled",e),this.element[0].disabled=e,e&&this.element.blur())},refresh:function(){var t=this.element.is("input, button")?this.element[0].disabled:this.element.hasClass("ui-button-disabled");t!==this.options.disabled&&this._setOptions({disabled:t}),this._updateTooltip()}}),t.uiBackCompat!==!1&&(t.widget("ui.button",t.ui.button,{options:{text:!0,icons:{primary:null,secondary:null}},_create:function(){this.options.showLabel&&!this.options.text&&(this.options.showLabel=this.options.text),!this.options.showLabel&&this.options.text&&(this.options.text=this.options.showLabel),this.options.icon||!this.options.icons.primary&&!this.options.icons.secondary?this.options.icon&&(this.options.icons.primary=this.options.icon):this.options.icons.primary?this.options.icon=this.options.icons.primary:(this.options.icon=this.options.icons.secondary,this.options.iconPosition="end"),this._super()},_setOption:function(t,e){return"text"===t?(this._super("showLabel",e),void 0):("showLabel"===t&&(this.options.text=e),"icon"===t&&(this.options.icons.primary=e),"icons"===t&&(e.primary?(this._super("icon",e.primary),this._super("iconPosition","beginning")):e.secondary&&(this._super("icon",e.secondary),this._super("iconPosition","end"))),this._superApply(arguments),void 0)}}),t.fn.button=function(e){return function(){return!this.length||this.length&&"INPUT"!==this[0].tagName||this.length&&"INPUT"===this[0].tagName&&"checkbox"!==this.attr("type")&&"radio"!==this.attr("type")?e.apply(this,arguments):(t.ui.checkboxradio||t.error("Checkboxradio widget missing"),0===arguments.length?this.checkboxradio({icon:!1}):this.checkboxradio.apply(this,arguments))}}(t.fn.button),t.fn.buttonset=function(){return t.ui.controlgroup||t.error("Controlgroup widget missing"),"option"===arguments[0]&&"items"===arguments[1]&&arguments[2]?this.controlgroup.apply(this,[arguments[0],"items.button",arguments[2]]):"option"===arguments[0]&&"items"===arguments[1]?this.controlgroup.apply(this,[arguments[0],"items.button"]):("object"==typeof arguments[0]&&arguments[0].items&&(arguments[0].items={button:arguments[0].items}),this.controlgroup.apply(this,arguments))}),t.ui.button,t.extend(t.ui,{datepicker:{version:"1.12.1"}});var m;t.extend(s.prototype,{markerClassName:"hasDatepicker",maxRows:4,_widgetDatepicker:function(){return this.dpDiv},setDefaults:function(t){return a(this._defaults,t||{}),this},_attachDatepicker:function(e,i){var s,n,o;s=e.nodeName.toLowerCase(),n="div"===s||"span"===s,e.id||(this.uuid+=1,e.id="dp"+this.uuid),o=this._newInst(t(e),n),o.settings=t.extend({},i||{}),"input"===s?this._connectDatepicker(e,o):n&&this._inlineDatepicker(e,o)},_newInst:function(e,i){var s=e[0].id.replace(/([^A-Za-z0-9_\-])/g,"\\\\$1");return{id:s,input:e,selectedDay:0,selectedMonth:0,selectedYear:0,drawMonth:0,drawYear:0,inline:i,dpDiv:i?n(t("<div class='"+this._inlineClass+" ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")):this.dpDiv}},_connectDatepicker:function(e,i){var s=t(e);i.append=t([]),i.trigger=t([]),s.hasClass(this.markerClassName)||(this._attachments(s,i),s.addClass(this.markerClassName).on("keydown",this._doKeyDown).on("keypress",this._doKeyPress).on("keyup",this._doKeyUp),this._autoSize(i),t.data(e,"datepicker",i),i.settings.disabled&&this._disableDatepicker(e))},_attachments:function(e,i){var s,n,o,a=this._get(i,"appendText"),r=this._get(i,"isRTL");i.append&&i.append.remove(),a&&(i.append=t("<span class='"+this._appendClass+"'>"+a+"</span>"),e[r?"before":"after"](i.append)),e.off("focus",this._showDatepicker),i.trigger&&i.trigger.remove(),s=this._get(i,"showOn"),("focus"===s||"both"===s)&&e.on("focus",this._showDatepicker),("button"===s||"both"===s)&&(n=this._get(i,"buttonText"),o=this._get(i,"buttonImage"),i.trigger=t(this._get(i,"buttonImageOnly")?t("<img/>").addClass(this._triggerClass).attr({src:o,alt:n,title:n}):t("<button type='button'></button>").addClass(this._triggerClass).html(o?t("<img/>").attr({src:o,alt:n,title:n}):n)),e[r?"before":"after"](i.trigger),i.trigger.on("click",function(){return t.datepicker._datepickerShowing&&t.datepicker._lastInput===e[0]?t.datepicker._hideDatepicker():t.datepicker._datepickerShowing&&t.datepicker._lastInput!==e[0]?(t.datepicker._hideDatepicker(),t.datepicker._showDatepicker(e[0])):t.datepicker._showDatepicker(e[0]),!1}))},_autoSize:function(t){if(this._get(t,"autoSize")&&!t.inline){var e,i,s,n,o=new Date(2009,11,20),a=this._get(t,"dateFormat");a.match(/[DM]/)&&(e=function(t){for(i=0,s=0,n=0;t.length>n;n++)t[n].length>i&&(i=t[n].length,s=n);return s},o.setMonth(e(this._get(t,a.match(/MM/)?"monthNames":"monthNamesShort"))),o.setDate(e(this._get(t,a.match(/DD/)?"dayNames":"dayNamesShort"))+20-o.getDay())),t.input.attr("size",this._formatDate(t,o).length)}},_inlineDatepicker:function(e,i){var s=t(e);s.hasClass(this.markerClassName)||(s.addClass(this.markerClassName).append(i.dpDiv),t.data(e,"datepicker",i),this._setDate(i,this._getDefaultDate(i),!0),this._updateDatepicker(i),this._updateAlternate(i),i.settings.disabled&&this._disableDatepicker(e),i.dpDiv.css("display","block"))},_dialogDatepicker:function(e,i,s,n,o){var r,h,l,c,u,d=this._dialogInst;return d||(this.uuid+=1,r="dp"+this.uuid,this._dialogInput=t("<input type='text' id='"+r+"' style='position: absolute; top: -100px; width: 0px;'/>"),this._dialogInput.on("keydown",this._doKeyDown),t("body").append(this._dialogInput),d=this._dialogInst=this._newInst(this._dialogInput,!1),d.settings={},t.data(this._dialogInput[0],"datepicker",d)),a(d.settings,n||{}),i=i&&i.constructor===Date?this._formatDate(d,i):i,this._dialogInput.val(i),this._pos=o?o.length?o:[o.pageX,o.pageY]:null,this._pos||(h=document.documentElement.clientWidth,l=document.documentElement.clientHeight,c=document.documentElement.scrollLeft||document.body.scrollLeft,u=document.documentElement.scrollTop||document.body.scrollTop,this._pos=[h/2-100+c,l/2-150+u]),this._dialogInput.css("left",this._pos[0]+20+"px").css("top",this._pos[1]+"px"),d.settings.onSelect=s,this._inDialog=!0,this.dpDiv.addClass(this._dialogClass),this._showDatepicker(this._dialogInput[0]),t.blockUI&&t.blockUI(this.dpDiv),t.data(this._dialogInput[0],"datepicker",d),this},_destroyDatepicker:function(e){var i,s=t(e),n=t.data(e,"datepicker");s.hasClass(this.markerClassName)&&(i=e.nodeName.toLowerCase(),t.removeData(e,"datepicker"),"input"===i?(n.append.remove(),n.trigger.remove(),s.removeClass(this.markerClassName).off("focus",this._showDatepicker).off("keydown",this._doKeyDown).off("keypress",this._doKeyPress).off("keyup",this._doKeyUp)):("div"===i||"span"===i)&&s.removeClass(this.markerClassName).empty(),m===n&&(m=null))},_enableDatepicker:function(e){var i,s,n=t(e),o=t.data(e,"datepicker");n.hasClass(this.markerClassName)&&(i=e.nodeName.toLowerCase(),"input"===i?(e.disabled=!1,o.trigger.filter("button").each(function(){this.disabled=!1}).end().filter("img").css({opacity:"1.0",cursor:""})):("div"===i||"span"===i)&&(s=n.children("."+this._inlineClass),s.children().removeClass("ui-state-disabled"),s.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled",!1)),this._disabledInputs=t.map(this._disabledInputs,function(t){return t===e?null:t}))},_disableDatepicker:function(e){var i,s,n=t(e),o=t.data(e,"datepicker");n.hasClass(this.markerClassName)&&(i=e.nodeName.toLowerCase(),"input"===i?(e.disabled=!0,o.trigger.filter("button").each(function(){this.disabled=!0}).end().filter("img").css({opacity:"0.5",cursor:"default"})):("div"===i||"span"===i)&&(s=n.children("."+this._inlineClass),s.children().addClass("ui-state-disabled"),s.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled",!0)),this._disabledInputs=t.map(this._disabledInputs,function(t){return t===e?null:t}),this._disabledInputs[this._disabledInputs.length]=e)},_isDisabledDatepicker:function(t){if(!t)return!1;for(var e=0;this._disabledInputs.length>e;e++)if(this._disabledInputs[e]===t)return!0;return!1},_getInst:function(e){try{return t.data(e,"datepicker")}catch(i){throw"Missing instance data for this datepicker"}},_optionDatepicker:function(e,i,s){var n,o,r,h,l=this._getInst(e);return 2===arguments.length&&"string"==typeof i?"defaults"===i?t.extend({},t.datepicker._defaults):l?"all"===i?t.extend({},l.settings):this._get(l,i):null:(n=i||{},"string"==typeof i&&(n={},n[i]=s),l&&(this._curInst===l&&this._hideDatepicker(),o=this._getDateDatepicker(e,!0),r=this._getMinMaxDate(l,"min"),h=this._getMinMaxDate(l,"max"),a(l.settings,n),null!==r&&void 0!==n.dateFormat&&void 0===n.minDate&&(l.settings.minDate=this._formatDate(l,r)),null!==h&&void 0!==n.dateFormat&&void 0===n.maxDate&&(l.settings.maxDate=this._formatDate(l,h)),"disabled"in n&&(n.disabled?this._disableDatepicker(e):this._enableDatepicker(e)),this._attachments(t(e),l),this._autoSize(l),this._setDate(l,o),this._updateAlternate(l),this._updateDatepicker(l)),void 0)},_changeDatepicker:function(t,e,i){this._optionDatepicker(t,e,i)},_refreshDatepicker:function(t){var e=this._getInst(t);e&&this._updateDatepicker(e)},_setDateDatepicker:function(t,e){var i=this._getInst(t);i&&(this._setDate(i,e),this._updateDatepicker(i),this._updateAlternate(i))},_getDateDatepicker:function(t,e){var i=this._getInst(t);return i&&!i.inline&&this._setDateFromField(i,e),i?this._getDate(i):null},_doKeyDown:function(e){var i,s,n,o=t.datepicker._getInst(e.target),a=!0,r=o.dpDiv.is(".ui-datepicker-rtl");if(o._keyEvent=!0,t.datepicker._datepickerShowing)switch(e.keyCode){case 9:t.datepicker._hideDatepicker(),a=!1;break;case 13:return n=t("td."+t.datepicker._dayOverClass+":not(."+t.datepicker._currentClass+")",o.dpDiv),n[0]&&t.datepicker._selectDay(e.target,o.selectedMonth,o.selectedYear,n[0]),i=t.datepicker._get(o,"onSelect"),i?(s=t.datepicker._formatDate(o),i.apply(o.input?o.input[0]:null,[s,o])):t.datepicker._hideDatepicker(),!1;case 27:t.datepicker._hideDatepicker();break;case 33:t.datepicker._adjustDate(e.target,e.ctrlKey?-t.datepicker._get(o,"stepBigMonths"):-t.datepicker._get(o,"stepMonths"),"M");break;case 34:t.datepicker._adjustDate(e.target,e.ctrlKey?+t.datepicker._get(o,"stepBigMonths"):+t.datepicker._get(o,"stepMonths"),"M");break;case 35:(e.ctrlKey||e.metaKey)&&t.datepicker._clearDate(e.target),a=e.ctrlKey||e.metaKey;break;case 36:(e.ctrlKey||e.metaKey)&&t.datepicker._gotoToday(e.target),a=e.ctrlKey||e.metaKey;break;case 37:(e.ctrlKey||e.metaKey)&&t.datepicker._adjustDate(e.target,r?1:-1,"D"),a=e.ctrlKey||e.metaKey,e.originalEvent.altKey&&t.datepicker._adjustDate(e.target,e.ctrlKey?-t.datepicker._get(o,"stepBigMonths"):-t.datepicker._get(o,"stepMonths"),"M");break;case 38:(e.ctrlKey||e.metaKey)&&t.datepicker._adjustDate(e.target,-7,"D"),a=e.ctrlKey||e.metaKey;break;case 39:(e.ctrlKey||e.metaKey)&&t.datepicker._adjustDate(e.target,r?-1:1,"D"),a=e.ctrlKey||e.metaKey,e.originalEvent.altKey&&t.datepicker._adjustDate(e.target,e.ctrlKey?+t.datepicker._get(o,"stepBigMonths"):+t.datepicker._get(o,"stepMonths"),"M");break;case 40:(e.ctrlKey||e.metaKey)&&t.datepicker._adjustDate(e.target,7,"D"),a=e.ctrlKey||e.metaKey;break;default:a=!1}else 36===e.keyCode&&e.ctrlKey?t.datepicker._showDatepicker(this):a=!1;a&&(e.preventDefault(),e.stopPropagation())},_doKeyPress:function(e){var i,s,n=t.datepicker._getInst(e.target);return t.datepicker._get(n,"constrainInput")?(i=t.datepicker._possibleChars(t.datepicker._get(n,"dateFormat")),s=String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),e.ctrlKey||e.metaKey||" ">s||!i||i.indexOf(s)>-1):void 0},_doKeyUp:function(e){var i,s=t.datepicker._getInst(e.target);if(s.input.val()!==s.lastVal)try{i=t.datepicker.parseDate(t.datepicker._get(s,"dateFormat"),s.input?s.input.val():null,t.datepicker._getFormatConfig(s)),i&&(t.datepicker._setDateFromField(s),t.datepicker._updateAlternate(s),t.datepicker._updateDatepicker(s))}catch(n){}return!0},_showDatepicker:function(e){if(e=e.target||e,"input"!==e.nodeName.toLowerCase()&&(e=t("input",e.parentNode)[0]),!t.datepicker._isDisabledDatepicker(e)&&t.datepicker._lastInput!==e){var s,n,o,r,h,l,c;s=t.datepicker._getInst(e),t.datepicker._curInst&&t.datepicker._curInst!==s&&(t.datepicker._curInst.dpDiv.stop(!0,!0),s&&t.datepicker._datepickerShowing&&t.datepicker._hideDatepicker(t.datepicker._curInst.input[0])),n=t.datepicker._get(s,"beforeShow"),o=n?n.apply(e,[e,s]):{},o!==!1&&(a(s.settings,o),s.lastVal=null,t.datepicker._lastInput=e,t.datepicker._setDateFromField(s),t.datepicker._inDialog&&(e.value=""),t.datepicker._pos||(t.datepicker._pos=t.datepicker._findPos(e),t.datepicker._pos[1]+=e.offsetHeight),r=!1,t(e).parents().each(function(){return r|="fixed"===t(this).css("position"),!r}),h={left:t.datepicker._pos[0],top:t.datepicker._pos[1]},t.datepicker._pos=null,s.dpDiv.empty(),s.dpDiv.css({position:"absolute",display:"block",top:"-1000px"}),t.datepicker._updateDatepicker(s),h=t.datepicker._checkOffset(s,h,r),s.dpDiv.css({position:t.datepicker._inDialog&&t.blockUI?"static":r?"fixed":"absolute",display:"none",left:h.left+"px",top:h.top+"px"}),s.inline||(l=t.datepicker._get(s,"showAnim"),c=t.datepicker._get(s,"duration"),s.dpDiv.css("z-index",i(t(e))+1),t.datepicker._datepickerShowing=!0,t.effects&&t.effects.effect[l]?s.dpDiv.show(l,t.datepicker._get(s,"showOptions"),c):s.dpDiv[l||"show"](l?c:null),t.datepicker._shouldFocusInput(s)&&s.input.trigger("focus"),t.datepicker._curInst=s))
}},_updateDatepicker:function(e){this.maxRows=4,m=e,e.dpDiv.empty().append(this._generateHTML(e)),this._attachHandlers(e);var i,s=this._getNumberOfMonths(e),n=s[1],a=17,r=e.dpDiv.find("."+this._dayOverClass+" a");r.length>0&&o.apply(r.get(0)),e.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width(""),n>1&&e.dpDiv.addClass("ui-datepicker-multi-"+n).css("width",a*n+"em"),e.dpDiv[(1!==s[0]||1!==s[1]?"add":"remove")+"Class"]("ui-datepicker-multi"),e.dpDiv[(this._get(e,"isRTL")?"add":"remove")+"Class"]("ui-datepicker-rtl"),e===t.datepicker._curInst&&t.datepicker._datepickerShowing&&t.datepicker._shouldFocusInput(e)&&e.input.trigger("focus"),e.yearshtml&&(i=e.yearshtml,setTimeout(function(){i===e.yearshtml&&e.yearshtml&&e.dpDiv.find("select.ui-datepicker-year:first").replaceWith(e.yearshtml),i=e.yearshtml=null},0))},_shouldFocusInput:function(t){return t.input&&t.input.is(":visible")&&!t.input.is(":disabled")&&!t.input.is(":focus")},_checkOffset:function(e,i,s){var n=e.dpDiv.outerWidth(),o=e.dpDiv.outerHeight(),a=e.input?e.input.outerWidth():0,r=e.input?e.input.outerHeight():0,h=document.documentElement.clientWidth+(s?0:t(document).scrollLeft()),l=document.documentElement.clientHeight+(s?0:t(document).scrollTop());return i.left-=this._get(e,"isRTL")?n-a:0,i.left-=s&&i.left===e.input.offset().left?t(document).scrollLeft():0,i.top-=s&&i.top===e.input.offset().top+r?t(document).scrollTop():0,i.left-=Math.min(i.left,i.left+n>h&&h>n?Math.abs(i.left+n-h):0),i.top-=Math.min(i.top,i.top+o>l&&l>o?Math.abs(o+r):0),i},_findPos:function(e){for(var i,s=this._getInst(e),n=this._get(s,"isRTL");e&&("hidden"===e.type||1!==e.nodeType||t.expr.filters.hidden(e));)e=e[n?"previousSibling":"nextSibling"];return i=t(e).offset(),[i.left,i.top]},_hideDatepicker:function(e){var i,s,n,o,a=this._curInst;!a||e&&a!==t.data(e,"datepicker")||this._datepickerShowing&&(i=this._get(a,"showAnim"),s=this._get(a,"duration"),n=function(){t.datepicker._tidyDialog(a)},t.effects&&(t.effects.effect[i]||t.effects[i])?a.dpDiv.hide(i,t.datepicker._get(a,"showOptions"),s,n):a.dpDiv["slideDown"===i?"slideUp":"fadeIn"===i?"fadeOut":"hide"](i?s:null,n),i||n(),this._datepickerShowing=!1,o=this._get(a,"onClose"),o&&o.apply(a.input?a.input[0]:null,[a.input?a.input.val():"",a]),this._lastInput=null,this._inDialog&&(this._dialogInput.css({position:"absolute",left:"0",top:"-100px"}),t.blockUI&&(t.unblockUI(),t("body").append(this.dpDiv))),this._inDialog=!1)},_tidyDialog:function(t){t.dpDiv.removeClass(this._dialogClass).off(".ui-datepicker-calendar")},_checkExternalClick:function(e){if(t.datepicker._curInst){var i=t(e.target),s=t.datepicker._getInst(i[0]);(i[0].id!==t.datepicker._mainDivId&&0===i.parents("#"+t.datepicker._mainDivId).length&&!i.hasClass(t.datepicker.markerClassName)&&!i.closest("."+t.datepicker._triggerClass).length&&t.datepicker._datepickerShowing&&(!t.datepicker._inDialog||!t.blockUI)||i.hasClass(t.datepicker.markerClassName)&&t.datepicker._curInst!==s)&&t.datepicker._hideDatepicker()}},_adjustDate:function(e,i,s){var n=t(e),o=this._getInst(n[0]);this._isDisabledDatepicker(n[0])||(this._adjustInstDate(o,i+("M"===s?this._get(o,"showCurrentAtPos"):0),s),this._updateDatepicker(o))},_gotoToday:function(e){var i,s=t(e),n=this._getInst(s[0]);this._get(n,"gotoCurrent")&&n.currentDay?(n.selectedDay=n.currentDay,n.drawMonth=n.selectedMonth=n.currentMonth,n.drawYear=n.selectedYear=n.currentYear):(i=new Date,n.selectedDay=i.getDate(),n.drawMonth=n.selectedMonth=i.getMonth(),n.drawYear=n.selectedYear=i.getFullYear()),this._notifyChange(n),this._adjustDate(s)},_selectMonthYear:function(e,i,s){var n=t(e),o=this._getInst(n[0]);o["selected"+("M"===s?"Month":"Year")]=o["draw"+("M"===s?"Month":"Year")]=parseInt(i.options[i.selectedIndex].value,10),this._notifyChange(o),this._adjustDate(n)},_selectDay:function(e,i,s,n){var o,a=t(e);t(n).hasClass(this._unselectableClass)||this._isDisabledDatepicker(a[0])||(o=this._getInst(a[0]),o.selectedDay=o.currentDay=t("a",n).html(),o.selectedMonth=o.currentMonth=i,o.selectedYear=o.currentYear=s,this._selectDate(e,this._formatDate(o,o.currentDay,o.currentMonth,o.currentYear)))},_clearDate:function(e){var i=t(e);this._selectDate(i,"")},_selectDate:function(e,i){var s,n=t(e),o=this._getInst(n[0]);i=null!=i?i:this._formatDate(o),o.input&&o.input.val(i),this._updateAlternate(o),s=this._get(o,"onSelect"),s?s.apply(o.input?o.input[0]:null,[i,o]):o.input&&o.input.trigger("change"),o.inline?this._updateDatepicker(o):(this._hideDatepicker(),this._lastInput=o.input[0],"object"!=typeof o.input[0]&&o.input.trigger("focus"),this._lastInput=null)},_updateAlternate:function(e){var i,s,n,o=this._get(e,"altField");o&&(i=this._get(e,"altFormat")||this._get(e,"dateFormat"),s=this._getDate(e),n=this.formatDate(i,s,this._getFormatConfig(e)),t(o).val(n))},noWeekends:function(t){var e=t.getDay();return[e>0&&6>e,""]},iso8601Week:function(t){var e,i=new Date(t.getTime());return i.setDate(i.getDate()+4-(i.getDay()||7)),e=i.getTime(),i.setMonth(0),i.setDate(1),Math.floor(Math.round((e-i)/864e5)/7)+1},parseDate:function(e,i,s){if(null==e||null==i)throw"Invalid arguments";if(i="object"==typeof i?""+i:i+"",""===i)return null;var n,o,a,r,h=0,l=(s?s.shortYearCutoff:null)||this._defaults.shortYearCutoff,c="string"!=typeof l?l:(new Date).getFullYear()%100+parseInt(l,10),u=(s?s.dayNamesShort:null)||this._defaults.dayNamesShort,d=(s?s.dayNames:null)||this._defaults.dayNames,p=(s?s.monthNamesShort:null)||this._defaults.monthNamesShort,f=(s?s.monthNames:null)||this._defaults.monthNames,g=-1,m=-1,_=-1,v=-1,b=!1,y=function(t){var i=e.length>n+1&&e.charAt(n+1)===t;return i&&n++,i},w=function(t){var e=y(t),s="@"===t?14:"!"===t?20:"y"===t&&e?4:"o"===t?3:2,n="y"===t?s:1,o=RegExp("^\\d{"+n+","+s+"}"),a=i.substring(h).match(o);if(!a)throw"Missing number at position "+h;return h+=a[0].length,parseInt(a[0],10)},k=function(e,s,n){var o=-1,a=t.map(y(e)?n:s,function(t,e){return[[e,t]]}).sort(function(t,e){return-(t[1].length-e[1].length)});if(t.each(a,function(t,e){var s=e[1];return i.substr(h,s.length).toLowerCase()===s.toLowerCase()?(o=e[0],h+=s.length,!1):void 0}),-1!==o)return o+1;throw"Unknown name at position "+h},x=function(){if(i.charAt(h)!==e.charAt(n))throw"Unexpected literal at position "+h;h++};for(n=0;e.length>n;n++)if(b)"'"!==e.charAt(n)||y("'")?x():b=!1;else switch(e.charAt(n)){case"d":_=w("d");break;case"D":k("D",u,d);break;case"o":v=w("o");break;case"m":m=w("m");break;case"M":m=k("M",p,f);break;case"y":g=w("y");break;case"@":r=new Date(w("@")),g=r.getFullYear(),m=r.getMonth()+1,_=r.getDate();break;case"!":r=new Date((w("!")-this._ticksTo1970)/1e4),g=r.getFullYear(),m=r.getMonth()+1,_=r.getDate();break;case"'":y("'")?x():b=!0;break;default:x()}if(i.length>h&&(a=i.substr(h),!/^\s+/.test(a)))throw"Extra/unparsed characters found in date: "+a;if(-1===g?g=(new Date).getFullYear():100>g&&(g+=(new Date).getFullYear()-(new Date).getFullYear()%100+(c>=g?0:-100)),v>-1)for(m=1,_=v;;){if(o=this._getDaysInMonth(g,m-1),o>=_)break;m++,_-=o}if(r=this._daylightSavingAdjust(new Date(g,m-1,_)),r.getFullYear()!==g||r.getMonth()+1!==m||r.getDate()!==_)throw"Invalid date";return r},ATOM:"yy-mm-dd",COOKIE:"D, dd M yy",ISO_8601:"yy-mm-dd",RFC_822:"D, d M y",RFC_850:"DD, dd-M-y",RFC_1036:"D, d M y",RFC_1123:"D, d M yy",RFC_2822:"D, d M yy",RSS:"D, d M y",TICKS:"!",TIMESTAMP:"@",W3C:"yy-mm-dd",_ticksTo1970:1e7*60*60*24*(718685+Math.floor(492.5)-Math.floor(19.7)+Math.floor(4.925)),formatDate:function(t,e,i){if(!e)return"";var s,n=(i?i.dayNamesShort:null)||this._defaults.dayNamesShort,o=(i?i.dayNames:null)||this._defaults.dayNames,a=(i?i.monthNamesShort:null)||this._defaults.monthNamesShort,r=(i?i.monthNames:null)||this._defaults.monthNames,h=function(e){var i=t.length>s+1&&t.charAt(s+1)===e;return i&&s++,i},l=function(t,e,i){var s=""+e;if(h(t))for(;i>s.length;)s="0"+s;return s},c=function(t,e,i,s){return h(t)?s[e]:i[e]},u="",d=!1;if(e)for(s=0;t.length>s;s++)if(d)"'"!==t.charAt(s)||h("'")?u+=t.charAt(s):d=!1;else switch(t.charAt(s)){case"d":u+=l("d",e.getDate(),2);break;case"D":u+=c("D",e.getDay(),n,o);break;case"o":u+=l("o",Math.round((new Date(e.getFullYear(),e.getMonth(),e.getDate()).getTime()-new Date(e.getFullYear(),0,0).getTime())/864e5),3);break;case"m":u+=l("m",e.getMonth()+1,2);break;case"M":u+=c("M",e.getMonth(),a,r);break;case"y":u+=h("y")?e.getFullYear():(10>e.getFullYear()%100?"0":"")+e.getFullYear()%100;break;case"@":u+=e.getTime();break;case"!":u+=1e4*e.getTime()+this._ticksTo1970;break;case"'":h("'")?u+="'":d=!0;break;default:u+=t.charAt(s)}return u},_possibleChars:function(t){var e,i="",s=!1,n=function(i){var s=t.length>e+1&&t.charAt(e+1)===i;return s&&e++,s};for(e=0;t.length>e;e++)if(s)"'"!==t.charAt(e)||n("'")?i+=t.charAt(e):s=!1;else switch(t.charAt(e)){case"d":case"m":case"y":case"@":i+="0123456789";break;case"D":case"M":return null;case"'":n("'")?i+="'":s=!0;break;default:i+=t.charAt(e)}return i},_get:function(t,e){return void 0!==t.settings[e]?t.settings[e]:this._defaults[e]},_setDateFromField:function(t,e){if(t.input.val()!==t.lastVal){var i=this._get(t,"dateFormat"),s=t.lastVal=t.input?t.input.val():null,n=this._getDefaultDate(t),o=n,a=this._getFormatConfig(t);try{o=this.parseDate(i,s,a)||n}catch(r){s=e?"":s}t.selectedDay=o.getDate(),t.drawMonth=t.selectedMonth=o.getMonth(),t.drawYear=t.selectedYear=o.getFullYear(),t.currentDay=s?o.getDate():0,t.currentMonth=s?o.getMonth():0,t.currentYear=s?o.getFullYear():0,this._adjustInstDate(t)}},_getDefaultDate:function(t){return this._restrictMinMax(t,this._determineDate(t,this._get(t,"defaultDate"),new Date))},_determineDate:function(e,i,s){var n=function(t){var e=new Date;return e.setDate(e.getDate()+t),e},o=function(i){try{return t.datepicker.parseDate(t.datepicker._get(e,"dateFormat"),i,t.datepicker._getFormatConfig(e))}catch(s){}for(var n=(i.toLowerCase().match(/^c/)?t.datepicker._getDate(e):null)||new Date,o=n.getFullYear(),a=n.getMonth(),r=n.getDate(),h=/([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,l=h.exec(i);l;){switch(l[2]||"d"){case"d":case"D":r+=parseInt(l[1],10);break;case"w":case"W":r+=7*parseInt(l[1],10);break;case"m":case"M":a+=parseInt(l[1],10),r=Math.min(r,t.datepicker._getDaysInMonth(o,a));break;case"y":case"Y":o+=parseInt(l[1],10),r=Math.min(r,t.datepicker._getDaysInMonth(o,a))}l=h.exec(i)}return new Date(o,a,r)},a=null==i||""===i?s:"string"==typeof i?o(i):"number"==typeof i?isNaN(i)?s:n(i):new Date(i.getTime());return a=a&&"Invalid Date"==""+a?s:a,a&&(a.setHours(0),a.setMinutes(0),a.setSeconds(0),a.setMilliseconds(0)),this._daylightSavingAdjust(a)},_daylightSavingAdjust:function(t){return t?(t.setHours(t.getHours()>12?t.getHours()+2:0),t):null},_setDate:function(t,e,i){var s=!e,n=t.selectedMonth,o=t.selectedYear,a=this._restrictMinMax(t,this._determineDate(t,e,new Date));t.selectedDay=t.currentDay=a.getDate(),t.drawMonth=t.selectedMonth=t.currentMonth=a.getMonth(),t.drawYear=t.selectedYear=t.currentYear=a.getFullYear(),n===t.selectedMonth&&o===t.selectedYear||i||this._notifyChange(t),this._adjustInstDate(t),t.input&&t.input.val(s?"":this._formatDate(t))},_getDate:function(t){var e=!t.currentYear||t.input&&""===t.input.val()?null:this._daylightSavingAdjust(new Date(t.currentYear,t.currentMonth,t.currentDay));return e},_attachHandlers:function(e){var i=this._get(e,"stepMonths"),s="#"+e.id.replace(/\\\\/g,"\\");e.dpDiv.find("[data-handler]").map(function(){var e={prev:function(){t.datepicker._adjustDate(s,-i,"M")},next:function(){t.datepicker._adjustDate(s,+i,"M")},hide:function(){t.datepicker._hideDatepicker()},today:function(){t.datepicker._gotoToday(s)},selectDay:function(){return t.datepicker._selectDay(s,+this.getAttribute("data-month"),+this.getAttribute("data-year"),this),!1},selectMonth:function(){return t.datepicker._selectMonthYear(s,this,"M"),!1},selectYear:function(){return t.datepicker._selectMonthYear(s,this,"Y"),!1}};t(this).on(this.getAttribute("data-event"),e[this.getAttribute("data-handler")])})},_generateHTML:function(t){var e,i,s,n,o,a,r,h,l,c,u,d,p,f,g,m,_,v,b,y,w,k,x,C,D,I,T,P,M,S,H,z,O,A,N,W,E,F,L,R=new Date,B=this._daylightSavingAdjust(new Date(R.getFullYear(),R.getMonth(),R.getDate())),Y=this._get(t,"isRTL"),j=this._get(t,"showButtonPanel"),q=this._get(t,"hideIfNoPrevNext"),K=this._get(t,"navigationAsDateFormat"),U=this._getNumberOfMonths(t),V=this._get(t,"showCurrentAtPos"),$=this._get(t,"stepMonths"),X=1!==U[0]||1!==U[1],G=this._daylightSavingAdjust(t.currentDay?new Date(t.currentYear,t.currentMonth,t.currentDay):new Date(9999,9,9)),Q=this._getMinMaxDate(t,"min"),J=this._getMinMaxDate(t,"max"),Z=t.drawMonth-V,te=t.drawYear;if(0>Z&&(Z+=12,te--),J)for(e=this._daylightSavingAdjust(new Date(J.getFullYear(),J.getMonth()-U[0]*U[1]+1,J.getDate())),e=Q&&Q>e?Q:e;this._daylightSavingAdjust(new Date(te,Z,1))>e;)Z--,0>Z&&(Z=11,te--);for(t.drawMonth=Z,t.drawYear=te,i=this._get(t,"prevText"),i=K?this.formatDate(i,this._daylightSavingAdjust(new Date(te,Z-$,1)),this._getFormatConfig(t)):i,s=this._canAdjustMonth(t,-1,te,Z)?"<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click' title='"+i+"'><span class='ui-icon ui-icon-circle-triangle-"+(Y?"e":"w")+"'>"+i+"</span></a>":q?"":"<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='"+i+"'><span class='ui-icon ui-icon-circle-triangle-"+(Y?"e":"w")+"'>"+i+"</span></a>",n=this._get(t,"nextText"),n=K?this.formatDate(n,this._daylightSavingAdjust(new Date(te,Z+$,1)),this._getFormatConfig(t)):n,o=this._canAdjustMonth(t,1,te,Z)?"<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click' title='"+n+"'><span class='ui-icon ui-icon-circle-triangle-"+(Y?"w":"e")+"'>"+n+"</span></a>":q?"":"<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='"+n+"'><span class='ui-icon ui-icon-circle-triangle-"+(Y?"w":"e")+"'>"+n+"</span></a>",a=this._get(t,"currentText"),r=this._get(t,"gotoCurrent")&&t.currentDay?G:B,a=K?this.formatDate(a,r,this._getFormatConfig(t)):a,h=t.inline?"":"<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>"+this._get(t,"closeText")+"</button>",l=j?"<div class='ui-datepicker-buttonpane ui-widget-content'>"+(Y?h:"")+(this._isInRange(t,r)?"<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'>"+a+"</button>":"")+(Y?"":h)+"</div>":"",c=parseInt(this._get(t,"firstDay"),10),c=isNaN(c)?0:c,u=this._get(t,"showWeek"),d=this._get(t,"dayNames"),p=this._get(t,"dayNamesMin"),f=this._get(t,"monthNames"),g=this._get(t,"monthNamesShort"),m=this._get(t,"beforeShowDay"),_=this._get(t,"showOtherMonths"),v=this._get(t,"selectOtherMonths"),b=this._getDefaultDate(t),y="",k=0;U[0]>k;k++){for(x="",this.maxRows=4,C=0;U[1]>C;C++){if(D=this._daylightSavingAdjust(new Date(te,Z,t.selectedDay)),I=" ui-corner-all",T="",X){if(T+="<div class='ui-datepicker-group",U[1]>1)switch(C){case 0:T+=" ui-datepicker-group-first",I=" ui-corner-"+(Y?"right":"left");break;case U[1]-1:T+=" ui-datepicker-group-last",I=" ui-corner-"+(Y?"left":"right");break;default:T+=" ui-datepicker-group-middle",I=""}T+="'>"}for(T+="<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix"+I+"'>"+(/all|left/.test(I)&&0===k?Y?o:s:"")+(/all|right/.test(I)&&0===k?Y?s:o:"")+this._generateMonthYearHeader(t,Z,te,Q,J,k>0||C>0,f,g)+"</div><table class='ui-datepicker-calendar'><thead>"+"<tr>",P=u?"<th class='ui-datepicker-week-col'>"+this._get(t,"weekHeader")+"</th>":"",w=0;7>w;w++)M=(w+c)%7,P+="<th scope='col'"+((w+c+6)%7>=5?" class='ui-datepicker-week-end'":"")+">"+"<span title='"+d[M]+"'>"+p[M]+"</span></th>";for(T+=P+"</tr></thead><tbody>",S=this._getDaysInMonth(te,Z),te===t.selectedYear&&Z===t.selectedMonth&&(t.selectedDay=Math.min(t.selectedDay,S)),H=(this._getFirstDayOfMonth(te,Z)-c+7)%7,z=Math.ceil((H+S)/7),O=X?this.maxRows>z?this.maxRows:z:z,this.maxRows=O,A=this._daylightSavingAdjust(new Date(te,Z,1-H)),N=0;O>N;N++){for(T+="<tr>",W=u?"<td class='ui-datepicker-week-col'>"+this._get(t,"calculateWeek")(A)+"</td>":"",w=0;7>w;w++)E=m?m.apply(t.input?t.input[0]:null,[A]):[!0,""],F=A.getMonth()!==Z,L=F&&!v||!E[0]||Q&&Q>A||J&&A>J,W+="<td class='"+((w+c+6)%7>=5?" ui-datepicker-week-end":"")+(F?" ui-datepicker-other-month":"")+(A.getTime()===D.getTime()&&Z===t.selectedMonth&&t._keyEvent||b.getTime()===A.getTime()&&b.getTime()===D.getTime()?" "+this._dayOverClass:"")+(L?" "+this._unselectableClass+" ui-state-disabled":"")+(F&&!_?"":" "+E[1]+(A.getTime()===G.getTime()?" "+this._currentClass:"")+(A.getTime()===B.getTime()?" ui-datepicker-today":""))+"'"+(F&&!_||!E[2]?"":" title='"+E[2].replace(/'/g,"&#39;")+"'")+(L?"":" data-handler='selectDay' data-event='click' data-month='"+A.getMonth()+"' data-year='"+A.getFullYear()+"'")+">"+(F&&!_?"&#xa0;":L?"<span class='ui-state-default'>"+A.getDate()+"</span>":"<a class='ui-state-default"+(A.getTime()===B.getTime()?" ui-state-highlight":"")+(A.getTime()===G.getTime()?" ui-state-active":"")+(F?" ui-priority-secondary":"")+"' href='#'>"+A.getDate()+"</a>")+"</td>",A.setDate(A.getDate()+1),A=this._daylightSavingAdjust(A);T+=W+"</tr>"}Z++,Z>11&&(Z=0,te++),T+="</tbody></table>"+(X?"</div>"+(U[0]>0&&C===U[1]-1?"<div class='ui-datepicker-row-break'></div>":""):""),x+=T}y+=x}return y+=l,t._keyEvent=!1,y},_generateMonthYearHeader:function(t,e,i,s,n,o,a,r){var h,l,c,u,d,p,f,g,m=this._get(t,"changeMonth"),_=this._get(t,"changeYear"),v=this._get(t,"showMonthAfterYear"),b="<div class='ui-datepicker-title'>",y="";if(o||!m)y+="<span class='ui-datepicker-month'>"+a[e]+"</span>";else{for(h=s&&s.getFullYear()===i,l=n&&n.getFullYear()===i,y+="<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>",c=0;12>c;c++)(!h||c>=s.getMonth())&&(!l||n.getMonth()>=c)&&(y+="<option value='"+c+"'"+(c===e?" selected='selected'":"")+">"+r[c]+"</option>");y+="</select>"}if(v||(b+=y+(!o&&m&&_?"":"&#xa0;")),!t.yearshtml)if(t.yearshtml="",o||!_)b+="<span class='ui-datepicker-year'>"+i+"</span>";else{for(u=this._get(t,"yearRange").split(":"),d=(new Date).getFullYear(),p=function(t){var e=t.match(/c[+\-].*/)?i+parseInt(t.substring(1),10):t.match(/[+\-].*/)?d+parseInt(t,10):parseInt(t,10);return isNaN(e)?d:e},f=p(u[0]),g=Math.max(f,p(u[1]||"")),f=s?Math.max(f,s.getFullYear()):f,g=n?Math.min(g,n.getFullYear()):g,t.yearshtml+="<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";g>=f;f++)t.yearshtml+="<option value='"+f+"'"+(f===i?" selected='selected'":"")+">"+f+"</option>";t.yearshtml+="</select>",b+=t.yearshtml,t.yearshtml=null}return b+=this._get(t,"yearSuffix"),v&&(b+=(!o&&m&&_?"":"&#xa0;")+y),b+="</div>"},_adjustInstDate:function(t,e,i){var s=t.selectedYear+("Y"===i?e:0),n=t.selectedMonth+("M"===i?e:0),o=Math.min(t.selectedDay,this._getDaysInMonth(s,n))+("D"===i?e:0),a=this._restrictMinMax(t,this._daylightSavingAdjust(new Date(s,n,o)));t.selectedDay=a.getDate(),t.drawMonth=t.selectedMonth=a.getMonth(),t.drawYear=t.selectedYear=a.getFullYear(),("M"===i||"Y"===i)&&this._notifyChange(t)},_restrictMinMax:function(t,e){var i=this._getMinMaxDate(t,"min"),s=this._getMinMaxDate(t,"max"),n=i&&i>e?i:e;return s&&n>s?s:n},_notifyChange:function(t){var e=this._get(t,"onChangeMonthYear");e&&e.apply(t.input?t.input[0]:null,[t.selectedYear,t.selectedMonth+1,t])},_getNumberOfMonths:function(t){var e=this._get(t,"numberOfMonths");return null==e?[1,1]:"number"==typeof e?[1,e]:e},_getMinMaxDate:function(t,e){return this._determineDate(t,this._get(t,e+"Date"),null)},_getDaysInMonth:function(t,e){return 32-this._daylightSavingAdjust(new Date(t,e,32)).getDate()},_getFirstDayOfMonth:function(t,e){return new Date(t,e,1).getDay()},_canAdjustMonth:function(t,e,i,s){var n=this._getNumberOfMonths(t),o=this._daylightSavingAdjust(new Date(i,s+(0>e?e:n[0]*n[1]),1));return 0>e&&o.setDate(this._getDaysInMonth(o.getFullYear(),o.getMonth())),this._isInRange(t,o)},_isInRange:function(t,e){var i,s,n=this._getMinMaxDate(t,"min"),o=this._getMinMaxDate(t,"max"),a=null,r=null,h=this._get(t,"yearRange");return h&&(i=h.split(":"),s=(new Date).getFullYear(),a=parseInt(i[0],10),r=parseInt(i[1],10),i[0].match(/[+\-].*/)&&(a+=s),i[1].match(/[+\-].*/)&&(r+=s)),(!n||e.getTime()>=n.getTime())&&(!o||e.getTime()<=o.getTime())&&(!a||e.getFullYear()>=a)&&(!r||r>=e.getFullYear())},_getFormatConfig:function(t){var e=this._get(t,"shortYearCutoff");return e="string"!=typeof e?e:(new Date).getFullYear()%100+parseInt(e,10),{shortYearCutoff:e,dayNamesShort:this._get(t,"dayNamesShort"),dayNames:this._get(t,"dayNames"),monthNamesShort:this._get(t,"monthNamesShort"),monthNames:this._get(t,"monthNames")}},_formatDate:function(t,e,i,s){e||(t.currentDay=t.selectedDay,t.currentMonth=t.selectedMonth,t.currentYear=t.selectedYear);var n=e?"object"==typeof e?e:this._daylightSavingAdjust(new Date(s,i,e)):this._daylightSavingAdjust(new Date(t.currentYear,t.currentMonth,t.currentDay));return this.formatDate(this._get(t,"dateFormat"),n,this._getFormatConfig(t))}}),t.fn.datepicker=function(e){if(!this.length)return this;t.datepicker.initialized||(t(document).on("mousedown",t.datepicker._checkExternalClick),t.datepicker.initialized=!0),0===t("#"+t.datepicker._mainDivId).length&&t("body").append(t.datepicker.dpDiv);var i=Array.prototype.slice.call(arguments,1);return"string"!=typeof e||"isDisabled"!==e&&"getDate"!==e&&"widget"!==e?"option"===e&&2===arguments.length&&"string"==typeof arguments[1]?t.datepicker["_"+e+"Datepicker"].apply(t.datepicker,[this[0]].concat(i)):this.each(function(){"string"==typeof e?t.datepicker["_"+e+"Datepicker"].apply(t.datepicker,[this].concat(i)):t.datepicker._attachDatepicker(this,e)}):t.datepicker["_"+e+"Datepicker"].apply(t.datepicker,[this[0]].concat(i))},t.datepicker=new s,t.datepicker.initialized=!1,t.datepicker.uuid=(new Date).getTime(),t.datepicker.version="1.12.1",t.datepicker,t.ui.ie=!!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());var _=!1;t(document).on("mouseup",function(){_=!1}),t.widget("ui.mouse",{version:"1.12.1",options:{cancel:"input, textarea, button, select, option",distance:1,delay:0},_mouseInit:function(){var e=this;this.element.on("mousedown."+this.widgetName,function(t){return e._mouseDown(t)}).on("click."+this.widgetName,function(i){return!0===t.data(i.target,e.widgetName+".preventClickEvent")?(t.removeData(i.target,e.widgetName+".preventClickEvent"),i.stopImmediatePropagation(),!1):void 0}),this.started=!1},_mouseDestroy:function(){this.element.off("."+this.widgetName),this._mouseMoveDelegate&&this.document.off("mousemove."+this.widgetName,this._mouseMoveDelegate).off("mouseup."+this.widgetName,this._mouseUpDelegate)},_mouseDown:function(e){if(!_){this._mouseMoved=!1,this._mouseStarted&&this._mouseUp(e),this._mouseDownEvent=e;var i=this,s=1===e.which,n="string"==typeof this.options.cancel&&e.target.nodeName?t(e.target).closest(this.options.cancel).length:!1;return s&&!n&&this._mouseCapture(e)?(this.mouseDelayMet=!this.options.delay,this.mouseDelayMet||(this._mouseDelayTimer=setTimeout(function(){i.mouseDelayMet=!0},this.options.delay)),this._mouseDistanceMet(e)&&this._mouseDelayMet(e)&&(this._mouseStarted=this._mouseStart(e)!==!1,!this._mouseStarted)?(e.preventDefault(),!0):(!0===t.data(e.target,this.widgetName+".preventClickEvent")&&t.removeData(e.target,this.widgetName+".preventClickEvent"),this._mouseMoveDelegate=function(t){return i._mouseMove(t)},this._mouseUpDelegate=function(t){return i._mouseUp(t)},this.document.on("mousemove."+this.widgetName,this._mouseMoveDelegate).on("mouseup."+this.widgetName,this._mouseUpDelegate),e.preventDefault(),_=!0,!0)):!0}},_mouseMove:function(e){if(this._mouseMoved){if(t.ui.ie&&(!document.documentMode||9>document.documentMode)&&!e.button)return this._mouseUp(e);if(!e.which)if(e.originalEvent.altKey||e.originalEvent.ctrlKey||e.originalEvent.metaKey||e.originalEvent.shiftKey)this.ignoreMissingWhich=!0;else if(!this.ignoreMissingWhich)return this._mouseUp(e)}return(e.which||e.button)&&(this._mouseMoved=!0),this._mouseStarted?(this._mouseDrag(e),e.preventDefault()):(this._mouseDistanceMet(e)&&this._mouseDelayMet(e)&&(this._mouseStarted=this._mouseStart(this._mouseDownEvent,e)!==!1,this._mouseStarted?this._mouseDrag(e):this._mouseUp(e)),!this._mouseStarted)},_mouseUp:function(e){this.document.off("mousemove."+this.widgetName,this._mouseMoveDelegate).off("mouseup."+this.widgetName,this._mouseUpDelegate),this._mouseStarted&&(this._mouseStarted=!1,e.target===this._mouseDownEvent.target&&t.data(e.target,this.widgetName+".preventClickEvent",!0),this._mouseStop(e)),this._mouseDelayTimer&&(clearTimeout(this._mouseDelayTimer),delete this._mouseDelayTimer),this.ignoreMissingWhich=!1,_=!1,e.preventDefault()},_mouseDistanceMet:function(t){return Math.max(Math.abs(this._mouseDownEvent.pageX-t.pageX),Math.abs(this._mouseDownEvent.pageY-t.pageY))>=this.options.distance},_mouseDelayMet:function(){return this.mouseDelayMet},_mouseStart:function(){},_mouseDrag:function(){},_mouseStop:function(){},_mouseCapture:function(){return!0}}),t.ui.plugin={add:function(e,i,s){var n,o=t.ui[e].prototype;for(n in s)o.plugins[n]=o.plugins[n]||[],o.plugins[n].push([i,s[n]])},call:function(t,e,i,s){var n,o=t.plugins[e];if(o&&(s||t.element[0].parentNode&&11!==t.element[0].parentNode.nodeType))for(n=0;o.length>n;n++)t.options[o[n][0]]&&o[n][1].apply(t.element,i)}},t.ui.safeBlur=function(e){e&&"body"!==e.nodeName.toLowerCase()&&t(e).trigger("blur")},t.widget("ui.draggable",t.ui.mouse,{version:"1.12.1",widgetEventPrefix:"drag",options:{addClasses:!0,appendTo:"parent",axis:!1,connectToSortable:!1,containment:!1,cursor:"auto",cursorAt:!1,grid:!1,handle:!1,helper:"original",iframeFix:!1,opacity:!1,refreshPositions:!1,revert:!1,revertDuration:500,scope:"default",scroll:!0,scrollSensitivity:20,scrollSpeed:20,snap:!1,snapMode:"both",snapTolerance:20,stack:!1,zIndex:!1,drag:null,start:null,stop:null},_create:function(){"original"===this.options.helper&&this._setPositionRelative(),this.options.addClasses&&this._addClass("ui-draggable"),this._setHandleClassName(),this._mouseInit()},_setOption:function(t,e){this._super(t,e),"handle"===t&&(this._removeHandleClassName(),this._setHandleClassName())},_destroy:function(){return(this.helper||this.element).is(".ui-draggable-dragging")?(this.destroyOnClear=!0,void 0):(this._removeHandleClassName(),this._mouseDestroy(),void 0)},_mouseCapture:function(e){var i=this.options;return this.helper||i.disabled||t(e.target).closest(".ui-resizable-handle").length>0?!1:(this.handle=this._getHandle(e),this.handle?(this._blurActiveElement(e),this._blockFrames(i.iframeFix===!0?"iframe":i.iframeFix),!0):!1)},_blockFrames:function(e){this.iframeBlocks=this.document.find(e).map(function(){var e=t(this);return t("<div>").css("position","absolute").appendTo(e.parent()).outerWidth(e.outerWidth()).outerHeight(e.outerHeight()).offset(e.offset())[0]})},_unblockFrames:function(){this.iframeBlocks&&(this.iframeBlocks.remove(),delete this.iframeBlocks)},_blurActiveElement:function(e){var i=t.ui.safeActiveElement(this.document[0]),s=t(e.target);s.closest(i).length||t.ui.safeBlur(i)},_mouseStart:function(e){var i=this.options;return this.helper=this._createHelper(e),this._addClass(this.helper,"ui-draggable-dragging"),this._cacheHelperProportions(),t.ui.ddmanager&&(t.ui.ddmanager.current=this),this._cacheMargins(),this.cssPosition=this.helper.css("position"),this.scrollParent=this.helper.scrollParent(!0),this.offsetParent=this.helper.offsetParent(),this.hasFixedAncestor=this.helper.parents().filter(function(){return"fixed"===t(this).css("position")}).length>0,this.positionAbs=this.element.offset(),this._refreshOffsets(e),this.originalPosition=this.position=this._generatePosition(e,!1),this.originalPageX=e.pageX,this.originalPageY=e.pageY,i.cursorAt&&this._adjustOffsetFromHelper(i.cursorAt),this._setContainment(),this._trigger("start",e)===!1?(this._clear(),!1):(this._cacheHelperProportions(),t.ui.ddmanager&&!i.dropBehaviour&&t.ui.ddmanager.prepareOffsets(this,e),this._mouseDrag(e,!0),t.ui.ddmanager&&t.ui.ddmanager.dragStart(this,e),!0)},_refreshOffsets:function(t){this.offset={top:this.positionAbs.top-this.margins.top,left:this.positionAbs.left-this.margins.left,scroll:!1,parent:this._getParentOffset(),relative:this._getRelativeOffset()},this.offset.click={left:t.pageX-this.offset.left,top:t.pageY-this.offset.top}},_mouseDrag:function(e,i){if(this.hasFixedAncestor&&(this.offset.parent=this._getParentOffset()),this.position=this._generatePosition(e,!0),this.positionAbs=this._convertPositionTo("absolute"),!i){var s=this._uiHash();if(this._trigger("drag",e,s)===!1)return this._mouseUp(new t.Event("mouseup",e)),!1;this.position=s.position}return this.helper[0].style.left=this.position.left+"px",this.helper[0].style.top=this.position.top+"px",t.ui.ddmanager&&t.ui.ddmanager.drag(this,e),!1},_mouseStop:function(e){var i=this,s=!1;return t.ui.ddmanager&&!this.options.dropBehaviour&&(s=t.ui.ddmanager.drop(this,e)),this.dropped&&(s=this.dropped,this.dropped=!1),"invalid"===this.options.revert&&!s||"valid"===this.options.revert&&s||this.options.revert===!0||t.isFunction(this.options.revert)&&this.options.revert.call(this.element,s)?t(this.helper).animate(this.originalPosition,parseInt(this.options.revertDuration,10),function(){i._trigger("stop",e)!==!1&&i._clear()}):this._trigger("stop",e)!==!1&&this._clear(),!1},_mouseUp:function(e){return this._unblockFrames(),t.ui.ddmanager&&t.ui.ddmanager.dragStop(this,e),this.handleElement.is(e.target)&&this.element.trigger("focus"),t.ui.mouse.prototype._mouseUp.call(this,e)},cancel:function(){return this.helper.is(".ui-draggable-dragging")?this._mouseUp(new t.Event("mouseup",{target:this.element[0]})):this._clear(),this},_getHandle:function(e){return this.options.handle?!!t(e.target).closest(this.element.find(this.options.handle)).length:!0},_setHandleClassName:function(){this.handleElement=this.options.handle?this.element.find(this.options.handle):this.element,this._addClass(this.handleElement,"ui-draggable-handle")},_removeHandleClassName:function(){this._removeClass(this.handleElement,"ui-draggable-handle")},_createHelper:function(e){var i=this.options,s=t.isFunction(i.helper),n=s?t(i.helper.apply(this.element[0],[e])):"clone"===i.helper?this.element.clone().removeAttr("id"):this.element;return n.parents("body").length||n.appendTo("parent"===i.appendTo?this.element[0].parentNode:i.appendTo),s&&n[0]===this.element[0]&&this._setPositionRelative(),n[0]===this.element[0]||/(fixed|absolute)/.test(n.css("position"))||n.css("position","absolute"),n},_setPositionRelative:function(){/^(?:r|a|f)/.test(this.element.css("position"))||(this.element[0].style.position="relative")},_adjustOffsetFromHelper:function(e){"string"==typeof e&&(e=e.split(" ")),t.isArray(e)&&(e={left:+e[0],top:+e[1]||0}),"left"in e&&(this.offset.click.left=e.left+this.margins.left),"right"in e&&(this.offset.click.left=this.helperProportions.width-e.right+this.margins.left),"top"in e&&(this.offset.click.top=e.top+this.margins.top),"bottom"in e&&(this.offset.click.top=this.helperProportions.height-e.bottom+this.margins.top)},_isRootNode:function(t){return/(html|body)/i.test(t.tagName)||t===this.document[0]},_getParentOffset:function(){var e=this.offsetParent.offset(),i=this.document[0];return"absolute"===this.cssPosition&&this.scrollParent[0]!==i&&t.contains(this.scrollParent[0],this.offsetParent[0])&&(e.left+=this.scrollParent.scrollLeft(),e.top+=this.scrollParent.scrollTop()),this._isRootNode(this.offsetParent[0])&&(e={top:0,left:0}),{top:e.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:e.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"!==this.cssPosition)return{top:0,left:0};var t=this.element.position(),e=this._isRootNode(this.scrollParent[0]);return{top:t.top-(parseInt(this.helper.css("top"),10)||0)+(e?0:this.scrollParent.scrollTop()),left:t.left-(parseInt(this.helper.css("left"),10)||0)+(e?0:this.scrollParent.scrollLeft())}
},_cacheMargins:function(){this.margins={left:parseInt(this.element.css("marginLeft"),10)||0,top:parseInt(this.element.css("marginTop"),10)||0,right:parseInt(this.element.css("marginRight"),10)||0,bottom:parseInt(this.element.css("marginBottom"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var e,i,s,n=this.options,o=this.document[0];return this.relativeContainer=null,n.containment?"window"===n.containment?(this.containment=[t(window).scrollLeft()-this.offset.relative.left-this.offset.parent.left,t(window).scrollTop()-this.offset.relative.top-this.offset.parent.top,t(window).scrollLeft()+t(window).width()-this.helperProportions.width-this.margins.left,t(window).scrollTop()+(t(window).height()||o.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top],void 0):"document"===n.containment?(this.containment=[0,0,t(o).width()-this.helperProportions.width-this.margins.left,(t(o).height()||o.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top],void 0):n.containment.constructor===Array?(this.containment=n.containment,void 0):("parent"===n.containment&&(n.containment=this.helper[0].parentNode),i=t(n.containment),s=i[0],s&&(e=/(scroll|auto)/.test(i.css("overflow")),this.containment=[(parseInt(i.css("borderLeftWidth"),10)||0)+(parseInt(i.css("paddingLeft"),10)||0),(parseInt(i.css("borderTopWidth"),10)||0)+(parseInt(i.css("paddingTop"),10)||0),(e?Math.max(s.scrollWidth,s.offsetWidth):s.offsetWidth)-(parseInt(i.css("borderRightWidth"),10)||0)-(parseInt(i.css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left-this.margins.right,(e?Math.max(s.scrollHeight,s.offsetHeight):s.offsetHeight)-(parseInt(i.css("borderBottomWidth"),10)||0)-(parseInt(i.css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top-this.margins.bottom],this.relativeContainer=i),void 0):(this.containment=null,void 0)},_convertPositionTo:function(t,e){e||(e=this.position);var i="absolute"===t?1:-1,s=this._isRootNode(this.scrollParent[0]);return{top:e.top+this.offset.relative.top*i+this.offset.parent.top*i-("fixed"===this.cssPosition?-this.offset.scroll.top:s?0:this.offset.scroll.top)*i,left:e.left+this.offset.relative.left*i+this.offset.parent.left*i-("fixed"===this.cssPosition?-this.offset.scroll.left:s?0:this.offset.scroll.left)*i}},_generatePosition:function(t,e){var i,s,n,o,a=this.options,r=this._isRootNode(this.scrollParent[0]),h=t.pageX,l=t.pageY;return r&&this.offset.scroll||(this.offset.scroll={top:this.scrollParent.scrollTop(),left:this.scrollParent.scrollLeft()}),e&&(this.containment&&(this.relativeContainer?(s=this.relativeContainer.offset(),i=[this.containment[0]+s.left,this.containment[1]+s.top,this.containment[2]+s.left,this.containment[3]+s.top]):i=this.containment,t.pageX-this.offset.click.left<i[0]&&(h=i[0]+this.offset.click.left),t.pageY-this.offset.click.top<i[1]&&(l=i[1]+this.offset.click.top),t.pageX-this.offset.click.left>i[2]&&(h=i[2]+this.offset.click.left),t.pageY-this.offset.click.top>i[3]&&(l=i[3]+this.offset.click.top)),a.grid&&(n=a.grid[1]?this.originalPageY+Math.round((l-this.originalPageY)/a.grid[1])*a.grid[1]:this.originalPageY,l=i?n-this.offset.click.top>=i[1]||n-this.offset.click.top>i[3]?n:n-this.offset.click.top>=i[1]?n-a.grid[1]:n+a.grid[1]:n,o=a.grid[0]?this.originalPageX+Math.round((h-this.originalPageX)/a.grid[0])*a.grid[0]:this.originalPageX,h=i?o-this.offset.click.left>=i[0]||o-this.offset.click.left>i[2]?o:o-this.offset.click.left>=i[0]?o-a.grid[0]:o+a.grid[0]:o),"y"===a.axis&&(h=this.originalPageX),"x"===a.axis&&(l=this.originalPageY)),{top:l-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.offset.scroll.top:r?0:this.offset.scroll.top),left:h-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.offset.scroll.left:r?0:this.offset.scroll.left)}},_clear:function(){this._removeClass(this.helper,"ui-draggable-dragging"),this.helper[0]===this.element[0]||this.cancelHelperRemoval||this.helper.remove(),this.helper=null,this.cancelHelperRemoval=!1,this.destroyOnClear&&this.destroy()},_trigger:function(e,i,s){return s=s||this._uiHash(),t.ui.plugin.call(this,e,[i,s,this],!0),/^(drag|start|stop)/.test(e)&&(this.positionAbs=this._convertPositionTo("absolute"),s.offset=this.positionAbs),t.Widget.prototype._trigger.call(this,e,i,s)},plugins:{},_uiHash:function(){return{helper:this.helper,position:this.position,originalPosition:this.originalPosition,offset:this.positionAbs}}}),t.ui.plugin.add("draggable","connectToSortable",{start:function(e,i,s){var n=t.extend({},i,{item:s.element});s.sortables=[],t(s.options.connectToSortable).each(function(){var i=t(this).sortable("instance");i&&!i.options.disabled&&(s.sortables.push(i),i.refreshPositions(),i._trigger("activate",e,n))})},stop:function(e,i,s){var n=t.extend({},i,{item:s.element});s.cancelHelperRemoval=!1,t.each(s.sortables,function(){var t=this;t.isOver?(t.isOver=0,s.cancelHelperRemoval=!0,t.cancelHelperRemoval=!1,t._storedCSS={position:t.placeholder.css("position"),top:t.placeholder.css("top"),left:t.placeholder.css("left")},t._mouseStop(e),t.options.helper=t.options._helper):(t.cancelHelperRemoval=!0,t._trigger("deactivate",e,n))})},drag:function(e,i,s){t.each(s.sortables,function(){var n=!1,o=this;o.positionAbs=s.positionAbs,o.helperProportions=s.helperProportions,o.offset.click=s.offset.click,o._intersectsWith(o.containerCache)&&(n=!0,t.each(s.sortables,function(){return this.positionAbs=s.positionAbs,this.helperProportions=s.helperProportions,this.offset.click=s.offset.click,this!==o&&this._intersectsWith(this.containerCache)&&t.contains(o.element[0],this.element[0])&&(n=!1),n})),n?(o.isOver||(o.isOver=1,s._parent=i.helper.parent(),o.currentItem=i.helper.appendTo(o.element).data("ui-sortable-item",!0),o.options._helper=o.options.helper,o.options.helper=function(){return i.helper[0]},e.target=o.currentItem[0],o._mouseCapture(e,!0),o._mouseStart(e,!0,!0),o.offset.click.top=s.offset.click.top,o.offset.click.left=s.offset.click.left,o.offset.parent.left-=s.offset.parent.left-o.offset.parent.left,o.offset.parent.top-=s.offset.parent.top-o.offset.parent.top,s._trigger("toSortable",e),s.dropped=o.element,t.each(s.sortables,function(){this.refreshPositions()}),s.currentItem=s.element,o.fromOutside=s),o.currentItem&&(o._mouseDrag(e),i.position=o.position)):o.isOver&&(o.isOver=0,o.cancelHelperRemoval=!0,o.options._revert=o.options.revert,o.options.revert=!1,o._trigger("out",e,o._uiHash(o)),o._mouseStop(e,!0),o.options.revert=o.options._revert,o.options.helper=o.options._helper,o.placeholder&&o.placeholder.remove(),i.helper.appendTo(s._parent),s._refreshOffsets(e),i.position=s._generatePosition(e,!0),s._trigger("fromSortable",e),s.dropped=!1,t.each(s.sortables,function(){this.refreshPositions()}))})}}),t.ui.plugin.add("draggable","cursor",{start:function(e,i,s){var n=t("body"),o=s.options;n.css("cursor")&&(o._cursor=n.css("cursor")),n.css("cursor",o.cursor)},stop:function(e,i,s){var n=s.options;n._cursor&&t("body").css("cursor",n._cursor)}}),t.ui.plugin.add("draggable","opacity",{start:function(e,i,s){var n=t(i.helper),o=s.options;n.css("opacity")&&(o._opacity=n.css("opacity")),n.css("opacity",o.opacity)},stop:function(e,i,s){var n=s.options;n._opacity&&t(i.helper).css("opacity",n._opacity)}}),t.ui.plugin.add("draggable","scroll",{start:function(t,e,i){i.scrollParentNotHidden||(i.scrollParentNotHidden=i.helper.scrollParent(!1)),i.scrollParentNotHidden[0]!==i.document[0]&&"HTML"!==i.scrollParentNotHidden[0].tagName&&(i.overflowOffset=i.scrollParentNotHidden.offset())},drag:function(e,i,s){var n=s.options,o=!1,a=s.scrollParentNotHidden[0],r=s.document[0];a!==r&&"HTML"!==a.tagName?(n.axis&&"x"===n.axis||(s.overflowOffset.top+a.offsetHeight-e.pageY<n.scrollSensitivity?a.scrollTop=o=a.scrollTop+n.scrollSpeed:e.pageY-s.overflowOffset.top<n.scrollSensitivity&&(a.scrollTop=o=a.scrollTop-n.scrollSpeed)),n.axis&&"y"===n.axis||(s.overflowOffset.left+a.offsetWidth-e.pageX<n.scrollSensitivity?a.scrollLeft=o=a.scrollLeft+n.scrollSpeed:e.pageX-s.overflowOffset.left<n.scrollSensitivity&&(a.scrollLeft=o=a.scrollLeft-n.scrollSpeed))):(n.axis&&"x"===n.axis||(e.pageY-t(r).scrollTop()<n.scrollSensitivity?o=t(r).scrollTop(t(r).scrollTop()-n.scrollSpeed):t(window).height()-(e.pageY-t(r).scrollTop())<n.scrollSensitivity&&(o=t(r).scrollTop(t(r).scrollTop()+n.scrollSpeed))),n.axis&&"y"===n.axis||(e.pageX-t(r).scrollLeft()<n.scrollSensitivity?o=t(r).scrollLeft(t(r).scrollLeft()-n.scrollSpeed):t(window).width()-(e.pageX-t(r).scrollLeft())<n.scrollSensitivity&&(o=t(r).scrollLeft(t(r).scrollLeft()+n.scrollSpeed)))),o!==!1&&t.ui.ddmanager&&!n.dropBehaviour&&t.ui.ddmanager.prepareOffsets(s,e)}}),t.ui.plugin.add("draggable","snap",{start:function(e,i,s){var n=s.options;s.snapElements=[],t(n.snap.constructor!==String?n.snap.items||":data(ui-draggable)":n.snap).each(function(){var e=t(this),i=e.offset();this!==s.element[0]&&s.snapElements.push({item:this,width:e.outerWidth(),height:e.outerHeight(),top:i.top,left:i.left})})},drag:function(e,i,s){var n,o,a,r,h,l,c,u,d,p,f=s.options,g=f.snapTolerance,m=i.offset.left,_=m+s.helperProportions.width,v=i.offset.top,b=v+s.helperProportions.height;for(d=s.snapElements.length-1;d>=0;d--)h=s.snapElements[d].left-s.margins.left,l=h+s.snapElements[d].width,c=s.snapElements[d].top-s.margins.top,u=c+s.snapElements[d].height,h-g>_||m>l+g||c-g>b||v>u+g||!t.contains(s.snapElements[d].item.ownerDocument,s.snapElements[d].item)?(s.snapElements[d].snapping&&s.options.snap.release&&s.options.snap.release.call(s.element,e,t.extend(s._uiHash(),{snapItem:s.snapElements[d].item})),s.snapElements[d].snapping=!1):("inner"!==f.snapMode&&(n=g>=Math.abs(c-b),o=g>=Math.abs(u-v),a=g>=Math.abs(h-_),r=g>=Math.abs(l-m),n&&(i.position.top=s._convertPositionTo("relative",{top:c-s.helperProportions.height,left:0}).top),o&&(i.position.top=s._convertPositionTo("relative",{top:u,left:0}).top),a&&(i.position.left=s._convertPositionTo("relative",{top:0,left:h-s.helperProportions.width}).left),r&&(i.position.left=s._convertPositionTo("relative",{top:0,left:l}).left)),p=n||o||a||r,"outer"!==f.snapMode&&(n=g>=Math.abs(c-v),o=g>=Math.abs(u-b),a=g>=Math.abs(h-m),r=g>=Math.abs(l-_),n&&(i.position.top=s._convertPositionTo("relative",{top:c,left:0}).top),o&&(i.position.top=s._convertPositionTo("relative",{top:u-s.helperProportions.height,left:0}).top),a&&(i.position.left=s._convertPositionTo("relative",{top:0,left:h}).left),r&&(i.position.left=s._convertPositionTo("relative",{top:0,left:l-s.helperProportions.width}).left)),!s.snapElements[d].snapping&&(n||o||a||r||p)&&s.options.snap.snap&&s.options.snap.snap.call(s.element,e,t.extend(s._uiHash(),{snapItem:s.snapElements[d].item})),s.snapElements[d].snapping=n||o||a||r||p)}}),t.ui.plugin.add("draggable","stack",{start:function(e,i,s){var n,o=s.options,a=t.makeArray(t(o.stack)).sort(function(e,i){return(parseInt(t(e).css("zIndex"),10)||0)-(parseInt(t(i).css("zIndex"),10)||0)});a.length&&(n=parseInt(t(a[0]).css("zIndex"),10)||0,t(a).each(function(e){t(this).css("zIndex",n+e)}),this.css("zIndex",n+a.length))}}),t.ui.plugin.add("draggable","zIndex",{start:function(e,i,s){var n=t(i.helper),o=s.options;n.css("zIndex")&&(o._zIndex=n.css("zIndex")),n.css("zIndex",o.zIndex)},stop:function(e,i,s){var n=s.options;n._zIndex&&t(i.helper).css("zIndex",n._zIndex)}}),t.ui.draggable,t.widget("ui.resizable",t.ui.mouse,{version:"1.12.1",widgetEventPrefix:"resize",options:{alsoResize:!1,animate:!1,animateDuration:"slow",animateEasing:"swing",aspectRatio:!1,autoHide:!1,classes:{"ui-resizable-se":"ui-icon ui-icon-gripsmall-diagonal-se"},containment:!1,ghost:!1,grid:!1,handles:"e,s,se",helper:!1,maxHeight:null,maxWidth:null,minHeight:10,minWidth:10,zIndex:90,resize:null,start:null,stop:null},_num:function(t){return parseFloat(t)||0},_isNumber:function(t){return!isNaN(parseFloat(t))},_hasScroll:function(e,i){if("hidden"===t(e).css("overflow"))return!1;var s=i&&"left"===i?"scrollLeft":"scrollTop",n=!1;return e[s]>0?!0:(e[s]=1,n=e[s]>0,e[s]=0,n)},_create:function(){var e,i=this.options,s=this;this._addClass("ui-resizable"),t.extend(this,{_aspectRatio:!!i.aspectRatio,aspectRatio:i.aspectRatio,originalElement:this.element,_proportionallyResizeElements:[],_helper:i.helper||i.ghost||i.animate?i.helper||"ui-resizable-helper":null}),this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i)&&(this.element.wrap(t("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({position:this.element.css("position"),width:this.element.outerWidth(),height:this.element.outerHeight(),top:this.element.css("top"),left:this.element.css("left")})),this.element=this.element.parent().data("ui-resizable",this.element.resizable("instance")),this.elementIsWrapper=!0,e={marginTop:this.originalElement.css("marginTop"),marginRight:this.originalElement.css("marginRight"),marginBottom:this.originalElement.css("marginBottom"),marginLeft:this.originalElement.css("marginLeft")},this.element.css(e),this.originalElement.css("margin",0),this.originalResizeStyle=this.originalElement.css("resize"),this.originalElement.css("resize","none"),this._proportionallyResizeElements.push(this.originalElement.css({position:"static",zoom:1,display:"block"})),this.originalElement.css(e),this._proportionallyResize()),this._setupHandles(),i.autoHide&&t(this.element).on("mouseenter",function(){i.disabled||(s._removeClass("ui-resizable-autohide"),s._handles.show())}).on("mouseleave",function(){i.disabled||s.resizing||(s._addClass("ui-resizable-autohide"),s._handles.hide())}),this._mouseInit()},_destroy:function(){this._mouseDestroy();var e,i=function(e){t(e).removeData("resizable").removeData("ui-resizable").off(".resizable").find(".ui-resizable-handle").remove()};return this.elementIsWrapper&&(i(this.element),e=this.element,this.originalElement.css({position:e.css("position"),width:e.outerWidth(),height:e.outerHeight(),top:e.css("top"),left:e.css("left")}).insertAfter(e),e.remove()),this.originalElement.css("resize",this.originalResizeStyle),i(this.originalElement),this},_setOption:function(t,e){switch(this._super(t,e),t){case"handles":this._removeHandles(),this._setupHandles();break;default:}},_setupHandles:function(){var e,i,s,n,o,a=this.options,r=this;if(this.handles=a.handles||(t(".ui-resizable-handle",this.element).length?{n:".ui-resizable-n",e:".ui-resizable-e",s:".ui-resizable-s",w:".ui-resizable-w",se:".ui-resizable-se",sw:".ui-resizable-sw",ne:".ui-resizable-ne",nw:".ui-resizable-nw"}:"e,s,se"),this._handles=t(),this.handles.constructor===String)for("all"===this.handles&&(this.handles="n,e,s,w,se,sw,ne,nw"),s=this.handles.split(","),this.handles={},i=0;s.length>i;i++)e=t.trim(s[i]),n="ui-resizable-"+e,o=t("<div>"),this._addClass(o,"ui-resizable-handle "+n),o.css({zIndex:a.zIndex}),this.handles[e]=".ui-resizable-"+e,this.element.append(o);this._renderAxis=function(e){var i,s,n,o;e=e||this.element;for(i in this.handles)this.handles[i].constructor===String?this.handles[i]=this.element.children(this.handles[i]).first().show():(this.handles[i].jquery||this.handles[i].nodeType)&&(this.handles[i]=t(this.handles[i]),this._on(this.handles[i],{mousedown:r._mouseDown})),this.elementIsWrapper&&this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i)&&(s=t(this.handles[i],this.element),o=/sw|ne|nw|se|n|s/.test(i)?s.outerHeight():s.outerWidth(),n=["padding",/ne|nw|n/.test(i)?"Top":/se|sw|s/.test(i)?"Bottom":/^e$/.test(i)?"Right":"Left"].join(""),e.css(n,o),this._proportionallyResize()),this._handles=this._handles.add(this.handles[i])},this._renderAxis(this.element),this._handles=this._handles.add(this.element.find(".ui-resizable-handle")),this._handles.disableSelection(),this._handles.on("mouseover",function(){r.resizing||(this.className&&(o=this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i)),r.axis=o&&o[1]?o[1]:"se")}),a.autoHide&&(this._handles.hide(),this._addClass("ui-resizable-autohide"))},_removeHandles:function(){this._handles.remove()},_mouseCapture:function(e){var i,s,n=!1;for(i in this.handles)s=t(this.handles[i])[0],(s===e.target||t.contains(s,e.target))&&(n=!0);return!this.options.disabled&&n},_mouseStart:function(e){var i,s,n,o=this.options,a=this.element;return this.resizing=!0,this._renderProxy(),i=this._num(this.helper.css("left")),s=this._num(this.helper.css("top")),o.containment&&(i+=t(o.containment).scrollLeft()||0,s+=t(o.containment).scrollTop()||0),this.offset=this.helper.offset(),this.position={left:i,top:s},this.size=this._helper?{width:this.helper.width(),height:this.helper.height()}:{width:a.width(),height:a.height()},this.originalSize=this._helper?{width:a.outerWidth(),height:a.outerHeight()}:{width:a.width(),height:a.height()},this.sizeDiff={width:a.outerWidth()-a.width(),height:a.outerHeight()-a.height()},this.originalPosition={left:i,top:s},this.originalMousePosition={left:e.pageX,top:e.pageY},this.aspectRatio="number"==typeof o.aspectRatio?o.aspectRatio:this.originalSize.width/this.originalSize.height||1,n=t(".ui-resizable-"+this.axis).css("cursor"),t("body").css("cursor","auto"===n?this.axis+"-resize":n),this._addClass("ui-resizable-resizing"),this._propagate("start",e),!0},_mouseDrag:function(e){var i,s,n=this.originalMousePosition,o=this.axis,a=e.pageX-n.left||0,r=e.pageY-n.top||0,h=this._change[o];return this._updatePrevProperties(),h?(i=h.apply(this,[e,a,r]),this._updateVirtualBoundaries(e.shiftKey),(this._aspectRatio||e.shiftKey)&&(i=this._updateRatio(i,e)),i=this._respectSize(i,e),this._updateCache(i),this._propagate("resize",e),s=this._applyChanges(),!this._helper&&this._proportionallyResizeElements.length&&this._proportionallyResize(),t.isEmptyObject(s)||(this._updatePrevProperties(),this._trigger("resize",e,this.ui()),this._applyChanges()),!1):!1},_mouseStop:function(e){this.resizing=!1;var i,s,n,o,a,r,h,l=this.options,c=this;return this._helper&&(i=this._proportionallyResizeElements,s=i.length&&/textarea/i.test(i[0].nodeName),n=s&&this._hasScroll(i[0],"left")?0:c.sizeDiff.height,o=s?0:c.sizeDiff.width,a={width:c.helper.width()-o,height:c.helper.height()-n},r=parseFloat(c.element.css("left"))+(c.position.left-c.originalPosition.left)||null,h=parseFloat(c.element.css("top"))+(c.position.top-c.originalPosition.top)||null,l.animate||this.element.css(t.extend(a,{top:h,left:r})),c.helper.height(c.size.height),c.helper.width(c.size.width),this._helper&&!l.animate&&this._proportionallyResize()),t("body").css("cursor","auto"),this._removeClass("ui-resizable-resizing"),this._propagate("stop",e),this._helper&&this.helper.remove(),!1},_updatePrevProperties:function(){this.prevPosition={top:this.position.top,left:this.position.left},this.prevSize={width:this.size.width,height:this.size.height}},_applyChanges:function(){var t={};return this.position.top!==this.prevPosition.top&&(t.top=this.position.top+"px"),this.position.left!==this.prevPosition.left&&(t.left=this.position.left+"px"),this.size.width!==this.prevSize.width&&(t.width=this.size.width+"px"),this.size.height!==this.prevSize.height&&(t.height=this.size.height+"px"),this.helper.css(t),t},_updateVirtualBoundaries:function(t){var e,i,s,n,o,a=this.options;o={minWidth:this._isNumber(a.minWidth)?a.minWidth:0,maxWidth:this._isNumber(a.maxWidth)?a.maxWidth:1/0,minHeight:this._isNumber(a.minHeight)?a.minHeight:0,maxHeight:this._isNumber(a.maxHeight)?a.maxHeight:1/0},(this._aspectRatio||t)&&(e=o.minHeight*this.aspectRatio,s=o.minWidth/this.aspectRatio,i=o.maxHeight*this.aspectRatio,n=o.maxWidth/this.aspectRatio,e>o.minWidth&&(o.minWidth=e),s>o.minHeight&&(o.minHeight=s),o.maxWidth>i&&(o.maxWidth=i),o.maxHeight>n&&(o.maxHeight=n)),this._vBoundaries=o},_updateCache:function(t){this.offset=this.helper.offset(),this._isNumber(t.left)&&(this.position.left=t.left),this._isNumber(t.top)&&(this.position.top=t.top),this._isNumber(t.height)&&(this.size.height=t.height),this._isNumber(t.width)&&(this.size.width=t.width)},_updateRatio:function(t){var e=this.position,i=this.size,s=this.axis;return this._isNumber(t.height)?t.width=t.height*this.aspectRatio:this._isNumber(t.width)&&(t.height=t.width/this.aspectRatio),"sw"===s&&(t.left=e.left+(i.width-t.width),t.top=null),"nw"===s&&(t.top=e.top+(i.height-t.height),t.left=e.left+(i.width-t.width)),t},_respectSize:function(t){var e=this._vBoundaries,i=this.axis,s=this._isNumber(t.width)&&e.maxWidth&&e.maxWidth<t.width,n=this._isNumber(t.height)&&e.maxHeight&&e.maxHeight<t.height,o=this._isNumber(t.width)&&e.minWidth&&e.minWidth>t.width,a=this._isNumber(t.height)&&e.minHeight&&e.minHeight>t.height,r=this.originalPosition.left+this.originalSize.width,h=this.originalPosition.top+this.originalSize.height,l=/sw|nw|w/.test(i),c=/nw|ne|n/.test(i);return o&&(t.width=e.minWidth),a&&(t.height=e.minHeight),s&&(t.width=e.maxWidth),n&&(t.height=e.maxHeight),o&&l&&(t.left=r-e.minWidth),s&&l&&(t.left=r-e.maxWidth),a&&c&&(t.top=h-e.minHeight),n&&c&&(t.top=h-e.maxHeight),t.width||t.height||t.left||!t.top?t.width||t.height||t.top||!t.left||(t.left=null):t.top=null,t},_getPaddingPlusBorderDimensions:function(t){for(var e=0,i=[],s=[t.css("borderTopWidth"),t.css("borderRightWidth"),t.css("borderBottomWidth"),t.css("borderLeftWidth")],n=[t.css("paddingTop"),t.css("paddingRight"),t.css("paddingBottom"),t.css("paddingLeft")];4>e;e++)i[e]=parseFloat(s[e])||0,i[e]+=parseFloat(n[e])||0;return{height:i[0]+i[2],width:i[1]+i[3]}},_proportionallyResize:function(){if(this._proportionallyResizeElements.length)for(var t,e=0,i=this.helper||this.element;this._proportionallyResizeElements.length>e;e++)t=this._proportionallyResizeElements[e],this.outerDimensions||(this.outerDimensions=this._getPaddingPlusBorderDimensions(t)),t.css({height:i.height()-this.outerDimensions.height||0,width:i.width()-this.outerDimensions.width||0})},_renderProxy:function(){var e=this.element,i=this.options;this.elementOffset=e.offset(),this._helper?(this.helper=this.helper||t("<div style='overflow:hidden;'></div>"),this._addClass(this.helper,this._helper),this.helper.css({width:this.element.outerWidth(),height:this.element.outerHeight(),position:"absolute",left:this.elementOffset.left+"px",top:this.elementOffset.top+"px",zIndex:++i.zIndex}),this.helper.appendTo("body").disableSelection()):this.helper=this.element},_change:{e:function(t,e){return{width:this.originalSize.width+e}},w:function(t,e){var i=this.originalSize,s=this.originalPosition;return{left:s.left+e,width:i.width-e}},n:function(t,e,i){var s=this.originalSize,n=this.originalPosition;return{top:n.top+i,height:s.height-i}},s:function(t,e,i){return{height:this.originalSize.height+i}},se:function(e,i,s){return t.extend(this._change.s.apply(this,arguments),this._change.e.apply(this,[e,i,s]))},sw:function(e,i,s){return t.extend(this._change.s.apply(this,arguments),this._change.w.apply(this,[e,i,s]))},ne:function(e,i,s){return t.extend(this._change.n.apply(this,arguments),this._change.e.apply(this,[e,i,s]))},nw:function(e,i,s){return t.extend(this._change.n.apply(this,arguments),this._change.w.apply(this,[e,i,s]))}},_propagate:function(e,i){t.ui.plugin.call(this,e,[i,this.ui()]),"resize"!==e&&this._trigger(e,i,this.ui())},plugins:{},ui:function(){return{originalElement:this.originalElement,element:this.element,helper:this.helper,position:this.position,size:this.size,originalSize:this.originalSize,originalPosition:this.originalPosition}}}),t.ui.plugin.add("resizable","animate",{stop:function(e){var i=t(this).resizable("instance"),s=i.options,n=i._proportionallyResizeElements,o=n.length&&/textarea/i.test(n[0].nodeName),a=o&&i._hasScroll(n[0],"left")?0:i.sizeDiff.height,r=o?0:i.sizeDiff.width,h={width:i.size.width-r,height:i.size.height-a},l=parseFloat(i.element.css("left"))+(i.position.left-i.originalPosition.left)||null,c=parseFloat(i.element.css("top"))+(i.position.top-i.originalPosition.top)||null;i.element.animate(t.extend(h,c&&l?{top:c,left:l}:{}),{duration:s.animateDuration,easing:s.animateEasing,step:function(){var s={width:parseFloat(i.element.css("width")),height:parseFloat(i.element.css("height")),top:parseFloat(i.element.css("top")),left:parseFloat(i.element.css("left"))};n&&n.length&&t(n[0]).css({width:s.width,height:s.height}),i._updateCache(s),i._propagate("resize",e)}})}}),t.ui.plugin.add("resizable","containment",{start:function(){var e,i,s,n,o,a,r,h=t(this).resizable("instance"),l=h.options,c=h.element,u=l.containment,d=u instanceof t?u.get(0):/parent/.test(u)?c.parent().get(0):u;d&&(h.containerElement=t(d),/document/.test(u)||u===document?(h.containerOffset={left:0,top:0},h.containerPosition={left:0,top:0},h.parentData={element:t(document),left:0,top:0,width:t(document).width(),height:t(document).height()||document.body.parentNode.scrollHeight}):(e=t(d),i=[],t(["Top","Right","Left","Bottom"]).each(function(t,s){i[t]=h._num(e.css("padding"+s))}),h.containerOffset=e.offset(),h.containerPosition=e.position(),h.containerSize={height:e.innerHeight()-i[3],width:e.innerWidth()-i[1]},s=h.containerOffset,n=h.containerSize.height,o=h.containerSize.width,a=h._hasScroll(d,"left")?d.scrollWidth:o,r=h._hasScroll(d)?d.scrollHeight:n,h.parentData={element:d,left:s.left,top:s.top,width:a,height:r}))},resize:function(e){var i,s,n,o,a=t(this).resizable("instance"),r=a.options,h=a.containerOffset,l=a.position,c=a._aspectRatio||e.shiftKey,u={top:0,left:0},d=a.containerElement,p=!0;d[0]!==document&&/static/.test(d.css("position"))&&(u=h),l.left<(a._helper?h.left:0)&&(a.size.width=a.size.width+(a._helper?a.position.left-h.left:a.position.left-u.left),c&&(a.size.height=a.size.width/a.aspectRatio,p=!1),a.position.left=r.helper?h.left:0),l.top<(a._helper?h.top:0)&&(a.size.height=a.size.height+(a._helper?a.position.top-h.top:a.position.top),c&&(a.size.width=a.size.height*a.aspectRatio,p=!1),a.position.top=a._helper?h.top:0),n=a.containerElement.get(0)===a.element.parent().get(0),o=/relative|absolute/.test(a.containerElement.css("position")),n&&o?(a.offset.left=a.parentData.left+a.position.left,a.offset.top=a.parentData.top+a.position.top):(a.offset.left=a.element.offset().left,a.offset.top=a.element.offset().top),i=Math.abs(a.sizeDiff.width+(a._helper?a.offset.left-u.left:a.offset.left-h.left)),s=Math.abs(a.sizeDiff.height+(a._helper?a.offset.top-u.top:a.offset.top-h.top)),i+a.size.width>=a.parentData.width&&(a.size.width=a.parentData.width-i,c&&(a.size.height=a.size.width/a.aspectRatio,p=!1)),s+a.size.height>=a.parentData.height&&(a.size.height=a.parentData.height-s,c&&(a.size.width=a.size.height*a.aspectRatio,p=!1)),p||(a.position.left=a.prevPosition.left,a.position.top=a.prevPosition.top,a.size.width=a.prevSize.width,a.size.height=a.prevSize.height)},stop:function(){var e=t(this).resizable("instance"),i=e.options,s=e.containerOffset,n=e.containerPosition,o=e.containerElement,a=t(e.helper),r=a.offset(),h=a.outerWidth()-e.sizeDiff.width,l=a.outerHeight()-e.sizeDiff.height;e._helper&&!i.animate&&/relative/.test(o.css("position"))&&t(this).css({left:r.left-n.left-s.left,width:h,height:l}),e._helper&&!i.animate&&/static/.test(o.css("position"))&&t(this).css({left:r.left-n.left-s.left,width:h,height:l})}}),t.ui.plugin.add("resizable","alsoResize",{start:function(){var e=t(this).resizable("instance"),i=e.options;t(i.alsoResize).each(function(){var e=t(this);e.data("ui-resizable-alsoresize",{width:parseFloat(e.width()),height:parseFloat(e.height()),left:parseFloat(e.css("left")),top:parseFloat(e.css("top"))})})},resize:function(e,i){var s=t(this).resizable("instance"),n=s.options,o=s.originalSize,a=s.originalPosition,r={height:s.size.height-o.height||0,width:s.size.width-o.width||0,top:s.position.top-a.top||0,left:s.position.left-a.left||0};t(n.alsoResize).each(function(){var e=t(this),s=t(this).data("ui-resizable-alsoresize"),n={},o=e.parents(i.originalElement[0]).length?["width","height"]:["width","height","top","left"];t.each(o,function(t,e){var i=(s[e]||0)+(r[e]||0);i&&i>=0&&(n[e]=i||null)}),e.css(n)})},stop:function(){t(this).removeData("ui-resizable-alsoresize")}}),t.ui.plugin.add("resizable","ghost",{start:function(){var e=t(this).resizable("instance"),i=e.size;e.ghost=e.originalElement.clone(),e.ghost.css({opacity:.25,display:"block",position:"relative",height:i.height,width:i.width,margin:0,left:0,top:0}),e._addClass(e.ghost,"ui-resizable-ghost"),t.uiBackCompat!==!1&&"string"==typeof e.options.ghost&&e.ghost.addClass(this.options.ghost),e.ghost.appendTo(e.helper)},resize:function(){var e=t(this).resizable("instance");e.ghost&&e.ghost.css({position:"relative",height:e.size.height,width:e.size.width})},stop:function(){var e=t(this).resizable("instance");e.ghost&&e.helper&&e.helper.get(0).removeChild(e.ghost.get(0))}}),t.ui.plugin.add("resizable","grid",{resize:function(){var e,i=t(this).resizable("instance"),s=i.options,n=i.size,o=i.originalSize,a=i.originalPosition,r=i.axis,h="number"==typeof s.grid?[s.grid,s.grid]:s.grid,l=h[0]||1,c=h[1]||1,u=Math.round((n.width-o.width)/l)*l,d=Math.round((n.height-o.height)/c)*c,p=o.width+u,f=o.height+d,g=s.maxWidth&&p>s.maxWidth,m=s.maxHeight&&f>s.maxHeight,_=s.minWidth&&s.minWidth>p,v=s.minHeight&&s.minHeight>f;s.grid=h,_&&(p+=l),v&&(f+=c),g&&(p-=l),m&&(f-=c),/^(se|s|e)$/.test(r)?(i.size.width=p,i.size.height=f):/^(ne)$/.test(r)?(i.size.width=p,i.size.height=f,i.position.top=a.top-d):/^(sw)$/.test(r)?(i.size.width=p,i.size.height=f,i.position.left=a.left-u):((0>=f-c||0>=p-l)&&(e=i._getPaddingPlusBorderDimensions(this)),f-c>0?(i.size.height=f,i.position.top=a.top-d):(f=c-e.height,i.size.height=f,i.position.top=a.top+o.height-f),p-l>0?(i.size.width=p,i.position.left=a.left-u):(p=l-e.width,i.size.width=p,i.position.left=a.left+o.width-p))}}),t.ui.resizable,t.widget("ui.dialog",{version:"1.12.1",options:{appendTo:"body",autoOpen:!0,buttons:[],classes:{"ui-dialog":"ui-corner-all","ui-dialog-titlebar":"ui-corner-all"},closeOnEscape:!0,closeText:"Close",draggable:!0,hide:null,height:"auto",maxHeight:null,maxWidth:null,minHeight:150,minWidth:150,modal:!1,position:{my:"center",at:"center",of:window,collision:"fit",using:function(e){var i=t(this).css(e).offset().top;0>i&&t(this).css("top",e.top-i)}},resizable:!0,show:null,title:null,width:300,beforeClose:null,close:null,drag:null,dragStart:null,dragStop:null,focus:null,open:null,resize:null,resizeStart:null,resizeStop:null},sizeRelatedOptions:{buttons:!0,height:!0,maxHeight:!0,maxWidth:!0,minHeight:!0,minWidth:!0,width:!0},resizableRelatedOptions:{maxHeight:!0,maxWidth:!0,minHeight:!0,minWidth:!0},_create:function(){this.originalCss={display:this.element[0].style.display,width:this.element[0].style.width,minHeight:this.element[0].style.minHeight,maxHeight:this.element[0].style.maxHeight,height:this.element[0].style.height},this.originalPosition={parent:this.element.parent(),index:this.element.parent().children().index(this.element)},this.originalTitle=this.element.attr("title"),null==this.options.title&&null!=this.originalTitle&&(this.options.title=this.originalTitle),this.options.disabled&&(this.options.disabled=!1),this._createWrapper(),this.element.show().removeAttr("title").appendTo(this.uiDialog),this._addClass("ui-dialog-content","ui-widget-content"),this._createTitlebar(),this._createButtonPane(),this.options.draggable&&t.fn.draggable&&this._makeDraggable(),this.options.resizable&&t.fn.resizable&&this._makeResizable(),this._isOpen=!1,this._trackFocus()},_init:function(){this.options.autoOpen&&this.open()},_appendTo:function(){var e=this.options.appendTo;return e&&(e.jquery||e.nodeType)?t(e):this.document.find(e||"body").eq(0)},_destroy:function(){var t,e=this.originalPosition;this._untrackInstance(),this._destroyOverlay(),this.element.removeUniqueId().css(this.originalCss).detach(),this.uiDialog.remove(),this.originalTitle&&this.element.attr("title",this.originalTitle),t=e.parent.children().eq(e.index),t.length&&t[0]!==this.element[0]?t.before(this.element):e.parent.append(this.element)},widget:function(){return this.uiDialog
},disable:t.noop,enable:t.noop,close:function(e){var i=this;this._isOpen&&this._trigger("beforeClose",e)!==!1&&(this._isOpen=!1,this._focusedElement=null,this._destroyOverlay(),this._untrackInstance(),this.opener.filter(":focusable").trigger("focus").length||t.ui.safeBlur(t.ui.safeActiveElement(this.document[0])),this._hide(this.uiDialog,this.options.hide,function(){i._trigger("close",e)}))},isOpen:function(){return this._isOpen},moveToTop:function(){this._moveToTop()},_moveToTop:function(e,i){var s=!1,n=this.uiDialog.siblings(".ui-front:visible").map(function(){return+t(this).css("z-index")}).get(),o=Math.max.apply(null,n);return o>=+this.uiDialog.css("z-index")&&(this.uiDialog.css("z-index",o+1),s=!0),s&&!i&&this._trigger("focus",e),s},open:function(){var e=this;return this._isOpen?(this._moveToTop()&&this._focusTabbable(),void 0):(this._isOpen=!0,this.opener=t(t.ui.safeActiveElement(this.document[0])),this._size(),this._position(),this._createOverlay(),this._moveToTop(null,!0),this.overlay&&this.overlay.css("z-index",this.uiDialog.css("z-index")-1),this._show(this.uiDialog,this.options.show,function(){e._focusTabbable(),e._trigger("focus")}),this._makeFocusTarget(),this._trigger("open"),void 0)},_focusTabbable:function(){var t=this._focusedElement;t||(t=this.element.find("[autofocus]")),t.length||(t=this.element.find(":tabbable")),t.length||(t=this.uiDialogButtonPane.find(":tabbable")),t.length||(t=this.uiDialogTitlebarClose.filter(":tabbable")),t.length||(t=this.uiDialog),t.eq(0).trigger("focus")},_keepFocus:function(e){function i(){var e=t.ui.safeActiveElement(this.document[0]),i=this.uiDialog[0]===e||t.contains(this.uiDialog[0],e);i||this._focusTabbable()}e.preventDefault(),i.call(this),this._delay(i)},_createWrapper:function(){this.uiDialog=t("<div>").hide().attr({tabIndex:-1,role:"dialog"}).appendTo(this._appendTo()),this._addClass(this.uiDialog,"ui-dialog","ui-widget ui-widget-content ui-front"),this._on(this.uiDialog,{keydown:function(e){if(this.options.closeOnEscape&&!e.isDefaultPrevented()&&e.keyCode&&e.keyCode===t.ui.keyCode.ESCAPE)return e.preventDefault(),this.close(e),void 0;if(e.keyCode===t.ui.keyCode.TAB&&!e.isDefaultPrevented()){var i=this.uiDialog.find(":tabbable"),s=i.filter(":first"),n=i.filter(":last");e.target!==n[0]&&e.target!==this.uiDialog[0]||e.shiftKey?e.target!==s[0]&&e.target!==this.uiDialog[0]||!e.shiftKey||(this._delay(function(){n.trigger("focus")}),e.preventDefault()):(this._delay(function(){s.trigger("focus")}),e.preventDefault())}},mousedown:function(t){this._moveToTop(t)&&this._focusTabbable()}}),this.element.find("[aria-describedby]").length||this.uiDialog.attr({"aria-describedby":this.element.uniqueId().attr("id")})},_createTitlebar:function(){var e;this.uiDialogTitlebar=t("<div>"),this._addClass(this.uiDialogTitlebar,"ui-dialog-titlebar","ui-widget-header ui-helper-clearfix"),this._on(this.uiDialogTitlebar,{mousedown:function(e){t(e.target).closest(".ui-dialog-titlebar-close")||this.uiDialog.trigger("focus")}}),this.uiDialogTitlebarClose=t("<button type='button'></button>").button({label:t("<a>").text(this.options.closeText).html(),icon:"ui-icon-closethick",showLabel:!1}).appendTo(this.uiDialogTitlebar),this._addClass(this.uiDialogTitlebarClose,"ui-dialog-titlebar-close"),this._on(this.uiDialogTitlebarClose,{click:function(t){t.preventDefault(),this.close(t)}}),e=t("<span>").uniqueId().prependTo(this.uiDialogTitlebar),this._addClass(e,"ui-dialog-title"),this._title(e),this.uiDialogTitlebar.prependTo(this.uiDialog),this.uiDialog.attr({"aria-labelledby":e.attr("id")})},_title:function(t){this.options.title?t.text(this.options.title):t.html("&#160;")},_createButtonPane:function(){this.uiDialogButtonPane=t("<div>"),this._addClass(this.uiDialogButtonPane,"ui-dialog-buttonpane","ui-widget-content ui-helper-clearfix"),this.uiButtonSet=t("<div>").appendTo(this.uiDialogButtonPane),this._addClass(this.uiButtonSet,"ui-dialog-buttonset"),this._createButtons()},_createButtons:function(){var e=this,i=this.options.buttons;return this.uiDialogButtonPane.remove(),this.uiButtonSet.empty(),t.isEmptyObject(i)||t.isArray(i)&&!i.length?(this._removeClass(this.uiDialog,"ui-dialog-buttons"),void 0):(t.each(i,function(i,s){var n,o;s=t.isFunction(s)?{click:s,text:i}:s,s=t.extend({type:"button"},s),n=s.click,o={icon:s.icon,iconPosition:s.iconPosition,showLabel:s.showLabel,icons:s.icons,text:s.text},delete s.click,delete s.icon,delete s.iconPosition,delete s.showLabel,delete s.icons,"boolean"==typeof s.text&&delete s.text,t("<button></button>",s).button(o).appendTo(e.uiButtonSet).on("click",function(){n.apply(e.element[0],arguments)})}),this._addClass(this.uiDialog,"ui-dialog-buttons"),this.uiDialogButtonPane.appendTo(this.uiDialog),void 0)},_makeDraggable:function(){function e(t){return{position:t.position,offset:t.offset}}var i=this,s=this.options;this.uiDialog.draggable({cancel:".ui-dialog-content, .ui-dialog-titlebar-close",handle:".ui-dialog-titlebar",containment:"document",start:function(s,n){i._addClass(t(this),"ui-dialog-dragging"),i._blockFrames(),i._trigger("dragStart",s,e(n))},drag:function(t,s){i._trigger("drag",t,e(s))},stop:function(n,o){var a=o.offset.left-i.document.scrollLeft(),r=o.offset.top-i.document.scrollTop();s.position={my:"left top",at:"left"+(a>=0?"+":"")+a+" "+"top"+(r>=0?"+":"")+r,of:i.window},i._removeClass(t(this),"ui-dialog-dragging"),i._unblockFrames(),i._trigger("dragStop",n,e(o))}})},_makeResizable:function(){function e(t){return{originalPosition:t.originalPosition,originalSize:t.originalSize,position:t.position,size:t.size}}var i=this,s=this.options,n=s.resizable,o=this.uiDialog.css("position"),a="string"==typeof n?n:"n,e,s,w,se,sw,ne,nw";this.uiDialog.resizable({cancel:".ui-dialog-content",containment:"document",alsoResize:this.element,maxWidth:s.maxWidth,maxHeight:s.maxHeight,minWidth:s.minWidth,minHeight:this._minHeight(),handles:a,start:function(s,n){i._addClass(t(this),"ui-dialog-resizing"),i._blockFrames(),i._trigger("resizeStart",s,e(n))},resize:function(t,s){i._trigger("resize",t,e(s))},stop:function(n,o){var a=i.uiDialog.offset(),r=a.left-i.document.scrollLeft(),h=a.top-i.document.scrollTop();s.height=i.uiDialog.height(),s.width=i.uiDialog.width(),s.position={my:"left top",at:"left"+(r>=0?"+":"")+r+" "+"top"+(h>=0?"+":"")+h,of:i.window},i._removeClass(t(this),"ui-dialog-resizing"),i._unblockFrames(),i._trigger("resizeStop",n,e(o))}}).css("position",o)},_trackFocus:function(){this._on(this.widget(),{focusin:function(e){this._makeFocusTarget(),this._focusedElement=t(e.target)}})},_makeFocusTarget:function(){this._untrackInstance(),this._trackingInstances().unshift(this)},_untrackInstance:function(){var e=this._trackingInstances(),i=t.inArray(this,e);-1!==i&&e.splice(i,1)},_trackingInstances:function(){var t=this.document.data("ui-dialog-instances");return t||(t=[],this.document.data("ui-dialog-instances",t)),t},_minHeight:function(){var t=this.options;return"auto"===t.height?t.minHeight:Math.min(t.minHeight,t.height)},_position:function(){var t=this.uiDialog.is(":visible");t||this.uiDialog.show(),this.uiDialog.position(this.options.position),t||this.uiDialog.hide()},_setOptions:function(e){var i=this,s=!1,n={};t.each(e,function(t,e){i._setOption(t,e),t in i.sizeRelatedOptions&&(s=!0),t in i.resizableRelatedOptions&&(n[t]=e)}),s&&(this._size(),this._position()),this.uiDialog.is(":data(ui-resizable)")&&this.uiDialog.resizable("option",n)},_setOption:function(e,i){var s,n,o=this.uiDialog;"disabled"!==e&&(this._super(e,i),"appendTo"===e&&this.uiDialog.appendTo(this._appendTo()),"buttons"===e&&this._createButtons(),"closeText"===e&&this.uiDialogTitlebarClose.button({label:t("<a>").text(""+this.options.closeText).html()}),"draggable"===e&&(s=o.is(":data(ui-draggable)"),s&&!i&&o.draggable("destroy"),!s&&i&&this._makeDraggable()),"position"===e&&this._position(),"resizable"===e&&(n=o.is(":data(ui-resizable)"),n&&!i&&o.resizable("destroy"),n&&"string"==typeof i&&o.resizable("option","handles",i),n||i===!1||this._makeResizable()),"title"===e&&this._title(this.uiDialogTitlebar.find(".ui-dialog-title")))},_size:function(){var t,e,i,s=this.options;this.element.show().css({width:"auto",minHeight:0,maxHeight:"none",height:0}),s.minWidth>s.width&&(s.width=s.minWidth),t=this.uiDialog.css({height:"auto",width:s.width}).outerHeight(),e=Math.max(0,s.minHeight-t),i="number"==typeof s.maxHeight?Math.max(0,s.maxHeight-t):"none","auto"===s.height?this.element.css({minHeight:e,maxHeight:i,height:"auto"}):this.element.height(Math.max(0,s.height-t)),this.uiDialog.is(":data(ui-resizable)")&&this.uiDialog.resizable("option","minHeight",this._minHeight())},_blockFrames:function(){this.iframeBlocks=this.document.find("iframe").map(function(){var e=t(this);return t("<div>").css({position:"absolute",width:e.outerWidth(),height:e.outerHeight()}).appendTo(e.parent()).offset(e.offset())[0]})},_unblockFrames:function(){this.iframeBlocks&&(this.iframeBlocks.remove(),delete this.iframeBlocks)},_allowInteraction:function(e){return t(e.target).closest(".ui-dialog").length?!0:!!t(e.target).closest(".ui-datepicker").length},_createOverlay:function(){if(this.options.modal){var e=!0;this._delay(function(){e=!1}),this.document.data("ui-dialog-overlays")||this._on(this.document,{focusin:function(t){e||this._allowInteraction(t)||(t.preventDefault(),this._trackingInstances()[0]._focusTabbable())}}),this.overlay=t("<div>").appendTo(this._appendTo()),this._addClass(this.overlay,null,"ui-widget-overlay ui-front"),this._on(this.overlay,{mousedown:"_keepFocus"}),this.document.data("ui-dialog-overlays",(this.document.data("ui-dialog-overlays")||0)+1)}},_destroyOverlay:function(){if(this.options.modal&&this.overlay){var t=this.document.data("ui-dialog-overlays")-1;t?this.document.data("ui-dialog-overlays",t):(this._off(this.document,"focusin"),this.document.removeData("ui-dialog-overlays")),this.overlay.remove(),this.overlay=null}}}),t.uiBackCompat!==!1&&t.widget("ui.dialog",t.ui.dialog,{options:{dialogClass:""},_createWrapper:function(){this._super(),this.uiDialog.addClass(this.options.dialogClass)},_setOption:function(t,e){"dialogClass"===t&&this.uiDialog.removeClass(this.options.dialogClass).addClass(e),this._superApply(arguments)}}),t.ui.dialog,t.widget("ui.droppable",{version:"1.12.1",widgetEventPrefix:"drop",options:{accept:"*",addClasses:!0,greedy:!1,scope:"default",tolerance:"intersect",activate:null,deactivate:null,drop:null,out:null,over:null},_create:function(){var e,i=this.options,s=i.accept;this.isover=!1,this.isout=!0,this.accept=t.isFunction(s)?s:function(t){return t.is(s)},this.proportions=function(){return arguments.length?(e=arguments[0],void 0):e?e:e={width:this.element[0].offsetWidth,height:this.element[0].offsetHeight}},this._addToManager(i.scope),i.addClasses&&this._addClass("ui-droppable")},_addToManager:function(e){t.ui.ddmanager.droppables[e]=t.ui.ddmanager.droppables[e]||[],t.ui.ddmanager.droppables[e].push(this)},_splice:function(t){for(var e=0;t.length>e;e++)t[e]===this&&t.splice(e,1)},_destroy:function(){var e=t.ui.ddmanager.droppables[this.options.scope];this._splice(e)},_setOption:function(e,i){if("accept"===e)this.accept=t.isFunction(i)?i:function(t){return t.is(i)};else if("scope"===e){var s=t.ui.ddmanager.droppables[this.options.scope];this._splice(s),this._addToManager(i)}this._super(e,i)},_activate:function(e){var i=t.ui.ddmanager.current;this._addActiveClass(),i&&this._trigger("activate",e,this.ui(i))},_deactivate:function(e){var i=t.ui.ddmanager.current;this._removeActiveClass(),i&&this._trigger("deactivate",e,this.ui(i))},_over:function(e){var i=t.ui.ddmanager.current;i&&(i.currentItem||i.element)[0]!==this.element[0]&&this.accept.call(this.element[0],i.currentItem||i.element)&&(this._addHoverClass(),this._trigger("over",e,this.ui(i)))},_out:function(e){var i=t.ui.ddmanager.current;i&&(i.currentItem||i.element)[0]!==this.element[0]&&this.accept.call(this.element[0],i.currentItem||i.element)&&(this._removeHoverClass(),this._trigger("out",e,this.ui(i)))},_drop:function(e,i){var s=i||t.ui.ddmanager.current,n=!1;return s&&(s.currentItem||s.element)[0]!==this.element[0]?(this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function(){var i=t(this).droppable("instance");return i.options.greedy&&!i.options.disabled&&i.options.scope===s.options.scope&&i.accept.call(i.element[0],s.currentItem||s.element)&&v(s,t.extend(i,{offset:i.element.offset()}),i.options.tolerance,e)?(n=!0,!1):void 0}),n?!1:this.accept.call(this.element[0],s.currentItem||s.element)?(this._removeActiveClass(),this._removeHoverClass(),this._trigger("drop",e,this.ui(s)),this.element):!1):!1},ui:function(t){return{draggable:t.currentItem||t.element,helper:t.helper,position:t.position,offset:t.positionAbs}},_addHoverClass:function(){this._addClass("ui-droppable-hover")},_removeHoverClass:function(){this._removeClass("ui-droppable-hover")},_addActiveClass:function(){this._addClass("ui-droppable-active")},_removeActiveClass:function(){this._removeClass("ui-droppable-active")}});var v=t.ui.intersect=function(){function t(t,e,i){return t>=e&&e+i>t}return function(e,i,s,n){if(!i.offset)return!1;var o=(e.positionAbs||e.position.absolute).left+e.margins.left,a=(e.positionAbs||e.position.absolute).top+e.margins.top,r=o+e.helperProportions.width,h=a+e.helperProportions.height,l=i.offset.left,c=i.offset.top,u=l+i.proportions().width,d=c+i.proportions().height;switch(s){case"fit":return o>=l&&u>=r&&a>=c&&d>=h;case"intersect":return o+e.helperProportions.width/2>l&&u>r-e.helperProportions.width/2&&a+e.helperProportions.height/2>c&&d>h-e.helperProportions.height/2;case"pointer":return t(n.pageY,c,i.proportions().height)&&t(n.pageX,l,i.proportions().width);case"touch":return(a>=c&&d>=a||h>=c&&d>=h||c>a&&h>d)&&(o>=l&&u>=o||r>=l&&u>=r||l>o&&r>u);default:return!1}}}();t.ui.ddmanager={current:null,droppables:{"default":[]},prepareOffsets:function(e,i){var s,n,o=t.ui.ddmanager.droppables[e.options.scope]||[],a=i?i.type:null,r=(e.currentItem||e.element).find(":data(ui-droppable)").addBack();t:for(s=0;o.length>s;s++)if(!(o[s].options.disabled||e&&!o[s].accept.call(o[s].element[0],e.currentItem||e.element))){for(n=0;r.length>n;n++)if(r[n]===o[s].element[0]){o[s].proportions().height=0;continue t}o[s].visible="none"!==o[s].element.css("display"),o[s].visible&&("mousedown"===a&&o[s]._activate.call(o[s],i),o[s].offset=o[s].element.offset(),o[s].proportions({width:o[s].element[0].offsetWidth,height:o[s].element[0].offsetHeight}))}},drop:function(e,i){var s=!1;return t.each((t.ui.ddmanager.droppables[e.options.scope]||[]).slice(),function(){this.options&&(!this.options.disabled&&this.visible&&v(e,this,this.options.tolerance,i)&&(s=this._drop.call(this,i)||s),!this.options.disabled&&this.visible&&this.accept.call(this.element[0],e.currentItem||e.element)&&(this.isout=!0,this.isover=!1,this._deactivate.call(this,i)))}),s},dragStart:function(e,i){e.element.parentsUntil("body").on("scroll.droppable",function(){e.options.refreshPositions||t.ui.ddmanager.prepareOffsets(e,i)})},drag:function(e,i){e.options.refreshPositions&&t.ui.ddmanager.prepareOffsets(e,i),t.each(t.ui.ddmanager.droppables[e.options.scope]||[],function(){if(!this.options.disabled&&!this.greedyChild&&this.visible){var s,n,o,a=v(e,this,this.options.tolerance,i),r=!a&&this.isover?"isout":a&&!this.isover?"isover":null;r&&(this.options.greedy&&(n=this.options.scope,o=this.element.parents(":data(ui-droppable)").filter(function(){return t(this).droppable("instance").options.scope===n}),o.length&&(s=t(o[0]).droppable("instance"),s.greedyChild="isover"===r)),s&&"isover"===r&&(s.isover=!1,s.isout=!0,s._out.call(s,i)),this[r]=!0,this["isout"===r?"isover":"isout"]=!1,this["isover"===r?"_over":"_out"].call(this,i),s&&"isout"===r&&(s.isout=!1,s.isover=!0,s._over.call(s,i)))}})},dragStop:function(e,i){e.element.parentsUntil("body").off("scroll.droppable"),e.options.refreshPositions||t.ui.ddmanager.prepareOffsets(e,i)}},t.uiBackCompat!==!1&&t.widget("ui.droppable",t.ui.droppable,{options:{hoverClass:!1,activeClass:!1},_addActiveClass:function(){this._super(),this.options.activeClass&&this.element.addClass(this.options.activeClass)},_removeActiveClass:function(){this._super(),this.options.activeClass&&this.element.removeClass(this.options.activeClass)},_addHoverClass:function(){this._super(),this.options.hoverClass&&this.element.addClass(this.options.hoverClass)},_removeHoverClass:function(){this._super(),this.options.hoverClass&&this.element.removeClass(this.options.hoverClass)}}),t.ui.droppable,t.widget("ui.progressbar",{version:"1.12.1",options:{classes:{"ui-progressbar":"ui-corner-all","ui-progressbar-value":"ui-corner-left","ui-progressbar-complete":"ui-corner-right"},max:100,value:0,change:null,complete:null},min:0,_create:function(){this.oldValue=this.options.value=this._constrainedValue(),this.element.attr({role:"progressbar","aria-valuemin":this.min}),this._addClass("ui-progressbar","ui-widget ui-widget-content"),this.valueDiv=t("<div>").appendTo(this.element),this._addClass(this.valueDiv,"ui-progressbar-value","ui-widget-header"),this._refreshValue()},_destroy:function(){this.element.removeAttr("role aria-valuemin aria-valuemax aria-valuenow"),this.valueDiv.remove()},value:function(t){return void 0===t?this.options.value:(this.options.value=this._constrainedValue(t),this._refreshValue(),void 0)},_constrainedValue:function(t){return void 0===t&&(t=this.options.value),this.indeterminate=t===!1,"number"!=typeof t&&(t=0),this.indeterminate?!1:Math.min(this.options.max,Math.max(this.min,t))},_setOptions:function(t){var e=t.value;delete t.value,this._super(t),this.options.value=this._constrainedValue(e),this._refreshValue()},_setOption:function(t,e){"max"===t&&(e=Math.max(this.min,e)),this._super(t,e)},_setOptionDisabled:function(t){this._super(t),this.element.attr("aria-disabled",t),this._toggleClass(null,"ui-state-disabled",!!t)},_percentage:function(){return this.indeterminate?100:100*(this.options.value-this.min)/(this.options.max-this.min)},_refreshValue:function(){var e=this.options.value,i=this._percentage();this.valueDiv.toggle(this.indeterminate||e>this.min).width(i.toFixed(0)+"%"),this._toggleClass(this.valueDiv,"ui-progressbar-complete",null,e===this.options.max)._toggleClass("ui-progressbar-indeterminate",null,this.indeterminate),this.indeterminate?(this.element.removeAttr("aria-valuenow"),this.overlayDiv||(this.overlayDiv=t("<div>").appendTo(this.valueDiv),this._addClass(this.overlayDiv,"ui-progressbar-overlay"))):(this.element.attr({"aria-valuemax":this.options.max,"aria-valuenow":e}),this.overlayDiv&&(this.overlayDiv.remove(),this.overlayDiv=null)),this.oldValue!==e&&(this.oldValue=e,this._trigger("change")),e===this.options.max&&this._trigger("complete")}}),t.widget("ui.selectable",t.ui.mouse,{version:"1.12.1",options:{appendTo:"body",autoRefresh:!0,distance:0,filter:"*",tolerance:"touch",selected:null,selecting:null,start:null,stop:null,unselected:null,unselecting:null},_create:function(){var e=this;this._addClass("ui-selectable"),this.dragged=!1,this.refresh=function(){e.elementPos=t(e.element[0]).offset(),e.selectees=t(e.options.filter,e.element[0]),e._addClass(e.selectees,"ui-selectee"),e.selectees.each(function(){var i=t(this),s=i.offset(),n={left:s.left-e.elementPos.left,top:s.top-e.elementPos.top};t.data(this,"selectable-item",{element:this,$element:i,left:n.left,top:n.top,right:n.left+i.outerWidth(),bottom:n.top+i.outerHeight(),startselected:!1,selected:i.hasClass("ui-selected"),selecting:i.hasClass("ui-selecting"),unselecting:i.hasClass("ui-unselecting")})})},this.refresh(),this._mouseInit(),this.helper=t("<div>"),this._addClass(this.helper,"ui-selectable-helper")},_destroy:function(){this.selectees.removeData("selectable-item"),this._mouseDestroy()},_mouseStart:function(e){var i=this,s=this.options;this.opos=[e.pageX,e.pageY],this.elementPos=t(this.element[0]).offset(),this.options.disabled||(this.selectees=t(s.filter,this.element[0]),this._trigger("start",e),t(s.appendTo).append(this.helper),this.helper.css({left:e.pageX,top:e.pageY,width:0,height:0}),s.autoRefresh&&this.refresh(),this.selectees.filter(".ui-selected").each(function(){var s=t.data(this,"selectable-item");s.startselected=!0,e.metaKey||e.ctrlKey||(i._removeClass(s.$element,"ui-selected"),s.selected=!1,i._addClass(s.$element,"ui-unselecting"),s.unselecting=!0,i._trigger("unselecting",e,{unselecting:s.element}))}),t(e.target).parents().addBack().each(function(){var s,n=t.data(this,"selectable-item");return n?(s=!e.metaKey&&!e.ctrlKey||!n.$element.hasClass("ui-selected"),i._removeClass(n.$element,s?"ui-unselecting":"ui-selected")._addClass(n.$element,s?"ui-selecting":"ui-unselecting"),n.unselecting=!s,n.selecting=s,n.selected=s,s?i._trigger("selecting",e,{selecting:n.element}):i._trigger("unselecting",e,{unselecting:n.element}),!1):void 0}))},_mouseDrag:function(e){if(this.dragged=!0,!this.options.disabled){var i,s=this,n=this.options,o=this.opos[0],a=this.opos[1],r=e.pageX,h=e.pageY;return o>r&&(i=r,r=o,o=i),a>h&&(i=h,h=a,a=i),this.helper.css({left:o,top:a,width:r-o,height:h-a}),this.selectees.each(function(){var i=t.data(this,"selectable-item"),l=!1,c={};i&&i.element!==s.element[0]&&(c.left=i.left+s.elementPos.left,c.right=i.right+s.elementPos.left,c.top=i.top+s.elementPos.top,c.bottom=i.bottom+s.elementPos.top,"touch"===n.tolerance?l=!(c.left>r||o>c.right||c.top>h||a>c.bottom):"fit"===n.tolerance&&(l=c.left>o&&r>c.right&&c.top>a&&h>c.bottom),l?(i.selected&&(s._removeClass(i.$element,"ui-selected"),i.selected=!1),i.unselecting&&(s._removeClass(i.$element,"ui-unselecting"),i.unselecting=!1),i.selecting||(s._addClass(i.$element,"ui-selecting"),i.selecting=!0,s._trigger("selecting",e,{selecting:i.element}))):(i.selecting&&((e.metaKey||e.ctrlKey)&&i.startselected?(s._removeClass(i.$element,"ui-selecting"),i.selecting=!1,s._addClass(i.$element,"ui-selected"),i.selected=!0):(s._removeClass(i.$element,"ui-selecting"),i.selecting=!1,i.startselected&&(s._addClass(i.$element,"ui-unselecting"),i.unselecting=!0),s._trigger("unselecting",e,{unselecting:i.element}))),i.selected&&(e.metaKey||e.ctrlKey||i.startselected||(s._removeClass(i.$element,"ui-selected"),i.selected=!1,s._addClass(i.$element,"ui-unselecting"),i.unselecting=!0,s._trigger("unselecting",e,{unselecting:i.element})))))}),!1}},_mouseStop:function(e){var i=this;return this.dragged=!1,t(".ui-unselecting",this.element[0]).each(function(){var s=t.data(this,"selectable-item");i._removeClass(s.$element,"ui-unselecting"),s.unselecting=!1,s.startselected=!1,i._trigger("unselected",e,{unselected:s.element})}),t(".ui-selecting",this.element[0]).each(function(){var s=t.data(this,"selectable-item");i._removeClass(s.$element,"ui-selecting")._addClass(s.$element,"ui-selected"),s.selecting=!1,s.selected=!0,s.startselected=!0,i._trigger("selected",e,{selected:s.element})}),this._trigger("stop",e),this.helper.remove(),!1}}),t.widget("ui.selectmenu",[t.ui.formResetMixin,{version:"1.12.1",defaultElement:"<select>",options:{appendTo:null,classes:{"ui-selectmenu-button-open":"ui-corner-top","ui-selectmenu-button-closed":"ui-corner-all"},disabled:null,icons:{button:"ui-icon-triangle-1-s"},position:{my:"left top",at:"left bottom",collision:"none"},width:!1,change:null,close:null,focus:null,open:null,select:null},_create:function(){var e=this.element.uniqueId().attr("id");this.ids={element:e,button:e+"-button",menu:e+"-menu"},this._drawButton(),this._drawMenu(),this._bindFormResetHandler(),this._rendered=!1,this.menuItems=t()},_drawButton:function(){var e,i=this,s=this._parseOption(this.element.find("option:selected"),this.element[0].selectedIndex);this.labels=this.element.labels().attr("for",this.ids.button),this._on(this.labels,{click:function(t){this.button.focus(),t.preventDefault()}}),this.element.hide(),this.button=t("<span>",{tabindex:this.options.disabled?-1:0,id:this.ids.button,role:"combobox","aria-expanded":"false","aria-autocomplete":"list","aria-owns":this.ids.menu,"aria-haspopup":"true",title:this.element.attr("title")}).insertAfter(this.element),this._addClass(this.button,"ui-selectmenu-button ui-selectmenu-button-closed","ui-button ui-widget"),e=t("<span>").appendTo(this.button),this._addClass(e,"ui-selectmenu-icon","ui-icon "+this.options.icons.button),this.buttonItem=this._renderButtonItem(s).appendTo(this.button),this.options.width!==!1&&this._resizeButton(),this._on(this.button,this._buttonEvents),this.button.one("focusin",function(){i._rendered||i._refreshMenu()})},_drawMenu:function(){var e=this;this.menu=t("<ul>",{"aria-hidden":"true","aria-labelledby":this.ids.button,id:this.ids.menu}),this.menuWrap=t("<div>").append(this.menu),this._addClass(this.menuWrap,"ui-selectmenu-menu","ui-front"),this.menuWrap.appendTo(this._appendTo()),this.menuInstance=this.menu.menu({classes:{"ui-menu":"ui-corner-bottom"},role:"listbox",select:function(t,i){t.preventDefault(),e._setSelection(),e._select(i.item.data("ui-selectmenu-item"),t)},focus:function(t,i){var s=i.item.data("ui-selectmenu-item");null!=e.focusIndex&&s.index!==e.focusIndex&&(e._trigger("focus",t,{item:s}),e.isOpen||e._select(s,t)),e.focusIndex=s.index,e.button.attr("aria-activedescendant",e.menuItems.eq(s.index).attr("id"))}}).menu("instance"),this.menuInstance._off(this.menu,"mouseleave"),this.menuInstance._closeOnDocumentClick=function(){return!1},this.menuInstance._isDivider=function(){return!1}},refresh:function(){this._refreshMenu(),this.buttonItem.replaceWith(this.buttonItem=this._renderButtonItem(this._getSelectedItem().data("ui-selectmenu-item")||{})),null===this.options.width&&this._resizeButton()},_refreshMenu:function(){var t,e=this.element.find("option");this.menu.empty(),this._parseOptions(e),this._renderMenu(this.menu,this.items),this.menuInstance.refresh(),this.menuItems=this.menu.find("li").not(".ui-selectmenu-optgroup").find(".ui-menu-item-wrapper"),this._rendered=!0,e.length&&(t=this._getSelectedItem(),this.menuInstance.focus(null,t),this._setAria(t.data("ui-selectmenu-item")),this._setOption("disabled",this.element.prop("disabled")))},open:function(t){this.options.disabled||(this._rendered?(this._removeClass(this.menu.find(".ui-state-active"),null,"ui-state-active"),this.menuInstance.focus(null,this._getSelectedItem())):this._refreshMenu(),this.menuItems.length&&(this.isOpen=!0,this._toggleAttr(),this._resizeMenu(),this._position(),this._on(this.document,this._documentClick),this._trigger("open",t)))},_position:function(){this.menuWrap.position(t.extend({of:this.button},this.options.position))},close:function(t){this.isOpen&&(this.isOpen=!1,this._toggleAttr(),this.range=null,this._off(this.document),this._trigger("close",t))},widget:function(){return this.button},menuWidget:function(){return this.menu},_renderButtonItem:function(e){var i=t("<span>");return this._setText(i,e.label),this._addClass(i,"ui-selectmenu-text"),i},_renderMenu:function(e,i){var s=this,n="";t.each(i,function(i,o){var a;o.optgroup!==n&&(a=t("<li>",{text:o.optgroup}),s._addClass(a,"ui-selectmenu-optgroup","ui-menu-divider"+(o.element.parent("optgroup").prop("disabled")?" ui-state-disabled":"")),a.appendTo(e),n=o.optgroup),s._renderItemData(e,o)})},_renderItemData:function(t,e){return this._renderItem(t,e).data("ui-selectmenu-item",e)},_renderItem:function(e,i){var s=t("<li>"),n=t("<div>",{title:i.element.attr("title")});return i.disabled&&this._addClass(s,null,"ui-state-disabled"),this._setText(n,i.label),s.append(n).appendTo(e)},_setText:function(t,e){e?t.text(e):t.html("&#160;")},_move:function(t,e){var i,s,n=".ui-menu-item";this.isOpen?i=this.menuItems.eq(this.focusIndex).parent("li"):(i=this.menuItems.eq(this.element[0].selectedIndex).parent("li"),n+=":not(.ui-state-disabled)"),s="first"===t||"last"===t?i["first"===t?"prevAll":"nextAll"](n).eq(-1):i[t+"All"](n).eq(0),s.length&&this.menuInstance.focus(e,s)},_getSelectedItem:function(){return this.menuItems.eq(this.element[0].selectedIndex).parent("li")},_toggle:function(t){this[this.isOpen?"close":"open"](t)},_setSelection:function(){var t;this.range&&(window.getSelection?(t=window.getSelection(),t.removeAllRanges(),t.addRange(this.range)):this.range.select(),this.button.focus())},_documentClick:{mousedown:function(e){this.isOpen&&(t(e.target).closest(".ui-selectmenu-menu, #"+t.ui.escapeSelector(this.ids.button)).length||this.close(e))}},_buttonEvents:{mousedown:function(){var t;window.getSelection?(t=window.getSelection(),t.rangeCount&&(this.range=t.getRangeAt(0))):this.range=document.selection.createRange()},click:function(t){this._setSelection(),this._toggle(t)},keydown:function(e){var i=!0;switch(e.keyCode){case t.ui.keyCode.TAB:case t.ui.keyCode.ESCAPE:this.close(e),i=!1;break;case t.ui.keyCode.ENTER:this.isOpen&&this._selectFocusedItem(e);break;case t.ui.keyCode.UP:e.altKey?this._toggle(e):this._move("prev",e);break;case t.ui.keyCode.DOWN:e.altKey?this._toggle(e):this._move("next",e);break;case t.ui.keyCode.SPACE:this.isOpen?this._selectFocusedItem(e):this._toggle(e);break;case t.ui.keyCode.LEFT:this._move("prev",e);break;case t.ui.keyCode.RIGHT:this._move("next",e);break;case t.ui.keyCode.HOME:case t.ui.keyCode.PAGE_UP:this._move("first",e);break;case t.ui.keyCode.END:case t.ui.keyCode.PAGE_DOWN:this._move("last",e);break;default:this.menu.trigger(e),i=!1}i&&e.preventDefault()}},_selectFocusedItem:function(t){var e=this.menuItems.eq(this.focusIndex).parent("li");e.hasClass("ui-state-disabled")||this._select(e.data("ui-selectmenu-item"),t)},_select:function(t,e){var i=this.element[0].selectedIndex;this.element[0].selectedIndex=t.index,this.buttonItem.replaceWith(this.buttonItem=this._renderButtonItem(t)),this._setAria(t),this._trigger("select",e,{item:t}),t.index!==i&&this._trigger("change",e,{item:t}),this.close(e)},_setAria:function(t){var e=this.menuItems.eq(t.index).attr("id");this.button.attr({"aria-labelledby":e,"aria-activedescendant":e}),this.menu.attr("aria-activedescendant",e)},_setOption:function(t,e){if("icons"===t){var i=this.button.find("span.ui-icon");this._removeClass(i,null,this.options.icons.button)._addClass(i,null,e.button)}this._super(t,e),"appendTo"===t&&this.menuWrap.appendTo(this._appendTo()),"width"===t&&this._resizeButton()},_setOptionDisabled:function(t){this._super(t),this.menuInstance.option("disabled",t),this.button.attr("aria-disabled",t),this._toggleClass(this.button,null,"ui-state-disabled",t),this.element.prop("disabled",t),t?(this.button.attr("tabindex",-1),this.close()):this.button.attr("tabindex",0)},_appendTo:function(){var e=this.options.appendTo;return e&&(e=e.jquery||e.nodeType?t(e):this.document.find(e).eq(0)),e&&e[0]||(e=this.element.closest(".ui-front, dialog")),e.length||(e=this.document[0].body),e},_toggleAttr:function(){this.button.attr("aria-expanded",this.isOpen),this._removeClass(this.button,"ui-selectmenu-button-"+(this.isOpen?"closed":"open"))._addClass(this.button,"ui-selectmenu-button-"+(this.isOpen?"open":"closed"))._toggleClass(this.menuWrap,"ui-selectmenu-open",null,this.isOpen),this.menu.attr("aria-hidden",!this.isOpen)},_resizeButton:function(){var t=this.options.width;return t===!1?(this.button.css("width",""),void 0):(null===t&&(t=this.element.show().outerWidth(),this.element.hide()),this.button.outerWidth(t),void 0)},_resizeMenu:function(){this.menu.outerWidth(Math.max(this.button.outerWidth(),this.menu.width("").outerWidth()+1))},_getCreateOptions:function(){var t=this._super();return t.disabled=this.element.prop("disabled"),t},_parseOptions:function(e){var i=this,s=[];e.each(function(e,n){s.push(i._parseOption(t(n),e))}),this.items=s},_parseOption:function(t,e){var i=t.parent("optgroup");return{element:t,index:e,value:t.val(),label:t.text(),optgroup:i.attr("label")||"",disabled:i.prop("disabled")||t.prop("disabled")}},_destroy:function(){this._unbindFormResetHandler(),this.menuWrap.remove(),this.button.remove(),this.element.show(),this.element.removeUniqueId(),this.labels.attr("for",this.ids.element)}}]),t.widget("ui.slider",t.ui.mouse,{version:"1.12.1",widgetEventPrefix:"slide",options:{animate:!1,classes:{"ui-slider":"ui-corner-all","ui-slider-handle":"ui-corner-all","ui-slider-range":"ui-corner-all ui-widget-header"},distance:0,max:100,min:0,orientation:"horizontal",range:!1,step:1,value:0,values:null,change:null,slide:null,start:null,stop:null},numPages:5,_create:function(){this._keySliding=!1,this._mouseSliding=!1,this._animateOff=!0,this._handleIndex=null,this._detectOrientation(),this._mouseInit(),this._calculateNewMax(),this._addClass("ui-slider ui-slider-"+this.orientation,"ui-widget ui-widget-content"),this._refresh(),this._animateOff=!1
},_refresh:function(){this._createRange(),this._createHandles(),this._setupEvents(),this._refreshValue()},_createHandles:function(){var e,i,s=this.options,n=this.element.find(".ui-slider-handle"),o="<span tabindex='0'></span>",a=[];for(i=s.values&&s.values.length||1,n.length>i&&(n.slice(i).remove(),n=n.slice(0,i)),e=n.length;i>e;e++)a.push(o);this.handles=n.add(t(a.join("")).appendTo(this.element)),this._addClass(this.handles,"ui-slider-handle","ui-state-default"),this.handle=this.handles.eq(0),this.handles.each(function(e){t(this).data("ui-slider-handle-index",e).attr("tabIndex",0)})},_createRange:function(){var e=this.options;e.range?(e.range===!0&&(e.values?e.values.length&&2!==e.values.length?e.values=[e.values[0],e.values[0]]:t.isArray(e.values)&&(e.values=e.values.slice(0)):e.values=[this._valueMin(),this._valueMin()]),this.range&&this.range.length?(this._removeClass(this.range,"ui-slider-range-min ui-slider-range-max"),this.range.css({left:"",bottom:""})):(this.range=t("<div>").appendTo(this.element),this._addClass(this.range,"ui-slider-range")),("min"===e.range||"max"===e.range)&&this._addClass(this.range,"ui-slider-range-"+e.range)):(this.range&&this.range.remove(),this.range=null)},_setupEvents:function(){this._off(this.handles),this._on(this.handles,this._handleEvents),this._hoverable(this.handles),this._focusable(this.handles)},_destroy:function(){this.handles.remove(),this.range&&this.range.remove(),this._mouseDestroy()},_mouseCapture:function(e){var i,s,n,o,a,r,h,l,c=this,u=this.options;return u.disabled?!1:(this.elementSize={width:this.element.outerWidth(),height:this.element.outerHeight()},this.elementOffset=this.element.offset(),i={x:e.pageX,y:e.pageY},s=this._normValueFromMouse(i),n=this._valueMax()-this._valueMin()+1,this.handles.each(function(e){var i=Math.abs(s-c.values(e));(n>i||n===i&&(e===c._lastChangedValue||c.values(e)===u.min))&&(n=i,o=t(this),a=e)}),r=this._start(e,a),r===!1?!1:(this._mouseSliding=!0,this._handleIndex=a,this._addClass(o,null,"ui-state-active"),o.trigger("focus"),h=o.offset(),l=!t(e.target).parents().addBack().is(".ui-slider-handle"),this._clickOffset=l?{left:0,top:0}:{left:e.pageX-h.left-o.width()/2,top:e.pageY-h.top-o.height()/2-(parseInt(o.css("borderTopWidth"),10)||0)-(parseInt(o.css("borderBottomWidth"),10)||0)+(parseInt(o.css("marginTop"),10)||0)},this.handles.hasClass("ui-state-hover")||this._slide(e,a,s),this._animateOff=!0,!0))},_mouseStart:function(){return!0},_mouseDrag:function(t){var e={x:t.pageX,y:t.pageY},i=this._normValueFromMouse(e);return this._slide(t,this._handleIndex,i),!1},_mouseStop:function(t){return this._removeClass(this.handles,null,"ui-state-active"),this._mouseSliding=!1,this._stop(t,this._handleIndex),this._change(t,this._handleIndex),this._handleIndex=null,this._clickOffset=null,this._animateOff=!1,!1},_detectOrientation:function(){this.orientation="vertical"===this.options.orientation?"vertical":"horizontal"},_normValueFromMouse:function(t){var e,i,s,n,o;return"horizontal"===this.orientation?(e=this.elementSize.width,i=t.x-this.elementOffset.left-(this._clickOffset?this._clickOffset.left:0)):(e=this.elementSize.height,i=t.y-this.elementOffset.top-(this._clickOffset?this._clickOffset.top:0)),s=i/e,s>1&&(s=1),0>s&&(s=0),"vertical"===this.orientation&&(s=1-s),n=this._valueMax()-this._valueMin(),o=this._valueMin()+s*n,this._trimAlignValue(o)},_uiHash:function(t,e,i){var s={handle:this.handles[t],handleIndex:t,value:void 0!==e?e:this.value()};return this._hasMultipleValues()&&(s.value=void 0!==e?e:this.values(t),s.values=i||this.values()),s},_hasMultipleValues:function(){return this.options.values&&this.options.values.length},_start:function(t,e){return this._trigger("start",t,this._uiHash(e))},_slide:function(t,e,i){var s,n,o=this.value(),a=this.values();this._hasMultipleValues()&&(n=this.values(e?0:1),o=this.values(e),2===this.options.values.length&&this.options.range===!0&&(i=0===e?Math.min(n,i):Math.max(n,i)),a[e]=i),i!==o&&(s=this._trigger("slide",t,this._uiHash(e,i,a)),s!==!1&&(this._hasMultipleValues()?this.values(e,i):this.value(i)))},_stop:function(t,e){this._trigger("stop",t,this._uiHash(e))},_change:function(t,e){this._keySliding||this._mouseSliding||(this._lastChangedValue=e,this._trigger("change",t,this._uiHash(e)))},value:function(t){return arguments.length?(this.options.value=this._trimAlignValue(t),this._refreshValue(),this._change(null,0),void 0):this._value()},values:function(e,i){var s,n,o;if(arguments.length>1)return this.options.values[e]=this._trimAlignValue(i),this._refreshValue(),this._change(null,e),void 0;if(!arguments.length)return this._values();if(!t.isArray(arguments[0]))return this._hasMultipleValues()?this._values(e):this.value();for(s=this.options.values,n=arguments[0],o=0;s.length>o;o+=1)s[o]=this._trimAlignValue(n[o]),this._change(null,o);this._refreshValue()},_setOption:function(e,i){var s,n=0;switch("range"===e&&this.options.range===!0&&("min"===i?(this.options.value=this._values(0),this.options.values=null):"max"===i&&(this.options.value=this._values(this.options.values.length-1),this.options.values=null)),t.isArray(this.options.values)&&(n=this.options.values.length),this._super(e,i),e){case"orientation":this._detectOrientation(),this._removeClass("ui-slider-horizontal ui-slider-vertical")._addClass("ui-slider-"+this.orientation),this._refreshValue(),this.options.range&&this._refreshRange(i),this.handles.css("horizontal"===i?"bottom":"left","");break;case"value":this._animateOff=!0,this._refreshValue(),this._change(null,0),this._animateOff=!1;break;case"values":for(this._animateOff=!0,this._refreshValue(),s=n-1;s>=0;s--)this._change(null,s);this._animateOff=!1;break;case"step":case"min":case"max":this._animateOff=!0,this._calculateNewMax(),this._refreshValue(),this._animateOff=!1;break;case"range":this._animateOff=!0,this._refresh(),this._animateOff=!1}},_setOptionDisabled:function(t){this._super(t),this._toggleClass(null,"ui-state-disabled",!!t)},_value:function(){var t=this.options.value;return t=this._trimAlignValue(t)},_values:function(t){var e,i,s;if(arguments.length)return e=this.options.values[t],e=this._trimAlignValue(e);if(this._hasMultipleValues()){for(i=this.options.values.slice(),s=0;i.length>s;s+=1)i[s]=this._trimAlignValue(i[s]);return i}return[]},_trimAlignValue:function(t){if(this._valueMin()>=t)return this._valueMin();if(t>=this._valueMax())return this._valueMax();var e=this.options.step>0?this.options.step:1,i=(t-this._valueMin())%e,s=t-i;return 2*Math.abs(i)>=e&&(s+=i>0?e:-e),parseFloat(s.toFixed(5))},_calculateNewMax:function(){var t=this.options.max,e=this._valueMin(),i=this.options.step,s=Math.round((t-e)/i)*i;t=s+e,t>this.options.max&&(t-=i),this.max=parseFloat(t.toFixed(this._precision()))},_precision:function(){var t=this._precisionOf(this.options.step);return null!==this.options.min&&(t=Math.max(t,this._precisionOf(this.options.min))),t},_precisionOf:function(t){var e=""+t,i=e.indexOf(".");return-1===i?0:e.length-i-1},_valueMin:function(){return this.options.min},_valueMax:function(){return this.max},_refreshRange:function(t){"vertical"===t&&this.range.css({width:"",left:""}),"horizontal"===t&&this.range.css({height:"",bottom:""})},_refreshValue:function(){var e,i,s,n,o,a=this.options.range,r=this.options,h=this,l=this._animateOff?!1:r.animate,c={};this._hasMultipleValues()?this.handles.each(function(s){i=100*((h.values(s)-h._valueMin())/(h._valueMax()-h._valueMin())),c["horizontal"===h.orientation?"left":"bottom"]=i+"%",t(this).stop(1,1)[l?"animate":"css"](c,r.animate),h.options.range===!0&&("horizontal"===h.orientation?(0===s&&h.range.stop(1,1)[l?"animate":"css"]({left:i+"%"},r.animate),1===s&&h.range[l?"animate":"css"]({width:i-e+"%"},{queue:!1,duration:r.animate})):(0===s&&h.range.stop(1,1)[l?"animate":"css"]({bottom:i+"%"},r.animate),1===s&&h.range[l?"animate":"css"]({height:i-e+"%"},{queue:!1,duration:r.animate}))),e=i}):(s=this.value(),n=this._valueMin(),o=this._valueMax(),i=o!==n?100*((s-n)/(o-n)):0,c["horizontal"===this.orientation?"left":"bottom"]=i+"%",this.handle.stop(1,1)[l?"animate":"css"](c,r.animate),"min"===a&&"horizontal"===this.orientation&&this.range.stop(1,1)[l?"animate":"css"]({width:i+"%"},r.animate),"max"===a&&"horizontal"===this.orientation&&this.range.stop(1,1)[l?"animate":"css"]({width:100-i+"%"},r.animate),"min"===a&&"vertical"===this.orientation&&this.range.stop(1,1)[l?"animate":"css"]({height:i+"%"},r.animate),"max"===a&&"vertical"===this.orientation&&this.range.stop(1,1)[l?"animate":"css"]({height:100-i+"%"},r.animate))},_handleEvents:{keydown:function(e){var i,s,n,o,a=t(e.target).data("ui-slider-handle-index");switch(e.keyCode){case t.ui.keyCode.HOME:case t.ui.keyCode.END:case t.ui.keyCode.PAGE_UP:case t.ui.keyCode.PAGE_DOWN:case t.ui.keyCode.UP:case t.ui.keyCode.RIGHT:case t.ui.keyCode.DOWN:case t.ui.keyCode.LEFT:if(e.preventDefault(),!this._keySliding&&(this._keySliding=!0,this._addClass(t(e.target),null,"ui-state-active"),i=this._start(e,a),i===!1))return}switch(o=this.options.step,s=n=this._hasMultipleValues()?this.values(a):this.value(),e.keyCode){case t.ui.keyCode.HOME:n=this._valueMin();break;case t.ui.keyCode.END:n=this._valueMax();break;case t.ui.keyCode.PAGE_UP:n=this._trimAlignValue(s+(this._valueMax()-this._valueMin())/this.numPages);break;case t.ui.keyCode.PAGE_DOWN:n=this._trimAlignValue(s-(this._valueMax()-this._valueMin())/this.numPages);break;case t.ui.keyCode.UP:case t.ui.keyCode.RIGHT:if(s===this._valueMax())return;n=this._trimAlignValue(s+o);break;case t.ui.keyCode.DOWN:case t.ui.keyCode.LEFT:if(s===this._valueMin())return;n=this._trimAlignValue(s-o)}this._slide(e,a,n)},keyup:function(e){var i=t(e.target).data("ui-slider-handle-index");this._keySliding&&(this._keySliding=!1,this._stop(e,i),this._change(e,i),this._removeClass(t(e.target),null,"ui-state-active"))}}}),t.widget("ui.sortable",t.ui.mouse,{version:"1.12.1",widgetEventPrefix:"sort",ready:!1,options:{appendTo:"parent",axis:!1,connectWith:!1,containment:!1,cursor:"auto",cursorAt:!1,dropOnEmpty:!0,forcePlaceholderSize:!1,forceHelperSize:!1,grid:!1,handle:!1,helper:"original",items:"> *",opacity:!1,placeholder:!1,revert:!1,scroll:!0,scrollSensitivity:20,scrollSpeed:20,scope:"default",tolerance:"intersect",zIndex:1e3,activate:null,beforeStop:null,change:null,deactivate:null,out:null,over:null,receive:null,remove:null,sort:null,start:null,stop:null,update:null},_isOverAxis:function(t,e,i){return t>=e&&e+i>t},_isFloating:function(t){return/left|right/.test(t.css("float"))||/inline|table-cell/.test(t.css("display"))},_create:function(){this.containerCache={},this._addClass("ui-sortable"),this.refresh(),this.offset=this.element.offset(),this._mouseInit(),this._setHandleClassName(),this.ready=!0},_setOption:function(t,e){this._super(t,e),"handle"===t&&this._setHandleClassName()},_setHandleClassName:function(){var e=this;this._removeClass(this.element.find(".ui-sortable-handle"),"ui-sortable-handle"),t.each(this.items,function(){e._addClass(this.instance.options.handle?this.item.find(this.instance.options.handle):this.item,"ui-sortable-handle")})},_destroy:function(){this._mouseDestroy();for(var t=this.items.length-1;t>=0;t--)this.items[t].item.removeData(this.widgetName+"-item");return this},_mouseCapture:function(e,i){var s=null,n=!1,o=this;return this.reverting?!1:this.options.disabled||"static"===this.options.type?!1:(this._refreshItems(e),t(e.target).parents().each(function(){return t.data(this,o.widgetName+"-item")===o?(s=t(this),!1):void 0}),t.data(e.target,o.widgetName+"-item")===o&&(s=t(e.target)),s?!this.options.handle||i||(t(this.options.handle,s).find("*").addBack().each(function(){this===e.target&&(n=!0)}),n)?(this.currentItem=s,this._removeCurrentsFromItems(),!0):!1:!1)},_mouseStart:function(e,i,s){var n,o,a=this.options;if(this.currentContainer=this,this.refreshPositions(),this.helper=this._createHelper(e),this._cacheHelperProportions(),this._cacheMargins(),this.scrollParent=this.helper.scrollParent(),this.offset=this.currentItem.offset(),this.offset={top:this.offset.top-this.margins.top,left:this.offset.left-this.margins.left},t.extend(this.offset,{click:{left:e.pageX-this.offset.left,top:e.pageY-this.offset.top},parent:this._getParentOffset(),relative:this._getRelativeOffset()}),this.helper.css("position","absolute"),this.cssPosition=this.helper.css("position"),this.originalPosition=this._generatePosition(e),this.originalPageX=e.pageX,this.originalPageY=e.pageY,a.cursorAt&&this._adjustOffsetFromHelper(a.cursorAt),this.domPosition={prev:this.currentItem.prev()[0],parent:this.currentItem.parent()[0]},this.helper[0]!==this.currentItem[0]&&this.currentItem.hide(),this._createPlaceholder(),a.containment&&this._setContainment(),a.cursor&&"auto"!==a.cursor&&(o=this.document.find("body"),this.storedCursor=o.css("cursor"),o.css("cursor",a.cursor),this.storedStylesheet=t("<style>*{ cursor: "+a.cursor+" !important; }</style>").appendTo(o)),a.opacity&&(this.helper.css("opacity")&&(this._storedOpacity=this.helper.css("opacity")),this.helper.css("opacity",a.opacity)),a.zIndex&&(this.helper.css("zIndex")&&(this._storedZIndex=this.helper.css("zIndex")),this.helper.css("zIndex",a.zIndex)),this.scrollParent[0]!==this.document[0]&&"HTML"!==this.scrollParent[0].tagName&&(this.overflowOffset=this.scrollParent.offset()),this._trigger("start",e,this._uiHash()),this._preserveHelperProportions||this._cacheHelperProportions(),!s)for(n=this.containers.length-1;n>=0;n--)this.containers[n]._trigger("activate",e,this._uiHash(this));return t.ui.ddmanager&&(t.ui.ddmanager.current=this),t.ui.ddmanager&&!a.dropBehaviour&&t.ui.ddmanager.prepareOffsets(this,e),this.dragging=!0,this._addClass(this.helper,"ui-sortable-helper"),this._mouseDrag(e),!0},_mouseDrag:function(e){var i,s,n,o,a=this.options,r=!1;for(this.position=this._generatePosition(e),this.positionAbs=this._convertPositionTo("absolute"),this.lastPositionAbs||(this.lastPositionAbs=this.positionAbs),this.options.scroll&&(this.scrollParent[0]!==this.document[0]&&"HTML"!==this.scrollParent[0].tagName?(this.overflowOffset.top+this.scrollParent[0].offsetHeight-e.pageY<a.scrollSensitivity?this.scrollParent[0].scrollTop=r=this.scrollParent[0].scrollTop+a.scrollSpeed:e.pageY-this.overflowOffset.top<a.scrollSensitivity&&(this.scrollParent[0].scrollTop=r=this.scrollParent[0].scrollTop-a.scrollSpeed),this.overflowOffset.left+this.scrollParent[0].offsetWidth-e.pageX<a.scrollSensitivity?this.scrollParent[0].scrollLeft=r=this.scrollParent[0].scrollLeft+a.scrollSpeed:e.pageX-this.overflowOffset.left<a.scrollSensitivity&&(this.scrollParent[0].scrollLeft=r=this.scrollParent[0].scrollLeft-a.scrollSpeed)):(e.pageY-this.document.scrollTop()<a.scrollSensitivity?r=this.document.scrollTop(this.document.scrollTop()-a.scrollSpeed):this.window.height()-(e.pageY-this.document.scrollTop())<a.scrollSensitivity&&(r=this.document.scrollTop(this.document.scrollTop()+a.scrollSpeed)),e.pageX-this.document.scrollLeft()<a.scrollSensitivity?r=this.document.scrollLeft(this.document.scrollLeft()-a.scrollSpeed):this.window.width()-(e.pageX-this.document.scrollLeft())<a.scrollSensitivity&&(r=this.document.scrollLeft(this.document.scrollLeft()+a.scrollSpeed))),r!==!1&&t.ui.ddmanager&&!a.dropBehaviour&&t.ui.ddmanager.prepareOffsets(this,e)),this.positionAbs=this._convertPositionTo("absolute"),this.options.axis&&"y"===this.options.axis||(this.helper[0].style.left=this.position.left+"px"),this.options.axis&&"x"===this.options.axis||(this.helper[0].style.top=this.position.top+"px"),i=this.items.length-1;i>=0;i--)if(s=this.items[i],n=s.item[0],o=this._intersectsWithPointer(s),o&&s.instance===this.currentContainer&&n!==this.currentItem[0]&&this.placeholder[1===o?"next":"prev"]()[0]!==n&&!t.contains(this.placeholder[0],n)&&("semi-dynamic"===this.options.type?!t.contains(this.element[0],n):!0)){if(this.direction=1===o?"down":"up","pointer"!==this.options.tolerance&&!this._intersectsWithSides(s))break;this._rearrange(e,s),this._trigger("change",e,this._uiHash());break}return this._contactContainers(e),t.ui.ddmanager&&t.ui.ddmanager.drag(this,e),this._trigger("sort",e,this._uiHash()),this.lastPositionAbs=this.positionAbs,!1},_mouseStop:function(e,i){if(e){if(t.ui.ddmanager&&!this.options.dropBehaviour&&t.ui.ddmanager.drop(this,e),this.options.revert){var s=this,n=this.placeholder.offset(),o=this.options.axis,a={};o&&"x"!==o||(a.left=n.left-this.offset.parent.left-this.margins.left+(this.offsetParent[0]===this.document[0].body?0:this.offsetParent[0].scrollLeft)),o&&"y"!==o||(a.top=n.top-this.offset.parent.top-this.margins.top+(this.offsetParent[0]===this.document[0].body?0:this.offsetParent[0].scrollTop)),this.reverting=!0,t(this.helper).animate(a,parseInt(this.options.revert,10)||500,function(){s._clear(e)})}else this._clear(e,i);return!1}},cancel:function(){if(this.dragging){this._mouseUp(new t.Event("mouseup",{target:null})),"original"===this.options.helper?(this.currentItem.css(this._storedCSS),this._removeClass(this.currentItem,"ui-sortable-helper")):this.currentItem.show();for(var e=this.containers.length-1;e>=0;e--)this.containers[e]._trigger("deactivate",null,this._uiHash(this)),this.containers[e].containerCache.over&&(this.containers[e]._trigger("out",null,this._uiHash(this)),this.containers[e].containerCache.over=0)}return this.placeholder&&(this.placeholder[0].parentNode&&this.placeholder[0].parentNode.removeChild(this.placeholder[0]),"original"!==this.options.helper&&this.helper&&this.helper[0].parentNode&&this.helper.remove(),t.extend(this,{helper:null,dragging:!1,reverting:!1,_noFinalSort:null}),this.domPosition.prev?t(this.domPosition.prev).after(this.currentItem):t(this.domPosition.parent).prepend(this.currentItem)),this},serialize:function(e){var i=this._getItemsAsjQuery(e&&e.connected),s=[];return e=e||{},t(i).each(function(){var i=(t(e.item||this).attr(e.attribute||"id")||"").match(e.expression||/(.+)[\-=_](.+)/);i&&s.push((e.key||i[1]+"[]")+"="+(e.key&&e.expression?i[1]:i[2]))}),!s.length&&e.key&&s.push(e.key+"="),s.join("&")},toArray:function(e){var i=this._getItemsAsjQuery(e&&e.connected),s=[];return e=e||{},i.each(function(){s.push(t(e.item||this).attr(e.attribute||"id")||"")}),s},_intersectsWith:function(t){var e=this.positionAbs.left,i=e+this.helperProportions.width,s=this.positionAbs.top,n=s+this.helperProportions.height,o=t.left,a=o+t.width,r=t.top,h=r+t.height,l=this.offset.click.top,c=this.offset.click.left,u="x"===this.options.axis||s+l>r&&h>s+l,d="y"===this.options.axis||e+c>o&&a>e+c,p=u&&d;return"pointer"===this.options.tolerance||this.options.forcePointerForContainers||"pointer"!==this.options.tolerance&&this.helperProportions[this.floating?"width":"height"]>t[this.floating?"width":"height"]?p:e+this.helperProportions.width/2>o&&a>i-this.helperProportions.width/2&&s+this.helperProportions.height/2>r&&h>n-this.helperProportions.height/2},_intersectsWithPointer:function(t){var e,i,s="x"===this.options.axis||this._isOverAxis(this.positionAbs.top+this.offset.click.top,t.top,t.height),n="y"===this.options.axis||this._isOverAxis(this.positionAbs.left+this.offset.click.left,t.left,t.width),o=s&&n;return o?(e=this._getDragVerticalDirection(),i=this._getDragHorizontalDirection(),this.floating?"right"===i||"down"===e?2:1:e&&("down"===e?2:1)):!1},_intersectsWithSides:function(t){var e=this._isOverAxis(this.positionAbs.top+this.offset.click.top,t.top+t.height/2,t.height),i=this._isOverAxis(this.positionAbs.left+this.offset.click.left,t.left+t.width/2,t.width),s=this._getDragVerticalDirection(),n=this._getDragHorizontalDirection();return this.floating&&n?"right"===n&&i||"left"===n&&!i:s&&("down"===s&&e||"up"===s&&!e)},_getDragVerticalDirection:function(){var t=this.positionAbs.top-this.lastPositionAbs.top;return 0!==t&&(t>0?"down":"up")},_getDragHorizontalDirection:function(){var t=this.positionAbs.left-this.lastPositionAbs.left;return 0!==t&&(t>0?"right":"left")},refresh:function(t){return this._refreshItems(t),this._setHandleClassName(),this.refreshPositions(),this},_connectWith:function(){var t=this.options;return t.connectWith.constructor===String?[t.connectWith]:t.connectWith},_getItemsAsjQuery:function(e){function i(){r.push(this)}var s,n,o,a,r=[],h=[],l=this._connectWith();if(l&&e)for(s=l.length-1;s>=0;s--)for(o=t(l[s],this.document[0]),n=o.length-1;n>=0;n--)a=t.data(o[n],this.widgetFullName),a&&a!==this&&!a.options.disabled&&h.push([t.isFunction(a.options.items)?a.options.items.call(a.element):t(a.options.items,a.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),a]);for(h.push([t.isFunction(this.options.items)?this.options.items.call(this.element,null,{options:this.options,item:this.currentItem}):t(this.options.items,this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),this]),s=h.length-1;s>=0;s--)h[s][0].each(i);return t(r)},_removeCurrentsFromItems:function(){var e=this.currentItem.find(":data("+this.widgetName+"-item)");this.items=t.grep(this.items,function(t){for(var i=0;e.length>i;i++)if(e[i]===t.item[0])return!1;return!0})},_refreshItems:function(e){this.items=[],this.containers=[this];var i,s,n,o,a,r,h,l,c=this.items,u=[[t.isFunction(this.options.items)?this.options.items.call(this.element[0],e,{item:this.currentItem}):t(this.options.items,this.element),this]],d=this._connectWith();if(d&&this.ready)for(i=d.length-1;i>=0;i--)for(n=t(d[i],this.document[0]),s=n.length-1;s>=0;s--)o=t.data(n[s],this.widgetFullName),o&&o!==this&&!o.options.disabled&&(u.push([t.isFunction(o.options.items)?o.options.items.call(o.element[0],e,{item:this.currentItem}):t(o.options.items,o.element),o]),this.containers.push(o));for(i=u.length-1;i>=0;i--)for(a=u[i][1],r=u[i][0],s=0,l=r.length;l>s;s++)h=t(r[s]),h.data(this.widgetName+"-item",a),c.push({item:h,instance:a,width:0,height:0,left:0,top:0})},refreshPositions:function(e){this.floating=this.items.length?"x"===this.options.axis||this._isFloating(this.items[0].item):!1,this.offsetParent&&this.helper&&(this.offset.parent=this._getParentOffset());var i,s,n,o;for(i=this.items.length-1;i>=0;i--)s=this.items[i],s.instance!==this.currentContainer&&this.currentContainer&&s.item[0]!==this.currentItem[0]||(n=this.options.toleranceElement?t(this.options.toleranceElement,s.item):s.item,e||(s.width=n.outerWidth(),s.height=n.outerHeight()),o=n.offset(),s.left=o.left,s.top=o.top);if(this.options.custom&&this.options.custom.refreshContainers)this.options.custom.refreshContainers.call(this);else for(i=this.containers.length-1;i>=0;i--)o=this.containers[i].element.offset(),this.containers[i].containerCache.left=o.left,this.containers[i].containerCache.top=o.top,this.containers[i].containerCache.width=this.containers[i].element.outerWidth(),this.containers[i].containerCache.height=this.containers[i].element.outerHeight();return this},_createPlaceholder:function(e){e=e||this;var i,s=e.options;s.placeholder&&s.placeholder.constructor!==String||(i=s.placeholder,s.placeholder={element:function(){var s=e.currentItem[0].nodeName.toLowerCase(),n=t("<"+s+">",e.document[0]);return e._addClass(n,"ui-sortable-placeholder",i||e.currentItem[0].className)._removeClass(n,"ui-sortable-helper"),"tbody"===s?e._createTrPlaceholder(e.currentItem.find("tr").eq(0),t("<tr>",e.document[0]).appendTo(n)):"tr"===s?e._createTrPlaceholder(e.currentItem,n):"img"===s&&n.attr("src",e.currentItem.attr("src")),i||n.css("visibility","hidden"),n},update:function(t,n){(!i||s.forcePlaceholderSize)&&(n.height()||n.height(e.currentItem.innerHeight()-parseInt(e.currentItem.css("paddingTop")||0,10)-parseInt(e.currentItem.css("paddingBottom")||0,10)),n.width()||n.width(e.currentItem.innerWidth()-parseInt(e.currentItem.css("paddingLeft")||0,10)-parseInt(e.currentItem.css("paddingRight")||0,10)))}}),e.placeholder=t(s.placeholder.element.call(e.element,e.currentItem)),e.currentItem.after(e.placeholder),s.placeholder.update(e,e.placeholder)},_createTrPlaceholder:function(e,i){var s=this;e.children().each(function(){t("<td>&#160;</td>",s.document[0]).attr("colspan",t(this).attr("colspan")||1).appendTo(i)})},_contactContainers:function(e){var i,s,n,o,a,r,h,l,c,u,d=null,p=null;for(i=this.containers.length-1;i>=0;i--)if(!t.contains(this.currentItem[0],this.containers[i].element[0]))if(this._intersectsWith(this.containers[i].containerCache)){if(d&&t.contains(this.containers[i].element[0],d.element[0]))continue;d=this.containers[i],p=i}else this.containers[i].containerCache.over&&(this.containers[i]._trigger("out",e,this._uiHash(this)),this.containers[i].containerCache.over=0);if(d)if(1===this.containers.length)this.containers[p].containerCache.over||(this.containers[p]._trigger("over",e,this._uiHash(this)),this.containers[p].containerCache.over=1);else{for(n=1e4,o=null,c=d.floating||this._isFloating(this.currentItem),a=c?"left":"top",r=c?"width":"height",u=c?"pageX":"pageY",s=this.items.length-1;s>=0;s--)t.contains(this.containers[p].element[0],this.items[s].item[0])&&this.items[s].item[0]!==this.currentItem[0]&&(h=this.items[s].item.offset()[a],l=!1,e[u]-h>this.items[s][r]/2&&(l=!0),n>Math.abs(e[u]-h)&&(n=Math.abs(e[u]-h),o=this.items[s],this.direction=l?"up":"down"));if(!o&&!this.options.dropOnEmpty)return;if(this.currentContainer===this.containers[p])return this.currentContainer.containerCache.over||(this.containers[p]._trigger("over",e,this._uiHash()),this.currentContainer.containerCache.over=1),void 0;o?this._rearrange(e,o,null,!0):this._rearrange(e,null,this.containers[p].element,!0),this._trigger("change",e,this._uiHash()),this.containers[p]._trigger("change",e,this._uiHash(this)),this.currentContainer=this.containers[p],this.options.placeholder.update(this.currentContainer,this.placeholder),this.containers[p]._trigger("over",e,this._uiHash(this)),this.containers[p].containerCache.over=1}},_createHelper:function(e){var i=this.options,s=t.isFunction(i.helper)?t(i.helper.apply(this.element[0],[e,this.currentItem])):"clone"===i.helper?this.currentItem.clone():this.currentItem;return s.parents("body").length||t("parent"!==i.appendTo?i.appendTo:this.currentItem[0].parentNode)[0].appendChild(s[0]),s[0]===this.currentItem[0]&&(this._storedCSS={width:this.currentItem[0].style.width,height:this.currentItem[0].style.height,position:this.currentItem.css("position"),top:this.currentItem.css("top"),left:this.currentItem.css("left")}),(!s[0].style.width||i.forceHelperSize)&&s.width(this.currentItem.width()),(!s[0].style.height||i.forceHelperSize)&&s.height(this.currentItem.height()),s},_adjustOffsetFromHelper:function(e){"string"==typeof e&&(e=e.split(" ")),t.isArray(e)&&(e={left:+e[0],top:+e[1]||0}),"left"in e&&(this.offset.click.left=e.left+this.margins.left),"right"in e&&(this.offset.click.left=this.helperProportions.width-e.right+this.margins.left),"top"in e&&(this.offset.click.top=e.top+this.margins.top),"bottom"in e&&(this.offset.click.top=this.helperProportions.height-e.bottom+this.margins.top)},_getParentOffset:function(){this.offsetParent=this.helper.offsetParent();var e=this.offsetParent.offset();return"absolute"===this.cssPosition&&this.scrollParent[0]!==this.document[0]&&t.contains(this.scrollParent[0],this.offsetParent[0])&&(e.left+=this.scrollParent.scrollLeft(),e.top+=this.scrollParent.scrollTop()),(this.offsetParent[0]===this.document[0].body||this.offsetParent[0].tagName&&"html"===this.offsetParent[0].tagName.toLowerCase()&&t.ui.ie)&&(e={top:0,left:0}),{top:e.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:e.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"===this.cssPosition){var t=this.currentItem.position();return{top:t.top-(parseInt(this.helper.css("top"),10)||0)+this.scrollParent.scrollTop(),left:t.left-(parseInt(this.helper.css("left"),10)||0)+this.scrollParent.scrollLeft()}}return{top:0,left:0}},_cacheMargins:function(){this.margins={left:parseInt(this.currentItem.css("marginLeft"),10)||0,top:parseInt(this.currentItem.css("marginTop"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var e,i,s,n=this.options;"parent"===n.containment&&(n.containment=this.helper[0].parentNode),("document"===n.containment||"window"===n.containment)&&(this.containment=[0-this.offset.relative.left-this.offset.parent.left,0-this.offset.relative.top-this.offset.parent.top,"document"===n.containment?this.document.width():this.window.width()-this.helperProportions.width-this.margins.left,("document"===n.containment?this.document.height()||document.body.parentNode.scrollHeight:this.window.height()||this.document[0].body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top]),/^(document|window|parent)$/.test(n.containment)||(e=t(n.containment)[0],i=t(n.containment).offset(),s="hidden"!==t(e).css("overflow"),this.containment=[i.left+(parseInt(t(e).css("borderLeftWidth"),10)||0)+(parseInt(t(e).css("paddingLeft"),10)||0)-this.margins.left,i.top+(parseInt(t(e).css("borderTopWidth"),10)||0)+(parseInt(t(e).css("paddingTop"),10)||0)-this.margins.top,i.left+(s?Math.max(e.scrollWidth,e.offsetWidth):e.offsetWidth)-(parseInt(t(e).css("borderLeftWidth"),10)||0)-(parseInt(t(e).css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left,i.top+(s?Math.max(e.scrollHeight,e.offsetHeight):e.offsetHeight)-(parseInt(t(e).css("borderTopWidth"),10)||0)-(parseInt(t(e).css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top])},_convertPositionTo:function(e,i){i||(i=this.position);var s="absolute"===e?1:-1,n="absolute"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&t.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,o=/(html|body)/i.test(n[0].tagName);return{top:i.top+this.offset.relative.top*s+this.offset.parent.top*s-("fixed"===this.cssPosition?-this.scrollParent.scrollTop():o?0:n.scrollTop())*s,left:i.left+this.offset.relative.left*s+this.offset.parent.left*s-("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():o?0:n.scrollLeft())*s}},_generatePosition:function(e){var i,s,n=this.options,o=e.pageX,a=e.pageY,r="absolute"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&t.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,h=/(html|body)/i.test(r[0].tagName);return"relative"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&this.scrollParent[0]!==this.offsetParent[0]||(this.offset.relative=this._getRelativeOffset()),this.originalPosition&&(this.containment&&(e.pageX-this.offset.click.left<this.containment[0]&&(o=this.containment[0]+this.offset.click.left),e.pageY-this.offset.click.top<this.containment[1]&&(a=this.containment[1]+this.offset.click.top),e.pageX-this.offset.click.left>this.containment[2]&&(o=this.containment[2]+this.offset.click.left),e.pageY-this.offset.click.top>this.containment[3]&&(a=this.containment[3]+this.offset.click.top)),n.grid&&(i=this.originalPageY+Math.round((a-this.originalPageY)/n.grid[1])*n.grid[1],a=this.containment?i-this.offset.click.top>=this.containment[1]&&i-this.offset.click.top<=this.containment[3]?i:i-this.offset.click.top>=this.containment[1]?i-n.grid[1]:i+n.grid[1]:i,s=this.originalPageX+Math.round((o-this.originalPageX)/n.grid[0])*n.grid[0],o=this.containment?s-this.offset.click.left>=this.containment[0]&&s-this.offset.click.left<=this.containment[2]?s:s-this.offset.click.left>=this.containment[0]?s-n.grid[0]:s+n.grid[0]:s)),{top:a-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.scrollParent.scrollTop():h?0:r.scrollTop()),left:o-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():h?0:r.scrollLeft())}},_rearrange:function(t,e,i,s){i?i[0].appendChild(this.placeholder[0]):e.item[0].parentNode.insertBefore(this.placeholder[0],"down"===this.direction?e.item[0]:e.item[0].nextSibling),this.counter=this.counter?++this.counter:1;var n=this.counter;
this._delay(function(){n===this.counter&&this.refreshPositions(!s)})},_clear:function(t,e){function i(t,e,i){return function(s){i._trigger(t,s,e._uiHash(e))}}this.reverting=!1;var s,n=[];if(!this._noFinalSort&&this.currentItem.parent().length&&this.placeholder.before(this.currentItem),this._noFinalSort=null,this.helper[0]===this.currentItem[0]){for(s in this._storedCSS)("auto"===this._storedCSS[s]||"static"===this._storedCSS[s])&&(this._storedCSS[s]="");this.currentItem.css(this._storedCSS),this._removeClass(this.currentItem,"ui-sortable-helper")}else this.currentItem.show();for(this.fromOutside&&!e&&n.push(function(t){this._trigger("receive",t,this._uiHash(this.fromOutside))}),!this.fromOutside&&this.domPosition.prev===this.currentItem.prev().not(".ui-sortable-helper")[0]&&this.domPosition.parent===this.currentItem.parent()[0]||e||n.push(function(t){this._trigger("update",t,this._uiHash())}),this!==this.currentContainer&&(e||(n.push(function(t){this._trigger("remove",t,this._uiHash())}),n.push(function(t){return function(e){t._trigger("receive",e,this._uiHash(this))}}.call(this,this.currentContainer)),n.push(function(t){return function(e){t._trigger("update",e,this._uiHash(this))}}.call(this,this.currentContainer)))),s=this.containers.length-1;s>=0;s--)e||n.push(i("deactivate",this,this.containers[s])),this.containers[s].containerCache.over&&(n.push(i("out",this,this.containers[s])),this.containers[s].containerCache.over=0);if(this.storedCursor&&(this.document.find("body").css("cursor",this.storedCursor),this.storedStylesheet.remove()),this._storedOpacity&&this.helper.css("opacity",this._storedOpacity),this._storedZIndex&&this.helper.css("zIndex","auto"===this._storedZIndex?"":this._storedZIndex),this.dragging=!1,e||this._trigger("beforeStop",t,this._uiHash()),this.placeholder[0].parentNode.removeChild(this.placeholder[0]),this.cancelHelperRemoval||(this.helper[0]!==this.currentItem[0]&&this.helper.remove(),this.helper=null),!e){for(s=0;n.length>s;s++)n[s].call(this,t);this._trigger("stop",t,this._uiHash())}return this.fromOutside=!1,!this.cancelHelperRemoval},_trigger:function(){t.Widget.prototype._trigger.apply(this,arguments)===!1&&this.cancel()},_uiHash:function(e){var i=e||this;return{helper:i.helper,placeholder:i.placeholder||t([]),position:i.position,originalPosition:i.originalPosition,offset:i.positionAbs,item:i.currentItem,sender:e?e.element:null}}}),t.widget("ui.spinner",{version:"1.12.1",defaultElement:"<input>",widgetEventPrefix:"spin",options:{classes:{"ui-spinner":"ui-corner-all","ui-spinner-down":"ui-corner-br","ui-spinner-up":"ui-corner-tr"},culture:null,icons:{down:"ui-icon-triangle-1-s",up:"ui-icon-triangle-1-n"},incremental:!0,max:null,min:null,numberFormat:null,page:10,step:1,change:null,spin:null,start:null,stop:null},_create:function(){this._setOption("max",this.options.max),this._setOption("min",this.options.min),this._setOption("step",this.options.step),""!==this.value()&&this._value(this.element.val(),!0),this._draw(),this._on(this._events),this._refresh(),this._on(this.window,{beforeunload:function(){this.element.removeAttr("autocomplete")}})},_getCreateOptions:function(){var e=this._super(),i=this.element;return t.each(["min","max","step"],function(t,s){var n=i.attr(s);null!=n&&n.length&&(e[s]=n)}),e},_events:{keydown:function(t){this._start(t)&&this._keydown(t)&&t.preventDefault()},keyup:"_stop",focus:function(){this.previous=this.element.val()},blur:function(t){return this.cancelBlur?(delete this.cancelBlur,void 0):(this._stop(),this._refresh(),this.previous!==this.element.val()&&this._trigger("change",t),void 0)},mousewheel:function(t,e){if(e){if(!this.spinning&&!this._start(t))return!1;this._spin((e>0?1:-1)*this.options.step,t),clearTimeout(this.mousewheelTimer),this.mousewheelTimer=this._delay(function(){this.spinning&&this._stop(t)},100),t.preventDefault()}},"mousedown .ui-spinner-button":function(e){function i(){var e=this.element[0]===t.ui.safeActiveElement(this.document[0]);e||(this.element.trigger("focus"),this.previous=s,this._delay(function(){this.previous=s}))}var s;s=this.element[0]===t.ui.safeActiveElement(this.document[0])?this.previous:this.element.val(),e.preventDefault(),i.call(this),this.cancelBlur=!0,this._delay(function(){delete this.cancelBlur,i.call(this)}),this._start(e)!==!1&&this._repeat(null,t(e.currentTarget).hasClass("ui-spinner-up")?1:-1,e)},"mouseup .ui-spinner-button":"_stop","mouseenter .ui-spinner-button":function(e){return t(e.currentTarget).hasClass("ui-state-active")?this._start(e)===!1?!1:(this._repeat(null,t(e.currentTarget).hasClass("ui-spinner-up")?1:-1,e),void 0):void 0},"mouseleave .ui-spinner-button":"_stop"},_enhance:function(){this.uiSpinner=this.element.attr("autocomplete","off").wrap("<span>").parent().append("<a></a><a></a>")},_draw:function(){this._enhance(),this._addClass(this.uiSpinner,"ui-spinner","ui-widget ui-widget-content"),this._addClass("ui-spinner-input"),this.element.attr("role","spinbutton"),this.buttons=this.uiSpinner.children("a").attr("tabIndex",-1).attr("aria-hidden",!0).button({classes:{"ui-button":""}}),this._removeClass(this.buttons,"ui-corner-all"),this._addClass(this.buttons.first(),"ui-spinner-button ui-spinner-up"),this._addClass(this.buttons.last(),"ui-spinner-button ui-spinner-down"),this.buttons.first().button({icon:this.options.icons.up,showLabel:!1}),this.buttons.last().button({icon:this.options.icons.down,showLabel:!1}),this.buttons.height()>Math.ceil(.5*this.uiSpinner.height())&&this.uiSpinner.height()>0&&this.uiSpinner.height(this.uiSpinner.height())},_keydown:function(e){var i=this.options,s=t.ui.keyCode;switch(e.keyCode){case s.UP:return this._repeat(null,1,e),!0;case s.DOWN:return this._repeat(null,-1,e),!0;case s.PAGE_UP:return this._repeat(null,i.page,e),!0;case s.PAGE_DOWN:return this._repeat(null,-i.page,e),!0}return!1},_start:function(t){return this.spinning||this._trigger("start",t)!==!1?(this.counter||(this.counter=1),this.spinning=!0,!0):!1},_repeat:function(t,e,i){t=t||500,clearTimeout(this.timer),this.timer=this._delay(function(){this._repeat(40,e,i)},t),this._spin(e*this.options.step,i)},_spin:function(t,e){var i=this.value()||0;this.counter||(this.counter=1),i=this._adjustValue(i+t*this._increment(this.counter)),this.spinning&&this._trigger("spin",e,{value:i})===!1||(this._value(i),this.counter++)},_increment:function(e){var i=this.options.incremental;return i?t.isFunction(i)?i(e):Math.floor(e*e*e/5e4-e*e/500+17*e/200+1):1},_precision:function(){var t=this._precisionOf(this.options.step);return null!==this.options.min&&(t=Math.max(t,this._precisionOf(this.options.min))),t},_precisionOf:function(t){var e=""+t,i=e.indexOf(".");return-1===i?0:e.length-i-1},_adjustValue:function(t){var e,i,s=this.options;return e=null!==s.min?s.min:0,i=t-e,i=Math.round(i/s.step)*s.step,t=e+i,t=parseFloat(t.toFixed(this._precision())),null!==s.max&&t>s.max?s.max:null!==s.min&&s.min>t?s.min:t},_stop:function(t){this.spinning&&(clearTimeout(this.timer),clearTimeout(this.mousewheelTimer),this.counter=0,this.spinning=!1,this._trigger("stop",t))},_setOption:function(t,e){var i,s,n;return"culture"===t||"numberFormat"===t?(i=this._parse(this.element.val()),this.options[t]=e,this.element.val(this._format(i)),void 0):(("max"===t||"min"===t||"step"===t)&&"string"==typeof e&&(e=this._parse(e)),"icons"===t&&(s=this.buttons.first().find(".ui-icon"),this._removeClass(s,null,this.options.icons.up),this._addClass(s,null,e.up),n=this.buttons.last().find(".ui-icon"),this._removeClass(n,null,this.options.icons.down),this._addClass(n,null,e.down)),this._super(t,e),void 0)},_setOptionDisabled:function(t){this._super(t),this._toggleClass(this.uiSpinner,null,"ui-state-disabled",!!t),this.element.prop("disabled",!!t),this.buttons.button(t?"disable":"enable")},_setOptions:r(function(t){this._super(t)}),_parse:function(t){return"string"==typeof t&&""!==t&&(t=window.Globalize&&this.options.numberFormat?Globalize.parseFloat(t,10,this.options.culture):+t),""===t||isNaN(t)?null:t},_format:function(t){return""===t?"":window.Globalize&&this.options.numberFormat?Globalize.format(t,this.options.numberFormat,this.options.culture):t},_refresh:function(){this.element.attr({"aria-valuemin":this.options.min,"aria-valuemax":this.options.max,"aria-valuenow":this._parse(this.element.val())})},isValid:function(){var t=this.value();return null===t?!1:t===this._adjustValue(t)},_value:function(t,e){var i;""!==t&&(i=this._parse(t),null!==i&&(e||(i=this._adjustValue(i)),t=this._format(i))),this.element.val(t),this._refresh()},_destroy:function(){this.element.prop("disabled",!1).removeAttr("autocomplete role aria-valuemin aria-valuemax aria-valuenow"),this.uiSpinner.replaceWith(this.element)},stepUp:r(function(t){this._stepUp(t)}),_stepUp:function(t){this._start()&&(this._spin((t||1)*this.options.step),this._stop())},stepDown:r(function(t){this._stepDown(t)}),_stepDown:function(t){this._start()&&(this._spin((t||1)*-this.options.step),this._stop())},pageUp:r(function(t){this._stepUp((t||1)*this.options.page)}),pageDown:r(function(t){this._stepDown((t||1)*this.options.page)}),value:function(t){return arguments.length?(r(this._value).call(this,t),void 0):this._parse(this.element.val())},widget:function(){return this.uiSpinner}}),t.uiBackCompat!==!1&&t.widget("ui.spinner",t.ui.spinner,{_enhance:function(){this.uiSpinner=this.element.attr("autocomplete","off").wrap(this._uiSpinnerHtml()).parent().append(this._buttonHtml())},_uiSpinnerHtml:function(){return"<span>"},_buttonHtml:function(){return"<a></a><a></a>"}}),t.ui.spinner,t.widget("ui.tabs",{version:"1.12.1",delay:300,options:{active:null,classes:{"ui-tabs":"ui-corner-all","ui-tabs-nav":"ui-corner-all","ui-tabs-panel":"ui-corner-bottom","ui-tabs-tab":"ui-corner-top"},collapsible:!1,event:"click",heightStyle:"content",hide:null,show:null,activate:null,beforeActivate:null,beforeLoad:null,load:null},_isLocal:function(){var t=/#.*$/;return function(e){var i,s;i=e.href.replace(t,""),s=location.href.replace(t,"");try{i=decodeURIComponent(i)}catch(n){}try{s=decodeURIComponent(s)}catch(n){}return e.hash.length>1&&i===s}}(),_create:function(){var e=this,i=this.options;this.running=!1,this._addClass("ui-tabs","ui-widget ui-widget-content"),this._toggleClass("ui-tabs-collapsible",null,i.collapsible),this._processTabs(),i.active=this._initialActive(),t.isArray(i.disabled)&&(i.disabled=t.unique(i.disabled.concat(t.map(this.tabs.filter(".ui-state-disabled"),function(t){return e.tabs.index(t)}))).sort()),this.active=this.options.active!==!1&&this.anchors.length?this._findActive(i.active):t(),this._refresh(),this.active.length&&this.load(i.active)},_initialActive:function(){var e=this.options.active,i=this.options.collapsible,s=location.hash.substring(1);return null===e&&(s&&this.tabs.each(function(i,n){return t(n).attr("aria-controls")===s?(e=i,!1):void 0}),null===e&&(e=this.tabs.index(this.tabs.filter(".ui-tabs-active"))),(null===e||-1===e)&&(e=this.tabs.length?0:!1)),e!==!1&&(e=this.tabs.index(this.tabs.eq(e)),-1===e&&(e=i?!1:0)),!i&&e===!1&&this.anchors.length&&(e=0),e},_getCreateEventData:function(){return{tab:this.active,panel:this.active.length?this._getPanelForTab(this.active):t()}},_tabKeydown:function(e){var i=t(t.ui.safeActiveElement(this.document[0])).closest("li"),s=this.tabs.index(i),n=!0;if(!this._handlePageNav(e)){switch(e.keyCode){case t.ui.keyCode.RIGHT:case t.ui.keyCode.DOWN:s++;break;case t.ui.keyCode.UP:case t.ui.keyCode.LEFT:n=!1,s--;break;case t.ui.keyCode.END:s=this.anchors.length-1;break;case t.ui.keyCode.HOME:s=0;break;case t.ui.keyCode.SPACE:return e.preventDefault(),clearTimeout(this.activating),this._activate(s),void 0;case t.ui.keyCode.ENTER:return e.preventDefault(),clearTimeout(this.activating),this._activate(s===this.options.active?!1:s),void 0;default:return}e.preventDefault(),clearTimeout(this.activating),s=this._focusNextTab(s,n),e.ctrlKey||e.metaKey||(i.attr("aria-selected","false"),this.tabs.eq(s).attr("aria-selected","true"),this.activating=this._delay(function(){this.option("active",s)},this.delay))}},_panelKeydown:function(e){this._handlePageNav(e)||e.ctrlKey&&e.keyCode===t.ui.keyCode.UP&&(e.preventDefault(),this.active.trigger("focus"))},_handlePageNav:function(e){return e.altKey&&e.keyCode===t.ui.keyCode.PAGE_UP?(this._activate(this._focusNextTab(this.options.active-1,!1)),!0):e.altKey&&e.keyCode===t.ui.keyCode.PAGE_DOWN?(this._activate(this._focusNextTab(this.options.active+1,!0)),!0):void 0},_findNextTab:function(e,i){function s(){return e>n&&(e=0),0>e&&(e=n),e}for(var n=this.tabs.length-1;-1!==t.inArray(s(),this.options.disabled);)e=i?e+1:e-1;return e},_focusNextTab:function(t,e){return t=this._findNextTab(t,e),this.tabs.eq(t).trigger("focus"),t},_setOption:function(t,e){return"active"===t?(this._activate(e),void 0):(this._super(t,e),"collapsible"===t&&(this._toggleClass("ui-tabs-collapsible",null,e),e||this.options.active!==!1||this._activate(0)),"event"===t&&this._setupEvents(e),"heightStyle"===t&&this._setupHeightStyle(e),void 0)},_sanitizeSelector:function(t){return t?t.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g,"\\$&"):""},refresh:function(){var e=this.options,i=this.tablist.children(":has(a[href])");e.disabled=t.map(i.filter(".ui-state-disabled"),function(t){return i.index(t)}),this._processTabs(),e.active!==!1&&this.anchors.length?this.active.length&&!t.contains(this.tablist[0],this.active[0])?this.tabs.length===e.disabled.length?(e.active=!1,this.active=t()):this._activate(this._findNextTab(Math.max(0,e.active-1),!1)):e.active=this.tabs.index(this.active):(e.active=!1,this.active=t()),this._refresh()},_refresh:function(){this._setOptionDisabled(this.options.disabled),this._setupEvents(this.options.event),this._setupHeightStyle(this.options.heightStyle),this.tabs.not(this.active).attr({"aria-selected":"false","aria-expanded":"false",tabIndex:-1}),this.panels.not(this._getPanelForTab(this.active)).hide().attr({"aria-hidden":"true"}),this.active.length?(this.active.attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0}),this._addClass(this.active,"ui-tabs-active","ui-state-active"),this._getPanelForTab(this.active).show().attr({"aria-hidden":"false"})):this.tabs.eq(0).attr("tabIndex",0)},_processTabs:function(){var e=this,i=this.tabs,s=this.anchors,n=this.panels;this.tablist=this._getList().attr("role","tablist"),this._addClass(this.tablist,"ui-tabs-nav","ui-helper-reset ui-helper-clearfix ui-widget-header"),this.tablist.on("mousedown"+this.eventNamespace,"> li",function(e){t(this).is(".ui-state-disabled")&&e.preventDefault()}).on("focus"+this.eventNamespace,".ui-tabs-anchor",function(){t(this).closest("li").is(".ui-state-disabled")&&this.blur()}),this.tabs=this.tablist.find("> li:has(a[href])").attr({role:"tab",tabIndex:-1}),this._addClass(this.tabs,"ui-tabs-tab","ui-state-default"),this.anchors=this.tabs.map(function(){return t("a",this)[0]}).attr({role:"presentation",tabIndex:-1}),this._addClass(this.anchors,"ui-tabs-anchor"),this.panels=t(),this.anchors.each(function(i,s){var n,o,a,r=t(s).uniqueId().attr("id"),h=t(s).closest("li"),l=h.attr("aria-controls");e._isLocal(s)?(n=s.hash,a=n.substring(1),o=e.element.find(e._sanitizeSelector(n))):(a=h.attr("aria-controls")||t({}).uniqueId()[0].id,n="#"+a,o=e.element.find(n),o.length||(o=e._createPanel(a),o.insertAfter(e.panels[i-1]||e.tablist)),o.attr("aria-live","polite")),o.length&&(e.panels=e.panels.add(o)),l&&h.data("ui-tabs-aria-controls",l),h.attr({"aria-controls":a,"aria-labelledby":r}),o.attr("aria-labelledby",r)}),this.panels.attr("role","tabpanel"),this._addClass(this.panels,"ui-tabs-panel","ui-widget-content"),i&&(this._off(i.not(this.tabs)),this._off(s.not(this.anchors)),this._off(n.not(this.panels)))},_getList:function(){return this.tablist||this.element.find("ol, ul").eq(0)},_createPanel:function(e){return t("<div>").attr("id",e).data("ui-tabs-destroy",!0)},_setOptionDisabled:function(e){var i,s,n;for(t.isArray(e)&&(e.length?e.length===this.anchors.length&&(e=!0):e=!1),n=0;s=this.tabs[n];n++)i=t(s),e===!0||-1!==t.inArray(n,e)?(i.attr("aria-disabled","true"),this._addClass(i,null,"ui-state-disabled")):(i.removeAttr("aria-disabled"),this._removeClass(i,null,"ui-state-disabled"));this.options.disabled=e,this._toggleClass(this.widget(),this.widgetFullName+"-disabled",null,e===!0)},_setupEvents:function(e){var i={};e&&t.each(e.split(" "),function(t,e){i[e]="_eventHandler"}),this._off(this.anchors.add(this.tabs).add(this.panels)),this._on(!0,this.anchors,{click:function(t){t.preventDefault()}}),this._on(this.anchors,i),this._on(this.tabs,{keydown:"_tabKeydown"}),this._on(this.panels,{keydown:"_panelKeydown"}),this._focusable(this.tabs),this._hoverable(this.tabs)},_setupHeightStyle:function(e){var i,s=this.element.parent();"fill"===e?(i=s.height(),i-=this.element.outerHeight()-this.element.height(),this.element.siblings(":visible").each(function(){var e=t(this),s=e.css("position");"absolute"!==s&&"fixed"!==s&&(i-=e.outerHeight(!0))}),this.element.children().not(this.panels).each(function(){i-=t(this).outerHeight(!0)}),this.panels.each(function(){t(this).height(Math.max(0,i-t(this).innerHeight()+t(this).height()))}).css("overflow","auto")):"auto"===e&&(i=0,this.panels.each(function(){i=Math.max(i,t(this).height("").height())}).height(i))},_eventHandler:function(e){var i=this.options,s=this.active,n=t(e.currentTarget),o=n.closest("li"),a=o[0]===s[0],r=a&&i.collapsible,h=r?t():this._getPanelForTab(o),l=s.length?this._getPanelForTab(s):t(),c={oldTab:s,oldPanel:l,newTab:r?t():o,newPanel:h};e.preventDefault(),o.hasClass("ui-state-disabled")||o.hasClass("ui-tabs-loading")||this.running||a&&!i.collapsible||this._trigger("beforeActivate",e,c)===!1||(i.active=r?!1:this.tabs.index(o),this.active=a?t():o,this.xhr&&this.xhr.abort(),l.length||h.length||t.error("jQuery UI Tabs: Mismatching fragment identifier."),h.length&&this.load(this.tabs.index(o),e),this._toggle(e,c))},_toggle:function(e,i){function s(){o.running=!1,o._trigger("activate",e,i)}function n(){o._addClass(i.newTab.closest("li"),"ui-tabs-active","ui-state-active"),a.length&&o.options.show?o._show(a,o.options.show,s):(a.show(),s())}var o=this,a=i.newPanel,r=i.oldPanel;this.running=!0,r.length&&this.options.hide?this._hide(r,this.options.hide,function(){o._removeClass(i.oldTab.closest("li"),"ui-tabs-active","ui-state-active"),n()}):(this._removeClass(i.oldTab.closest("li"),"ui-tabs-active","ui-state-active"),r.hide(),n()),r.attr("aria-hidden","true"),i.oldTab.attr({"aria-selected":"false","aria-expanded":"false"}),a.length&&r.length?i.oldTab.attr("tabIndex",-1):a.length&&this.tabs.filter(function(){return 0===t(this).attr("tabIndex")}).attr("tabIndex",-1),a.attr("aria-hidden","false"),i.newTab.attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0})},_activate:function(e){var i,s=this._findActive(e);s[0]!==this.active[0]&&(s.length||(s=this.active),i=s.find(".ui-tabs-anchor")[0],this._eventHandler({target:i,currentTarget:i,preventDefault:t.noop}))},_findActive:function(e){return e===!1?t():this.tabs.eq(e)},_getIndex:function(e){return"string"==typeof e&&(e=this.anchors.index(this.anchors.filter("[href$='"+t.ui.escapeSelector(e)+"']"))),e},_destroy:function(){this.xhr&&this.xhr.abort(),this.tablist.removeAttr("role").off(this.eventNamespace),this.anchors.removeAttr("role tabIndex").removeUniqueId(),this.tabs.add(this.panels).each(function(){t.data(this,"ui-tabs-destroy")?t(this).remove():t(this).removeAttr("role tabIndex aria-live aria-busy aria-selected aria-labelledby aria-hidden aria-expanded")}),this.tabs.each(function(){var e=t(this),i=e.data("ui-tabs-aria-controls");i?e.attr("aria-controls",i).removeData("ui-tabs-aria-controls"):e.removeAttr("aria-controls")}),this.panels.show(),"content"!==this.options.heightStyle&&this.panels.css("height","")},enable:function(e){var i=this.options.disabled;i!==!1&&(void 0===e?i=!1:(e=this._getIndex(e),i=t.isArray(i)?t.map(i,function(t){return t!==e?t:null}):t.map(this.tabs,function(t,i){return i!==e?i:null})),this._setOptionDisabled(i))},disable:function(e){var i=this.options.disabled;if(i!==!0){if(void 0===e)i=!0;else{if(e=this._getIndex(e),-1!==t.inArray(e,i))return;i=t.isArray(i)?t.merge([e],i).sort():[e]}this._setOptionDisabled(i)}},load:function(e,i){e=this._getIndex(e);var s=this,n=this.tabs.eq(e),o=n.find(".ui-tabs-anchor"),a=this._getPanelForTab(n),r={tab:n,panel:a},h=function(t,e){"abort"===e&&s.panels.stop(!1,!0),s._removeClass(n,"ui-tabs-loading"),a.removeAttr("aria-busy"),t===s.xhr&&delete s.xhr};this._isLocal(o[0])||(this.xhr=t.ajax(this._ajaxSettings(o,i,r)),this.xhr&&"canceled"!==this.xhr.statusText&&(this._addClass(n,"ui-tabs-loading"),a.attr("aria-busy","true"),this.xhr.done(function(t,e,n){setTimeout(function(){a.html(t),s._trigger("load",i,r),h(n,e)},1)}).fail(function(t,e){setTimeout(function(){h(t,e)},1)})))},_ajaxSettings:function(e,i,s){var n=this;return{url:e.attr("href").replace(/#.*$/,""),beforeSend:function(e,o){return n._trigger("beforeLoad",i,t.extend({jqXHR:e,ajaxSettings:o},s))}}},_getPanelForTab:function(e){var i=t(e).attr("aria-controls");return this.element.find(this._sanitizeSelector("#"+i))}}),t.uiBackCompat!==!1&&t.widget("ui.tabs",t.ui.tabs,{_processTabs:function(){this._superApply(arguments),this._addClass(this.tabs,"ui-tab")}}),t.ui.tabs,t.widget("ui.tooltip",{version:"1.12.1",options:{classes:{"ui-tooltip":"ui-corner-all ui-widget-shadow"},content:function(){var e=t(this).attr("title")||"";return t("<a>").text(e).html()},hide:!0,items:"[title]:not([disabled])",position:{my:"left top+15",at:"left bottom",collision:"flipfit flip"},show:!0,track:!1,close:null,open:null},_addDescribedBy:function(e,i){var s=(e.attr("aria-describedby")||"").split(/\s+/);s.push(i),e.data("ui-tooltip-id",i).attr("aria-describedby",t.trim(s.join(" ")))},_removeDescribedBy:function(e){var i=e.data("ui-tooltip-id"),s=(e.attr("aria-describedby")||"").split(/\s+/),n=t.inArray(i,s);-1!==n&&s.splice(n,1),e.removeData("ui-tooltip-id"),s=t.trim(s.join(" ")),s?e.attr("aria-describedby",s):e.removeAttr("aria-describedby")},_create:function(){this._on({mouseover:"open",focusin:"open"}),this.tooltips={},this.parents={},this.liveRegion=t("<div>").attr({role:"log","aria-live":"assertive","aria-relevant":"additions"}).appendTo(this.document[0].body),this._addClass(this.liveRegion,null,"ui-helper-hidden-accessible"),this.disabledTitles=t([])},_setOption:function(e,i){var s=this;this._super(e,i),"content"===e&&t.each(this.tooltips,function(t,e){s._updateContent(e.element)})},_setOptionDisabled:function(t){this[t?"_disable":"_enable"]()},_disable:function(){var e=this;t.each(this.tooltips,function(i,s){var n=t.Event("blur");n.target=n.currentTarget=s.element[0],e.close(n,!0)}),this.disabledTitles=this.disabledTitles.add(this.element.find(this.options.items).addBack().filter(function(){var e=t(this);return e.is("[title]")?e.data("ui-tooltip-title",e.attr("title")).removeAttr("title"):void 0}))},_enable:function(){this.disabledTitles.each(function(){var e=t(this);e.data("ui-tooltip-title")&&e.attr("title",e.data("ui-tooltip-title"))}),this.disabledTitles=t([])},open:function(e){var i=this,s=t(e?e.target:this.element).closest(this.options.items);s.length&&!s.data("ui-tooltip-id")&&(s.attr("title")&&s.data("ui-tooltip-title",s.attr("title")),s.data("ui-tooltip-open",!0),e&&"mouseover"===e.type&&s.parents().each(function(){var e,s=t(this);s.data("ui-tooltip-open")&&(e=t.Event("blur"),e.target=e.currentTarget=this,i.close(e,!0)),s.attr("title")&&(s.uniqueId(),i.parents[this.id]={element:this,title:s.attr("title")},s.attr("title",""))}),this._registerCloseHandlers(e,s),this._updateContent(s,e))},_updateContent:function(t,e){var i,s=this.options.content,n=this,o=e?e.type:null;return"string"==typeof s||s.nodeType||s.jquery?this._open(e,t,s):(i=s.call(t[0],function(i){n._delay(function(){t.data("ui-tooltip-open")&&(e&&(e.type=o),this._open(e,t,i))})}),i&&this._open(e,t,i),void 0)},_open:function(e,i,s){function n(t){l.of=t,a.is(":hidden")||a.position(l)}var o,a,r,h,l=t.extend({},this.options.position);if(s){if(o=this._find(i))return o.tooltip.find(".ui-tooltip-content").html(s),void 0;i.is("[title]")&&(e&&"mouseover"===e.type?i.attr("title",""):i.removeAttr("title")),o=this._tooltip(i),a=o.tooltip,this._addDescribedBy(i,a.attr("id")),a.find(".ui-tooltip-content").html(s),this.liveRegion.children().hide(),h=t("<div>").html(a.find(".ui-tooltip-content").html()),h.removeAttr("name").find("[name]").removeAttr("name"),h.removeAttr("id").find("[id]").removeAttr("id"),h.appendTo(this.liveRegion),this.options.track&&e&&/^mouse/.test(e.type)?(this._on(this.document,{mousemove:n}),n(e)):a.position(t.extend({of:i},this.options.position)),a.hide(),this._show(a,this.options.show),this.options.track&&this.options.show&&this.options.show.delay&&(r=this.delayedShow=setInterval(function(){a.is(":visible")&&(n(l.of),clearInterval(r))},t.fx.interval)),this._trigger("open",e,{tooltip:a})}},_registerCloseHandlers:function(e,i){var s={keyup:function(e){if(e.keyCode===t.ui.keyCode.ESCAPE){var s=t.Event(e);s.currentTarget=i[0],this.close(s,!0)}}};i[0]!==this.element[0]&&(s.remove=function(){this._removeTooltip(this._find(i).tooltip)}),e&&"mouseover"!==e.type||(s.mouseleave="close"),e&&"focusin"!==e.type||(s.focusout="close"),this._on(!0,i,s)},close:function(e){var i,s=this,n=t(e?e.currentTarget:this.element),o=this._find(n);return o?(i=o.tooltip,o.closing||(clearInterval(this.delayedShow),n.data("ui-tooltip-title")&&!n.attr("title")&&n.attr("title",n.data("ui-tooltip-title")),this._removeDescribedBy(n),o.hiding=!0,i.stop(!0),this._hide(i,this.options.hide,function(){s._removeTooltip(t(this))}),n.removeData("ui-tooltip-open"),this._off(n,"mouseleave focusout keyup"),n[0]!==this.element[0]&&this._off(n,"remove"),this._off(this.document,"mousemove"),e&&"mouseleave"===e.type&&t.each(this.parents,function(e,i){t(i.element).attr("title",i.title),delete s.parents[e]}),o.closing=!0,this._trigger("close",e,{tooltip:i}),o.hiding||(o.closing=!1)),void 0):(n.removeData("ui-tooltip-open"),void 0)},_tooltip:function(e){var i=t("<div>").attr("role","tooltip"),s=t("<div>").appendTo(i),n=i.uniqueId().attr("id");return this._addClass(s,"ui-tooltip-content"),this._addClass(i,"ui-tooltip","ui-widget ui-widget-content"),i.appendTo(this._appendTo(e)),this.tooltips[n]={element:e,tooltip:i}},_find:function(t){var e=t.data("ui-tooltip-id");return e?this.tooltips[e]:null},_removeTooltip:function(t){t.remove(),delete this.tooltips[t.attr("id")]},_appendTo:function(t){var e=t.closest(".ui-front, dialog");return e.length||(e=this.document[0].body),e},_destroy:function(){var e=this;t.each(this.tooltips,function(i,s){var n=t.Event("blur"),o=s.element;n.target=n.currentTarget=o[0],e.close(n,!0),t("#"+i).remove(),o.data("ui-tooltip-title")&&(o.attr("title")||o.attr("title",o.data("ui-tooltip-title")),o.removeData("ui-tooltip-title"))}),this.liveRegion.remove()}}),t.uiBackCompat!==!1&&t.widget("ui.tooltip",t.ui.tooltip,{options:{tooltipClass:null},_tooltip:function(){var t=this._superApply(arguments);return this.options.tooltipClass&&t.tooltip.addClass(this.options.tooltipClass),t}}),t.ui.tooltip});
;
//# sourceMappingURL=scripts.js.map